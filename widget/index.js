// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"awqi":[function(require,module,exports) {
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';

var l = Symbol.for("react.element"),
  n = Symbol.for("react.portal"),
  p = Symbol.for("react.fragment"),
  q = Symbol.for("react.strict_mode"),
  r = Symbol.for("react.profiler"),
  t = Symbol.for("react.provider"),
  u = Symbol.for("react.context"),
  v = Symbol.for("react.forward_ref"),
  w = Symbol.for("react.suspense"),
  x = Symbol.for("react.memo"),
  y = Symbol.for("react.lazy"),
  z = Symbol.iterator;
function A(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z && a[z] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  C = Object.assign,
  D = {};
function E(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = e || B;
}
E.prototype.isReactComponent = {};
E.prototype.setState = function (a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};
E.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {}
F.prototype = E.prototype;
function G(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = e || B;
}
var H = G.prototype = new F();
H.constructor = G;
C(H, E.prototype);
H.isPureReactComponent = !0;
var I = Array.isArray,
  J = Object.prototype.hasOwnProperty,
  K = {
    current: null
  },
  L = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };
function M(a, b, e) {
  var d,
    c = {},
    k = null,
    h = null;
  if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
  var g = arguments.length - 2;
  if (1 === g) c.children = e;else if (1 < g) {
    for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
    c.children = f;
  }
  if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
  return {
    $$typeof: l,
    type: a,
    key: k,
    ref: h,
    props: c,
    _owner: K.current
  };
}
function N(a, b) {
  return {
    $$typeof: l,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  };
}
function O(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l;
}
function escape(a) {
  var b = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + a.replace(/[=:]/g, function (a) {
    return b[a];
  });
}
var P = /\/+/g;
function Q(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function R(a, b, e, d, c) {
  var k = typeof a;
  if ("undefined" === k || "boolean" === k) a = null;
  var h = !1;
  if (null === a) h = !0;else switch (k) {
    case "string":
    case "number":
      h = !0;
      break;
    case "object":
      switch (a.$$typeof) {
        case l:
        case n:
          h = !0;
      }
  }
  if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function (a) {
    return a;
  })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
  h = 0;
  d = "" === d ? "." : d + ":";
  if (I(a)) for (var g = 0; g < a.length; g++) {
    k = a[g];
    var f = d + Q(k, g);
    h += R(k, b, e, f, c);
  } else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return h;
}
function S(a, b, e) {
  if (null == a) return a;
  var d = [],
    c = 0;
  R(a, d, "", "", function (a) {
    return b.call(e, a, c++);
  });
  return d;
}
function T(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function (b) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
    }, function (b) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }
  if (1 === a._status) return a._result.default;
  throw a._result;
}
var U = {
    current: null
  },
  V = {
    transition: null
  },
  W = {
    ReactCurrentDispatcher: U,
    ReactCurrentBatchConfig: V,
    ReactCurrentOwner: K
  };
exports.Children = {
  map: S,
  forEach: function (a, b, e) {
    S(a, function () {
      b.apply(this, arguments);
    }, e);
  },
  count: function (a) {
    var b = 0;
    S(a, function () {
      b++;
    });
    return b;
  },
  toArray: function (a) {
    return S(a, function (a) {
      return a;
    }) || [];
  },
  only: function (a) {
    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  }
};
exports.Component = E;
exports.Fragment = p;
exports.Profiler = r;
exports.PureComponent = G;
exports.StrictMode = q;
exports.Suspense = w;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
exports.cloneElement = function (a, b, e) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C({}, a.props),
    c = a.key,
    k = a.ref,
    h = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k = b.ref, h = K.current);
    void 0 !== b.key && (c = "" + b.key);
    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
    for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
  }
  var f = arguments.length - 2;
  if (1 === f) d.children = e;else if (1 < f) {
    g = Array(f);
    for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
    d.children = g;
  }
  return {
    $$typeof: l,
    type: a.type,
    key: c,
    ref: k,
    props: d,
    _owner: h
  };
};
exports.createContext = function (a) {
  a = {
    $$typeof: u,
    _currentValue: a,
    _currentValue2: a,
    _threadCount: 0,
    Provider: null,
    Consumer: null,
    _defaultValue: null,
    _globalName: null
  };
  a.Provider = {
    $$typeof: t,
    _context: a
  };
  return a.Consumer = a;
};
exports.createElement = M;
exports.createFactory = function (a) {
  var b = M.bind(null, a);
  b.type = a;
  return b;
};
exports.createRef = function () {
  return {
    current: null
  };
};
exports.forwardRef = function (a) {
  return {
    $$typeof: v,
    render: a
  };
};
exports.isValidElement = O;
exports.lazy = function (a) {
  return {
    $$typeof: y,
    _payload: {
      _status: -1,
      _result: a
    },
    _init: T
  };
};
exports.memo = function (a, b) {
  return {
    $$typeof: x,
    type: a,
    compare: void 0 === b ? null : b
  };
};
exports.startTransition = function (a) {
  var b = V.transition;
  V.transition = {};
  try {
    a();
  } finally {
    V.transition = b;
  }
};
exports.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
exports.useCallback = function (a, b) {
  return U.current.useCallback(a, b);
};
exports.useContext = function (a) {
  return U.current.useContext(a);
};
exports.useDebugValue = function () {};
exports.useDeferredValue = function (a) {
  return U.current.useDeferredValue(a);
};
exports.useEffect = function (a, b) {
  return U.current.useEffect(a, b);
};
exports.useId = function () {
  return U.current.useId();
};
exports.useImperativeHandle = function (a, b, e) {
  return U.current.useImperativeHandle(a, b, e);
};
exports.useInsertionEffect = function (a, b) {
  return U.current.useInsertionEffect(a, b);
};
exports.useLayoutEffect = function (a, b) {
  return U.current.useLayoutEffect(a, b);
};
exports.useMemo = function (a, b) {
  return U.current.useMemo(a, b);
};
exports.useReducer = function (a, b, e) {
  return U.current.useReducer(a, b, e);
};
exports.useRef = function (a) {
  return U.current.useRef(a);
};
exports.useState = function (a) {
  return U.current.useState(a);
};
exports.useSyncExternalStore = function (a, b, e) {
  return U.current.useSyncExternalStore(a, b, e);
};
exports.useTransition = function () {
  return U.current.useTransition();
};
exports.version = "18.2.0";
},{}],"n8MK":[function(require,module,exports) {
'use strict';

if ("production" === 'production') {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = require('./cjs/react.development.js');
}
},{"./cjs/react.production.min.js":"awqi"}],"IvPb":[function(require,module,exports) {
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}
function g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D="function"===typeof setTimeout?setTimeout:null,E="function"===typeof clearTimeout?clearTimeout:null,F="undefined"!==typeof setImmediate?setImmediate:null;
"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t)}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else{var b=h(t);null!==b&&K(H,b.startTime-a)}}
function J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if("function"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?v.callback=e:v===h(r)&&k(r);G(b)}else k(r);v=h(r)}if(null!==v)var w=!0;else{var m=h(t);null!==m&&K(H,m.startTime-b);w=!1}return w}finally{v=null,y=c,z=!1}}var N=!1,O=null,L=-1,P=5,Q=-1;
function M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a)}finally{b?S():(N=!1,O=null)}}else N=!1}var S;if("function"===typeof F)S=function(){F(R)};else if("undefined"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null)}}else S=function(){D(R,0)};function I(a){O=a;N||(N=!0,S())}function K(a,b){L=D(function(){a(exports.unstable_now())},b)}
exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J))};
exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<a?Math.floor(1E3/a):5};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y}var c=y;y=b;try{return a()}finally{y=c}};exports.unstable_pauseExecution=function(){};
exports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=y;y=a;try{return b()}finally{y=c}};
exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};
exports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c}}};

},{}],"MDSO":[function(require,module,exports) {
'use strict';

if ("production" === 'production') {
  module.exports = require('./cjs/scheduler.production.min.js');
} else {
  module.exports = require('./cjs/scheduler.development.js');
}
},{"./cjs/scheduler.production.min.js":"IvPb"}],"i17t":[function(require,module,exports) {
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';var aa=require("react"),ca=require("scheduler");function p(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+"Capture",b)}
function ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a])}
var ia=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la=
{},ma={};function oa(a){if(ja.call(ma,a))return!0;if(ja.call(la,a))return!1;if(ka.test(a))return ma[a]=!0;la[a]=!0;return!1}function pa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}
function qa(a,b,c,d){if(null===b||"undefined"===typeof b||pa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var z={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z[a]=new v(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];z[b]=new v(b,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z[a]=new v(a,2,!1,a.toLowerCase(),null,!1,!1)});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z[a]=new v(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z[a]=new v(a,3,!1,a.toLowerCase(),null,!1,!1)});
["checked","multiple","muted","selected"].forEach(function(a){z[a]=new v(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){z[a]=new v(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){z[a]=new v(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){z[a]=new v(a,5,!1,a.toLowerCase(),null,!1,!1)});var ra=/[\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(ra,
sa);z[b]=new v(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!1,!1)});
z.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!0,!0)});
function ta(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1])qa(b,c,e,d)&&(c=null),d||null===e?oa(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)))}
var ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for("react.element"),wa=Symbol.for("react.portal"),ya=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy");Symbol.for("react.scope");Symbol.for("react.debug_trace_mode");
var Ia=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden");Symbol.for("react.cache");Symbol.for("react.tracing_marker");var Ja=Symbol.iterator;function Ka(a){if(null===a||"object"!==typeof a)return null;a=Ja&&a[Ja]||a["@@iterator"];return"function"===typeof a?a:null}var A=Object.assign,La;function Ma(a){if(void 0===La)try{throw Error();}catch(c){var b=c.stack.trim().match(/\n( *(at )?)/);La=b&&b[1]||""}return"\n"+La+a}var Na=!1;
function Oa(a,b){if(!a||Na)return"";Na=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(l){var d=l}Reflect.construct(a,[],b)}else{try{b.call()}catch(l){d=l}a.call(b.prototype)}else{try{throw Error();}catch(l){d=l}a()}}catch(l){if(l&&d&&"string"===typeof l.stack){for(var e=l.stack.split("\n"),
f=d.stack.split("\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?Ma(a):""}
function Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return a=Oa(a.type,!1),a;case 11:return a=Oa(a.type.render,!1),a;case 1:return a=Oa(a.type,!0),a;default:return""}}
function Qa(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ya:return"Fragment";case wa:return"Portal";case Aa:return"Profiler";case za:return"StrictMode";case Ea:return"Suspense";case Fa:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Ca:return(a.displayName||"Context")+".Consumer";case Ba:return(a._context.displayName||"Context")+".Provider";case Da:var b=a.render;a=a.displayName;a||(a=b.displayName||
b.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case Ga:return b=a.displayName||null,null!==b?b:Qa(a.type)||"Memo";case Ha:b=a._payload;a=a._init;try{return Qa(a(b))}catch(c){}}return null}
function Ra(a){var b=a.type;switch(a.tag){case 24:return"Cache";case 9:return(b.displayName||"Context")+".Consumer";case 10:return(b._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return"Fragment";case 5:return b;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa(b);case 8:return b===za?"StrictMode":"Mode";case 22:return"Offscreen";
case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function Sa(a){switch(typeof a){case "boolean":case "number":case "string":case "undefined":return a;case "object":return a;default:return""}}
function Ta(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ua(a){var b=Ta(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=
null;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ta(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}
function Ya(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function ab(a,b){b=b.checked;null!=b&&ta(a,"checked",b,!1)}
function bb(a,b){ab(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?cb(a,b.type,c):b.hasOwnProperty("defaultValue")&&cb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function db(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}
function cb(a,b,c){if("number"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}var eb=Array.isArray;
function fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(eb(c)){if(1<c.length)throw Error(p(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:Sa(c)}}
function ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}function kb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}
function lb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?kb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var mb,nb=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{mb=mb||document.createElement("div");mb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function ob(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,
zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(a){qb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb[b]=pb[a]})});function rb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||pb.hasOwnProperty(a)&&pb[a]?(""+b).trim():b+"px"}
function sb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=rb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function ub(a,b){if(b){if(tb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if("object"!==typeof b.dangerouslySetInnerHTML||!("__html"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(p(62));}}
function vb(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var wb=null;function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;
function Bb(a){if(a=Cb(a)){if("function"!==typeof yb)throw Error(p(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(){}var Ib=!1;function Jb(a,b,c){if(Ib)return a(b,c);Ib=!0;try{return Gb(a,b,c)}finally{if(Ib=!1,null!==zb||null!==Ab)Hb(),Fb()}}
function Kb(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==
typeof c)throw Error(p(231,b,typeof c));return c}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0}});window.addEventListener("test",Mb,Mb);window.removeEventListener("test",Mb,Mb)}catch(a){Lb=!1}function Nb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(a){Ob=!0;Pb=a}};function Tb(a,b,c,d,e,f,g,h,k){Ob=!1;Pb=null;Nb.apply(Sb,arguments)}
function Ub(a,b,c,d,e,f,g,h,k){Tb.apply(this,arguments);if(Ob){if(Ob){var l=Pb;Ob=!1;Pb=null}else throw Error(p(198));Qb||(Qb=!0,Rb=l)}}function Vb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p(188));}
function Yb(a){var b=a.alternate;if(!b){b=Vb(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb(e),a;if(f===d)return Xb(e),b;f=f.sibling}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===
c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Zb(a){a=Yb(a);return null!==a?$b(a):null}function $b(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b(a);if(null!==b)return b;a=a.sibling}return null}
var ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&"function"===typeof lc.onCommitFiberRoot)try{lc.onCommitFiberRoot(kc,a,void 0,128===(a.current.flags&128))}catch(b){}}
var oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){a>>>=0;return 0===a?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;
function tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;
default:return a}}function uc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc(h):(f&=g,0!==f&&(d=tc(f)))}else g=c&~e,0!==g?d=tc(g):0!==f&&(d=tc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc(b),e=1<<c,d|=a[c],b&=~e;return d}
function vc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}
function wc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function xc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc(){var a=rc;rc<<=1;0===(rc&4194240)&&(rc=64);return a}function zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}
function Ac(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc(b);a[b]=c}function Bc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}
function Cc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e}}var C=0;function Dc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a,b){switch(a){case "focusin":case "focusout":Lc=null;break;case "dragenter":case "dragleave":Mc=null;break;case "mouseover":case "mouseout":Nc=null;break;case "pointerover":case "pointerout":Oc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Pc.delete(b.pointerId)}}
function Tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb(b),null!==b&&Fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}
function Uc(a,b,c,d,e){switch(b){case "focusin":return Lc=Tc(Lc,a,b,c,d,e),!0;case "dragenter":return Mc=Tc(Mc,a,b,c,d,e),!0;case "mouseover":return Nc=Tc(Nc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Oc.set(f,Tc(Oc.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Pc.set(f,Tc(Pc.get(f)||null,a,b,c,d,e)),!0}return!1}
function Vc(a){var b=Wc(a.target);if(null!==b){var c=Vb(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb(c),null!==b){a.blockedOn=b;Ic(a.priority,function(){Gc(c)});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}
function Xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=Yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb=d;c.target.dispatchEvent(d);wb=null}else return b=Cb(c),null!==b&&Fc(b),a.blockedOn=c,!1;b.shift()}return!0}function Zc(a,b,c){Xc(a)&&c.delete(b)}function $c(){Jc=!1;null!==Lc&&Xc(Lc)&&(Lc=null);null!==Mc&&Xc(Mc)&&(Mc=null);null!==Nc&&Xc(Nc)&&(Nc=null);Oc.forEach(Zc);Pc.forEach(Zc)}
function ad(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}
function bd(a){function b(b){return ad(b,a)}if(0<Kc.length){ad(Kc[0],a);for(var c=1;c<Kc.length;c++){var d=Kc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Lc&&ad(Lc,a);null!==Mc&&ad(Mc,a);null!==Nc&&ad(Nc,a);Oc.forEach(b);Pc.forEach(b);for(c=0;c<Qc.length;c++)d=Qc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc.length&&(c=Qc[0],null===c.blockedOn);)Vc(c),null===c.blockedOn&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;
function ed(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=1,fd(a,b,c,d)}finally{C=e,cd.transition=f}}function gd(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=4,fd(a,b,c,d)}finally{C=e,cd.transition=f}}
function fd(a,b,c,d){if(dd){var e=Yc(a,b,c,d);if(null===e)hd(a,b,d,id,c),Sc(a,d);else if(Uc(e,a,b,c,d))d.stopPropagation();else if(Sc(a,d),b&4&&-1<Rc.indexOf(a)){for(;null!==e;){var f=Cb(e);null!==f&&Ec(f);f=Yc(a,b,c,d);null===f&&hd(a,b,d,id,c);if(f===e)break;e=f}null!==e&&d.stopPropagation()}else hd(a,b,d,null,c)}}var id=null;
function Yc(a,b,c,d){id=null;a=xb(d);a=Wc(a);if(null!==a)if(b=Vb(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb(b);if(null!==a)return a;a=null}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null}else b!==a&&(a=null);id=a;return null}
function jd(a){switch(a){case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 1;case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "toggle":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 4;
case "message":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,b=ld,c=b.length,d,e="value"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}
function od(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}
function rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&
(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}
var sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in
a)return a.movementX;a!==yd&&(yd&&"mousemove"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return"movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A({},sd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",
Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",
119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}
var Qd=A({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=od(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return"keypress"===a.type?od(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?od(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A({},Ad,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},
deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&"CompositionEvent"in window,be=null;ia&&"documentMode"in document&&(be=document.documentMode);var ce=ia&&"TextEvent"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;
function ge(a,b){switch(a){case "keyup":return-1!==$d.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return!0;default:return!1}}function he(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case "compositionend":return he(b);case "keypress":if(32!==b.which)return null;fe=!0;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}
function ke(a,b){if(ie)return"compositionend"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}
var le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!le[a.type]:"textarea"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,"onChange");0<b.length&&(c=new td("onChange","change",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}
function ve(a,b){if("change"===a)return b}var we=!1;if(ia){var xe;if(ia){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;");ye="function"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null)}function Be(a){if("value"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));Jb(re,b)}}
function Ce(a,b,c){"focusin"===a?(Ae(),pe=b,qe=c,pe.attachEvent("onpropertychange",Be)):"focusout"===a&&Ae()}function De(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te(qe)}function Ee(a,b){if("click"===a)return te(b)}function Fe(a,b){if("input"===a||"change"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He="function"===typeof Object.is?Object.is:Ge;
function Ie(a,b){if(He(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!He(a[e],b[e]))return!1}return!0}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Ke(a,b){var c=Je(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Je(c)}}function Le(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Le(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}
function Me(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Ne(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
function Oe(a){var b=Me(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le(c.ownerDocument.documentElement,c)){if(null!==d&&Ne(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke(c,f);var g=Ke(c,
d);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}
var Pe=ia&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;
function Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,"selectionStart"in d&&Ne(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Ie(Se,d)||(Se=d,d=oe(Re,"onSelect"),0<d.length&&(b=new td("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}
function Ve(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var We={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye={};
ia&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),"TransitionEvent"in window||delete We.transitionend.transition);function Ze(a){if(Xe[a])return Xe[a];if(!We[a])return a;var b=We[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye)return Xe[a]=b[c];return a}var $e=Ze("animationend"),af=Ze("animationiteration"),bf=Ze("animationstart"),cf=Ze("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a,b){df.set(a,b);fa(b,[a])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,"on"+kf)}ff($e,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);
ha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Ub(d,b,void 0,a);a.currentTarget=null}
function se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}}}if(Qb)throw a=Rb,Qb=!1,Rb=null,a;}
function D(a,b){var c=b[of];void 0===c&&(c=b[of]=new Set);var d=a+"__bubble";c.has(d)||(pf(b,a,2,!1),c.add(d))}function qf(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b)}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=!0;da.forEach(function(b){"selectionchange"!==b&&(mf.has(b)||qf(b,!1,a),qf(b,!0,a))});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=!0,qf("selectionchange",!1,b))}}
function pf(a,b,c,d){switch(jd(b)){case 1:var e=ed;break;case 4:e=gd;break;default:e=fd}c=e.bind(null,b,c,a);e=void 0;!Lb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}
function hd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=Wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Jb(function(){var d=f,e=xb(c),g=[];
a:{var h=df.get(a);if(void 0!==h){var k=td,n=a;switch(a){case "keypress":if(0===od(c))break a;case "keydown":case "keyup":k=Rd;break;case "focusin":n="focus";k=Fd;break;case "focusout":n="blur";k=Fd;break;case "beforeblur":case "afterblur":k=Fd;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=
Dd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd;break;case $e:case af:case bf:k=Hd;break;case cf:k=Xd;break;case "scroll":k=vd;break;case "wheel":k=Zd;break;case "copy":case "cut":case "paste":k=Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td}var t=0!==(b&4),J=!t&&"scroll"===a,x=t?null!==h?h+"Capture":null:h;t=[];for(var w=d,u;null!==
w;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}))}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&c!==wb&&(n=c.relatedTarget||c.fromElement)&&(Wc(n)||n[uf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc(n):null,null!==
n&&(J=Vb(n),n!==J||5!==n.tag&&6!==n.tag))n=null}else k=null,n=d;if(k!==n){t=Bd;F="onMouseLeave";x="onMouseEnter";w="mouse";if("pointerout"===a||"pointerover"===a)t=Td,F="onPointerLeave",x="onPointerEnter",w="pointer";J=null==k?h:ue(k);u=null==n?h:ue(n);h=new t(F,w+"leave",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc(e)===d&&(t=new t(x,w+"enter",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf(u))w++;u=0;for(F=x;F;F=vf(F))u++;for(;0<w-u;)t=vf(t),w--;for(;0<u-w;)x=
vf(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf(t);x=vf(x)}t=null}else t=null;null!==k&&wf(g,h,k,t,!1);null!==n&&null!==J&&wf(g,J,n,t,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var na=ve;else if(me(h))if(we)na=Fe;else{na=De;var xa=Ce}else(k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(na=Ee);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);"focusout"===a&&(xa=h._wrapperState)&&
xa.controlled&&"number"===h.type&&cb(h,"number",h.value)}xa=d?ue(d):window;switch(a){case "focusin":if(me(xa)||"true"===xa.contentEditable)Qe=xa,Re=d,Se=null;break;case "focusout":Se=Re=Qe=null;break;case "mousedown":Te=!0;break;case "contextmenu":case "mouseup":case "dragend":Te=!1;Ue(g,c,e);break;case "selectionchange":if(Pe)break;case "keydown":case "keyup":Ue(g,c,e)}var $a;if(ae)b:{switch(a){case "compositionstart":var ba="onCompositionStart";break b;case "compositionend":ba="onCompositionEnd";
break b;case "compositionupdate":ba="onCompositionUpdate";break b}ba=void 0}else ie?ge(a,c)&&(ba="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(ba="onCompositionStart");ba&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==ba?"onCompositionEnd"===ba&&ie&&($a=nd()):(kd=e,ld="value"in kd?kd.value:kd.textContent,ie=!0)),xa=oe(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he(c),null!==$a&&(ba.data=$a))));if($a=ce?je(a,c):ke(a,c))d=oe(d,"onBeforeInput"),
0<d.length&&(e=new Ld("onBeforeInput","beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=$a)}se(g,b)})}function tf(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return}return d}function vf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}
function wf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(a){return("string"===typeof a?a:""+a).replace(xf,"\n").replace(yf,"")}function Af(a,b,c){b=zf(b);if(zf(a)!==b&&c)throw Error(p(425));}function Bf(){}
var Cf=null,Df=null;function Ef(a,b){return"textarea"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}
var Ff="function"===typeof setTimeout?setTimeout:void 0,Gf="function"===typeof clearTimeout?clearTimeout:void 0,Hf="function"===typeof Promise?Promise:void 0,Jf="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof Hf?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a;})}
function Kf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,"/$"===c){if(0===d){a.removeChild(e);bd(b);return}d--}else"$"!==c&&"$?"!==c&&"$!"!==c||d++;c=e}while(c);bd(b)}function Lf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if("$"===b||"$!"===b||"$?"===b)break;if("/$"===b)return null}}return a}
function Mf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--}else"/$"===c&&b++}a=a.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf="__reactContainer$"+Nf,of="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;
function Wc(a){var b=a[Of];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf]||c[Of]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf(a);null!==a;){if(c=a[Of])return c;a=Mf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[Of]||a[uf];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return{current:a}}
function E(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(a,b){Tf++;Sf[Tf]=a.current;a.current=b}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(a,b){var c=a.type.contextTypes;if(!c)return Vf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}
function Zf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E(Wf);E(H)}function ag(a,b,c){if(H.current!==Vf)throw Error(p(168));G(H,b);G(Wf,c)}function bg(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Ra(a)||"Unknown",e));return A({},c,d)}
function cg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf;Xf=H.current;G(H,a);G(Wf,Wf.current);return!0}function dg(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=bg(a,b,Xf),d.__reactInternalMemoizedMergedChildContext=a,E(Wf),E(H),G(H,a)):E(Wf);G(Wf,c)}var eg=null,fg=!1,gg=!1;function hg(a){null===eg?eg=[a]:eg.push(a)}function ig(a){fg=!0;hg(a)}
function jg(){if(!gg&&null!==eg){gg=!0;var a=0,b=C;try{var c=eg;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg=null;fg=!1}catch(e){throw null!==eg&&(eg=eg.slice(a+1)),ac(fc,jg),e;}finally{C=b,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(a,b){kg[lg++]=ng;kg[lg++]=mg;mg=a;ng=b}
function ug(a,b,c){og[pg++]=rg;og[pg++]=sg;og[pg++]=qg;qg=a;var d=rg;a=sg;var e=32-oc(d)-1;d&=~(1<<e);c+=1;var f=32-oc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg=1<<32-oc(b)+e|c<<e|d;sg=f+a}else rg=1<<f|c<<e|d,sg=a}function vg(a){null!==a.return&&(tg(a,1),ug(a,1,0))}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;
function Ag(a,b){var c=Bg(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}
function Cg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg=a,yg=Lf(b.firstChild),!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg=a,yg=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg=a,yg=
null,!0):!1;default:return!1}}function Dg(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg(a){if(I){var b=yg;if(b){var c=b;if(!Cg(a,b)){if(Dg(a))throw Error(p(418));b=Lf(c.nextSibling);var d=xg;b&&Cg(a,b)?Ag(d,c):(a.flags=a.flags&-4097|2,I=!1,xg=a)}}else{if(Dg(a))throw Error(p(418));a.flags=a.flags&-4097|2;I=!1;xg=a}}}function Fg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg=a}
function Gg(a){if(a!==xg)return!1;if(!I)return Fg(a),I=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b="head"!==b&&"body"!==b&&!Ef(a.type,a.memoizedProps));if(b&&(b=yg)){if(Dg(a))throw Hg(),Error(p(418));for(;b;)Ag(a,b),b=Lf(b.nextSibling)}Fg(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){yg=Lf(a.nextSibling);break a}b--}else"$"!==c&&"$!"!==c&&"$?"!==c||b++}a=a.nextSibling}yg=
null}}else yg=xg?Lf(a.stateNode.nextSibling):null;return!0}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling)}function Ig(){yg=xg=null;I=!1}function Jg(a){null===zg?zg=[a]:zg.push(a)}var Kg=ua.ReactCurrentBatchConfig;function Lg(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var Mg=Uf(null),Ng=null,Og=null,Pg=null;function Qg(){Pg=Og=Ng=null}function Rg(a){var b=Mg.current;E(Mg);a._currentValue=b}
function Sg(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}function Tg(a,b){Ng=a;Pg=Og=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(Ug=!0),a.firstContext=null)}
function Vg(a){var b=a._currentValue;if(Pg!==a)if(a={context:a,memoizedValue:b,next:null},null===Og){if(null===Ng)throw Error(p(308));Og=a;Ng.dependencies={lanes:0,firstContext:a}}else Og=Og.next=a;return b}var Wg=null;function Xg(a){null===Wg?Wg=[a]:Wg.push(a)}function Yg(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,Xg(b)):(c.next=e.next,e.next=c);b.interleaved=c;return Zg(a,d)}
function Zg(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var $g=!1;function ah(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}
function bh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function ch(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}
function dh(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return Zg(a,c)}e=d.interleaved;null===e?(b.next=b,Xg(d)):(b.next=e.next,e.next=b);d.interleaved=b;return Zg(a,c)}function eh(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}
function fh(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=
b;c.lastBaseUpdate=b}
function gh(a,b,c,d){var e=a.updateQueue;$g=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k))}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,
next:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if("function"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r="function"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A({},q,r);break a;case 2:$g=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h))}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;
h=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);hh|=g;a.lanes=g;a.memoizedState=q}}
function ih(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(p(191,e));e.call(d)}}}var jh=(new aa.Component).refs;function kh(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}
var nh={isMounted:function(a){return(a=a._reactInternals)?Vb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=L(),d=
lh(a),e=ch(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=dh(a,e,d);null!==b&&(mh(b,a,d,c),eh(b,a,d))}};function oh(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie(c,d)||!Ie(e,f):!0}
function ph(a,b,c){var d=!1,e=Vf;var f=b.contextType;"object"===typeof f&&null!==f?f=Vg(f):(e=Zf(b)?Xf:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf(a,e):Vf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=nh;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function qh(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&nh.enqueueReplaceState(b,b.state,null)}
function rh(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=jh;ah(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=Vg(f):(f=Zf(b)?Xf:H.current,e.context=Yf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(kh(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,
"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&nh.enqueueReplaceState(e,e.state,null),gh(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308)}
function sh(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode}if(!d)throw Error(p(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;b===jh&&(b=e.refs={});null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if("string"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}
function th(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function uh(a){var b=a._init;return b(a._payload)}
function vh(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=wh(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&
null===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=xh(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===Ha&&uh(f)===b.type))return d=e(b,c.props),d.ref=sh(a,b,c),d.return=a,d;d=yh(c.type,c.key,c.props,null,a.mode,d);d.ref=sh(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||
b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=zh(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ah(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if("string"===typeof b&&""!==b||"number"===typeof b)return b=xh(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case va:return c=yh(b.type,b.key,b.props,null,a.mode,c),
c.ref=sh(a,null,b),c.return=a,c;case wa:return b=zh(b,a.mode,c),b.return=a,b;case Ha:var d=b._init;return q(a,d(b._payload),c)}if(eb(b)||Ka(b))return b=Ah(b,a.mode,c,null),b.return=a,b;th(a,b)}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case va:return c.key===e?k(a,b,c,d):null;case wa:return c.key===e?l(a,b,c,d):null;case Ha:return e=c._init,r(a,
b,e(c._payload),d)}if(eb(c)||Ka(c))return null!==e?null:m(a,b,c,d,null);th(a,c)}return null}function y(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case va:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb(d)||Ka(d))return a=a.get(c)||null,m(b,a,d,e,null);th(b,d)}return null}
function n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x}if(w===h.length)return c(e,u),I&&tg(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I&&tg(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===
x.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function t(e,g,h,k){var l=Ka(h);if("function"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x}if(n.done)return c(e,
m),I&&tg(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I&&tg(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function J(a,d,f,h){"object"===typeof f&&null!==f&&f.type===ya&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==f){switch(f.$$typeof){case va:a:{for(var k=
f.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===Ha&&uh(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=sh(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling}f.type===ya?(d=Ah(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=yh(f.type,f.key,f.props,null,a.mode,h),h.ref=sh(a,d,f),h.return=a,a=h)}return g(a);case wa:a:{for(l=f.key;null!==
d;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=zh(f,a.mode,h);d.return=a;a=d}return g(a);case Ha:return l=f._init,J(a,d,l(f._payload),h)}if(eb(f))return n(a,d,f,h);if(Ka(f))return t(a,d,f,h);th(a,f)}return"string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):
(c(a,d),d=xh(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Bh=vh(!0),Ch=vh(!1),Dh={},Eh=Uf(Dh),Fh=Uf(Dh),Gh=Uf(Dh);function Hh(a){if(a===Dh)throw Error(p(174));return a}function Ih(a,b){G(Gh,b);G(Fh,a);G(Eh,Dh);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb(b,a)}E(Eh);G(Eh,b)}function Jh(){E(Eh);E(Fh);E(Gh)}
function Kh(a){Hh(Gh.current);var b=Hh(Eh.current);var c=lb(b,a.type);b!==c&&(G(Fh,a),G(Eh,c))}function Lh(a){Fh.current===a&&(E(Eh),E(Fh))}var M=Uf(0);
function Mh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var Nh=[];
function Oh(){for(var a=0;a<Nh.length;a++)Nh[a]._workInProgressVersionPrimary=null;Nh.length=0}var Ph=ua.ReactCurrentDispatcher,Qh=ua.ReactCurrentBatchConfig,Rh=0,N=null,O=null,P=null,Sh=!1,Th=!1,Uh=0,Vh=0;function Q(){throw Error(p(321));}function Wh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}
function Xh(a,b,c,d,e,f){Rh=f;N=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Ph.current=null===a||null===a.memoizedState?Yh:Zh;a=c(d,e);if(Th){f=0;do{Th=!1;Uh=0;if(25<=f)throw Error(p(301));f+=1;P=O=null;b.updateQueue=null;Ph.current=$h;a=c(d,e)}while(Th)}Ph.current=ai;b=null!==O&&null!==O.next;Rh=0;P=O=N=null;Sh=!1;if(b)throw Error(p(300));return a}function bi(){var a=0!==Uh;Uh=0;return a}
function ci(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P?N.memoizedState=P=a:P=P.next=a;return P}function di(){if(null===O){var a=N.alternate;a=null!==a?a.memoizedState:null}else a=O.next;var b=null===P?N.memoizedState:P.next;if(null!==b)P=b,O=a;else{if(null===a)throw Error(p(310));O=a;a={memoizedState:O.memoizedState,baseState:O.baseState,baseQueue:O.baseQueue,queue:O.queue,next:null};null===P?N.memoizedState=P=a:P=P.next=a}return P}
function ei(a,b){return"function"===typeof b?b(a):b}
function fi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=O,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Rh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else{var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,
eagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;N.lanes|=m;hh|=m}l=l.next}while(null!==l&&l!==f);null===k?g=d:k.next=h;He(d,b.memoizedState)||(Ug=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=e.lane,N.lanes|=f,hh|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}
function gi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(Ug=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function hi(){}
function ii(a,b){var c=N,d=di(),e=b(),f=!He(d.memoizedState,e);f&&(d.memoizedState=e,Ug=!0);d=d.queue;ji(ki.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==P&&P.memoizedState.tag&1){c.flags|=2048;li(9,mi.bind(null,c,d,e,b),void 0,null);if(null===R)throw Error(p(349));0!==(Rh&30)||ni(c,b,e)}return e}function ni(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}
function mi(a,b,c,d){b.value=c;b.getSnapshot=d;oi(b)&&pi(a)}function ki(a,b,c){return c(function(){oi(b)&&pi(a)})}function oi(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!He(a,c)}catch(d){return!0}}function pi(a){var b=Zg(a,1);null!==b&&mh(b,a,1,-1)}
function qi(a){var b=ci();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ei,lastRenderedState:a};b.queue=a;a=a.dispatch=ri.bind(null,N,a);return[b.memoizedState,a]}
function li(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function si(){return di().memoizedState}function ti(a,b,c,d){var e=ci();N.flags|=a;e.memoizedState=li(1|b,c,void 0,void 0===d?null:d)}
function ui(a,b,c,d){var e=di();d=void 0===d?null:d;var f=void 0;if(null!==O){var g=O.memoizedState;f=g.destroy;if(null!==d&&Wh(d,g.deps)){e.memoizedState=li(b,c,f,d);return}}N.flags|=a;e.memoizedState=li(1|b,c,f,d)}function vi(a,b){return ti(8390656,8,a,b)}function ji(a,b){return ui(2048,8,a,b)}function wi(a,b){return ui(4,2,a,b)}function xi(a,b){return ui(4,4,a,b)}
function yi(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function zi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ui(4,4,yi.bind(null,b,a),c)}function Ai(){}function Bi(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
function Ci(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Di(a,b,c){if(0===(Rh&21))return a.baseState&&(a.baseState=!1,Ug=!0),a.memoizedState=c;He(c,b)||(c=yc(),N.lanes|=c,hh|=c,a.baseState=!0);return b}function Ei(a,b){var c=C;C=0!==c&&4>c?c:4;a(!0);var d=Qh.transition;Qh.transition={};try{a(!1),b()}finally{C=c,Qh.transition=d}}function Fi(){return di().memoizedState}
function Gi(a,b,c){var d=lh(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,c);else if(c=Yg(a,b,c,d),null!==c){var e=L();mh(c,a,d,e);Ji(c,b,d)}}
function ri(a,b,c){var d=lh(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,e);else{var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He(h,g)){var k=b.interleaved;null===k?(e.next=e,Xg(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=Yg(a,b,e,d);null!==c&&(e=L(),mh(c,a,d,e),Ji(c,b,d))}}
function Hi(a){var b=a.alternate;return a===N||null!==b&&b===N}function Ii(a,b){Th=Sh=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function Ji(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}
var ai={readContext:Vg,useCallback:Q,useContext:Q,useEffect:Q,useImperativeHandle:Q,useInsertionEffect:Q,useLayoutEffect:Q,useMemo:Q,useReducer:Q,useRef:Q,useState:Q,useDebugValue:Q,useDeferredValue:Q,useTransition:Q,useMutableSource:Q,useSyncExternalStore:Q,useId:Q,unstable_isNewReconciler:!1},Yh={readContext:Vg,useCallback:function(a,b){ci().memoizedState=[a,void 0===b?null:b];return a},useContext:Vg,useEffect:vi,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ti(4194308,
4,yi.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ti(4194308,4,a,b)},useInsertionEffect:function(a,b){return ti(4,2,a,b)},useMemo:function(a,b){var c=ci();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=ci();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=Gi.bind(null,N,a);return[d.memoizedState,a]},useRef:function(a){var b=
ci();a={current:a};return b.memoizedState=a},useState:qi,useDebugValue:Ai,useDeferredValue:function(a){return ci().memoizedState=a},useTransition:function(){var a=qi(!1),b=a[0];a=Ei.bind(null,a[1]);ci().memoizedState=a;return[b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=N,e=ci();if(I){if(void 0===c)throw Error(p(407));c=c()}else{c=b();if(null===R)throw Error(p(349));0!==(Rh&30)||ni(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;vi(ki.bind(null,d,
f,a),[a]);d.flags|=2048;li(9,mi.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=ci(),b=R.identifierPrefix;if(I){var c=sg;var d=rg;c=(d&~(1<<32-oc(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Uh++;0<c&&(b+="H"+c.toString(32));b+=":"}else c=Vh++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:!1},Zh={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:fi,useRef:si,useState:function(){return fi(ei)},
useDebugValue:Ai,useDeferredValue:function(a){var b=di();return Di(b,O.memoizedState,a)},useTransition:function(){var a=fi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1},$h={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:gi,useRef:si,useState:function(){return gi(ei)},useDebugValue:Ai,useDeferredValue:function(a){var b=di();return null===
O?b.memoizedState=a:Di(b,O.memoizedState,a)},useTransition:function(){var a=gi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1};function Ki(a,b){try{var c="",d=b;do c+=Pa(d),d=d.return;while(d);var e=c}catch(f){e="\nError generating stack: "+f.message+"\n"+f.stack}return{value:a,source:b,stack:e,digest:null}}function Li(a,b,c){return{value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}
function Mi(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Ni="function"===typeof WeakMap?WeakMap:Map;function Oi(a,b,c){c=ch(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Pi||(Pi=!0,Qi=d);Mi(a,b)};return c}
function Ri(a,b,c){c=ch(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Mi(a,b)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){Mi(a,b);"function"!==typeof d&&(null===Si?Si=new Set([this]):Si.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}
function Ti(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Ni;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ui.bind(null,a,b,c),b.then(a,a))}function Vi(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}
function Wi(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=ch(-1,1),b.tag=2,dh(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Xi=ua.ReactCurrentOwner,Ug=!1;function Yi(a,b,c,d){b.child=null===a?Ch(b,null,c,d):Bh(b,a.child,c,d)}
function Zi(a,b,c,d,e){c=c.render;var f=b.ref;Tg(b,e);d=Xh(a,b,c,d,f,e);c=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&c&&vg(b);b.flags|=1;Yi(a,b,d,e);return b.child}
function aj(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!bj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,cj(a,b,f,d,e);a=yh(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie;if(c(g,d)&&a.ref===b.ref)return $i(a,b,e)}b.flags|=1;a=wh(f,d);a.ref=b.ref;a.return=b;return b.child=a}
function cj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie(f,d)&&a.ref===b.ref)if(Ug=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(Ug=!0);else return b.lanes=a.lanes,$i(a,b,e)}return dj(a,b,c,d,e)}
function ej(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(fj,gj),gj|=c;else{if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G(fj,gj),gj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G(fj,gj);gj|=d}else null!==
f?(d=f.baseLanes|c,b.memoizedState=null):d=c,G(fj,gj),gj|=d;Yi(a,b,e,c);return b.child}function hj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function dj(a,b,c,d,e){var f=Zf(c)?Xf:H.current;f=Yf(b,f);Tg(b,e);c=Xh(a,b,c,d,f,e);d=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&d&&vg(b);b.flags|=1;Yi(a,b,c,e);return b.child}
function ij(a,b,c,d,e){if(Zf(c)){var f=!0;cg(b)}else f=!1;Tg(b,e);if(null===b.stateNode)jj(a,b),ph(b,c,d),rh(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=Vg(l):(l=Zf(c)?Xf:H.current,l=Yf(b,l));var m=c.getDerivedStateFromProps,q="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;q||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||
(h!==d||k!==l)&&qh(b,g,d,l);$g=!1;var r=b.memoizedState;g.state=r;gh(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||$g?("function"===typeof m&&(kh(b,c,m,d),k=b.memoizedState),(h=$g||oh(b,c,h,d,r,k,l))?(q||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.flags|=4194308)):
("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;bh(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Lg(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=Vg(k):(k=Zf(c)?Xf:H.current,k=Yf(b,k));var y=c.getDerivedStateFromProps;(m="function"===typeof y||"function"===typeof g.getSnapshotBeforeUpdate)||
"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&qh(b,g,d,k);$g=!1;r=b.memoizedState;g.state=r;gh(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||$g?("function"===typeof y&&(kh(b,c,y,d),n=b.memoizedState),(l=$g||oh(b,c,l,d,r,n,k)||!1)?(m||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),"function"===typeof g.UNSAFE_componentWillUpdate&&
g.UNSAFE_componentWillUpdate(d,n,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===
a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=!1)}return kj(a,b,c,d,f,e)}
function kj(a,b,c,d,e,f){hj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg(b,c,!1),$i(a,b,f);d=b.stateNode;Xi.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Bh(b,a.child,null,f),b.child=Bh(b,null,h,f)):Yi(a,b,h,f);b.memoizedState=d.state;e&&dg(b,c,!0);return b.child}function lj(a){var b=a.stateNode;b.pendingContext?ag(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag(a,b.context,!1);Ih(a,b.containerInfo)}
function mj(a,b,c,d,e){Ig();Jg(e);b.flags|=256;Yi(a,b,c,d);return b.child}var nj={dehydrated:null,treeContext:null,retryLane:0};function oj(a){return{baseLanes:a,cachePool:null,transitions:null}}
function pj(a,b,c){var d=b.pendingProps,e=M.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G(M,e&1);if(null===a){Eg(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:"$!"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:"hidden",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=
g):f=qj(g,d,0,null),a=Ah(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=oj(c),b.memoizedState=nj,a):rj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return sj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:"hidden",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=wh(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=wh(h,f):(f=Ah(f,g,c,null),f.flags|=2);f.return=
b;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?oj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=nj;return d}f=a.child;a=f.sibling;d=wh(f,{mode:"visible",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}
function rj(a,b){b=qj({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}function tj(a,b,c,d){null!==d&&Jg(d);Bh(b,a.child,null,c);a=rj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}
function sj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Li(Error(p(422))),tj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=qj({mode:"visible",children:d.children},e,0,null);f=Ah(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Bh(b,a.child,null,g);b.child.memoizedState=oj(g);b.memoizedState=nj;return f}if(0===(b.mode&1))return tj(a,b,g,null);if("$!"===e.data){d=e.nextSibling&&e.nextSibling.dataset;
if(d)var h=d.dgst;d=h;f=Error(p(419));d=Li(f,d,void 0);return tj(a,b,g,d)}h=0!==(g&a.childLanes);if(Ug||h){d=R;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0}e=0!==(e&(d.suspendedLanes|g))?0:e;
0!==e&&e!==f.retryLane&&(f.retryLane=e,Zg(a,e),mh(d,a,e,-1))}uj();d=Li(Error(p(421)));return tj(a,b,g,d)}if("$?"===e.data)return b.flags|=128,b.child=a.child,b=vj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg=Lf(e.nextSibling);xg=b;I=!0;zg=null;null!==a&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=b);b=rj(b,d.children);b.flags|=4096;return b}function wj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);Sg(a.return,b,c)}
function xj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}
function yj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Yi(a,b,d.children,c);d=M.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&wj(a,c,b);else if(19===a.tag)wj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}G(M,d);if(0===(b.mode&1))b.memoizedState=
null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Mh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);xj(b,!1,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Mh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}xj(b,!0,c,null,f);break;case "together":xj(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}
function jj(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2)}function $i(a,b,c){null!==a&&(b.dependencies=a.dependencies);hh|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=wh(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=wh(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function zj(a,b,c){switch(b.tag){case 3:lj(b);Ig();break;case 5:Kh(b);break;case 1:Zf(b.type)&&cg(b);break;case 4:Ih(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G(Mg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G(M,M.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return pj(a,b,c);G(M,M.current&1);a=$i(a,b,c);return null!==a?a.sibling:null}G(M,M.current&1);break;case 19:d=0!==(c&
b.childLanes);if(0!==(a.flags&128)){if(d)return yj(a,b,c);b.flags|=128}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G(M,M.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,ej(a,b,c)}return $i(a,b,c)}var Aj,Bj,Cj,Dj;
Aj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Bj=function(){};
Cj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;Hh(Eh.current);var f=null;switch(c){case "input":e=Ya(a,e);d=Ya(a,d);f=[];break;case "select":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case "textarea":e=gb(a,e);d=gb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=Bf)}ub(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&
(c||(c={}),c[g]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,
c)),c=k;else"dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ea.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&D("scroll",a),f||h===k||(f=[])):(f=f||[]).push(l,k))}c&&(f=f||[]).push("style",c);var l=f;if(b.updateQueue=l)b.flags|=4}};Dj=function(a,b,c,d){c!==d&&(b.flags|=4)};
function Ej(a,b){if(!I)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}
function S(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}
function Fj(a,b,c){var d=b.pendingProps;wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(b),null;case 1:return Zf(b.type)&&$f(),S(b),null;case 3:d=b.stateNode;Jh();E(Wf);E(H);Oh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Gj(zg),zg=null));Bj(a,b);S(b);return null;case 5:Lh(b);var e=Hh(Gh.current);
c=b.type;if(null!==a&&null!=b.stateNode)Cj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(p(166));S(b);return null}a=Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of]=b;d[Pf]=f;a=0!==(b.mode&1);switch(c){case "dialog":D("cancel",d);D("close",d);break;case "iframe":case "object":case "embed":D("load",d);break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],d);break;case "source":D("error",d);break;case "img":case "image":case "link":D("error",
d);D("load",d);break;case "details":D("toggle",d);break;case "input":Za(d,f);D("invalid",d);break;case "select":d._wrapperState={wasMultiple:!!f.multiple};D("invalid",d);break;case "textarea":hb(d,f),D("invalid",d)}ub(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,h,a),e=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,
h,a),e=["children",""+h]):ea.hasOwnProperty(g)&&null!=h&&"onScroll"===g&&D("scroll",d)}switch(c){case "input":Va(d);db(d,f,!0);break;case "textarea":Va(d);jb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=Bf)}d=e;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=kb(c));"http://www.w3.org/1999/xhtml"===a?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):
"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of]=b;a[Pf]=d;Aj(a,b,!1,!1);b.stateNode=a;a:{g=vb(c,d);switch(c){case "dialog":D("cancel",a);D("close",a);e=d;break;case "iframe":case "object":case "embed":D("load",a);e=d;break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],a);e=d;break;case "source":D("error",a);e=d;break;case "img":case "image":case "link":D("error",
a);D("load",a);e=d;break;case "details":D("toggle",a);e=d;break;case "input":Za(a,d);e=Ya(a,d);D("invalid",a);break;case "option":e=d;break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});D("invalid",a);break;case "textarea":hb(a,d);e=gb(a,d);D("invalid",a);break;default:e=d}ub(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?sb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&nb(a,k)):"children"===f?"string"===typeof k?("textarea"!==
c||""!==k)&&ob(a,k):"number"===typeof k&&ob(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ea.hasOwnProperty(f)?null!=k&&"onScroll"===f&&D("scroll",a):null!=k&&ta(a,f,k,g))}switch(c){case "input":Va(a);db(a,d,!1);break;case "textarea":Va(a);jb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,
!0);break;default:"function"===typeof e.onClick&&(a.onclick=Bf)}switch(c){case "button":case "input":case "select":case "textarea":d=!!d.autoFocus;break a;case "img":d=!0;break a;default:d=!1}}d&&(b.flags|=4)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}S(b);return null;case 6:if(a&&null!=b.stateNode)Dj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(p(166));c=Hh(Gh.current);Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.memoizedProps;d[Of]=b;if(f=d.nodeValue!==c)if(a=
xg,null!==a)switch(a.tag){case 3:Af(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&Af(d.nodeValue,c,0!==(a.mode&1))}f&&(b.flags|=4)}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of]=b,b.stateNode=d}S(b);return null;case 13:E(M);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I&&null!==yg&&0!==(b.mode&1)&&0===(b.flags&128))Hg(),Ig(),b.flags|=98560,f=!1;else if(f=Gg(b),null!==d&&null!==d.dehydrated){if(null===
a){if(!f)throw Error(p(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p(317));f[Of]=b}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S(b);f=!1}else null!==zg&&(Gj(zg),zg=null),f=!0;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(M.current&1)?0===T&&(T=3):uj()));null!==b.updateQueue&&(b.flags|=4);S(b);return null;case 4:return Jh(),
Bj(a,b),null===a&&sf(b.stateNode.containerInfo),S(b),null;case 10:return Rg(b.type._context),S(b),null;case 17:return Zf(b.type)&&$f(),S(b),null;case 19:E(M);f=b.memoizedState;if(null===f)return S(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Ej(f,!1);else{if(0!==T||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Mh(a);if(null!==g){b.flags|=128;Ej(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,
g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G(M,M.current&1|2);return b.child}a=
a.sibling}null!==f.tail&&B()>Hj&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304)}else{if(!d)if(a=Mh(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Ej(f,!0),null===f.tail&&"hidden"===f.tailMode&&!g.alternate&&!I)return S(b),null}else 2*B()-f.renderingStartTime>Hj&&1073741824!==c&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g)}if(null!==f.tail)return b=f.tail,f.rendering=
b,f.tail=b.sibling,f.renderingStartTime=B(),b.sibling=null,c=M.current,G(M,d?c&1|2:c&1),b;S(b);return null;case 22:case 23:return Ij(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(gj&1073741824)&&(S(b),b.subtreeFlags&6&&(b.flags|=8192)):S(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}
function Jj(a,b){wg(b);switch(b.tag){case 1:return Zf(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return Jh(),E(Wf),E(H),Oh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Lh(b),null;case 13:E(M);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));Ig()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E(M),null;case 4:return Jh(),null;case 10:return Rg(b.type._context),null;case 22:case 23:return Ij(),
null;case 24:return null;default:return null}}var Kj=!1,U=!1,Lj="function"===typeof WeakSet?WeakSet:Set,V=null;function Mj(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null)}catch(d){W(a,b,d)}else c.current=null}function Nj(a,b,c){try{c()}catch(d){W(a,b,d)}}var Oj=!1;
function Pj(a,b){Cf=dd;a=Me();if(Ne(a)){if("selectionStart"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=
q.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode}q=y}c=-1===h||-1===k?null:{start:h,end:k}}else c=null}c=c||{start:0,end:0}}else c=null;Df={focusedElem:a,selectionRange:c};dd=!1;for(V=b;null!==V;)if(b=V,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V=a;else for(;null!==V;){b=V;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;
case 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Lg(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent="":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(F){W(b,b.return,F)}a=b.sibling;if(null!==a){a.return=b.return;V=a;break}V=b.return}n=Oj;Oj=!1;return n}
function Qj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Nj(b,c,f)}e=e.next}while(e!==d)}}function Rj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function Sj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c}"function"===typeof b?b(a):b.current=a}}
function Tj(a){var b=a.alternate;null!==b&&(a.alternate=null,Tj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of],delete b[Pf],delete b[of],delete b[Qf],delete b[Rf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}function Uj(a){return 5===a.tag||3===a.tag||4===a.tag}
function Vj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Uj(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}
function Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf));else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling}
function Xj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Xj(a,b,c),a=a.sibling;null!==a;)Xj(a,b,c),a=a.sibling}var X=null,Yj=!1;function Zj(a,b,c){for(c=c.child;null!==c;)ak(a,b,c),c=c.sibling}
function ak(a,b,c){if(lc&&"function"===typeof lc.onCommitFiberUnmount)try{lc.onCommitFiberUnmount(kc,c)}catch(h){}switch(c.tag){case 5:U||Mj(c,b);case 6:var d=X,e=Yj;X=null;Zj(a,b,c);X=d;Yj=e;null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X.removeChild(c.stateNode));break;case 18:null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?Kf(a.parentNode,c):1===a.nodeType&&Kf(a,c),bd(a)):Kf(X,c.stateNode));break;case 4:d=X;e=Yj;X=c.stateNode.containerInfo;Yj=!0;
Zj(a,b,c);X=d;Yj=e;break;case 0:case 11:case 14:case 15:if(!U&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Nj(c,b,g):0!==(f&4)&&Nj(c,b,g));e=e.next}while(e!==d)}Zj(a,b,c);break;case 1:if(!U&&(Mj(c,b),d=c.stateNode,"function"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){W(c,b,h)}Zj(a,b,c);break;case 21:Zj(a,b,c);break;case 22:c.mode&1?(U=(d=U)||null!==
c.memoizedState,Zj(a,b,c),U=d):Zj(a,b,c);break;default:Zj(a,b,c)}}function bk(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Lj);b.forEach(function(b){var d=ck.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}
function dk(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X=h.stateNode;Yj=!1;break a;case 3:X=h.stateNode.containerInfo;Yj=!0;break a;case 4:X=h.stateNode.containerInfo;Yj=!0;break a}h=h.return}if(null===X)throw Error(p(160));ak(f,g,e);X=null;Yj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(l){W(e,b,l)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)ek(b,a),b=b.sibling}
function ek(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:dk(b,a);fk(a);if(d&4){try{Qj(3,a,a.return),Rj(3,a)}catch(t){W(a,a.return,t)}try{Qj(5,a,a.return)}catch(t){W(a,a.return,t)}}break;case 1:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);break;case 5:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob(e,"")}catch(t){W(a,a.return,t)}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;
a.updateQueue=null;if(null!==k)try{"input"===h&&"radio"===f.type&&null!=f.name&&ab(e,f);vb(h,g);var l=vb(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];"style"===m?sb(e,q):"dangerouslySetInnerHTML"===m?nb(e,q):"children"===m?ob(e,q):ta(e,m,q,l)}switch(h){case "input":bb(e,f);break;case "textarea":ib(e,f);break;case "select":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb(e,!!f.multiple,
f.defaultValue,!0):fb(e,!!f.multiple,f.multiple?[]:"",!1))}e[Pf]=f}catch(t){W(a,a.return,t)}}break;case 6:dk(b,a);fk(a);if(d&4){if(null===a.stateNode)throw Error(p(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f}catch(t){W(a,a.return,t)}}break;case 3:dk(b,a);fk(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd(b.containerInfo)}catch(t){W(a,a.return,t)}break;case 4:dk(b,a);fk(a);break;case 13:dk(b,a);fk(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||
null!==e.alternate&&null!==e.alternate.memoizedState||(gk=B()));d&4&&bk(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U=(l=U)||m,dk(b,a),U=l):dk(b,a);fk(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V=a,m=a.child;null!==m;){for(q=V=m;null!==V;){r=V;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Qj(4,r,r.return);break;case 1:Mj(r,r.return);var n=r.stateNode;if("function"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=
b.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount()}catch(t){W(d,c,t)}}break;case 5:Mj(r,r.return);break;case 22:if(null!==r.memoizedState){hk(q);continue}}null!==y?(y.return=r,V=y):hk(q)}m=m.sibling}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty("display")?k.display:null,h.style.display=
rb("display",g))}catch(t){W(a,a.return,t)}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?"":q.memoizedProps}catch(t){W(a,a.return,t)}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling}}break;case 19:dk(b,a);fk(a);d&4&&bk(a);break;case 21:break;default:dk(b,
a),fk(a)}}function fk(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Uj(c)){var d=c;break a}c=c.return}throw Error(p(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob(e,""),d.flags&=-33);var f=Vj(a);Xj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Vj(a);Wj(a,h,g);break;default:throw Error(p(161));}}catch(k){W(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function ik(a,b,c){V=a;jk(a,b,c)}
function jk(a,b,c){for(var d=0!==(a.mode&1);null!==V;){var e=V,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Kj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U;h=Kj;var l=U;Kj=g;if((U=k)&&!l)for(V=e;null!==V;)g=V,k=g.child,22===g.tag&&null!==g.memoizedState?kk(e):null!==k?(k.return=g,V=k):kk(e);for(;null!==f;)V=f,jk(f,b,c),f=f.sibling;V=e;Kj=h;U=l}lk(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V=f):lk(a,b,c)}}
function lk(a){for(;null!==V;){var b=V;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U||Rj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U)if(null===c)d.componentDidMount();else{var e=b.elementType===b.type?c.memoizedProps:Lg(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&ih(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=
b.child.stateNode;break;case 1:c=b.child.stateNode}ih(b,g,c)}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case "button":case "input":case "select":case "textarea":k.autoFocus&&c.focus();break;case "img":k.src&&(c.src=k.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd(q)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;
default:throw Error(p(163));}U||b.flags&512&&Sj(b)}catch(r){W(b,b.return,r)}}if(b===a){V=null;break}c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}function hk(a){for(;null!==V;){var b=V;if(b===a){V=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}
function kk(a){for(;null!==V;){var b=V;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Rj(4,b)}catch(k){W(b,c,k)}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){W(b,e,k)}}var f=b.return;try{Sj(b)}catch(k){W(b,f,k)}break;case 5:var g=b.return;try{Sj(b)}catch(k){W(b,g,k)}}}catch(k){W(b,b.return,k)}if(b===a){V=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V=h;break}V=b.return}}
var mk=Math.ceil,nk=ua.ReactCurrentDispatcher,ok=ua.ReactCurrentOwner,pk=ua.ReactCurrentBatchConfig,K=0,R=null,Y=null,Z=0,gj=0,fj=Uf(0),T=0,qk=null,hh=0,rk=0,sk=0,tk=null,uk=null,gk=0,Hj=Infinity,vk=null,Pi=!1,Qi=null,Si=null,wk=!1,xk=null,yk=0,zk=0,Ak=null,Bk=-1,Ck=0;function L(){return 0!==(K&6)?B():-1!==Bk?Bk:Bk=B()}
function lh(a){if(0===(a.mode&1))return 1;if(0!==(K&2)&&0!==Z)return Z&-Z;if(null!==Kg.transition)return 0===Ck&&(Ck=yc()),Ck;a=C;if(0!==a)return a;a=window.event;a=void 0===a?16:jd(a.type);return a}function mh(a,b,c,d){if(50<zk)throw zk=0,Ak=null,Error(p(185));Ac(a,c,d);if(0===(K&2)||a!==R)a===R&&(0===(K&2)&&(rk|=c),4===T&&Dk(a,Z)),Ek(a,d),1===c&&0===K&&0===(b.mode&1)&&(Hj=B()+500,fg&&jg())}
function Ek(a,b){var c=a.callbackNode;wc(a,b);var d=uc(a,a===R?Z:0);if(0===d)null!==c&&bc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc(c);if(1===b)0===a.tag?ig(Fk.bind(null,a)):hg(Fk.bind(null,a)),Jf(function(){0===(K&6)&&jg()}),c=null;else{switch(Dc(d)){case 1:c=fc;break;case 4:c=gc;break;case 16:c=hc;break;case 536870912:c=jc;break;default:c=hc}c=Gk(c,Hk.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}
function Hk(a,b){Bk=-1;Ck=0;if(0!==(K&6))throw Error(p(327));var c=a.callbackNode;if(Ik()&&a.callbackNode!==c)return null;var d=uc(a,a===R?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Jk(a,d);else{b=d;var e=K;K|=2;var f=Kk();if(R!==a||Z!==b)vk=null,Hj=B()+500,Lk(a,b);do try{Mk();break}catch(h){Nk(a,h)}while(1);Qg();nk.current=f;K=e;null!==Y?b=0:(R=null,Z=0,b=T)}if(0!==b){2===b&&(e=xc(a),0!==e&&(d=e,b=Ok(a,e)));if(1===b)throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;if(6===b)Dk(a,d);
else{e=a.current.alternate;if(0===(d&30)&&!Pk(e)&&(b=Jk(a,d),2===b&&(f=xc(a),0!==f&&(d=f,b=Ok(a,f))),1===b))throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Qk(a,uk,vk);break;case 3:Dk(a,d);if((d&130023424)===d&&(b=gk+500-B(),10<b)){if(0!==uc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){L();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),b);break}Qk(a,uk,vk);break;case 4:Dk(a,d);if((d&4194240)===
d)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=B()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*mk(d/1960))-d;if(10<d){a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),d);break}Qk(a,uk,vk);break;case 5:Qk(a,uk,vk);break;default:throw Error(p(329));}}}Ek(a,B());return a.callbackNode===c?Hk.bind(null,a):null}
function Ok(a,b){var c=tk;a.current.memoizedState.isDehydrated&&(Lk(a,b).flags|=256);a=Jk(a,b);2!==a&&(b=uk,uk=c,null!==b&&Gj(b));return a}function Gj(a){null===uk?uk=a:uk.push.apply(uk,a)}
function Pk(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}
function Dk(a,b){b&=~sk;b&=~rk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc(b),d=1<<c;a[c]=-1;b&=~d}}function Fk(a){if(0!==(K&6))throw Error(p(327));Ik();var b=uc(a,0);if(0===(b&1))return Ek(a,B()),null;var c=Jk(a,b);if(0!==a.tag&&2===c){var d=xc(a);0!==d&&(b=d,c=Ok(a,d))}if(1===c)throw c=qk,Lk(a,0),Dk(a,b),Ek(a,B()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Qk(a,uk,vk);Ek(a,B());return null}
function Rk(a,b){var c=K;K|=1;try{return a(b)}finally{K=c,0===K&&(Hj=B()+500,fg&&jg())}}function Sk(a){null!==xk&&0===xk.tag&&0===(K&6)&&Ik();var b=K;K|=1;var c=pk.transition,d=C;try{if(pk.transition=null,C=1,a)return a()}finally{C=d,pk.transition=c,K=b,0===(K&6)&&jg()}}function Ij(){gj=fj.current;E(fj)}
function Lk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:Jh();E(Wf);E(H);Oh();break;case 5:Lh(d);break;case 4:Jh();break;case 13:E(M);break;case 19:E(M);break;case 10:Rg(d.type._context);break;case 22:case 23:Ij()}c=c.return}R=a;Y=a=wh(a.current,null);Z=gj=b;T=0;qk=null;sk=rk=hh=0;uk=tk=null;if(null!==Wg){for(b=
0;b<Wg.length;b++)if(c=Wg[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}Wg=null}return a}
function Nk(a,b){do{var c=Y;try{Qg();Ph.current=ai;if(Sh){for(var d=N.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Sh=!1}Rh=0;P=O=N=null;Th=!1;Uh=0;ok.current=null;if(null===c||null===c.return){T=1;qk=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,
m.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null)}var y=Vi(g);if(null!==y){y.flags&=-257;Wi(y,g,h,f,b);y.mode&1&&Ti(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t}else n.add(k);break a}else{if(0===(b&1)){Ti(f,l,b);uj();break a}k=Error(p(426))}}else if(I&&h.mode&1){var J=Vi(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Wi(J,g,h,f,b);Jg(Ki(k,h));break a}}f=k=Ki(k,h);4!==T&&(T=2);null===tk?tk=[f]:tk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;
b&=-b;f.lanes|=b;var x=Oi(f,k,b);fh(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&("function"===typeof w.getDerivedStateFromError||null!==u&&"function"===typeof u.componentDidCatch&&(null===Si||!Si.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Ri(f,h,b);fh(f,F);break a}}f=f.return}while(null!==f)}Tk(c)}catch(na){b=na;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}function Kk(){var a=nk.current;nk.current=ai;return null===a?ai:a}
function uj(){if(0===T||3===T||2===T)T=4;null===R||0===(hh&268435455)&&0===(rk&268435455)||Dk(R,Z)}function Jk(a,b){var c=K;K|=2;var d=Kk();if(R!==a||Z!==b)vk=null,Lk(a,b);do try{Uk();break}catch(e){Nk(a,e)}while(1);Qg();K=c;nk.current=d;if(null!==Y)throw Error(p(261));R=null;Z=0;return T}function Uk(){for(;null!==Y;)Vk(Y)}function Mk(){for(;null!==Y&&!cc();)Vk(Y)}function Vk(a){var b=Wk(a.alternate,a,gj);a.memoizedProps=a.pendingProps;null===b?Tk(a):Y=b;ok.current=null}
function Tk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Fj(c,b,gj),null!==c){Y=c;return}}else{c=Jj(c,b);if(null!==c){c.flags&=32767;Y=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{T=6;Y=null;return}}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===T&&(T=5)}function Qk(a,b,c){var d=C,e=pk.transition;try{pk.transition=null,C=1,Xk(a,b,c,d)}finally{pk.transition=e,C=d}return null}
function Xk(a,b,c,d){do Ik();while(null!==xk);if(0!==(K&6))throw Error(p(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc(a,f);a===R&&(Y=R=null,Z=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||wk||(wk=!0,Gk(hc,function(){Ik();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=pk.transition;pk.transition=null;
var g=C;C=1;var h=K;K|=4;ok.current=null;Pj(a,c);ek(c,a);Oe(Df);dd=!!Cf;Df=Cf=null;a.current=c;ik(c,a,e);dc();K=h;C=g;pk.transition=f}else a.current=c;wk&&(wk=!1,xk=a,yk=e);f=a.pendingLanes;0===f&&(Si=null);mc(c.stateNode,d);Ek(a,B());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Pi)throw Pi=!1,a=Qi,Qi=null,a;0!==(yk&1)&&0!==a.tag&&Ik();f=a.pendingLanes;0!==(f&1)?a===Ak?zk++:(zk=0,Ak=a):zk=0;jg();return null}
function Ik(){if(null!==xk){var a=Dc(yk),b=pk.transition,c=C;try{pk.transition=null;C=16>a?16:a;if(null===xk)var d=!1;else{a=xk;xk=null;yk=0;if(0!==(K&6))throw Error(p(331));var e=K;K|=4;for(V=a.current;null!==V;){var f=V,g=f.child;if(0!==(V.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V=l;null!==V;){var m=V;switch(m.tag){case 0:case 11:case 15:Qj(8,m,f)}var q=m.child;if(null!==q)q.return=m,V=q;else for(;null!==V;){m=V;var r=m.sibling,y=m.return;Tj(m);if(m===
l){V=null;break}if(null!==r){r.return=y;V=r;break}V=y}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J}while(null!==t)}}V=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V=g;else b:for(;null!==V;){f=V;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Qj(9,f,f.return)}var x=f.sibling;if(null!==x){x.return=f.return;V=x;break b}V=f.return}}var w=a.current;for(V=w;null!==V;){g=V;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==
u)u.return=g,V=u;else b:for(g=w;null!==V;){h=V;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Rj(9,h)}}catch(na){W(h,h.return,na)}if(h===g){V=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V=F;break b}V=h.return}}K=e;jg();if(lc&&"function"===typeof lc.onPostCommitFiberRoot)try{lc.onPostCommitFiberRoot(kc,a)}catch(na){}d=!0}return d}finally{C=c,pk.transition=b}}return!1}function Yk(a,b,c){b=Ki(c,b);b=Oi(a,b,1);a=dh(a,b,1);b=L();null!==a&&(Ac(a,1,b),Ek(a,b))}
function W(a,b,c){if(3===a.tag)Yk(a,a,c);else for(;null!==b;){if(3===b.tag){Yk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Si||!Si.has(d))){a=Ki(c,a);a=Ri(b,a,1);b=dh(b,a,1);a=L();null!==b&&(Ac(b,1,a),Ek(b,a));break}}b=b.return}}
function Ui(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=L();a.pingedLanes|=a.suspendedLanes&c;R===a&&(Z&c)===c&&(4===T||3===T&&(Z&130023424)===Z&&500>B()-gk?Lk(a,0):sk|=c);Ek(a,b)}function Zk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc,sc<<=1,0===(sc&130023424)&&(sc=4194304)));var c=L();a=Zg(a,b);null!==a&&(Ac(a,b,c),Ek(a,c))}function vj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Zk(a,c)}
function ck(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Zk(a,c)}var Wk;
Wk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)Ug=!0;else{if(0===(a.lanes&c)&&0===(b.flags&128))return Ug=!1,zj(a,b,c);Ug=0!==(a.flags&131072)?!0:!1}else Ug=!1,I&&0!==(b.flags&1048576)&&ug(b,ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;jj(a,b);a=b.pendingProps;var e=Yf(b,H.current);Tg(b,c);e=Xh(null,b,d,a,e,c);var f=bi();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=
null,Zf(d)?(f=!0,cg(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,ah(b),e.updater=nh,b.stateNode=e,e._reactInternals=b,rh(b,d,a,c),b=kj(null,b,d,!0,f,c)):(b.tag=0,I&&f&&vg(b),Yi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{jj(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=$k(d);a=Lg(d,a);switch(e){case 0:b=dj(null,b,d,a,c);break a;case 1:b=ij(null,b,d,a,c);break a;case 11:b=Zi(null,b,d,a,c);break a;case 14:b=aj(null,b,d,Lg(d.type,a),c);break a}throw Error(p(306,
d,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),dj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),ij(a,b,d,e,c);case 3:a:{lj(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;bh(a,b);gh(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=
f,b.memoizedState=f,b.flags&256){e=Ki(Error(p(423)),b);b=mj(a,b,d,c,e);break a}else if(d!==e){e=Ki(Error(p(424)),b);b=mj(a,b,d,c,e);break a}else for(yg=Lf(b.stateNode.containerInfo.firstChild),xg=b,I=!0,zg=null,c=Ch(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{Ig();if(d===e){b=$i(a,b,c);break a}Yi(a,b,d,c)}b=b.child}return b;case 5:return Kh(b),null===a&&Eg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef(d,e)?g=null:null!==f&&Ef(d,f)&&(b.flags|=32),
hj(a,b),Yi(a,b,g,c),b.child;case 6:return null===a&&Eg(b),null;case 13:return pj(a,b,c);case 4:return Ih(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Bh(b,null,d,c):Yi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),Zi(a,b,d,e,c);case 7:return Yi(a,b,b.pendingProps,c),b.child;case 8:return Yi(a,b,b.pendingProps.children,c),b.child;case 12:return Yi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;
g=e.value;G(Mg,d._currentValue);d._currentValue=g;if(null!==f)if(He(f.value,g)){if(f.children===e.children&&!Wf.current){b=$i(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=ch(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);Sg(f.return,
c,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);Sg(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}Yi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,d=b.pendingProps.children,Tg(b,c),e=Vg(e),d=d(e),b.flags|=1,Yi(a,b,d,c),
b.child;case 14:return d=b.type,e=Lg(d,b.pendingProps),e=Lg(d.type,e),aj(a,b,d,e,c);case 15:return cj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),jj(a,b),b.tag=1,Zf(d)?(a=!0,cg(b)):a=!1,Tg(b,c),ph(b,d,e),rh(b,d,e,c),kj(null,b,d,!0,a,c);case 19:return yj(a,b,c);case 22:return ej(a,b,c)}throw Error(p(156,b.tag));};function Gk(a,b){return ac(a,b)}
function al(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function Bg(a,b,c,d){return new al(a,b,c,d)}function bj(a){a=a.prototype;return!(!a||!a.isReactComponent)}
function $k(a){if("function"===typeof a)return bj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da)return 11;if(a===Ga)return 14}return 2}
function wh(a,b){var c=a.alternate;null===c?(c=Bg(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};
c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function yh(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)bj(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ya:return Ah(c.children,e,f,b);case za:g=8;e|=8;break;case Aa:return a=Bg(12,c,b,e|2),a.elementType=Aa,a.lanes=f,a;case Ea:return a=Bg(13,c,b,e),a.elementType=Ea,a.lanes=f,a;case Fa:return a=Bg(19,c,b,e),a.elementType=Fa,a.lanes=f,a;case Ia:return qj(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Ba:g=10;break a;case Ca:g=9;break a;case Da:g=11;
break a;case Ga:g=14;break a;case Ha:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,""));}b=Bg(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Ah(a,b,c,d){a=Bg(7,a,d,b);a.lanes=c;return a}function qj(a,b,c,d){a=Bg(22,a,d,b);a.elementType=Ia;a.lanes=c;a.stateNode={isHidden:!1};return a}function xh(a,b,c){a=Bg(6,a,null,b);a.lanes=c;return a}
function zh(a,b,c){b=Bg(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function bl(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc(0);this.expirationTimes=zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=
null}function cl(a,b,c,d,e,f,g,h,k){a=new bl(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=Bg(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};ah(f);return a}function dl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:wa,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
function el(a){if(!a)return Vf;a=a._reactInternals;a:{if(Vb(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Zf(c))return bg(a,c,b)}return b}
function fl(a,b,c,d,e,f,g,h,k){a=cl(c,d,!0,a,e,f,g,h,k);a.context=el(null);c=a.current;d=L();e=lh(c);f=ch(d,e);f.callback=void 0!==b&&null!==b?b:null;dh(c,f,e);a.current.lanes=e;Ac(a,e,d);Ek(a,d);return a}function gl(a,b,c,d){var e=b.current,f=L(),g=lh(e);c=el(c);null===b.context?b.context=c:b.pendingContext=c;b=ch(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=dh(e,b,g);null!==a&&(mh(a,e,g,f),eh(a,e,g));return g}
function hl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function il(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function jl(a,b){il(a,b);(a=a.alternate)&&il(a,b)}function kl(){return null}var ll="function"===typeof reportError?reportError:function(a){console.error(a)};function ml(a){this._internalRoot=a}
nl.prototype.render=ml.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));gl(a,b,null,null)};nl.prototype.unmount=ml.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Sk(function(){gl(null,a,null,null)});b[uf]=null}};function nl(a){this._internalRoot=a}
nl.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc.length&&0!==b&&b<Qc[c].priority;c++);Qc.splice(c,0,a);0===c&&Vc(a)}};function ol(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function pl(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function ql(){}
function rl(a,b,c,d,e){if(e){if("function"===typeof d){var f=d;d=function(){var a=hl(g);f.call(a)}}var g=fl(b,d,a,0,null,!1,!1,"",ql);a._reactRootContainer=g;a[uf]=g.current;sf(8===a.nodeType?a.parentNode:a);Sk();return g}for(;e=a.lastChild;)a.removeChild(e);if("function"===typeof d){var h=d;d=function(){var a=hl(k);h.call(a)}}var k=cl(a,0,!1,null,null,!1,!1,"",ql);a._reactRootContainer=k;a[uf]=k.current;sf(8===a.nodeType?a.parentNode:a);Sk(function(){gl(b,k,c,d)});return k}
function sl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if("function"===typeof e){var h=e;e=function(){var a=hl(g);h.call(a)}}gl(b,g,a,e)}else g=rl(c,b,a,e,d);return hl(g)}Ec=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc(b.pendingLanes);0!==c&&(Cc(b,c|1),Ek(b,B()),0===(K&6)&&(Hj=B()+500,jg()))}break;case 13:Sk(function(){var b=Zg(a,1);if(null!==b){var c=L();mh(b,a,1,c)}}),jl(a,1)}};
Fc=function(a){if(13===a.tag){var b=Zg(a,134217728);if(null!==b){var c=L();mh(b,a,134217728,c)}jl(a,134217728)}};Gc=function(a){if(13===a.tag){var b=lh(a),c=Zg(a,b);if(null!==c){var d=L();mh(c,a,b,d)}jl(a,b)}};Hc=function(){return C};Ic=function(a,b){var c=C;try{return C=a,b()}finally{C=c}};
yb=function(a,b,c){switch(b){case "input":bb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(p(90));Wa(d);bb(d,e)}}}break;case "textarea":ib(a,c);break;case "select":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Rk;Hb=Sk;
var tl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Rk]},ul={findFiberByHostInstance:Wc,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"};
var vl={bundleType:ul.bundleType,version:ul.version,rendererPackageName:ul.rendererPackageName,rendererConfig:ul.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb(a);return null===a?null:a.stateNode},findFiberByHostInstance:ul.findFiberByHostInstance||
kl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var wl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!wl.isDisabled&&wl.supportsFiber)try{kc=wl.inject(vl),lc=wl}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=tl;
exports.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!ol(b))throw Error(p(200));return dl(a,b,null,c)};exports.createRoot=function(a,b){if(!ol(a))throw Error(p(299));var c=!1,d="",e=ll;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=cl(a,1,!1,null,null,c,!1,d,e);a[uf]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ml(b)};
exports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(",");throw Error(p(268,a));}a=Zb(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a){return Sk(a)};exports.hydrate=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!0,c)};
exports.hydrateRoot=function(a,b,c){if(!ol(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=!1,f="",g=ll;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=fl(b,null,a,1,null!=c?c:null,e,!1,f,g);a[uf]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,
e);return new nl(b)};exports.render=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!pl(a))throw Error(p(40));return a._reactRootContainer?(Sk(function(){sl(null,null,a,!1,function(){a._reactRootContainer=null;a[uf]=null})}),!0):!1};exports.unstable_batchedUpdates=Rk;
exports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!pl(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return sl(a,b,c,!1,d)};exports.version="18.2.0-next-9e3b772b8-20220608";

},{"react":"n8MK","scheduler":"MDSO"}],"NKHc":[function(require,module,exports) {
'use strict';

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if ("production" !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}
if ("production" === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = require('./cjs/react-dom.production.min.js');
} else {
  module.exports = require('./cjs/react-dom.development.js');
}
},{"./cjs/react-dom.production.min.js":"i17t"}],"NdAl":[function(require,module,exports) {
'use strict';

var m = require('react-dom');
if ("production" === 'production') {
  exports.createRoot = m.createRoot;
  exports.hydrateRoot = m.hydrateRoot;
} else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  exports.createRoot = function (c, o) {
    i.usingClientEntryPoint = true;
    try {
      return m.createRoot(c, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };
  exports.hydrateRoot = function (c, h, o) {
    i.usingClientEntryPoint = true;
    try {
      return m.hydrateRoot(c, h, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };
}
},{"react-dom":"NKHc"}],"Tnu0":[function(require,module,exports) {

},{}],"SVCm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
//https://forms-eu1.hsforms.com/embed/v3/form/25321820/4cfc5151-36dc-4f43-be48-75425a6da2aa/

{/* {
    "form": {
        "portalId": 25321820,
        "guid": "4cfc5151-36dc-4f43-be48-75425a6da2aa",
        "cssClass": "",
        "inlineMessage": "",
        "redirectUrl": "https://www.ctb.nl/bedankt-contact/",
        "submitText": "Verstuur bericht",
        "formFieldGroups": [
            {
                "fields": [
                    {
                        "name": "firstname",
                        "label": "Voornaam",
                        "type": "string",
                        "fieldType": "text",
                        "description": "",
                        "groupName": "",
                        "displayOrder": -1,
                        "required": false,
                        "selectedOptions": [],
                        "options": [],
                        "validation": {
                            "name": "",
                            "message": "",
                            "data": "",
                            "useDefaultBlockList": false,
                            "blockedEmailAddresses": []
                        },
                        "enabled": true,
                        "hidden": false,
                        "defaultValue": "",
                        "isSmartField": false,
                        "unselectedLabel": "",
                        "placeholder": "",
                        "dependentFieldFilters": [],
                        "labelHidden": false,
                        "propertyObjectType": "CONTACT",
                        "metaData": [],
                        "objectTypeId": "0-1"
                    },
                    {
                        "name": "lastname",
                        "label": "Achternaam",
                        "type": "string",
                        "fieldType": "text",
                        "description": "",
                        "groupName": "",
                        "displayOrder": -1,
                        "required": true,
                        "selectedOptions": [],
                        "options": [],
                        "validation": {
                            "name": "",
                            "message": "",
                            "data": "",
                            "useDefaultBlockList": false,
                            "blockedEmailAddresses": []
                        },
                        "enabled": true,
                        "hidden": false,
                        "defaultValue": "",
                        "isSmartField": false,
                        "unselectedLabel": "",
                        "placeholder": "",
                        "dependentFieldFilters": [],
                        "labelHidden": false,
                        "propertyObjectType": "CONTACT",
                        "metaData": [],
                        "objectTypeId": "0-1"
                    }
                ],
                "default": true,
                "isSmartGroup": false,
                "richText": {
                    "content": "",
                    "type": "TEXT"
                },
                "isPageBreak": false
            },
            {
                "fields": [
                    {
                        "name": "email",
                        "label": "E-mail",
                        "type": "string",
                        "fieldType": "text",
                        "description": "",
                        "groupName": "",
                        "displayOrder": -1,
                        "required": true,
                        "selectedOptions": [],
                        "options": [],
                        "validation": {
                            "name": "",
                            "message": "",
                            "data": "",
                            "useDefaultBlockList": true,
                            "blockedEmailAddresses": []
                        },
                        "enabled": true,
                        "hidden": false,
                        "defaultValue": "",
                        "isSmartField": false,
                        "unselectedLabel": "",
                        "placeholder": "",
                        "dependentFieldFilters": [],
                        "labelHidden": false,
                        "propertyObjectType": "CONTACT",
                        "metaData": [],
                        "objectTypeId": "0-1"
                    },
                    {
                        "name": "phone",
                        "label": "Telefoonnummer",
                        "type": "string",
                        "fieldType": "phonenumber",
                        "description": "",
                        "groupName": "contactinformation",
                        "displayOrder": -1,
                        "required": false,
                        "selectedOptions": [],
                        "options": [],
                        "validation": {
                            "name": "",
                            "message": "",
                            "data": "7:20:true",
                            "useDefaultBlockList": false,
                            "blockedEmailAddresses": []
                        },
                        "enabled": true,
                        "hidden": false,
                        "defaultValue": "",
                        "isSmartField": false,
                        "unselectedLabel": "",
                        "placeholder": "",
                        "dependentFieldFilters": [],
                        "labelHidden": false,
                        "propertyObjectType": "CONTACT",
                        "metaData": [],
                        "objectTypeId": "0-1"
                    }
                ],
                "default": true,
                "isSmartGroup": false,
                "richText": {
                    "content": "",
                    "type": "TEXT"
                },
                "isPageBreak": false
            },
            {
                "fields": [
                    {
                        "name": "message",
                        "label": "Bericht",
                        "type": "string",
                        "fieldType": "textarea",
                        "description": "",
                        "groupName": "contact_activity",
                        "displayOrder": -1,
                        "required": true,
                        "selectedOptions": [],
                        "options": [],
                        "validation": {
                            "name": "",
                            "message": "",
                            "data": "",
                            "useDefaultBlockList": false,
                            "blockedEmailAddresses": []
                        },
                        "enabled": true,
                        "hidden": false,
                        "defaultValue": "",
                        "isSmartField": false,
                        "unselectedLabel": "",
                        "placeholder": "",
                        "dependentFieldFilters": [],
                        "labelHidden": false,
                        "propertyObjectType": "CONTACT",
                        "metaData": [],
                        "objectTypeId": "0-1"
                    }
                ],
                "default": true,
                "isSmartGroup": false,
                "richText": {
                    "content": "",
                    "type": "TEXT"
                },
                "isPageBreak": false
            }
        ],
        "metaData": [
            {
                "name": "notifyHubSpotOwner",
                "value": "true"
            },
            {
                "name": "lang",
                "value": "nl"
            },
            {
                "name": "clonedFromForm",
                "value": "8cfea3c4-439b-41fa-a65e-7dbadf8ca261"
            },
            {
                "name": "legalConsentOptions",
                "value": "{\"legitimateInterestSubscriptionTypes\":[126370477,125837255],\"communicationConsentCheckboxes\":[{\"communicationTypeId\":125837255,\"label\":\"<p>Ik ga ermee akkoord om berichten te ontvangen van CTB.</p>\",\"required\":true}],\"legitimateInterestLegalBasis\":\"LEGITIMATE_INTEREST_PQL\",\"communicationConsentText\":\"<p>CTB is toegewijd aan het beschermen en respecteren van je privacy, en we zullen je persoonlijke informatie alleen gebruiken om je account te beheren en om de producten en diensten te leveren waar je ons om hebt gevraagd. Van tijd tot tijd willen wij contact met je opnemen over onze producten en diensten, en andere inhoud die je interessant zou kunnen vinden.  Als je ermee instemt dat wij contact met je opnemen, vink dan hieronder aan hoe je wilt dat wij contact met je opnemen:</p>\",\"processingConsentType\":\"IMPLICIT\",\"processingConsentText\":\"<p>Om je van de gevraagde inhoud te voorzien, moeten wij je persoonlijke gegevens opslaan en verwerken. Vink het onderstaande selectievakje aan als je ons toestemming geeft je persoonlijke gegevens voor dit doel op te slaan.</p>\",\"processingConsentCheckboxLabel\":\"<p>Ik geef toestemming aan CTB om mijn persoonlijke gegevens op te slaan en te verwerken.</p>\",\"privacyPolicyText\":\"<p>CTB heeft de door jou verstrekte contactgegevens nodig om contact met je op te nemen over onze producten en diensten. Je kunt je op elk moment afmelden voor deze berichten. Bekijk ons privacybeleid voor meer informatie over hoe je je af kan melden, onze privacypraktijken en hoe we ons inzetten om je privacy te beschermen en respecteren.</p>\",\"isLegitimateInterest\":true}"
            },
            {
                "name": "embedAtTimestamp",
                "value": "1672323297291"
            },
            {
                "name": "formDefinitionUpdatedAt",
                "value": "1646045760105"
            }
        ],
        "captchaEnabled": false,
        "formTypeNumber": 0,
        "thankYouMessageJson": "",
        "themeColor": "",
        "themeName": "canvas",
        "style": null,
        "variantId": null,
        "isPublished": true
    },
    "properties": {},
    "knownSmartFields": [],
    "gates": {
        "viralityVariation": false,
        "useRecaptchaEnterprise": true
    },
    "scopes": {
        "noBranding": true,
        "renderShell": true,
        "rawHtmlAccess": false,
        "customStyleAccess": true
    },
    "time": 1672323297297,
    "themeCss": "",
    "globalStyle": "{\"fontFamily\":\"Titillium Web\",\"labelTextColor\":\"#201c1d\",\"labelTextSize\":\"14px\",\"submitFontColor\":\"#ffffff\",\"submitColor\":\"#d71430\",\"submitAlignment\":\"left\"}",
    "countryCode": "NL",
    "portalSetting": {
        "enableLiveValidation": true
    },
    "errorCode": null
 }*/}
var useFormData = function useFormData(_ref) {
  var formId = _ref.formId,
    portalId = _ref.portalId;
  var _useState = (0, _react.useState)([]),
    _useState2 = _slicedToArray(_useState, 2),
    formData = _useState2[0],
    setFormData = _useState2[1];
  var _useState3 = (0, _react.useState)(true),
    _useState4 = _slicedToArray(_useState3, 2),
    isLoading = _useState4[0],
    setLoading = _useState4[1];
  (0, _react.useEffect)(function () {
    setLoading(true);
    fetch("https://forms-eu1.hsforms.com/embed/v3/form/".concat(portalId, "/").concat(formId, "/json")).then(function (res) {
      return res.json();
    }).then(function (data) {
      console.log(data);
      setFormData(data);
    }).finally(function () {
      return setLoading(false);
    });
  }, []);
  return {
    formData: formData,
    isLoading: isLoading
  };
};
var _default = useFormData;
exports.default = _default;
},{"react":"n8MK"}],"deiQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StyleSheet = void 0;
/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */

  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);
  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }
  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}
var StyleSheet = /*#__PURE__*/function () {
  // Using Node instead of HTMLElement since container may be a ShadowRoot
  function StyleSheet(options) {
    var _this = this;
    this._insertTag = function (tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if ("production" !== 'production') {
      var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
        // this would only cause problem in speedy mode
        // but we don't want enabling speedy to affect the observable behavior
        // so we report this error at all times
        console.error("You're attempting to insert the following rule:\n" + rule + '\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.');
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if ("production" !== 'production' && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error("There was a problem inserting the following rule: \"" + rule + "\"", e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    if ("production" !== 'production') {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet;
}();
exports.StyleSheet = StyleSheet;
},{}],"ansa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.abs = exports.WEBKIT = exports.VIEWPORT = exports.SUPPORTS = exports.RULESET = exports.PAGE = exports.NAMESPACE = exports.MS = exports.MOZ = exports.MEDIA = exports.KEYFRAMES = exports.IMPORT = exports.FONT_FEATURE_VALUES = exports.FONT_FACE = exports.DOCUMENT = exports.DECLARATION = exports.COUNTER_STYLE = exports.COMMENT = exports.CHARSET = void 0;
exports.alloc = U;
exports.append = S;
exports.assign = void 0;
exports.caret = Q;
exports.char = K;
exports.characters = exports.character = void 0;
exports.charat = C;
exports.column = void 0;
exports.combine = q;
exports.comment = te;
exports.commenter = re;
exports.compile = ne;
exports.copy = J;
exports.dealloc = V;
exports.declaration = ue;
exports.delimit = W;
exports.delimiter = ee;
exports.escaping = _;
exports.from = void 0;
exports.hash = m;
exports.identifier = ae;
exports.indexof = z;
exports.line = exports.length = void 0;
exports.match = y;
exports.middleware = le;
exports.namespace = he;
exports.next = N;
exports.node = I;
exports.parse = ce;
exports.peek = P;
exports.position = void 0;
exports.prefix = ie;
exports.prefixer = pe;
exports.prev = L;
exports.replace = j;
exports.ruleset = se;
exports.rulesheet = ve;
exports.serialize = fe;
exports.sizeof = M;
exports.slice = R;
exports.stringify = oe;
exports.strlen = A;
exports.substr = O;
exports.token = T;
exports.tokenize = X;
exports.tokenizer = Z;
exports.trim = x;
exports.whitespace = Y;
var _D, _B, _F, _F2, _D2, _B2;
var e = "-ms-";
exports.MS = e;
var r = "-moz-";
exports.MOZ = r;
var a = "-webkit-";
exports.WEBKIT = a;
var n = "comm";
exports.COMMENT = n;
var c = "rule";
exports.RULESET = c;
var s = "decl";
exports.DECLARATION = s;
var t = "@page";
exports.PAGE = t;
var u = "@media";
exports.MEDIA = u;
var i = "@import";
exports.IMPORT = i;
var f = "@charset";
exports.CHARSET = f;
var o = "@viewport";
exports.VIEWPORT = o;
var l = "@supports";
exports.SUPPORTS = l;
var v = "@document";
exports.DOCUMENT = v;
var p = "@namespace";
exports.NAMESPACE = p;
var h = "@keyframes";
exports.KEYFRAMES = h;
var b = "@font-face";
exports.FONT_FACE = b;
var w = "@counter-style";
exports.COUNTER_STYLE = w;
var d = "@font-feature-values";
exports.FONT_FEATURE_VALUES = d;
var $ = Math.abs;
exports.abs = $;
var k = String.fromCharCode;
exports.from = k;
var g = Object.assign;
exports.assign = g;
function m(e, r) {
  return C(e, 0) ^ 45 ? (((r << 2 ^ C(e, 0)) << 2 ^ C(e, 1)) << 2 ^ C(e, 2)) << 2 ^ C(e, 3) : 0;
}
function x(e) {
  return e.trim();
}
function y(e, r) {
  return (e = r.exec(e)) ? e[0] : e;
}
function j(e, r, a) {
  return e.replace(r, a);
}
function z(e, r) {
  return e.indexOf(r);
}
function C(e, r) {
  return e.charCodeAt(r) | 0;
}
function O(e, r, a) {
  return e.slice(r, a);
}
function A(e) {
  return e.length;
}
function M(e) {
  return e.length;
}
function S(e, r) {
  return r.push(e), e;
}
function q(e, r) {
  return e.map(r).join("");
}
var B = 1;
exports.line = B;
var D = 1;
exports.column = D;
var E = 0;
exports.length = E;
var F = 0;
exports.position = F;
var G = 0;
exports.character = G;
var H = "";
exports.characters = H;
function I(e, r, a, n, c, s, t) {
  return {
    value: e,
    root: r,
    parent: a,
    type: n,
    props: c,
    children: s,
    line: B,
    column: D,
    length: t,
    return: ""
  };
}
function J(e, r) {
  return g(I("", null, null, "", null, null, 0), e, {
    length: -e.length
  }, r);
}
function K() {
  return G;
}
function L() {
  exports.character = G = F > 0 ? C(H, exports.position = exports.position = --F) : 0;
  if ((_D = D--, exports.column = D, _D), G === 10) exports.column = D = 1, (_B = B--, exports.line = B, _B);
  return G;
}
function N() {
  exports.character = G = F < E ? C(H, (_F = (_F2 = F++, exports.position = F, _F2), exports.position = F, _F)) : 0;
  if ((_D2 = D++, exports.column = D, _D2), G === 10) exports.column = D = 1, (_B2 = B++, exports.line = B, _B2);
  return G;
}
function P() {
  return C(H, F);
}
function Q() {
  return F;
}
function R(e, r) {
  return O(H, e, r);
}
function T(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function U(e) {
  return exports.line = B = exports.column = D = 1, exports.length = E = A(exports.characters = H = e), exports.position = F = 0, [];
}
function V(e) {
  return exports.characters = H = "", e;
}
function W(e) {
  return x(R(F - 1, ee(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function X(e) {
  return V(Z(U(e)));
}
function Y(e) {
  while (exports.character = G = P()) if (G < 33) N();else break;
  return T(e) > 2 || T(G) > 3 ? "" : " ";
}
function Z(e) {
  while (N()) switch (T(G)) {
    case 0:
      S(ae(F - 1), e);
      break;
    case 2:
      S(W(G), e);
      break;
    default:
      S(k(G), e);
  }
  return e;
}
function _(e, r) {
  while (--r && N()) if (G < 48 || G > 102 || G > 57 && G < 65 || G > 70 && G < 97) break;
  return R(e, Q() + (r < 6 && P() == 32 && N() == 32));
}
function ee(e) {
  while (N()) switch (G) {
    case e:
      return F;
    case 34:
    case 39:
      if (e !== 34 && e !== 39) ee(G);
      break;
    case 40:
      if (e === 41) ee(e);
      break;
    case 92:
      N();
      break;
  }
  return F;
}
function re(e, r) {
  while (N()) if (e + G === 47 + 10) break;else if (e + G === 42 + 42 && P() === 47) break;
  return "/*" + R(r, F - 1) + "*" + k(e === 47 ? e : N());
}
function ae(e) {
  while (!T(P())) N();
  return R(e, F);
}
function ne(e) {
  return V(ce("", null, null, null, [""], e = U(e), 0, [0], e));
}
function ce(e, r, a, n, c, s, t, u, i) {
  var f = 0;
  var o = 0;
  var l = t;
  var v = 0;
  var p = 0;
  var h = 0;
  var b = 1;
  var w = 1;
  var d = 1;
  var $ = 0;
  var g = "";
  var m = c;
  var x = s;
  var y = n;
  var O = g;
  while (w) switch (h = $, $ = N()) {
    case 40:
      if (h != 108 && C(O, l - 1) == 58) {
        if (z(O += j(W($), "&", "&\f"), "&\f") != -1) d = -1;
        break;
      }
    case 34:
    case 39:
    case 91:
      O += W($);
      break;
    case 9:
    case 10:
    case 13:
    case 32:
      O += Y(h);
      break;
    case 92:
      O += _(Q() - 1, 7);
      continue;
    case 47:
      switch (P()) {
        case 42:
        case 47:
          S(te(re(N(), Q()), r, a), i);
          break;
        default:
          O += "/";
      }
      break;
    case 123 * b:
      u[f++] = A(O) * d;
    case 125 * b:
    case 59:
    case 0:
      switch ($) {
        case 0:
        case 125:
          w = 0;
        case 59 + o:
          if (p > 0 && A(O) - l) S(p > 32 ? ue(O + ";", n, a, l - 1) : ue(j(O, " ", "") + ";", n, a, l - 2), i);
          break;
        case 59:
          O += ";";
        default:
          S(y = se(O, r, a, f, o, c, u, g, m = [], x = [], l), s);
          if ($ === 123) if (o === 0) ce(O, r, y, y, m, s, l, u, x);else switch (v === 99 && C(O, 3) === 110 ? 100 : v) {
            case 100:
            case 109:
            case 115:
              ce(e, y, y, n && S(se(e, y, y, 0, 0, c, u, g, c, m = [], l), x), c, x, l, u, n ? m : x);
              break;
            default:
              ce(O, y, y, y, [""], x, 0, u, x);
          }
      }
      f = o = p = 0, b = d = 1, g = O = "", l = t;
      break;
    case 58:
      l = 1 + A(O), p = h;
    default:
      if (b < 1) if ($ == 123) --b;else if ($ == 125 && b++ == 0 && L() == 125) continue;
      switch (O += k($), $ * b) {
        case 38:
          d = o > 0 ? 1 : (O += "\f", -1);
          break;
        case 44:
          u[f++] = (A(O) - 1) * d, d = 1;
          break;
        case 64:
          if (P() === 45) O += W(N());
          v = P(), o = l = A(g = O += ae(Q())), $++;
          break;
        case 45:
          if (h === 45 && A(O) == 2) b = 0;
      }
  }
  return s;
}
function se(e, r, a, n, s, t, u, i, f, o, l) {
  var v = s - 1;
  var p = s === 0 ? t : [""];
  var h = M(p);
  for (var b = 0, w = 0, d = 0; b < n; ++b) for (var k = 0, g = O(e, v + 1, v = $(w = u[b])), m = e; k < h; ++k) if (m = x(w > 0 ? p[k] + " " + g : j(g, /&\f/g, p[k]))) f[d++] = m;
  return I(e, r, a, s === 0 ? c : i, f, o, l);
}
function te(e, r, a) {
  return I(e, r, a, n, k(K()), O(e, 2, -2), 0);
}
function ue(e, r, a, n) {
  return I(e, r, a, s, O(e, 0, n), O(e, n + 1, -1), n);
}
function ie(n, c, s) {
  switch (m(n, c)) {
    case 5103:
      return a + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return a + n + n;
    case 4789:
      return r + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return a + n + r + n + e + n + n;
    case 5936:
      switch (C(n, c + 11)) {
        case 114:
          return a + n + e + j(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
          return a + n + e + j(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        case 45:
          return a + n + e + j(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
    case 6828:
    case 4268:
    case 2903:
      return a + n + e + n + n;
    case 6165:
      return a + n + e + "flex-" + n + n;
    case 5187:
      return a + n + j(n, /(\w+).+(:[^]+)/, a + "box-$1$2" + e + "flex-$1$2") + n;
    case 5443:
      return a + n + e + "flex-item-" + j(n, /flex-|-self/g, "") + (!y(n, /flex-|baseline/) ? e + "grid-row-" + j(n, /flex-|-self/g, "") : "") + n;
    case 4675:
      return a + n + e + "flex-line-pack" + j(n, /align-content|flex-|-self/g, "") + n;
    case 5548:
      return a + n + e + j(n, "shrink", "negative") + n;
    case 5292:
      return a + n + e + j(n, "basis", "preferred-size") + n;
    case 6060:
      return a + "box-" + j(n, "-grow", "") + a + n + e + j(n, "grow", "positive") + n;
    case 4554:
      return a + j(n, /([^-])(transform)/g, "$1" + a + "$2") + n;
    case 6187:
      return j(j(j(n, /(zoom-|grab)/, a + "$1"), /(image-set)/, a + "$1"), n, "") + n;
    case 5495:
    case 3959:
      return j(n, /(image-set\([^]*)/, a + "$1" + "$`$1");
    case 4968:
      return j(j(n, /(.+:)(flex-)?(.*)/, a + "box-pack:$3" + e + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + a + n + n;
    case 4200:
      if (!y(n, /flex-|baseline/)) return e + "grid-column-align" + O(n, c) + n;
      break;
    case 2592:
    case 3360:
      return e + j(n, "template-", "") + n;
    case 4384:
    case 3616:
      if (s && s.some(function (e, r) {
        return c = r, y(e.props, /grid-\w+-end/);
      })) {
        return ~z(n + (s = s[c].value), "span") ? n : e + j(n, "-start", "") + n + e + "grid-row-span:" + (~z(s, "span") ? y(s, /\d+/) : +y(s, /\d+/) - +y(n, /\d+/)) + ";";
      }
      return e + j(n, "-start", "") + n;
    case 4896:
    case 4128:
      return s && s.some(function (e) {
        return y(e.props, /grid-\w+-start/);
      }) ? n : e + j(j(n, "-end", "-span"), "span ", "") + n;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return j(n, /(.+)-inline(.+)/, a + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (A(n) - 1 - c > 6) switch (C(n, c + 1)) {
        case 109:
          if (C(n, c + 4) !== 45) break;
        case 102:
          return j(n, /(.+:)(.+)-([^]+)/, "$1" + a + "$2-$3" + "$1" + r + (C(n, c + 3) == 108 ? "$3" : "$2-$3")) + n;
        case 115:
          return ~z(n, "stretch") ? ie(j(n, "stretch", "fill-available"), c, s) + n : n;
      }
      break;
    case 5152:
    case 5920:
      return j(n, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function (r, a, c, s, t, u, i) {
        return e + a + ":" + c + i + (s ? e + a + "-span:" + (t ? u : +u - +c) + i : "") + n;
      });
    case 4949:
      if (C(n, c + 6) === 121) return j(n, ":", ":" + a) + n;
      break;
    case 6444:
      switch (C(n, C(n, 14) === 45 ? 18 : 11)) {
        case 120:
          return j(n, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + a + (C(n, 14) === 45 ? "inline-" : "") + "box$3" + "$1" + a + "$2$3" + "$1" + e + "$2box$3") + n;
        case 100:
          return j(n, ":", ":" + e) + n;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return j(n, "scroll-", "scroll-snap-") + n;
  }
  return n;
}
function fe(e, r) {
  var a = "";
  var n = M(e);
  for (var c = 0; c < n; c++) a += r(e[c], c, e, r) || "";
  return a;
}
function oe(e, r, a, t) {
  switch (e.type) {
    case i:
    case s:
      return e.return = e.return || e.value;
    case n:
      return "";
    case h:
      return e.return = e.value + "{" + fe(e.children, t) + "}";
    case c:
      e.value = e.props.join(",");
  }
  return A(a = fe(e.children, t)) ? e.return = e.value + "{" + a + "}" : "";
}
function le(e) {
  var r = M(e);
  return function (a, n, c, s) {
    var t = "";
    for (var u = 0; u < r; u++) t += e[u](a, n, c, s) || "";
    return t;
  };
}
function ve(e) {
  return function (r) {
    if (!r.root) if (r = r.return) e(r);
  };
}
function pe(n, t, u, i) {
  if (n.length > -1) if (!n.return) switch (n.type) {
    case s:
      n.return = ie(n.value, n.length, u);
      return;
    case h:
      return fe([J(n, {
        value: j(n.value, "@", "@" + a)
      })], i);
    case c:
      if (n.length) return q(n.props, function (c) {
        switch (y(c, /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            return fe([J(n, {
              props: [j(c, /:(read-\w+)/, ":" + r + "$1")]
            })], i);
          case "::placeholder":
            return fe([J(n, {
              props: [j(c, /:(plac\w+)/, ":" + a + "input-$1")]
            }), J(n, {
              props: [j(c, /:(plac\w+)/, ":" + r + "$1")]
            }), J(n, {
              props: [j(c, /:(plac\w+)/, e + "input-$1")]
            })], i);
        }
        return "";
      });
  }
}
function he(e) {
  switch (e.type) {
    case c:
      e.props = e.props.map(function (r) {
        return q(X(r), function (r, a, n) {
          switch (C(r, 0)) {
            case 12:
              return O(r, 1, A(r));
            case 0:
            case 40:
            case 43:
            case 62:
            case 126:
              return r;
            case 58:
              if (n[++a] === "global") n[a] = "", n[++a] = "\f" + O(n[a], a = 1, -1);
            case 32:
              return a === 1 ? "" : r;
            default:
              switch (a) {
                case 0:
                  e = r;
                  return M(n) > 1 ? "" : r;
                case a = M(n) - 1:
                case 2:
                  return a === 2 ? r + e + e : r + e;
                default:
                  return r;
              }
          }
        });
      });
  }
}
},{}],"Js5v":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var weakMemoize = function weakMemoize(func) {
  // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
  var cache = new WeakMap();
  return function (arg) {
    if (cache.has(arg)) {
      // $FlowFixMe
      return cache.get(arg);
    }
    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};
var _default = weakMemoize;
exports.default = _default;
},{}],"z7su":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}
var _default = memoize;
exports.default = _default;
},{}],"hQoc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sheet = require("@emotion/sheet");
var _stylis = require("stylis");
require("@emotion/weak-memoize");
require("@emotion/memoize");
var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
  var previous = 0;
  var character = 0;
  while (true) {
    previous = character;
    character = (0, _stylis.peek)(); // &\f

    if (previous === 38 && character === 12) {
      points[index] = 1;
    }
    if ((0, _stylis.token)(character)) {
      break;
    }
    (0, _stylis.next)();
  }
  return (0, _stylis.slice)(begin, _stylis.position);
};
var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;
  do {
    switch ((0, _stylis.token)(character)) {
      case 0:
        // &\f
        if (character === 38 && (0, _stylis.peek)() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(_stylis.position - 1, points, index);
        break;
      case 2:
        parsed[index] += (0, _stylis.delimit)(character);
        break;
      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = (0, _stylis.peek)() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += (0, _stylis.from)(character);
    }
  } while (character = (0, _stylis.next)());
  return parsed;
};
var getRules = function getRules(value, points) {
  return (0, _stylis.dealloc)(toRules((0, _stylis.alloc)(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11

var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent ||
  // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value,
    parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case

  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */ && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"

  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;
    if (
    // charcode for l
    value.charCodeAt(0) === 108 &&
    // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};
var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';
var isIgnoringComment = function isIgnoringComment(element) {
  return element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
  return function (element, index, children) {
    if (element.type !== 'rule' || cache.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = element.parent === children[0]; // in nested rules comments become children of the "auto-inserted" rule
      //
      // considering this input:
      // .a {
      //   .b /* comm */ {}
      //   color: hotpink;
      // }
      // we get output corresponding to this:
      // .a {
      //   & {
      //     /* comm */
      //     color: hotpink;
      //   }
      //   .b {}
      // }

      var commentContainer = isNested ? children[0].children :
      // global rule at the root level
      children;
      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node = commentContainer[i];
        if (node.line < element.line) {
          break;
        } // it is quite weird but comments are *usually* put at `column: element.column - 1`
        // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
        // this will also match inputs like this:
        // .a {
        //   /* comm */
        //   .b {}
        // }
        //
        // but that is fine
        //
        // it would be the easiest to change the placement of the comment to be the first child of the rule:
        // .a {
        //   .b { /* comm */ }
        // }
        // with such inputs we wouldn't have to search for the comment at all
        // TODO: consider changing this comment placement in the next major version

        if (node.column < element.column) {
          if (isIgnoringComment(node)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
      });
    }
  };
};
var isImportRule = function isImportRule(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }
  return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user

var nullifyElement = function nullifyElement(element) {
  element.type = '';
  element.value = '';
  element["return"] = '';
  element.children = '';
  element.props = '';
};
var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};

/* eslint-disable no-fallthrough */

function prefix(value, length) {
  switch ((0, _stylis.hash)(value, length)) {
    // color-adjust
    case 5103:
      return _stylis.WEBKIT + 'print-' + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return _stylis.WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust

    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return _stylis.WEBKIT + value + _stylis.MOZ + value + _stylis.MS + value + value;
    // flex, flex-direction

    case 6828:
    case 4268:
      return _stylis.WEBKIT + value + _stylis.MS + value + value;
    // order

    case 6165:
      return _stylis.WEBKIT + value + _stylis.MS + 'flex-' + value + value;
    // align-items

    case 5187:
      return _stylis.WEBKIT + value + (0, _stylis.replace)(value, /(\w+).+(:[^]+)/, _stylis.WEBKIT + 'box-$1$2' + _stylis.MS + 'flex-$1$2') + value;
    // align-self

    case 5443:
      return _stylis.WEBKIT + value + _stylis.MS + 'flex-item-' + (0, _stylis.replace)(value, /flex-|-self/, '') + value;
    // align-content

    case 4675:
      return _stylis.WEBKIT + value + _stylis.MS + 'flex-line-pack' + (0, _stylis.replace)(value, /align-content|flex-|-self/, '') + value;
    // flex-shrink

    case 5548:
      return _stylis.WEBKIT + value + _stylis.MS + (0, _stylis.replace)(value, 'shrink', 'negative') + value;
    // flex-basis

    case 5292:
      return _stylis.WEBKIT + value + _stylis.MS + (0, _stylis.replace)(value, 'basis', 'preferred-size') + value;
    // flex-grow

    case 6060:
      return _stylis.WEBKIT + 'box-' + (0, _stylis.replace)(value, '-grow', '') + _stylis.WEBKIT + value + _stylis.MS + (0, _stylis.replace)(value, 'grow', 'positive') + value;
    // transition

    case 4554:
      return _stylis.WEBKIT + (0, _stylis.replace)(value, /([^-])(transform)/g, '$1' + _stylis.WEBKIT + '$2') + value;
    // cursor

    case 6187:
      return (0, _stylis.replace)((0, _stylis.replace)((0, _stylis.replace)(value, /(zoom-|grab)/, _stylis.WEBKIT + '$1'), /(image-set)/, _stylis.WEBKIT + '$1'), value, '') + value;
    // background, background-image

    case 5495:
    case 3959:
      return (0, _stylis.replace)(value, /(image-set\([^]*)/, _stylis.WEBKIT + '$1' + '$`$1');
    // justify-content

    case 4968:
      return (0, _stylis.replace)((0, _stylis.replace)(value, /(.+:)(flex-)?(.*)/, _stylis.WEBKIT + 'box-pack:$3' + _stylis.MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + _stylis.WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)

    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return (0, _stylis.replace)(value, /(.+)-inline(.+)/, _stylis.WEBKIT + '$1$2') + value;
    // (min|max)?(width|height|inline-size|block-size)

    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      // stretch, max-content, min-content, fill-available
      if ((0, _stylis.strlen)(value) - 1 - length > 6) switch ((0, _stylis.charat)(value, length + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          // -
          if ((0, _stylis.charat)(value, length + 4) !== 45) break;
        // (f)ill-available, (f)it-content

        case 102:
          return (0, _stylis.replace)(value, /(.+:)(.+)-([^]+)/, '$1' + _stylis.WEBKIT + '$2-$3' + '$1' + _stylis.MOZ + ((0, _stylis.charat)(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
        // (s)tretch

        case 115:
          return ~(0, _stylis.indexof)(value, 'stretch') ? prefix((0, _stylis.replace)(value, 'stretch', 'fill-available'), length) + value : value;
      }
      break;
    // position: sticky

    case 4949:
      // (s)ticky?
      if ((0, _stylis.charat)(value, length + 1) !== 115) break;
    // display: (flex|inline-flex)

    case 6444:
      switch ((0, _stylis.charat)(value, (0, _stylis.strlen)(value) - 3 - (~(0, _stylis.indexof)(value, '!important') && 10))) {
        // stic(k)y
        case 107:
          return (0, _stylis.replace)(value, ':', ':' + _stylis.WEBKIT) + value;
        // (inline-)?fl(e)x

        case 101:
          return (0, _stylis.replace)(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + _stylis.WEBKIT + ((0, _stylis.charat)(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + _stylis.WEBKIT + '$2$3' + '$1' + _stylis.MS + '$2box$3') + value;
      }
      break;
    // writing-mode

    case 5936:
      switch ((0, _stylis.charat)(value, length + 11)) {
        // vertical-l(r)
        case 114:
          return _stylis.WEBKIT + value + _stylis.MS + (0, _stylis.replace)(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
        // vertical-r(l)

        case 108:
          return _stylis.WEBKIT + value + _stylis.MS + (0, _stylis.replace)(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
        // horizontal(-)tb

        case 45:
          return _stylis.WEBKIT + value + _stylis.MS + (0, _stylis.replace)(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
      }
      return _stylis.WEBKIT + value + _stylis.MS + value + value;
  }
  return value;
}
var prefixer = function prefixer(element, index, children, callback) {
  if (element.length > -1) if (!element["return"]) switch (element.type) {
    case _stylis.DECLARATION:
      element["return"] = prefix(element.value, element.length);
      break;
    case _stylis.KEYFRAMES:
      return (0, _stylis.serialize)([(0, _stylis.copy)(element, {
        value: (0, _stylis.replace)(element.value, '@', '@' + _stylis.WEBKIT)
      })], callback);
    case _stylis.RULESET:
      if (element.length) return (0, _stylis.combine)(element.props, function (value) {
        switch ((0, _stylis.match)(value, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ':read-only':
          case ':read-write':
            return (0, _stylis.serialize)([(0, _stylis.copy)(element, {
              props: [(0, _stylis.replace)(value, /:(read-\w+)/, ':' + _stylis.MOZ + '$1')]
            })], callback);
          // :placeholder

          case '::placeholder':
            return (0, _stylis.serialize)([(0, _stylis.copy)(element, {
              props: [(0, _stylis.replace)(value, /:(plac\w+)/, ':' + _stylis.WEBKIT + 'input-$1')]
            }), (0, _stylis.copy)(element, {
              props: [(0, _stylis.replace)(value, /:(plac\w+)/, ':' + _stylis.MOZ + '$1')]
            }), (0, _stylis.copy)(element, {
              props: [(0, _stylis.replace)(value, /:(plac\w+)/, _stylis.MS + 'input-$1')]
            })], callback);
        }
        return '';
      });
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache(options) {
  var key = options.key;
  if ("production" !== 'production' && !key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\n" + "If multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');
      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }
      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  if ("production" !== 'production') {
    // $FlowFixMe
    if (/[^a-z-]/.test(key)) {
      throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }
      nodesToHydrate.push(node);
    });
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if ("production" !== 'production') {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [_stylis.stringify, "production" !== 'production' ? function (element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== _stylis.COMMENT) {
          // insert empty rule in non-production environments
          // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet
          currentSheet.insert(element.value + "{}");
        }
      }
    } : (0, _stylis.rulesheet)(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = (0, _stylis.middleware)(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis(styles) {
      return (0, _stylis.serialize)((0, _stylis.compile)(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if ("production" !== 'production' && serialized.map !== undefined) {
        currentSheet = {
          insert: function insert(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key: key,
    sheet: new _sheet.StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var _default = createCache;
exports.default = _default;
},{"@emotion/sheet":"deiQ","stylis":"ansa","@emotion/weak-memoize":"Js5v","@emotion/memoize":"z7su"}],"SpjQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _extends;
function _extends() {
  exports.default = _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
},{}],"DsZo":[function(require,module,exports) {
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;

},{}],"rMf3":[function(require,module,exports) {
'use strict';

if ("production" === 'production') {
  module.exports = require('./cjs/react-is.production.min.js');
} else {
  module.exports = require('./cjs/react-is.development.js');
}
},{"./cjs/react-is.production.min.js":"DsZo"}],"ElIr":[function(require,module,exports) {
'use strict';

var reactIs = require('react-is');

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;

},{"react-is":"rMf3"}],"CdxT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _hoistNonReactStatics = _interopRequireDefault(require("hoist-non-react-statics"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// this file isolates this package that is not tree-shakeable
// and if this module doesn't actually contain any logic of its own
// then Rollup just use 'hoist-non-react-statics' directly in other chunks

var hoistNonReactStatics = function (targetComponent, sourceComponent) {
  return (0, _hoistNonReactStatics.default)(targetComponent, sourceComponent);
};
var _default = hoistNonReactStatics;
exports.default = _default;
},{"hoist-non-react-statics":"ElIr"}],"QVCr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRegisteredStyles = getRegisteredStyles;
exports.registerStyles = exports.insertStyles = void 0;
var isBrowser = "object" !== 'undefined';
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false ||
  // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }
};
exports.registerStyles = registerStyles;
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;
    do {
      var maybeStyles = cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);
      current = current.next;
    } while (current !== undefined);
  }
};
exports.insertStyles = insertStyles;
},{}],"BsPI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
    i = 0,
    len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k = /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array

  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h = /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.

  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var _default = murmur2;
exports.default = _default;
},{}],"UXEF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var _default = unitlessKeys;
exports.default = _default;
},{}],"YZxA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serializeStyles = void 0;
var _hash = _interopRequireDefault(require("@emotion/hash"));
var _unitless = _interopRequireDefault(require("@emotion/unitless"));
var _memoize = _interopRequireDefault(require("@emotion/memoize"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};
var processStyleName = /* #__PURE__ */(0, _memoize.default)(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});
var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }
  if (_unitless.default[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }
  return value;
};
if ("production" !== 'production') {
  var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  var contentValues = ['normal', 'none', 'initial', 'inherit', 'unset'];
  var oldProcessStyleValue = processStyleValue;
  var msPattern = /^-ms-/;
  var hyphenPattern = /-(.)/g;
  var hyphenatedCache = {};
  processStyleValue = function processStyleValue(key, value) {
    if (key === 'content') {
      if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== '' && !isCustomProperty(key) && key.indexOf('-') !== -1 && hyphenatedCache[key] === undefined) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, 'ms-').replace(hyphenPattern, function (str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var noComponentSelectorMessage = 'Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.';
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }
  if (interpolation.__emotion_styles !== undefined) {
    if ("production" !== 'production' && interpolation.toString() === 'NO_COMPONENT_SELECTOR') {
      throw new Error(noComponentSelectorMessage);
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }
    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }
        if (interpolation.styles !== undefined) {
          var next = interpolation.next;
          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }
          var styles = interpolation.styles + ";";
          if ("production" !== 'production' && interpolation.map !== undefined) {
            styles += interpolation.map;
          }
          return styles;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        } else if ("production" !== 'production') {
          console.error('Functions that are interpolated in css calls will be stringified.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
        }
        break;
      }
    case 'string':
      if ("production" !== 'production') {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function (match, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, '') + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error('`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\n' + 'Instead of doing this:\n\n' + [].concat(matched, ["`" + replaced + "`"]).join('\n') + '\n\nYou should wrap it with `css` like this:\n\n' + ("css`" + replaced + "`"));
        }
      }
      break;
  } // finalize string values (regular strings and functions interpolated into css calls)

  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== undefined ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = '';
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }
            default:
              {
                if ("production" !== 'production' && _key === 'undefined') {
                  console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                }
                string += _key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
if ("production" !== 'production') {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
} // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list

var cursor;
var serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }
  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];
  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if ("production" !== 'production' && strings[0] === undefined) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += strings[0];
  } // we start at 1 since we've already handled the first arg

  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      if ("production" !== 'production' && strings[i] === undefined) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += strings[i];
    }
  }
  var sourceMap;
  if ("production" !== 'production') {
    styles = styles.replace(sourceMapPattern, function (match) {
      sourceMap = match;
      return '';
    });
  } // using a global regex with .exec is stateful so lastIndex has to be reset each time

  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' +
    // $FlowFixMe we know it's not null
    match[1];
  }
  var name = (0, _hash.default)(styles) + identifierName;
  if ("production" !== 'production') {
    // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)
    return {
      name: name,
      styles: styles,
      map: sourceMap,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }
  return {
    name: name,
    styles: styles,
    next: cursor
  };
};
exports.serializeStyles = serializeStyles;
},{"@emotion/hash":"BsPI","@emotion/unitless":"UXEF","@emotion/memoize":"z7su"}],"ucFO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInsertionEffectWithLayoutFallback = exports.useInsertionEffectAlwaysWithSyncFallback = void 0;
var React = _interopRequireWildcard(require("react"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var syncFallback = function syncFallback(create) {
  return create();
};
var useInsertionEffect = React['useInsertion' + 'Effect'] ? React['useInsertion' + 'Effect'] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
exports.useInsertionEffectAlwaysWithSyncFallback = useInsertionEffectAlwaysWithSyncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || React.useLayoutEffect;
exports.useInsertionEffectWithLayoutFallback = useInsertionEffectWithLayoutFallback;
},{"react":"n8MK"}],"eOrn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.a = exports._ = exports.T = exports.E = exports.C = void 0;
exports.b = withTheme;
exports.w = exports.u = exports.h = exports.c = void 0;
var _react = require("react");
var _cache = _interopRequireDefault(require("@emotion/cache"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/extends"));
var _weakMemoize = _interopRequireDefault(require("@emotion/weak-memoize"));
var _emotionReact_isolatedHnrsBrowserEsm = _interopRequireDefault(require("../_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js"));
var _utils = require("@emotion/utils");
var _serialize = require("@emotion/serialize");
var _useInsertionEffectWithFallbacks = require("@emotion/use-insertion-effect-with-fallbacks");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var hasOwnProperty = {}.hasOwnProperty;
exports.h = hasOwnProperty;
var EmotionCacheContext = /* #__PURE__ */(0, _react.createContext)(
// we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? /* #__PURE__ */(0, _cache.default)({
  key: 'css'
}) : null);
if ("production" !== 'production') {
  EmotionCacheContext.displayName = 'EmotionCacheContext';
}
var CacheProvider = EmotionCacheContext.Provider;
exports.C = CacheProvider;
var __unsafe_useEmotionCache = function useEmotionCache() {
  return (0, _react.useContext)(EmotionCacheContext);
};
exports._ = __unsafe_useEmotionCache;
var withEmotionCache = function withEmotionCache(func) {
  // $FlowFixMe
  return /*#__PURE__*/(0, _react.forwardRef)(function (props, ref) {
    // the cache will never be null in the browser
    var cache = (0, _react.useContext)(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
exports.w = withEmotionCache;
var ThemeContext = /* #__PURE__ */(0, _react.createContext)({});
exports.T = ThemeContext;
if ("production" !== 'production') {
  ThemeContext.displayName = 'EmotionThemeContext';
}
var useTheme = function useTheme() {
  return (0, _react.useContext)(ThemeContext);
};
exports.u = useTheme;
var getTheme = function getTheme(outerTheme, theme) {
  if (typeof theme === 'function') {
    var mergedTheme = theme(outerTheme);
    if ("production" !== 'production' && (mergedTheme == null || typeof mergedTheme !== 'object' || Array.isArray(mergedTheme))) {
      throw new Error('[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!');
    }
    return mergedTheme;
  }
  if ("production" !== 'production' && (theme == null || typeof theme !== 'object' || Array.isArray(theme))) {
    throw new Error('[ThemeProvider] Please make your theme prop a plain object');
  }
  return (0, _extends2.default)({}, outerTheme, theme);
};
var createCacheWithTheme = /* #__PURE__ */(0, _weakMemoize.default)(function (outerTheme) {
  return (0, _weakMemoize.default)(function (theme) {
    return getTheme(outerTheme, theme);
  });
});
var ThemeProvider = function ThemeProvider(props) {
  var theme = (0, _react.useContext)(ThemeContext);
  if (props.theme !== theme) {
    theme = createCacheWithTheme(theme)(props.theme);
  }
  return /*#__PURE__*/(0, _react.createElement)(ThemeContext.Provider, {
    value: theme
  }, props.children);
};
exports.a = ThemeProvider;
function withTheme(Component) {
  var componentName = Component.displayName || Component.name || 'Component';
  var render = function render(props, ref) {
    var theme = (0, _react.useContext)(ThemeContext);
    return /*#__PURE__*/(0, _react.createElement)(Component, (0, _extends2.default)({
      theme: theme,
      ref: ref
    }, props));
  }; // $FlowFixMe

  var WithTheme = /*#__PURE__*/(0, _react.forwardRef)(render);
  WithTheme.displayName = "WithTheme(" + componentName + ")";
  return (0, _emotionReact_isolatedHnrsBrowserEsm.default)(WithTheme, Component);
}
var getLastPart = function getLastPart(functionName) {
  // The match may be something like 'Object.createEmotionProps' or
  // 'Loader.prototype.render'
  var parts = functionName.split('.');
  return parts[parts.length - 1];
};
var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine(line) {
  // V8
  var match = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line);
  if (match) return getLastPart(match[1]); // Safari / Firefox

  match = /^([A-Za-z0-9$.]+)@/.exec(line);
  if (match) return getLastPart(match[1]);
  return undefined;
};
var internalReactFunctionNames = /* #__PURE__ */new Set(['renderWithHooks', 'processChild', 'finishClassComponent', 'renderToString']); // These identifiers come from error stacks, so they have to be valid JS
// identifiers, thus we only need to replace what is a valid character for JS,
// but not for CSS.

var sanitizeIdentifier = function sanitizeIdentifier(identifier) {
  return identifier.replace(/\$/g, '-');
};
var getLabelFromStackTrace = function getLabelFromStackTrace(stackTrace) {
  if (!stackTrace) return undefined;
  var lines = stackTrace.split('\n');
  for (var i = 0; i < lines.length; i++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i]); // The first line of V8 stack traces is just "Error"

    if (!functionName) continue; // If we reach one of these, we have gone too far and should quit

    if (internalReactFunctionNames.has(functionName)) break; // The component name is the first function in the stack that starts with an
    // uppercase letter

    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);
  }
  return undefined;
};
var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';
var createEmotionProps = function createEmotionProps(type, props) {
  if ("production" !== 'production' && typeof props.css === 'string' &&
  // check if there is a css declaration
  props.css.indexOf(':') !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
  }
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type; // For performance, only call getLabelFromStackTrace in development and when
  // the label hasn't already been computed

  if ("production" !== 'production' && !!props.css && (typeof props.css !== 'object' || typeof props.css.name !== 'string' || props.css.name.indexOf('-') === -1)) {
    var label = getLabelFromStackTrace(new Error().stack);
    if (label) newProps[labelPropName] = label;
  }
  return newProps;
};
exports.c = createEmotionProps;
var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
    serialized = _ref.serialized,
    isStringTag = _ref.isStringTag;
  (0, _utils.registerStyles)(cache, serialized, isStringTag);
  var rules = (0, _useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback)(function () {
    return (0, _utils.insertStyles)(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';
  if (typeof props.className === 'string') {
    className = (0, _utils.getRegisteredStyles)(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = (0, _serialize.serializeStyles)(registeredStyles, undefined, (0, _react.useContext)(ThemeContext));
  if ("production" !== 'production' && serialized.name.indexOf('-') === -1) {
    var labelFromStack = props[labelPropName];
    if (labelFromStack) {
      serialized = (0, _serialize.serializeStyles)([serialized, 'label:' + labelFromStack + ';']);
    }
  }
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && ("production" === 'production' || key !== labelPropName)) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return /*#__PURE__*/(0, _react.createElement)(_react.Fragment, null, /*#__PURE__*/(0, _react.createElement)(Insertion, {
    cache: cache,
    serialized: serialized,
    isStringTag: typeof WrappedComponent === 'string'
  }), /*#__PURE__*/(0, _react.createElement)(WrappedComponent, newProps));
});
exports.E = Emotion;
if ("production" !== 'production') {
  Emotion.displayName = 'EmotionCssPropInternal';
}
},{"react":"n8MK","@emotion/cache":"hQoc","@babel/runtime/helpers/esm/extends":"SpjQ","@emotion/weak-memoize":"Js5v","../_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js":"CdxT","@emotion/utils":"QVCr","@emotion/serialize":"YZxA","@emotion/use-insertion-effect-with-fallbacks":"ucFO"}],"dLyZ":[function(require,module,exports) {
function _extends() {
  module.exports = _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _extends.apply(this, arguments);
}
module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],"cUkA":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CacheProvider", {
  enumerable: true,
  get: function () {
    return _emotionElement6a883da9BrowserEsm.C;
  }
});
exports.Global = exports.ClassNames = void 0;
Object.defineProperty(exports, "ThemeContext", {
  enumerable: true,
  get: function () {
    return _emotionElement6a883da9BrowserEsm.T;
  }
});
Object.defineProperty(exports, "ThemeProvider", {
  enumerable: true,
  get: function () {
    return _emotionElement6a883da9BrowserEsm.a;
  }
});
Object.defineProperty(exports, "__unsafe_useEmotionCache", {
  enumerable: true,
  get: function () {
    return _emotionElement6a883da9BrowserEsm._;
  }
});
exports.createElement = void 0;
exports.css = css;
exports.keyframes = exports.jsx = void 0;
Object.defineProperty(exports, "useTheme", {
  enumerable: true,
  get: function () {
    return _emotionElement6a883da9BrowserEsm.u;
  }
});
Object.defineProperty(exports, "withEmotionCache", {
  enumerable: true,
  get: function () {
    return _emotionElement6a883da9BrowserEsm.w;
  }
});
Object.defineProperty(exports, "withTheme", {
  enumerable: true,
  get: function () {
    return _emotionElement6a883da9BrowserEsm.b;
  }
});
var _react = require("react");
require("@emotion/cache");
var _emotionElement6a883da9BrowserEsm = require("./emotion-element-6a883da9.browser.esm.js");
require("@babel/runtime/helpers/extends");
require("@emotion/weak-memoize");
require("hoist-non-react-statics");
require("../_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js");
var _utils = require("@emotion/utils");
var _serialize = require("@emotion/serialize");
var _useInsertionEffectWithFallbacks = require("@emotion/use-insertion-effect-with-fallbacks");
var pkg = {
  name: "@emotion/react",
  version: "11.10.5",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        "default": "./dist/emotion-react.esm.js"
      },
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": "./macro.js"
  },
  types: "types/index.d.ts",
  files: ["src", "dist", "jsx-runtime", "jsx-dev-runtime", "_isolated-hnrs", "types/*.d.ts", "macro.js", "macro.d.ts", "macro.js.flow"],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.10.5",
    "@emotion/cache": "^11.10.5",
    "@emotion/serialize": "^1.1.1",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.0",
    "@emotion/utils": "^1.2.0",
    "@emotion/weak-memoize": "^0.3.0",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    "@babel/core": "^7.0.0",
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@babel/core": {
      optional: true
    },
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@babel/core": "^7.18.5",
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.10.5",
    "@emotion/css-prettifier": "1.1.1",
    "@emotion/server": "11.10.0",
    "@emotion/styled": "11.10.5",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: ["./index.js", "./jsx-runtime.js", "./jsx-dev-runtime.js", "./_isolated-hnrs.js"],
    umdName: "emotionReact",
    exports: {
      envConditions: ["browser", "worker"],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": "./macro.js"
      }
    }
  }
};
var jsx = function jsx(type, props) {
  var args = arguments;
  if (props == null || !_emotionElement6a883da9BrowserEsm.h.call(props, 'css')) {
    // $FlowFixMe
    return _react.createElement.apply(undefined, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = _emotionElement6a883da9BrowserEsm.E;
  createElementArgArray[1] = (0, _emotionElement6a883da9BrowserEsm.c)(type, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  } // $FlowFixMe

  return _react.createElement.apply(null, createElementArgArray);
};
exports.jsx = exports.createElement = jsx;
var warnedAboutCssPropForGlobal = false; // maintain place over rerenders.
// initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
// initial client-side render from SSR, use place of hydrating tag

var Global = /* #__PURE__ */(0, _emotionElement6a883da9BrowserEsm.w)(function (props, cache) {
  if ("production" !== 'production' && !warnedAboutCssPropForGlobal && (
  // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  props.className || props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles = props.styles;
  var serialized = (0, _serialize.serializeStyles)([styles], undefined, (0, _react.useContext)(_emotionElement6a883da9BrowserEsm.T));
  // but it is based on a constant that will never change at runtime
  // it's effectively like having two implementations and switching them out
  // so it's not actually breaking anything

  var sheetRef = (0, _react.useRef)();
  (0, _useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback)(function () {
    var key = cache.key + "-global"; // use case of https://github.com/emotion-js/emotion/issues/2675

    var sheet = new cache.sheet.constructor({
      key: key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false; // $FlowFixMe

    var node = document.querySelector("style[data-emotion=\"" + key + " " + serialized.name + "\"]");
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node !== null) {
      rehydrating = true; // clear the hash so this node won't be recognizable as rehydratable by other <Global/>s

      node.setAttribute('data-emotion', key);
      sheet.hydrate([node]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function () {
      sheet.flush();
    };
  }, [cache]);
  (0, _useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback)(function () {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0],
      rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== undefined) {
      // insert keyframes
      (0, _utils.insertStyles)(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      // if this doesn't exist then it will be null so the style element will be appended
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
exports.Global = Global;
if ("production" !== 'production') {
  Global.displayName = 'EmotionGlobal';
}
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return (0, _serialize.serializeStyles)(args);
}
var keyframes = function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name; // $FlowFixMe

  return {
    name: name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
exports.keyframes = keyframes;
var classnames = function classnames(args) {
  var len = args.length;
  var i = 0;
  var cls = '';
  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case 'boolean':
        break;
      case 'object':
        {
          if (Array.isArray(arg)) {
            toAdd = classnames(arg);
          } else {
            if ("production" !== 'production' && arg.styles !== undefined && arg.name !== undefined) {
              console.error('You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n' + '`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.');
            }
            toAdd = '';
            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += ' ');
                toAdd += k;
              }
            }
          }
          break;
        }
      default:
        {
          toAdd = arg;
        }
    }
    if (toAdd) {
      cls && (cls += ' ');
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css, className) {
  var registeredStyles = [];
  var rawClassName = (0, _utils.getRegisteredStyles)(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css(registeredStyles);
}
var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
    serializedArr = _ref.serializedArr;
  var rules = (0, _useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback)(function () {
    for (var i = 0; i < serializedArr.length; i++) {
      var res = (0, _utils.insertStyles)(cache, serializedArr[i], false);
    }
  });
  return null;
};
var ClassNames = /* #__PURE__ */(0, _emotionElement6a883da9BrowserEsm.w)(function (props, cache) {
  var hasRendered = false;
  var serializedArr = [];
  var css = function css() {
    if (hasRendered && "production" !== 'production') {
      throw new Error('css can only be used during render');
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = (0, _serialize.serializeStyles)(args, cache.registered);
    serializedArr.push(serialized); // registration has to happen here as the result of this might get consumed by `cx`

    (0, _utils.registerStyles)(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };
  var cx = function cx() {
    if (hasRendered && "production" !== 'production') {
      throw new Error('cx can only be used during render');
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache.registered, css, classnames(args));
  };
  var content = {
    css: css,
    cx: cx,
    theme: (0, _react.useContext)(_emotionElement6a883da9BrowserEsm.T)
  };
  var ele = props.children(content);
  hasRendered = true;
  return /*#__PURE__*/(0, _react.createElement)(_react.Fragment, null, /*#__PURE__*/(0, _react.createElement)(Insertion, {
    cache: cache,
    serializedArr: serializedArr
  }), ele);
});
exports.ClassNames = ClassNames;
if ("production" !== 'production') {
  ClassNames.displayName = 'EmotionClassNames';
}
if ("production" !== 'production') {
  var isBrowser = "object" !== 'undefined'; // #1727, #2905 for some reason Jest and Vitest evaluate modules twice if some consuming module gets mocked

  var isTestEnv = typeof jest !== 'undefined' || typeof vi !== 'undefined';
  if (isBrowser && !isTestEnv) {
    // globalThis has wide browser support - https://caniuse.com/?search=globalThis, Node.js 12 and later
    var globalContext =
    // $FlowIgnore
    typeof globalThis !== 'undefined' ? globalThis // eslint-disable-line no-undef
    : isBrowser ? window : global;
    var globalKey = "__EMOTION_REACT_" + pkg.version.split('.')[0] + "__";
    if (globalContext[globalKey]) {
      console.warn('You are loading @emotion/react when it is already loaded. Running ' + 'multiple instances may cause problems. This can happen if multiple ' + 'versions are used, or if multiple builds of the same version are ' + 'used.');
    }
    globalContext[globalKey] = true;
  }
}
},{"react":"n8MK","@emotion/cache":"hQoc","./emotion-element-6a883da9.browser.esm.js":"eOrn","@babel/runtime/helpers/extends":"dLyZ","@emotion/weak-memoize":"Js5v","hoist-non-react-statics":"ElIr","../_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js":"CdxT","@emotion/utils":"QVCr","@emotion/serialize":"YZxA","@emotion/use-insertion-effect-with-fallbacks":"ucFO"}],"Kl7u":[function(require,module,exports) {
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';

var f = require("react"),
  k = Symbol.for("react.element"),
  l = Symbol.for("react.fragment"),
  m = Object.prototype.hasOwnProperty,
  n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  p = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };
function q(c, a, g) {
  var b,
    d = {},
    e = null,
    h = null;
  void 0 !== g && (e = "" + g);
  void 0 !== a.key && (e = "" + a.key);
  void 0 !== a.ref && (h = a.ref);
  for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
  return {
    $$typeof: k,
    type: c,
    key: e,
    ref: h,
    props: d,
    _owner: n.current
  };
}
exports.Fragment = l;
exports.jsx = q;
exports.jsxs = q;
},{"react":"n8MK"}],"plwR":[function(require,module,exports) {
'use strict';

if ("production" === 'production') {
  module.exports = require('./cjs/react-jsx-runtime.production.min.js');
} else {
  module.exports = require('./cjs/react-jsx-runtime.development.js');
}
},{"./cjs/react-jsx-runtime.production.min.js":"Kl7u"}],"MbOF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.css_reset_default = exports.CSSReset = exports.CSSPolyfill = void 0;
var _react = require("@emotion/react");
var _jsxRuntime = require("react/jsx-runtime");
// src/css-reset.tsx

var vhPolyfill = `
  :root {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root {
      --chakra-vh: 100dvh;
    }
  }
`;
var CSSPolyfill = () => /* @__PURE__ */(0, _jsxRuntime.jsx)(_react.Global, {
  styles: vhPolyfill
});
exports.CSSPolyfill = CSSPolyfill;
var CSSReset = () => /* @__PURE__ */(0, _jsxRuntime.jsx)(_react.Global, {
  styles: `
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        font-feature-settings: 'kern';
      }

      *,
      *::before,
      *::after {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
      }

      main {
        display: block;
      }

      hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      pre,
      code,
      kbd,
      samp {
        font-family: SFMono-Regular,  Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      b,
      strong {
        font-weight: bold;
      }

      small {
        font-size: 80%;
      }

      sub,
      sup {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      sub {
        bottom: -0.25em;
      }

      sup {
        top: -0.5em;
      }

      img {
        border-style: none;
      }

      button,
      input,
      optgroup,
      select,
      textarea {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      button,
      input {
        overflow: visible;
      }

      button,
      select {
        text-transform: none;
      }

      button::-moz-focus-inner,
      [type="button"]::-moz-focus-inner,
      [type="reset"]::-moz-focus-inner,
      [type="submit"]::-moz-focus-inner {
        border-style: none;
        padding: 0;
      }

      fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      progress {
        vertical-align: baseline;
      }

      textarea {
        overflow: auto;
      }

      [type="checkbox"],
      [type="radio"] {
        box-sizing: border-box;
        padding: 0;
      }

      [type="number"]::-webkit-inner-spin-button,
      [type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      input[type="number"] {
        -moz-appearance: textfield;
      }

      [type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      [type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      details {
        display: block;
      }

      summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      body,
      blockquote,
      dl,
      dd,
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      hr,
      figure,
      p,
      pre {
        margin: 0;
      }

      button {
        background: transparent;
        padding: 0;
      }

      fieldset {
        margin: 0;
        padding: 0;
      }

      ol,
      ul {
        margin: 0;
        padding: 0;
      }

      textarea {
        resize: vertical;
      }

      button,
      [role="button"] {
        cursor: pointer;
      }

      button::-moz-focus-inner {
        border: 0 !important;
      }

      table {
        border-collapse: collapse;
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        font-size: inherit;
        font-weight: inherit;
      }

      button,
      input,
      optgroup,
      select,
      textarea {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      img,
      svg,
      video,
      canvas,
      audio,
      iframe,
      embed,
      object {
        display: block;
      }

      img,
      video {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible] :focus:not([data-focus-visible-added]):not([data-focus-visible-disabled]) {
        outline: none;
        box-shadow: none;
      }

      select::-ms-expand {
        display: none;
      }

      ${vhPolyfill}
    `
});
exports.CSSReset = CSSReset;
var css_reset_default = CSSReset;
exports.css_reset_default = css_reset_default;
},{"@emotion/react":"cUkA","react/jsx-runtime":"plwR"}],"oD4r":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CSSPolyfill", {
  enumerable: true,
  get: function () {
    return _chunk4RZFXYZH.CSSPolyfill;
  }
});
Object.defineProperty(exports, "CSSReset", {
  enumerable: true,
  get: function () {
    return _chunk4RZFXYZH.CSSReset;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _chunk4RZFXYZH.css_reset_default;
  }
});
var _chunk4RZFXYZH = require("./chunk-4RZFXYZH.mjs");
},{"./chunk-4RZFXYZH.mjs":"MbOF"}],"lT23":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createContext = createContext;
var _react = require("react");
// src/index.ts

function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage
  } = options;
  const Context = (0, _react.createContext)(void 0);
  Context.displayName = name;
  function useContext() {
    var _a;
    const context = (0, _react.useContext)(Context);
    if (!context && strict) {
      const error = new Error(errorMessage != null ? errorMessage : getErrorMessage(hookName, providerName));
      error.name = "ContextError";
      (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, error, useContext);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext, Context];
}
},{"react":"n8MK"}],"lm4h":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PortalManager = PortalManager;
exports.usePortalManager = void 0;
var _reactContext = require("@chakra-ui/react-context");
var _jsxRuntime = require("react/jsx-runtime");
// src/portal-manager.tsx

var [PortalManagerContextProvider, usePortalManager] = (0, _reactContext.createContext)({
  strict: false,
  name: "PortalManagerContext"
});
exports.usePortalManager = usePortalManager;
function PortalManager(props) {
  const {
    children,
    zIndex
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(PortalManagerContextProvider, {
    value: {
      zIndex
    },
    children
  });
}
PortalManager.displayName = "PortalManager";
},{"@chakra-ui/react-context":"lT23","react/jsx-runtime":"plwR"}],"cYtR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSafeLayoutEffect = void 0;
var _react = require("react");
// src/index.ts

var useSafeLayoutEffect = Boolean(globalThis == null ? void 0 : globalThis.document) ? _react.useLayoutEffect : _react.useEffect;
exports.useSafeLayoutEffect = useSafeLayoutEffect;
},{"react":"n8MK"}],"H0Y2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Portal = Portal;
var _chunkEJ37EVSP = require("./chunk-EJ37EVSP.mjs");
var _reactUseSafeLayoutEffect = require("@chakra-ui/react-use-safe-layout-effect");
var _reactContext = require("@chakra-ui/react-context");
var _reactDom = require("react-dom");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/portal.tsx

var [PortalContextProvider, usePortalContext] = (0, _reactContext.createContext)({
  strict: false,
  name: "PortalContext"
});
var PORTAL_CLASSNAME = "chakra-portal";
var PORTAL_SELECTOR = `.chakra-portal`;
var Container = props => /* @__PURE__ */(0, _jsxRuntime.jsx)("div", {
  className: "chakra-portal-zIndex",
  style: {
    position: "absolute",
    zIndex: props.zIndex,
    top: 0,
    left: 0,
    right: 0
  },
  children: props.children
});
var DefaultPortal = props => {
  const {
    appendToParentPortal,
    children
  } = props;
  const [tempNode, setTempNode] = (0, _react.useState)(null);
  const portal = (0, _react.useRef)(null);
  const [, forceUpdate] = (0, _react.useState)({});
  (0, _react.useEffect)(() => forceUpdate({}), []);
  const parentPortal = usePortalContext();
  const manager = (0, _chunkEJ37EVSP.usePortalManager)();
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => {
    if (!tempNode) return;
    const doc = tempNode.ownerDocument;
    const host = appendToParentPortal ? parentPortal != null ? parentPortal : doc.body : doc.body;
    if (!host) return;
    portal.current = doc.createElement("div");
    portal.current.className = PORTAL_CLASSNAME;
    host.appendChild(portal.current);
    forceUpdate({});
    const portalNode = portal.current;
    return () => {
      if (host.contains(portalNode)) {
        host.removeChild(portalNode);
      }
    };
  }, [tempNode]);
  const _children = (manager == null ? void 0 : manager.zIndex) ? /* @__PURE__ */(0, _jsxRuntime.jsx)(Container, {
    zIndex: manager == null ? void 0 : manager.zIndex,
    children
  }) : children;
  return portal.current ? (0, _reactDom.createPortal)( /* @__PURE__ */(0, _jsxRuntime.jsx)(PortalContextProvider, {
    value: portal.current,
    children: _children
  }), portal.current) : /* @__PURE__ */(0, _jsxRuntime.jsx)("span", {
    ref: el => {
      if (el) setTempNode(el);
    }
  });
};
var ContainerPortal = props => {
  const {
    children,
    containerRef,
    appendToParentPortal
  } = props;
  const containerEl = containerRef.current;
  const host = containerEl != null ? containerEl : typeof window !== "undefined" ? document.body : void 0;
  const portal = (0, _react.useMemo)(() => {
    const node = containerEl == null ? void 0 : containerEl.ownerDocument.createElement("div");
    if (node) node.className = PORTAL_CLASSNAME;
    return node;
  }, [containerEl]);
  const [, forceUpdate] = (0, _react.useState)({});
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => forceUpdate({}), []);
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => {
    if (!portal || !host) return;
    host.appendChild(portal);
    return () => {
      host.removeChild(portal);
    };
  }, [portal, host]);
  if (host && portal) {
    return (0, _reactDom.createPortal)( /* @__PURE__ */(0, _jsxRuntime.jsx)(PortalContextProvider, {
      value: appendToParentPortal ? portal : null,
      children
    }), portal);
  }
  return null;
};
function Portal(props) {
  const portalProps = {
    appendToParentPortal: true,
    ...props
  };
  const {
    containerRef,
    ...rest
  } = portalProps;
  return containerRef ? /* @__PURE__ */(0, _jsxRuntime.jsx)(ContainerPortal, {
    containerRef,
    ...rest
  }) : /* @__PURE__ */(0, _jsxRuntime.jsx)(DefaultPortal, {
    ...rest
  });
}
Portal.className = PORTAL_CLASSNAME;
Portal.selector = PORTAL_SELECTOR;
Portal.displayName = "Portal";
},{"./chunk-EJ37EVSP.mjs":"lm4h","@chakra-ui/react-use-safe-layout-effect":"cYtR","@chakra-ui/react-context":"lT23","react-dom":"NKHc","react":"n8MK","react/jsx-runtime":"plwR"}],"HPzc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Portal", {
  enumerable: true,
  get: function () {
    return _chunkYLCZP3C.Portal;
  }
});
Object.defineProperty(exports, "PortalManager", {
  enumerable: true,
  get: function () {
    return _chunkEJ37EVSP.PortalManager;
  }
});
Object.defineProperty(exports, "usePortalManager", {
  enumerable: true,
  get: function () {
    return _chunkEJ37EVSP.usePortalManager;
  }
});
var _chunkYLCZP3C = require("./chunk-YLCZP3C4.mjs");
var _chunkEJ37EVSP = require("./chunk-EJ37EVSP.mjs");
},{"./chunk-YLCZP3C4.mjs":"H0Y2","./chunk-EJ37EVSP.mjs":"lm4h"}],"mp9o":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTheme = useTheme;
var _react = require("@emotion/react");
var _react2 = require("react");
// src/use-theme.ts

function useTheme() {
  const theme = (0, _react2.useContext)(_react.ThemeContext);
  if (!theme) {
    throw Error("useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`");
  }
  return theme;
}
},{"@emotion/react":"cUkA","react":"n8MK"}],"hxIl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorModeContext = void 0;
exports.useColorMode = useColorMode;
exports.useColorModeValue = useColorModeValue;
var _react = require("react");
// src/color-mode-context.ts

var ColorModeContext = (0, _react.createContext)({});
exports.ColorModeContext = ColorModeContext;
ColorModeContext.displayName = "ColorModeContext";
function useColorMode() {
  const context = (0, _react.useContext)(ColorModeContext);
  if (context === void 0) {
    throw new Error("useColorMode must be used within a ColorModeProvider");
  }
  return context;
}
function useColorModeValue(light, dark) {
  const {
    colorMode
  } = useColorMode();
  return colorMode === "dark" ? dark : light;
}
},{"react":"n8MK"}],"E3dv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getColorModeUtils = getColorModeUtils;
// src/color-mode.utils.ts
var classNames = {
  light: "chakra-ui-light",
  dark: "chakra-ui-dark"
};
function getColorModeUtils(options = {}) {
  const {
    preventTransition = true
  } = options;
  const utils = {
    setDataset: value => {
      const cleanup = preventTransition ? utils.preventTransition() : void 0;
      document.documentElement.dataset.theme = value;
      document.documentElement.style.colorScheme = value;
      cleanup == null ? void 0 : cleanup();
    },
    setClassName(dark) {
      document.body.classList.add(dark ? classNames.dark : classNames.light);
      document.body.classList.remove(dark ? classNames.light : classNames.dark);
    },
    query() {
      return window.matchMedia("(prefers-color-scheme: dark)");
    },
    getSystemTheme(fallback) {
      var _a;
      const dark = (_a = utils.query().matches) != null ? _a : fallback === "dark";
      return dark ? "dark" : "light";
    },
    addListener(fn) {
      const mql = utils.query();
      const listener = e => {
        fn(e.matches ? "dark" : "light");
      };
      if (typeof mql.addListener === "function") mql.addListener(listener);else mql.addEventListener("change", listener);
      return () => {
        if (typeof mql.removeListener === "function") mql.removeListener(listener);else mql.removeEventListener("change", listener);
      };
    },
    preventTransition() {
      const css = document.createElement("style");
      css.appendChild(document.createTextNode(`*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`));
      document.head.appendChild(css);
      return () => {
        ;
        (() => window.getComputedStyle(document.body))();
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            document.head.removeChild(css);
          });
        });
      };
    }
  };
  return utils;
}
},{}],"Vt2M":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cookieStorageManagerSSR = exports.cookieStorageManager = exports.STORAGE_KEY = void 0;
exports.createCookieStorageManager = createCookieStorageManager;
exports.createLocalStorageManager = createLocalStorageManager;
exports.localStorageManager = void 0;
// src/storage-manager.ts
var STORAGE_KEY = "chakra-ui-color-mode";
exports.STORAGE_KEY = STORAGE_KEY;
function createLocalStorageManager(key) {
  return {
    ssr: false,
    type: "localStorage",
    get(init) {
      if (!(globalThis == null ? void 0 : globalThis.document)) return init;
      let value;
      try {
        value = localStorage.getItem(key) || init;
      } catch (e) {}
      return value || init;
    },
    set(value) {
      try {
        localStorage.setItem(key, value);
      } catch (e) {}
    }
  };
}
var localStorageManager = createLocalStorageManager(STORAGE_KEY);
exports.localStorageManager = localStorageManager;
function parseCookie(cookie, key) {
  const match = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match == null ? void 0 : match[2];
}
function createCookieStorageManager(key, cookie) {
  return {
    ssr: !!cookie,
    type: "cookie",
    get(init) {
      if (cookie) return parseCookie(cookie, key);
      if (!(globalThis == null ? void 0 : globalThis.document)) return init;
      return parseCookie(document.cookie, key) || init;
    },
    set(value) {
      document.cookie = `${key}=${value}; max-age=31536000; path=/`;
    }
  };
}
var cookieStorageManager = createCookieStorageManager(STORAGE_KEY);
exports.cookieStorageManager = cookieStorageManager;
var cookieStorageManagerSSR = cookie => createCookieStorageManager(STORAGE_KEY, cookie);
exports.cookieStorageManagerSSR = cookieStorageManagerSSR;
},{}],"uj3H":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorModeProvider = ColorModeProvider;
exports.DarkMode = DarkMode;
exports.LightMode = LightMode;
var _chunk7NLW6UB = require("./chunk-7NLW6UB6.mjs");
var _chunkQTTMAIIW = require("./chunk-QTTMAIIW.mjs");
var _chunkBWTZURQV = require("./chunk-BWTZURQV.mjs");
var _reactUseSafeLayoutEffect = require("@chakra-ui/react-use-safe-layout-effect");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/color-mode-provider.tsx

var noop = () => {};
function getTheme(manager, fallback) {
  return manager.type === "cookie" && manager.ssr ? manager.get(fallback) : fallback;
}
function ColorModeProvider(props) {
  const {
    value,
    children,
    options: {
      useSystemColorMode,
      initialColorMode,
      disableTransitionOnChange
    } = {},
    colorModeManager = _chunkBWTZURQV.localStorageManager
  } = props;
  const defaultColorMode = initialColorMode === "dark" ? "dark" : "light";
  const [colorMode, rawSetColorMode] = (0, _react.useState)(() => getTheme(colorModeManager, defaultColorMode));
  const [resolvedColorMode, setResolvedColorMode] = (0, _react.useState)(() => getTheme(colorModeManager));
  const {
    getSystemTheme,
    setClassName,
    setDataset,
    addListener
  } = (0, _react.useMemo)(() => (0, _chunkQTTMAIIW.getColorModeUtils)({
    preventTransition: disableTransitionOnChange
  }), [disableTransitionOnChange]);
  const resolvedValue = initialColorMode === "system" && !colorMode ? resolvedColorMode : colorMode;
  const setColorMode = (0, _react.useCallback)(value2 => {
    const resolved = value2 === "system" ? getSystemTheme() : value2;
    rawSetColorMode(resolved);
    setClassName(resolved === "dark");
    setDataset(resolved);
    colorModeManager.set(resolved);
  }, [colorModeManager, getSystemTheme, setClassName, setDataset]);
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => {
    if (initialColorMode === "system") {
      setResolvedColorMode(getSystemTheme());
    }
  }, []);
  (0, _react.useEffect)(() => {
    const managerValue = colorModeManager.get();
    if (managerValue) {
      setColorMode(managerValue);
      return;
    }
    if (initialColorMode === "system") {
      setColorMode("system");
      return;
    }
    setColorMode(defaultColorMode);
  }, [colorModeManager, defaultColorMode, initialColorMode, setColorMode]);
  const toggleColorMode = (0, _react.useCallback)(() => {
    setColorMode(resolvedValue === "dark" ? "light" : "dark");
  }, [resolvedValue, setColorMode]);
  (0, _react.useEffect)(() => {
    if (!useSystemColorMode) return;
    return addListener(setColorMode);
  }, [useSystemColorMode, addListener, setColorMode]);
  const context = (0, _react.useMemo)(() => ({
    colorMode: value != null ? value : resolvedValue,
    toggleColorMode: value ? noop : toggleColorMode,
    setColorMode: value ? noop : setColorMode,
    forced: value !== void 0
  }), [resolvedValue, toggleColorMode, setColorMode, value]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk7NLW6UB.ColorModeContext.Provider, {
    value: context,
    children
  });
}
ColorModeProvider.displayName = "ColorModeProvider";
function DarkMode(props) {
  const context = (0, _react.useMemo)(() => ({
    colorMode: "dark",
    toggleColorMode: noop,
    setColorMode: noop,
    forced: true
  }), []);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk7NLW6UB.ColorModeContext.Provider, {
    value: context,
    ...props
  });
}
DarkMode.displayName = "DarkMode";
function LightMode(props) {
  const context = (0, _react.useMemo)(() => ({
    colorMode: "light",
    toggleColorMode: noop,
    setColorMode: noop,
    forced: true
  }), []);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk7NLW6UB.ColorModeContext.Provider, {
    value: context,
    ...props
  });
}
LightMode.displayName = "LightMode";
},{"./chunk-7NLW6UB6.mjs":"hxIl","./chunk-QTTMAIIW.mjs":"E3dv","./chunk-BWTZURQV.mjs":"Vt2M","@chakra-ui/react-use-safe-layout-effect":"cYtR","react":"n8MK","react/jsx-runtime":"plwR"}],"qCbg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorModeScript = ColorModeScript;
exports.getScriptSrc = getScriptSrc;
var _jsxRuntime = require("react/jsx-runtime");
// src/color-mode-script.tsx

var VALID_VALUES = /* @__PURE__ */new Set(["dark", "light", "system"]);
function normalize(initialColorMode) {
  let value = initialColorMode;
  if (!VALID_VALUES.has(value)) value = "light";
  return value;
}
function getScriptSrc(props = {}) {
  const {
    initialColorMode = "light",
    type = "localStorage",
    storageKey: key = "chakra-ui-color-mode"
  } = props;
  const init = normalize(initialColorMode);
  const isCookie = type === "cookie";
  const cookieScript = `(function(){try{var a=function(o){var l="(prefers-color-scheme: dark)",v=window.matchMedia(l).matches?"dark":"light",e=o==="system"?v:o,d=document.documentElement,m=document.body,i="chakra-ui-light",n="chakra-ui-dark",s=e==="dark";return m.classList.add(s?n:i),m.classList.remove(s?i:n),d.style.colorScheme=e,d.dataset.theme=e,e},u=a,h="${init}",r="${key}",t=document.cookie.match(new RegExp("(^| )".concat(r,"=([^;]+)"))),c=t?t[2]:null;c?a(c):document.cookie="".concat(r,"=").concat(a(h),"; max-age=31536000; path=/")}catch(a){}})();
  `;
  const localStorageScript = `(function(){try{var a=function(c){var v="(prefers-color-scheme: dark)",h=window.matchMedia(v).matches?"dark":"light",r=c==="system"?h:c,o=document.documentElement,s=document.body,l="chakra-ui-light",d="chakra-ui-dark",i=r==="dark";return s.classList.add(i?d:l),s.classList.remove(i?l:d),o.style.colorScheme=r,o.dataset.theme=r,r},n=a,m="${init}",e="${key}",t=localStorage.getItem(e);t?a(t):localStorage.setItem(e,a(m))}catch(a){}})();
  `;
  const fn = isCookie ? cookieScript : localStorageScript;
  return `!${fn}`.trim();
}
function ColorModeScript(props = {}) {
  const {
    nonce
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)("script", {
    id: "chakra-script",
    nonce,
    dangerouslySetInnerHTML: {
      __html: getScriptSrc(props)
    }
  });
}
},{"react/jsx-runtime":"plwR"}],"x8lr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ColorModeContext", {
  enumerable: true,
  get: function () {
    return _chunk7NLW6UB.ColorModeContext;
  }
});
Object.defineProperty(exports, "ColorModeProvider", {
  enumerable: true,
  get: function () {
    return _chunk4DEUOPYU.ColorModeProvider;
  }
});
Object.defineProperty(exports, "ColorModeScript", {
  enumerable: true,
  get: function () {
    return _chunkDCUKMMT.ColorModeScript;
  }
});
Object.defineProperty(exports, "DarkMode", {
  enumerable: true,
  get: function () {
    return _chunk4DEUOPYU.DarkMode;
  }
});
Object.defineProperty(exports, "LightMode", {
  enumerable: true,
  get: function () {
    return _chunk4DEUOPYU.LightMode;
  }
});
Object.defineProperty(exports, "cookieStorageManager", {
  enumerable: true,
  get: function () {
    return _chunkBWTZURQV.cookieStorageManager;
  }
});
Object.defineProperty(exports, "cookieStorageManagerSSR", {
  enumerable: true,
  get: function () {
    return _chunkBWTZURQV.cookieStorageManagerSSR;
  }
});
Object.defineProperty(exports, "createCookieStorageManager", {
  enumerable: true,
  get: function () {
    return _chunkBWTZURQV.createCookieStorageManager;
  }
});
Object.defineProperty(exports, "createLocalStorageManager", {
  enumerable: true,
  get: function () {
    return _chunkBWTZURQV.createLocalStorageManager;
  }
});
Object.defineProperty(exports, "getScriptSrc", {
  enumerable: true,
  get: function () {
    return _chunkDCUKMMT.getScriptSrc;
  }
});
Object.defineProperty(exports, "localStorageManager", {
  enumerable: true,
  get: function () {
    return _chunkBWTZURQV.localStorageManager;
  }
});
Object.defineProperty(exports, "useColorMode", {
  enumerable: true,
  get: function () {
    return _chunk7NLW6UB.useColorMode;
  }
});
Object.defineProperty(exports, "useColorModeValue", {
  enumerable: true,
  get: function () {
    return _chunk7NLW6UB.useColorModeValue;
  }
});
var _chunk4DEUOPYU = require("./chunk-4DEUOPYU.mjs");
var _chunk7NLW6UB = require("./chunk-7NLW6UB6.mjs");
var _chunkDCUKMMT = require("./chunk-DCUKMMT3.mjs");
require("./chunk-QTTMAIIW.mjs");
var _chunkBWTZURQV = require("./chunk-BWTZURQV.mjs");
},{"./chunk-4DEUOPYU.mjs":"uj3H","./chunk-7NLW6UB6.mjs":"hxIl","./chunk-DCUKMMT3.mjs":"qCbg","./chunk-QTTMAIIW.mjs":"E3dv","./chunk-BWTZURQV.mjs":"Vt2M"}],"pItx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getToken = getToken;
exports.useChakra = useChakra;
exports.useToken = useToken;
var _chunkNLMMK76H = require("./chunk-NLMMK76H.mjs");
var _colorMode = require("@chakra-ui/color-mode");
// src/hooks.ts

function useChakra() {
  const colorModeResult = (0, _colorMode.useColorMode)();
  const theme = (0, _chunkNLMMK76H.useTheme)();
  return {
    ...colorModeResult,
    theme
  };
}
function getBreakpointValue(theme, value, fallback) {
  var _a, _b;
  if (value == null) return value;
  const getValue = val => {
    var _a2, _b2;
    return (_b2 = (_a2 = theme.__breakpoints) == null ? void 0 : _a2.asArray) == null ? void 0 : _b2[val];
  };
  return (_b = (_a = getValue(value)) != null ? _a : getValue(fallback)) != null ? _b : fallback;
}
function getTokenValue(theme, value, fallback) {
  var _a, _b;
  if (value == null) return value;
  const getValue = val => {
    var _a2, _b2;
    return (_b2 = (_a2 = theme.__cssMap) == null ? void 0 : _a2[val]) == null ? void 0 : _b2.value;
  };
  return (_b = (_a = getValue(value)) != null ? _a : getValue(fallback)) != null ? _b : fallback;
}
function useToken(scale, token, fallback) {
  const theme = (0, _chunkNLMMK76H.useTheme)();
  return getToken(scale, token, fallback)(theme);
}
function getToken(scale, token, fallback) {
  const _token = Array.isArray(token) ? token : [token];
  const _fallback = Array.isArray(fallback) ? fallback : [fallback];
  return theme => {
    const fallbackArr = _fallback.filter(Boolean);
    const result = _token.map((token2, index) => {
      var _a, _b;
      if (scale === "breakpoints") {
        return getBreakpointValue(theme, token2, (_a = fallbackArr[index]) != null ? _a : token2);
      }
      const path = `${scale}.${token2}`;
      return getTokenValue(theme, path, (_b = fallbackArr[index]) != null ? _b : token2);
    });
    return Array.isArray(token) ? result : result[0];
  };
}
},{"./chunk-NLMMK76H.mjs":"mp9o","@chakra-ui/color-mode":"x8lr"}],"gghr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ariaAttr = void 0;
exports.callAll = callAll;
exports.callAllHandlers = callAllHandlers;
exports.dataAttr = exports.cx = void 0;
exports.isObject = isObject;
exports.runIfFn = runIfFn;
exports.warn = void 0;
// src/index.ts
var cx = (...classNames) => classNames.filter(Boolean).join(" ");
exports.cx = cx;
function isDev() {
  return "production" !== "production";
}
function isObject(value) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function") && !Array.isArray(value);
}
var warn = options => {
  const {
    condition,
    message
  } = options;
  if (condition && isDev()) {
    console.warn(message);
  }
};
exports.warn = warn;
function runIfFn(valueOrFn, ...args) {
  return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}
var isFunction = value => typeof value === "function";
var dataAttr = condition => condition ? "" : void 0;
exports.dataAttr = dataAttr;
var ariaAttr = condition => condition ? true : void 0;
exports.ariaAttr = ariaAttr;
function callAllHandlers(...fns) {
  return function func(event) {
    fns.some(fn => {
      fn == null ? void 0 : fn(event);
      return event == null ? void 0 : event.defaultPrevented;
    });
  };
}
function callAll(...fns) {
  return function mergedFn(arg) {
    fns.forEach(fn => {
      fn == null ? void 0 : fn(arg);
    });
  };
}
},{}],"fWTD":[function(require,module,exports) {
var global = arguments[3];

/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeMax = Math.max,
    nativeNow = Date.now;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = mergeWith;

},{}],"asJy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addPrefix = addPrefix;
exports.color = exports.calc = exports.border = exports.background = void 0;
exports.createMultiStyleConfigHelpers = createMultiStyleConfigHelpers;
exports.css = void 0;
exports.cssVar = cssVar;
exports.defineStyle = defineStyle;
exports.defineStyleConfig = defineStyleConfig;
exports.filter = exports.effect = void 0;
exports.flatten = flatten;
exports.flattenTokens = flattenTokens;
exports.flexbox = void 0;
exports.getCSSVar = getCSSVar;
exports.getCss = getCss;
exports.list = exports.layoutPropNames = exports.layout = exports.isStyleProp = exports.interactivity = exports.grid = void 0;
exports.omitThemingProps = omitThemingProps;
exports.pseudoSelectors = exports.pseudoPropNames = exports.propNames = exports.position = exports.others = void 0;
exports.resolveStyleConfig = resolveStyleConfig;
exports.textDecoration = exports.systemProps = exports.space = exports.scroll = exports.ring = void 0;
exports.toCSSVar = toCSSVar;
exports.toVarDefinition = toVarDefinition;
exports.toVarReference = toVarReference;
exports.typography = exports.transition = exports.transform = exports.tokenToCSSVar = void 0;
var _sharedUtils = require("@chakra-ui/shared-utils");
var _lodash = _interopRequireDefault(require("lodash.mergewith"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// src/utils/create-transform.ts

var isImportant = value => /!(important)?$/.test(value);
var withoutImportant = value => typeof value === "string" ? value.replace(/!(important)?$/, "").trim() : value;
var tokenToCSSVar = (scale, value) => theme => {
  const valueStr = String(value);
  const important = isImportant(valueStr);
  const valueWithoutImportant = withoutImportant(valueStr);
  const key = scale ? `${scale}.${valueWithoutImportant}` : valueWithoutImportant;
  let transformed = (0, _sharedUtils.isObject)(theme.__cssMap) && key in theme.__cssMap ? theme.__cssMap[key].varRef : value;
  transformed = withoutImportant(transformed);
  return important ? `${transformed} !important` : transformed;
};
exports.tokenToCSSVar = tokenToCSSVar;
function createTransform(options) {
  const {
    scale,
    transform: transform2,
    compose
  } = options;
  const fn = (value, theme) => {
    var _a;
    const _value = tokenToCSSVar(scale, value)(theme);
    let result = (_a = transform2 == null ? void 0 : transform2(_value, theme)) != null ? _a : _value;
    if (compose) {
      result = compose(result, theme);
    }
    return result;
  };
  return fn;
}

// src/utils/pipe.ts
var pipe = (...fns) => v => fns.reduce((a, b) => b(a), v);

// src/utils/prop-config.ts
function toConfig(scale, transform2) {
  return property => {
    const result = {
      property,
      scale
    };
    result.transform = createTransform({
      scale,
      transform: transform2
    });
    return result;
  };
}
var getRtl = ({
  rtl,
  ltr
}) => theme => theme.direction === "rtl" ? rtl : ltr;
function logical(options) {
  const {
    property,
    scale,
    transform: transform2
  } = options;
  return {
    scale,
    property: getRtl(property),
    transform: scale ? createTransform({
      scale,
      compose: transform2
    }) : transform2
  };
}

// src/utils/templates.ts
var transformTemplate = ["rotate(var(--chakra-rotate, 0))", "scaleX(var(--chakra-scale-x, 1))", "scaleY(var(--chakra-scale-y, 1))", "skewX(var(--chakra-skew-x, 0))", "skewY(var(--chakra-skew-y, 0))"];
function getTransformTemplate() {
  return ["translateX(var(--chakra-translate-x, 0))", "translateY(var(--chakra-translate-y, 0))", ...transformTemplate].join(" ");
}
function getTransformGpuTemplate() {
  return ["translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)", ...transformTemplate].join(" ");
}
var filterTemplate = {
  "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
  filter: ["var(--chakra-blur)", "var(--chakra-brightness)", "var(--chakra-contrast)", "var(--chakra-grayscale)", "var(--chakra-hue-rotate)", "var(--chakra-invert)", "var(--chakra-saturate)", "var(--chakra-sepia)", "var(--chakra-drop-shadow)"].join(" ")
};
var backdropFilterTemplate = {
  backdropFilter: ["var(--chakra-backdrop-blur)", "var(--chakra-backdrop-brightness)", "var(--chakra-backdrop-contrast)", "var(--chakra-backdrop-grayscale)", "var(--chakra-backdrop-hue-rotate)", "var(--chakra-backdrop-invert)", "var(--chakra-backdrop-opacity)", "var(--chakra-backdrop-saturate)", "var(--chakra-backdrop-sepia)"].join(" "),
  "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};
function getRingTemplate(value) {
  return {
    "--chakra-ring-offset-shadow": `var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)`,
    "--chakra-ring-shadow": `var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)`,
    "--chakra-ring-width": value,
    boxShadow: [`var(--chakra-ring-offset-shadow)`, `var(--chakra-ring-shadow)`, `var(--chakra-shadow, 0 0 #0000)`].join(", ")
  };
}
var flexDirectionTemplate = {
  "row-reverse": {
    space: "--chakra-space-x-reverse",
    divide: "--chakra-divide-x-reverse"
  },
  "column-reverse": {
    space: "--chakra-space-y-reverse",
    divide: "--chakra-divide-y-reverse"
  }
};
var owlSelector = "& > :not(style) ~ :not(style)";
var spaceXTemplate = {
  [owlSelector]: {
    marginInlineStart: "calc(var(--chakra-space-x) * calc(1 - var(--chakra-space-x-reverse)))",
    marginInlineEnd: "calc(var(--chakra-space-x) * var(--chakra-space-x-reverse))"
  }
};
var spaceYTemplate = {
  [owlSelector]: {
    marginTop: "calc(var(--chakra-space-y) * calc(1 - var(--chakra-space-y-reverse)))",
    marginBottom: "calc(var(--chakra-space-y) * var(--chakra-space-y-reverse))"
  }
};

// src/utils/parse-gradient.ts
var directionMap = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
};
var valueSet = new Set(Object.values(directionMap));
var globalSet = /* @__PURE__ */new Set(["none", "-moz-initial", "inherit", "initial", "revert", "unset"]);
var trimSpace = str => str.trim();
function parseGradient(value, theme) {
  var _a, _b;
  if (value == null || globalSet.has(value)) return value;
  const regex = /(?<type>^[a-z-A-Z]+)\((?<values>(.*))\)/g;
  const {
    type,
    values
  } = (_b = (_a = regex.exec(value)) == null ? void 0 : _a.groups) != null ? _b : {};
  if (!type || !values) return value;
  const _type = type.includes("-gradient") ? type : `${type}-gradient`;
  const [maybeDirection, ...stops] = values.split(",").map(trimSpace).filter(Boolean);
  if ((stops == null ? void 0 : stops.length) === 0) return value;
  const direction = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
  stops.unshift(direction);
  const _values = stops.map(stop => {
    if (valueSet.has(stop)) return stop;
    const firstStop = stop.indexOf(" ");
    const [_color, _stop] = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop];
    const _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(" ");
    const key = `colors.${_color}`;
    const color2 = key in theme.__cssMap ? theme.__cssMap[key].varRef : _color;
    return _stopOrFunc ? [color2, ...(Array.isArray(_stopOrFunc) ? _stopOrFunc : [_stopOrFunc])].join(" ") : color2;
  });
  return `${_type}(${_values.join(", ")})`;
}
var isCSSFunction = value => {
  return typeof value === "string" && value.includes("(") && value.includes(")");
};
var gradientTransform = (value, theme) => parseGradient(value, theme != null ? theme : {});

// src/utils/transform-functions.ts
function isCssVar(value) {
  return /^var\(--.+\)$/.test(value);
}
var analyzeCSSValue = value => {
  const num = parseFloat(value.toString());
  const unit = value.toString().replace(String(num), "");
  return {
    unitless: !unit,
    value: num,
    unit
  };
};
var wrap = str => value => `${str}(${value})`;
var transformFunctions = {
  filter(value) {
    return value !== "auto" ? value : filterTemplate;
  },
  backdropFilter(value) {
    return value !== "auto" ? value : backdropFilterTemplate;
  },
  ring(value) {
    return getRingTemplate(transformFunctions.px(value));
  },
  bgClip(value) {
    return value === "text" ? {
      color: "transparent",
      backgroundClip: "text"
    } : {
      backgroundClip: value
    };
  },
  transform(value) {
    if (value === "auto") return getTransformTemplate();
    if (value === "auto-gpu") return getTransformGpuTemplate();
    return value;
  },
  vh(value) {
    return value === "$100vh" ? "var(--chakra-vh)" : value;
  },
  px(value) {
    if (value == null) return value;
    const {
      unitless
    } = analyzeCSSValue(value);
    return unitless || typeof value === "number" ? `${value}px` : value;
  },
  fraction(value) {
    return !(typeof value === "number") || value > 1 ? value : `${value * 100}%`;
  },
  float(value, theme) {
    const map = {
      left: "right",
      right: "left"
    };
    return theme.direction === "rtl" ? map[value] : value;
  },
  degree(value) {
    if (isCssVar(value) || value == null) return value;
    const unitless = typeof value === "string" && !value.endsWith("deg");
    return typeof value === "number" || unitless ? `${value}deg` : value;
  },
  gradient: gradientTransform,
  blur: wrap("blur"),
  opacity: wrap("opacity"),
  brightness: wrap("brightness"),
  contrast: wrap("contrast"),
  dropShadow: wrap("drop-shadow"),
  grayscale: wrap("grayscale"),
  hueRotate: wrap("hue-rotate"),
  invert: wrap("invert"),
  saturate: wrap("saturate"),
  sepia: wrap("sepia"),
  bgImage(value) {
    if (value == null) return value;
    const prevent = isCSSFunction(value) || globalSet.has(value);
    return !prevent ? `url(${value})` : value;
  },
  outline(value) {
    const isNoneOrZero = String(value) === "0" || String(value) === "none";
    return value !== null && isNoneOrZero ? {
      outline: "2px solid transparent",
      outlineOffset: "2px"
    } : {
      outline: value
    };
  },
  flexDirection(value) {
    var _a;
    const {
      space: space2,
      divide: divide2
    } = (_a = flexDirectionTemplate[value]) != null ? _a : {};
    const result = {
      flexDirection: value
    };
    if (space2) result[space2] = 1;
    if (divide2) result[divide2] = 1;
    return result;
  }
};

// src/utils/index.ts
var t = {
  borderWidths: toConfig("borderWidths"),
  borderStyles: toConfig("borderStyles"),
  colors: toConfig("colors"),
  borders: toConfig("borders"),
  radii: toConfig("radii", transformFunctions.px),
  space: toConfig("space", pipe(transformFunctions.vh, transformFunctions.px)),
  spaceT: toConfig("space", pipe(transformFunctions.vh, transformFunctions.px)),
  degreeT(property) {
    return {
      property,
      transform: transformFunctions.degree
    };
  },
  prop(property, scale, transform2) {
    return {
      property,
      scale,
      ...(scale && {
        transform: createTransform({
          scale,
          transform: transform2
        })
      })
    };
  },
  propT(property, transform2) {
    return {
      property,
      transform: transform2
    };
  },
  sizes: toConfig("sizes", pipe(transformFunctions.vh, transformFunctions.px)),
  sizesT: toConfig("sizes", pipe(transformFunctions.vh, transformFunctions.fraction)),
  shadows: toConfig("shadows"),
  logical,
  blur: toConfig("blur", transformFunctions.blur)
};

// src/config/background.ts
var background = {
  background: t.colors("background"),
  backgroundColor: t.colors("backgroundColor"),
  backgroundImage: t.propT("backgroundImage", transformFunctions.bgImage),
  backgroundSize: true,
  backgroundPosition: true,
  backgroundRepeat: true,
  backgroundAttachment: true,
  backgroundClip: {
    transform: transformFunctions.bgClip
  },
  bgSize: t.prop("backgroundSize"),
  bgPosition: t.prop("backgroundPosition"),
  bg: t.colors("background"),
  bgColor: t.colors("backgroundColor"),
  bgPos: t.prop("backgroundPosition"),
  bgRepeat: t.prop("backgroundRepeat"),
  bgAttachment: t.prop("backgroundAttachment"),
  bgGradient: t.propT("backgroundImage", transformFunctions.gradient),
  bgClip: {
    transform: transformFunctions.bgClip
  }
};
exports.background = background;
Object.assign(background, {
  bgImage: background.backgroundImage,
  bgImg: background.backgroundImage
});

// src/config/border.ts
var border = {
  border: t.borders("border"),
  borderWidth: t.borderWidths("borderWidth"),
  borderStyle: t.borderStyles("borderStyle"),
  borderColor: t.colors("borderColor"),
  borderRadius: t.radii("borderRadius"),
  borderTop: t.borders("borderTop"),
  borderBlockStart: t.borders("borderBlockStart"),
  borderTopLeftRadius: t.radii("borderTopLeftRadius"),
  borderStartStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopLeftRadius",
      rtl: "borderTopRightRadius"
    }
  }),
  borderEndStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomLeftRadius",
      rtl: "borderBottomRightRadius"
    }
  }),
  borderTopRightRadius: t.radii("borderTopRightRadius"),
  borderStartEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopRightRadius",
      rtl: "borderTopLeftRadius"
    }
  }),
  borderEndEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomRightRadius",
      rtl: "borderBottomLeftRadius"
    }
  }),
  borderRight: t.borders("borderRight"),
  borderInlineEnd: t.borders("borderInlineEnd"),
  borderBottom: t.borders("borderBottom"),
  borderBlockEnd: t.borders("borderBlockEnd"),
  borderBottomLeftRadius: t.radii("borderBottomLeftRadius"),
  borderBottomRightRadius: t.radii("borderBottomRightRadius"),
  borderLeft: t.borders("borderLeft"),
  borderInlineStart: {
    property: "borderInlineStart",
    scale: "borders"
  },
  borderInlineStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
      rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
    }
  }),
  borderInlineEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
      rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
    }
  }),
  borderX: t.borders(["borderLeft", "borderRight"]),
  borderInline: t.borders("borderInline"),
  borderY: t.borders(["borderTop", "borderBottom"]),
  borderBlock: t.borders("borderBlock"),
  borderTopWidth: t.borderWidths("borderTopWidth"),
  borderBlockStartWidth: t.borderWidths("borderBlockStartWidth"),
  borderTopColor: t.colors("borderTopColor"),
  borderBlockStartColor: t.colors("borderBlockStartColor"),
  borderTopStyle: t.borderStyles("borderTopStyle"),
  borderBlockStartStyle: t.borderStyles("borderBlockStartStyle"),
  borderBottomWidth: t.borderWidths("borderBottomWidth"),
  borderBlockEndWidth: t.borderWidths("borderBlockEndWidth"),
  borderBottomColor: t.colors("borderBottomColor"),
  borderBlockEndColor: t.colors("borderBlockEndColor"),
  borderBottomStyle: t.borderStyles("borderBottomStyle"),
  borderBlockEndStyle: t.borderStyles("borderBlockEndStyle"),
  borderLeftWidth: t.borderWidths("borderLeftWidth"),
  borderInlineStartWidth: t.borderWidths("borderInlineStartWidth"),
  borderLeftColor: t.colors("borderLeftColor"),
  borderInlineStartColor: t.colors("borderInlineStartColor"),
  borderLeftStyle: t.borderStyles("borderLeftStyle"),
  borderInlineStartStyle: t.borderStyles("borderInlineStartStyle"),
  borderRightWidth: t.borderWidths("borderRightWidth"),
  borderInlineEndWidth: t.borderWidths("borderInlineEndWidth"),
  borderRightColor: t.colors("borderRightColor"),
  borderInlineEndColor: t.colors("borderInlineEndColor"),
  borderRightStyle: t.borderStyles("borderRightStyle"),
  borderInlineEndStyle: t.borderStyles("borderInlineEndStyle"),
  borderTopRadius: t.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
  borderBottomRadius: t.radii(["borderBottomLeftRadius", "borderBottomRightRadius"]),
  borderLeftRadius: t.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
  borderRightRadius: t.radii(["borderTopRightRadius", "borderBottomRightRadius"])
};
exports.border = border;
Object.assign(border, {
  rounded: border.borderRadius,
  roundedTop: border.borderTopRadius,
  roundedTopLeft: border.borderTopLeftRadius,
  roundedTopRight: border.borderTopRightRadius,
  roundedTopStart: border.borderStartStartRadius,
  roundedTopEnd: border.borderStartEndRadius,
  roundedBottom: border.borderBottomRadius,
  roundedBottomLeft: border.borderBottomLeftRadius,
  roundedBottomRight: border.borderBottomRightRadius,
  roundedBottomStart: border.borderEndStartRadius,
  roundedBottomEnd: border.borderEndEndRadius,
  roundedLeft: border.borderLeftRadius,
  roundedRight: border.borderRightRadius,
  roundedStart: border.borderInlineStartRadius,
  roundedEnd: border.borderInlineEndRadius,
  borderStart: border.borderInlineStart,
  borderEnd: border.borderInlineEnd,
  borderTopStartRadius: border.borderStartStartRadius,
  borderTopEndRadius: border.borderStartEndRadius,
  borderBottomStartRadius: border.borderEndStartRadius,
  borderBottomEndRadius: border.borderEndEndRadius,
  borderStartRadius: border.borderInlineStartRadius,
  borderEndRadius: border.borderInlineEndRadius,
  borderStartWidth: border.borderInlineStartWidth,
  borderEndWidth: border.borderInlineEndWidth,
  borderStartColor: border.borderInlineStartColor,
  borderEndColor: border.borderInlineEndColor,
  borderStartStyle: border.borderInlineStartStyle,
  borderEndStyle: border.borderInlineEndStyle
});

// src/config/color.ts
var color = {
  color: t.colors("color"),
  textColor: t.colors("color"),
  fill: t.colors("fill"),
  stroke: t.colors("stroke")
};

// src/config/effect.ts
exports.color = color;
var effect = {
  boxShadow: t.shadows("boxShadow"),
  mixBlendMode: true,
  blendMode: t.prop("mixBlendMode"),
  backgroundBlendMode: true,
  bgBlendMode: t.prop("backgroundBlendMode"),
  opacity: true
};
exports.effect = effect;
Object.assign(effect, {
  shadow: effect.boxShadow
});

// src/config/filter.ts
var filter = {
  filter: {
    transform: transformFunctions.filter
  },
  blur: t.blur("--chakra-blur"),
  brightness: t.propT("--chakra-brightness", transformFunctions.brightness),
  contrast: t.propT("--chakra-contrast", transformFunctions.contrast),
  hueRotate: t.degreeT("--chakra-hue-rotate"),
  invert: t.propT("--chakra-invert", transformFunctions.invert),
  saturate: t.propT("--chakra-saturate", transformFunctions.saturate),
  dropShadow: t.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
  backdropFilter: {
    transform: transformFunctions.backdropFilter
  },
  backdropBlur: t.blur("--chakra-backdrop-blur"),
  backdropBrightness: t.propT("--chakra-backdrop-brightness", transformFunctions.brightness),
  backdropContrast: t.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
  backdropHueRotate: t.degreeT("--chakra-backdrop-hue-rotate"),
  backdropInvert: t.propT("--chakra-backdrop-invert", transformFunctions.invert),
  backdropSaturate: t.propT("--chakra-backdrop-saturate", transformFunctions.saturate)
};

// src/config/flexbox.ts
exports.filter = filter;
var flexbox = {
  alignItems: true,
  alignContent: true,
  justifyItems: true,
  justifyContent: true,
  flexWrap: true,
  flexDirection: {
    transform: transformFunctions.flexDirection
  },
  experimental_spaceX: {
    static: spaceXTemplate,
    transform: createTransform({
      scale: "space",
      transform: value => value !== null ? {
        "--chakra-space-x": value
      } : null
    })
  },
  experimental_spaceY: {
    static: spaceYTemplate,
    transform: createTransform({
      scale: "space",
      transform: value => value != null ? {
        "--chakra-space-y": value
      } : null
    })
  },
  flex: true,
  flexFlow: true,
  flexGrow: true,
  flexShrink: true,
  flexBasis: t.sizes("flexBasis"),
  justifySelf: true,
  alignSelf: true,
  order: true,
  placeItems: true,
  placeContent: true,
  placeSelf: true,
  gap: t.space("gap"),
  rowGap: t.space("rowGap"),
  columnGap: t.space("columnGap")
};
exports.flexbox = flexbox;
Object.assign(flexbox, {
  flexDir: flexbox.flexDirection
});

// src/config/grid.ts
var grid = {
  gridGap: t.space("gridGap"),
  gridColumnGap: t.space("gridColumnGap"),
  gridRowGap: t.space("gridRowGap"),
  gridColumn: true,
  gridRow: true,
  gridAutoFlow: true,
  gridAutoColumns: true,
  gridColumnStart: true,
  gridColumnEnd: true,
  gridRowStart: true,
  gridRowEnd: true,
  gridAutoRows: true,
  gridTemplate: true,
  gridTemplateColumns: true,
  gridTemplateRows: true,
  gridTemplateAreas: true,
  gridArea: true
};

// src/config/interactivity.ts
exports.grid = grid;
var interactivity = {
  appearance: true,
  cursor: true,
  resize: true,
  userSelect: true,
  pointerEvents: true,
  outline: {
    transform: transformFunctions.outline
  },
  outlineOffset: true,
  outlineColor: t.colors("outlineColor")
};

// src/config/layout.ts
exports.interactivity = interactivity;
var layout = {
  width: t.sizesT("width"),
  inlineSize: t.sizesT("inlineSize"),
  height: t.sizes("height"),
  blockSize: t.sizes("blockSize"),
  boxSize: t.sizes(["width", "height"]),
  minWidth: t.sizes("minWidth"),
  minInlineSize: t.sizes("minInlineSize"),
  minHeight: t.sizes("minHeight"),
  minBlockSize: t.sizes("minBlockSize"),
  maxWidth: t.sizes("maxWidth"),
  maxInlineSize: t.sizes("maxInlineSize"),
  maxHeight: t.sizes("maxHeight"),
  maxBlockSize: t.sizes("maxBlockSize"),
  overflow: true,
  overflowX: true,
  overflowY: true,
  overscrollBehavior: true,
  overscrollBehaviorX: true,
  overscrollBehaviorY: true,
  display: true,
  verticalAlign: true,
  boxSizing: true,
  boxDecorationBreak: true,
  float: t.propT("float", transformFunctions.float),
  objectFit: true,
  objectPosition: true,
  visibility: true,
  isolation: true
};
exports.layout = layout;
Object.assign(layout, {
  w: layout.width,
  h: layout.height,
  minW: layout.minWidth,
  maxW: layout.maxWidth,
  minH: layout.minHeight,
  maxH: layout.maxHeight,
  overscroll: layout.overscrollBehavior,
  overscrollX: layout.overscrollBehaviorX,
  overscrollY: layout.overscrollBehaviorY
});

// src/config/list.ts
var list = {
  listStyleType: true,
  listStylePosition: true,
  listStylePos: t.prop("listStylePosition"),
  listStyleImage: true,
  listStyleImg: t.prop("listStyleImage")
};

// src/get.ts
exports.list = list;
function get(obj, path, fallback, index) {
  const key = typeof path === "string" ? path.split(".") : [path];
  for (index = 0; index < key.length; index += 1) {
    if (!obj) break;
    obj = obj[key[index]];
  }
  return obj === void 0 ? fallback : obj;
}
var memoize = fn => {
  const cache = /* @__PURE__ */new WeakMap();
  const memoizedFn = (obj, path, fallback, index) => {
    if (typeof obj === "undefined") {
      return fn(obj, path, fallback);
    }
    if (!cache.has(obj)) {
      cache.set(obj, /* @__PURE__ */new Map());
    }
    const map = cache.get(obj);
    if (map.has(path)) {
      return map.get(path);
    }
    const value = fn(obj, path, fallback, index);
    map.set(path, value);
    return value;
  };
  return memoizedFn;
};
var memoizedGet = memoize(get);

// src/config/others.ts
var srOnly = {
  border: "0px",
  clip: "rect(0, 0, 0, 0)",
  width: "1px",
  height: "1px",
  margin: "-1px",
  padding: "0px",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
var srFocusable = {
  position: "static",
  width: "auto",
  height: "auto",
  clip: "auto",
  padding: "0",
  margin: "0",
  overflow: "visible",
  whiteSpace: "normal"
};
var getWithPriority = (theme, key, styles) => {
  const result = {};
  const obj = memoizedGet(theme, key, {});
  for (const prop in obj) {
    const isInStyles = prop in styles && styles[prop] != null;
    if (!isInStyles) result[prop] = obj[prop];
  }
  return result;
};
var others = {
  srOnly: {
    transform(value) {
      if (value === true) return srOnly;
      if (value === "focusable") return srFocusable;
      return {};
    }
  },
  layerStyle: {
    processResult: true,
    transform: (value, theme, styles) => getWithPriority(theme, `layerStyles.${value}`, styles)
  },
  textStyle: {
    processResult: true,
    transform: (value, theme, styles) => getWithPriority(theme, `textStyles.${value}`, styles)
  },
  apply: {
    processResult: true,
    transform: (value, theme, styles) => getWithPriority(theme, value, styles)
  }
};

// src/config/position.ts
exports.others = others;
var position = {
  position: true,
  pos: t.prop("position"),
  zIndex: t.prop("zIndex", "zIndices"),
  inset: t.spaceT("inset"),
  insetX: t.spaceT(["left", "right"]),
  insetInline: t.spaceT("insetInline"),
  insetY: t.spaceT(["top", "bottom"]),
  insetBlock: t.spaceT("insetBlock"),
  top: t.spaceT("top"),
  insetBlockStart: t.spaceT("insetBlockStart"),
  bottom: t.spaceT("bottom"),
  insetBlockEnd: t.spaceT("insetBlockEnd"),
  left: t.spaceT("left"),
  insetInlineStart: t.logical({
    scale: "space",
    property: {
      ltr: "left",
      rtl: "right"
    }
  }),
  right: t.spaceT("right"),
  insetInlineEnd: t.logical({
    scale: "space",
    property: {
      ltr: "right",
      rtl: "left"
    }
  })
};
exports.position = position;
Object.assign(position, {
  insetStart: position.insetInlineStart,
  insetEnd: position.insetInlineEnd
});

// src/config/ring.ts
var ring = {
  ring: {
    transform: transformFunctions.ring
  },
  ringColor: t.colors("--chakra-ring-color"),
  ringOffset: t.prop("--chakra-ring-offset-width"),
  ringOffsetColor: t.colors("--chakra-ring-offset-color"),
  ringInset: t.prop("--chakra-ring-inset")
};

// src/config/space.ts
exports.ring = ring;
var space = {
  margin: t.spaceT("margin"),
  marginTop: t.spaceT("marginTop"),
  marginBlockStart: t.spaceT("marginBlockStart"),
  marginRight: t.spaceT("marginRight"),
  marginInlineEnd: t.spaceT("marginInlineEnd"),
  marginBottom: t.spaceT("marginBottom"),
  marginBlockEnd: t.spaceT("marginBlockEnd"),
  marginLeft: t.spaceT("marginLeft"),
  marginInlineStart: t.spaceT("marginInlineStart"),
  marginX: t.spaceT(["marginInlineStart", "marginInlineEnd"]),
  marginInline: t.spaceT("marginInline"),
  marginY: t.spaceT(["marginTop", "marginBottom"]),
  marginBlock: t.spaceT("marginBlock"),
  padding: t.space("padding"),
  paddingTop: t.space("paddingTop"),
  paddingBlockStart: t.space("paddingBlockStart"),
  paddingRight: t.space("paddingRight"),
  paddingBottom: t.space("paddingBottom"),
  paddingBlockEnd: t.space("paddingBlockEnd"),
  paddingLeft: t.space("paddingLeft"),
  paddingInlineStart: t.space("paddingInlineStart"),
  paddingInlineEnd: t.space("paddingInlineEnd"),
  paddingX: t.space(["paddingInlineStart", "paddingInlineEnd"]),
  paddingInline: t.space("paddingInline"),
  paddingY: t.space(["paddingTop", "paddingBottom"]),
  paddingBlock: t.space("paddingBlock")
};
exports.space = space;
Object.assign(space, {
  m: space.margin,
  mt: space.marginTop,
  mr: space.marginRight,
  me: space.marginInlineEnd,
  marginEnd: space.marginInlineEnd,
  mb: space.marginBottom,
  ml: space.marginLeft,
  ms: space.marginInlineStart,
  marginStart: space.marginInlineStart,
  mx: space.marginX,
  my: space.marginY,
  p: space.padding,
  pt: space.paddingTop,
  py: space.paddingY,
  px: space.paddingX,
  pb: space.paddingBottom,
  pl: space.paddingLeft,
  ps: space.paddingInlineStart,
  paddingStart: space.paddingInlineStart,
  pr: space.paddingRight,
  pe: space.paddingInlineEnd,
  paddingEnd: space.paddingInlineEnd
});

// src/config/text-decoration.ts
var textDecoration = {
  textDecorationColor: t.colors("textDecorationColor"),
  textDecoration: true,
  textDecor: {
    property: "textDecoration"
  },
  textDecorationLine: true,
  textDecorationStyle: true,
  textDecorationThickness: true,
  textUnderlineOffset: true,
  textShadow: t.shadows("textShadow")
};

// src/config/transform.ts
exports.textDecoration = textDecoration;
var transform = {
  clipPath: true,
  transform: t.propT("transform", transformFunctions.transform),
  transformOrigin: true,
  translateX: t.spaceT("--chakra-translate-x"),
  translateY: t.spaceT("--chakra-translate-y"),
  skewX: t.degreeT("--chakra-skew-x"),
  skewY: t.degreeT("--chakra-skew-y"),
  scaleX: t.prop("--chakra-scale-x"),
  scaleY: t.prop("--chakra-scale-y"),
  scale: t.prop(["--chakra-scale-x", "--chakra-scale-y"]),
  rotate: t.degreeT("--chakra-rotate")
};

// src/config/transition.ts
exports.transform = transform;
var transition = {
  transition: true,
  transitionDelay: true,
  animation: true,
  willChange: true,
  transitionDuration: t.prop("transitionDuration", "transition.duration"),
  transitionProperty: t.prop("transitionProperty", "transition.property"),
  transitionTimingFunction: t.prop("transitionTimingFunction", "transition.easing")
};

// src/config/typography.ts
exports.transition = transition;
var typography = {
  fontFamily: t.prop("fontFamily", "fonts"),
  fontSize: t.prop("fontSize", "fontSizes", transformFunctions.px),
  fontWeight: t.prop("fontWeight", "fontWeights"),
  lineHeight: t.prop("lineHeight", "lineHeights"),
  letterSpacing: t.prop("letterSpacing", "letterSpacings"),
  textAlign: true,
  fontStyle: true,
  textIndent: true,
  wordBreak: true,
  overflowWrap: true,
  textOverflow: true,
  textTransform: true,
  whiteSpace: true,
  isTruncated: {
    transform(value) {
      if (value === true) {
        return {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
      }
    }
  },
  noOfLines: {
    static: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      WebkitLineClamp: "var(--chakra-line-clamp)"
    },
    property: "--chakra-line-clamp"
  }
};

// src/config/scroll.ts
exports.typography = typography;
var scroll = {
  scrollBehavior: true,
  scrollSnapAlign: true,
  scrollSnapStop: true,
  scrollSnapType: true,
  scrollMargin: t.spaceT("scrollMargin"),
  scrollMarginTop: t.spaceT("scrollMarginTop"),
  scrollMarginBottom: t.spaceT("scrollMarginBottom"),
  scrollMarginLeft: t.spaceT("scrollMarginLeft"),
  scrollMarginRight: t.spaceT("scrollMarginRight"),
  scrollMarginX: t.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
  scrollMarginY: t.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
  scrollPadding: t.spaceT("scrollPadding"),
  scrollPaddingTop: t.spaceT("scrollPaddingTop"),
  scrollPaddingBottom: t.spaceT("scrollPaddingBottom"),
  scrollPaddingLeft: t.spaceT("scrollPaddingLeft"),
  scrollPaddingRight: t.spaceT("scrollPaddingRight"),
  scrollPaddingX: t.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
  scrollPaddingY: t.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
};

// src/create-theme-vars/calc.ts
exports.scroll = scroll;
function resolveReference(operand) {
  if ((0, _sharedUtils.isObject)(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
var add = (...operands) => `calc(${toExpression("+", ...operands)})`;
var subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
var multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
var divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
var negate = x => {
  const value = resolveReference(x);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
var calc = Object.assign(x => ({
  add: (...operands) => calc(add(x, ...operands)),
  subtract: (...operands) => calc(subtract(x, ...operands)),
  multiply: (...operands) => calc(multiply(x, ...operands)),
  divide: (...operands) => calc(divide(x, ...operands)),
  negate: () => calc(negate(x)),
  toString: () => x.toString()
}), {
  add,
  subtract,
  multiply,
  divide,
  negate
});

// src/create-theme-vars/css-var.ts
exports.calc = calc;
function replaceWhiteSpace(value, replaceValue = "-") {
  return value.replace(/\s+/g, replaceValue);
}
function escape(value) {
  const valueStr = replaceWhiteSpace(value.toString());
  return escapeSymbol(escapeDot(valueStr));
}
function escapeDot(value) {
  if (value.includes("\\.")) return value;
  const isDecimal = !Number.isInteger(parseFloat(value.toString()));
  return isDecimal ? value.replace(".", `\\.`) : value;
}
function escapeSymbol(value) {
  return value.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
}
function addPrefix(value, prefix = "") {
  return [prefix, value].filter(Boolean).join("-");
}
function toVarReference(name, fallback) {
  return `var(${name}${fallback ? `, ${fallback}` : ""})`;
}
function toVarDefinition(value, prefix = "") {
  return escape(`--${addPrefix(value, prefix)}`);
}
function cssVar(name, fallback, cssVarPrefix) {
  const cssVariable = toVarDefinition(name, cssVarPrefix);
  return {
    variable: cssVariable,
    reference: toVarReference(cssVariable, fallback)
  };
}

// ../../utilities/breakpoint-utils/src/breakpoint.ts

function getLastItem(array) {
  const length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
function analyzeCSSValue2(value) {
  const num = parseFloat(value.toString());
  const unit = value.toString().replace(String(num), "");
  return {
    unitless: !unit,
    value: num,
    unit
  };
}
function px(value) {
  if (value == null) return value;
  const {
    unitless
  } = analyzeCSSValue2(value);
  return unitless || typeof value === "number" ? `${value}px` : value;
}
var sortByBreakpointValue = (a, b) => parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;
var sortBps = breakpoints => Object.fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue));
function normalize(breakpoints) {
  const sorted = sortBps(breakpoints);
  return Object.assign(Object.values(sorted), sorted);
}
function keys(breakpoints) {
  const value = Object.keys(sortBps(breakpoints));
  return new Set(value);
}
var OFFSET = 0.02;
function subtract2(value) {
  var _a;
  if (!value) return value;
  value = (_a = px(value)) != null ? _a : value;
  const factor = value.endsWith("px") ? -OFFSET : -(OFFSET / 16);
  return typeof value === "number" ? `${value + factor}` : value.replace(/(\d+\.?\d*)/u, m => `${parseFloat(m) + factor}`);
}
function toMediaQueryString(min, max) {
  const query = ["@media screen"];
  if (min) query.push("and", `(min-width: ${px(min)})`);
  if (max) query.push("and", `(max-width: ${px(max)})`);
  return query.join(" ");
}
function analyzeBreakpoints(breakpoints) {
  var _a;
  if (!breakpoints) return null;
  breakpoints.base = (_a = breakpoints.base) != null ? _a : "0px";
  const normalized = normalize(breakpoints);
  const queries = Object.entries(breakpoints).sort(sortByBreakpointValue).map(([breakpoint, minW], index, entry) => {
    var _a2;
    let [, maxW] = (_a2 = entry[index + 1]) != null ? _a2 : [];
    maxW = parseFloat(maxW) > 0 ? subtract2(maxW) : void 0;
    return {
      _minW: subtract2(minW),
      breakpoint,
      minW,
      maxW,
      maxWQuery: toMediaQueryString(null, maxW),
      minWQuery: toMediaQueryString(minW),
      minMaxQuery: toMediaQueryString(minW, maxW)
    };
  });
  const _keys = keys(breakpoints);
  const _keysArr = Array.from(_keys.values());
  return {
    keys: _keys,
    normalized,
    isResponsive(test) {
      const keys2 = Object.keys(test);
      return keys2.length > 0 && keys2.every(key => _keys.has(key));
    },
    asObject: sortBps(breakpoints),
    asArray: normalize(breakpoints),
    details: queries,
    media: [null, ...normalized.map(minW => toMediaQueryString(minW)).slice(1)],
    toArrayValue(test) {
      if (!(0, _sharedUtils.isObject)(test)) {
        throw new Error("toArrayValue: value must be an object");
      }
      const result = _keysArr.map(bp => {
        var _a2;
        return (_a2 = test[bp]) != null ? _a2 : null;
      });
      while (getLastItem(result) === null) {
        result.pop();
      }
      return result;
    },
    toObjectValue(test) {
      if (!Array.isArray(test)) {
        throw new Error("toObjectValue: value must be an array");
      }
      return test.reduce((acc, value, index) => {
        const key = _keysArr[index];
        if (key != null && value != null) acc[key] = value;
        return acc;
      }, {});
    }
  };
}

// src/create-theme-vars/create-theme-vars.ts

// src/pseudos.ts
var state = {
  hover: (str, post) => `${str}:hover ${post}, ${str}[data-hover] ${post}`,
  focus: (str, post) => `${str}:focus ${post}, ${str}[data-focus] ${post}`,
  focusVisible: (str, post) => `${str}:focus-visible ${post}`,
  focusWithin: (str, post) => `${str}:focus-within ${post}`,
  active: (str, post) => `${str}:active ${post}, ${str}[data-active] ${post}`,
  disabled: (str, post) => `${str}:disabled ${post}, ${str}[data-disabled] ${post}`,
  invalid: (str, post) => `${str}:invalid ${post}, ${str}[data-invalid] ${post}`,
  checked: (str, post) => `${str}:checked ${post}, ${str}[data-checked] ${post}`,
  indeterminate: (str, post) => `${str}:indeterminate ${post}, ${str}[aria-checked=mixed] ${post}, ${str}[data-indeterminate] ${post}`,
  readOnly: (str, post) => `${str}:read-only ${post}, ${str}[readonly] ${post}, ${str}[data-read-only] ${post}`,
  expanded: (str, post) => `${str}:read-only ${post}, ${str}[aria-expanded=true] ${post}, ${str}[data-expanded] ${post}`,
  placeholderShown: (str, post) => `${str}:placeholder-shown ${post}`
};
var toGroup = fn => merge(v => fn(v, "&"), "[role=group]", "[data-group]", ".group");
var toPeer = fn => merge(v => fn(v, "~ &"), "[data-peer]", ".peer");
var merge = (fn, ...selectors) => selectors.map(fn).join(", ");
var pseudoSelectors = {
  _hover: "&:hover, &[data-hover]",
  _active: "&:active, &[data-active]",
  _focus: "&:focus, &[data-focus]",
  _highlighted: "&[data-highlighted]",
  _focusWithin: "&:focus-within",
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
  _before: "&::before",
  _after: "&::after",
  _empty: "&:empty",
  _expanded: "&[aria-expanded=true], &[data-expanded]",
  _checked: "&[aria-checked=true], &[data-checked]",
  _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
  _pressed: "&[aria-pressed=true], &[data-pressed]",
  _invalid: "&[aria-invalid=true], &[data-invalid]",
  _valid: "&[data-valid], &[data-state=valid]",
  _loading: "&[data-loading], &[aria-busy=true]",
  _selected: "&[aria-selected=true], &[data-selected]",
  _hidden: "&[hidden], &[data-hidden]",
  _autofill: "&:-webkit-autofill",
  _even: "&:nth-of-type(even)",
  _odd: "&:nth-of-type(odd)",
  _first: "&:first-of-type",
  _last: "&:last-of-type",
  _notFirst: "&:not(:first-of-type)",
  _notLast: "&:not(:last-of-type)",
  _visited: "&:visited",
  _activeLink: "&[aria-current=page]",
  _activeStep: "&[aria-current=step]",
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
  _groupHover: toGroup(state.hover),
  _peerHover: toPeer(state.hover),
  _groupFocus: toGroup(state.focus),
  _peerFocus: toPeer(state.focus),
  _groupFocusVisible: toGroup(state.focusVisible),
  _peerFocusVisible: toPeer(state.focusVisible),
  _groupActive: toGroup(state.active),
  _peerActive: toPeer(state.active),
  _groupDisabled: toGroup(state.disabled),
  _peerDisabled: toPeer(state.disabled),
  _groupInvalid: toGroup(state.invalid),
  _peerInvalid: toPeer(state.invalid),
  _groupChecked: toGroup(state.checked),
  _peerChecked: toPeer(state.checked),
  _groupFocusWithin: toGroup(state.focusWithin),
  _peerFocusWithin: toPeer(state.focusWithin),
  _peerPlaceholderShown: toPeer(state.placeholderShown),
  _placeholder: "&::placeholder",
  _placeholderShown: "&:placeholder-shown",
  _fullScreen: "&:fullscreen",
  _selection: "&::selection",
  _rtl: "[dir=rtl] &, &[dir=rtl]",
  _ltr: "[dir=ltr] &, &[dir=ltr]",
  _mediaDark: "@media (prefers-color-scheme: dark)",
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
  _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]"
};
exports.pseudoSelectors = pseudoSelectors;
var pseudoPropNames = Object.keys(pseudoSelectors);

// src/create-theme-vars/create-theme-vars.ts
exports.pseudoPropNames = pseudoPropNames;
function tokenToCssVar(token, prefix) {
  return cssVar(String(token).replace(/\./g, "-"), void 0, prefix);
}
function createThemeVars(flatTokens, options) {
  let cssVars = {};
  const cssMap = {};
  for (const [token, tokenValue] of Object.entries(flatTokens)) {
    const {
      isSemantic,
      value
    } = tokenValue;
    const {
      variable,
      reference
    } = tokenToCssVar(token, options == null ? void 0 : options.cssVarPrefix);
    if (!isSemantic) {
      if (token.startsWith("space")) {
        const keys2 = token.split(".");
        const [firstKey, ...referenceKeys] = keys2;
        const negativeLookupKey = `${firstKey}.-${referenceKeys.join(".")}`;
        const negativeValue = calc.negate(value);
        const negatedReference = calc.negate(reference);
        cssMap[negativeLookupKey] = {
          value: negativeValue,
          var: variable,
          varRef: negatedReference
        };
      }
      cssVars[variable] = value;
      cssMap[token] = {
        value,
        var: variable,
        varRef: reference
      };
      continue;
    }
    const lookupToken = maybeToken => {
      const scale = String(token).split(".")[0];
      const withScale = [scale, maybeToken].join(".");
      const resolvedTokenValue = flatTokens[withScale];
      if (!resolvedTokenValue) return maybeToken;
      const {
        reference: reference2
      } = tokenToCssVar(withScale, options == null ? void 0 : options.cssVarPrefix);
      return reference2;
    };
    const normalizedValue = (0, _sharedUtils.isObject)(value) ? value : {
      default: value
    };
    cssVars = (0, _lodash.default)(cssVars, Object.entries(normalizedValue).reduce((acc, [conditionAlias, conditionValue]) => {
      var _a, _b;
      const maybeReference = lookupToken(conditionValue);
      if (conditionAlias === "default") {
        acc[variable] = maybeReference;
        return acc;
      }
      const conditionSelector = (_b = (_a = pseudoSelectors) == null ? void 0 : _a[conditionAlias]) != null ? _b : conditionAlias;
      acc[conditionSelector] = {
        [variable]: maybeReference
      };
      return acc;
    }, {}));
    cssMap[token] = {
      value: reference,
      var: variable,
      varRef: reference
    };
  }
  return {
    cssVars,
    cssMap
  };
}

// ../../utilities/object-utils/src/index.ts
function omit(object, keysToOmit = []) {
  const clone = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone) delete clone[key];
  }
  return clone;
}
function pick(object, keysToPick) {
  const result = {};
  for (const key of keysToPick) {
    if (key in object) {
      result[key] = object[key];
    }
  }
  return result;
}

// src/create-theme-vars/theme-tokens.ts
var tokens = ["colors", "borders", "borderWidths", "borderStyles", "fonts", "fontSizes", "fontWeights", "letterSpacings", "lineHeights", "radii", "space", "shadows", "sizes", "zIndices", "transition", "blur"];
function extractTokens(theme) {
  const _tokens = tokens;
  return pick(theme, _tokens);
}
function extractSemanticTokens(theme) {
  return theme.semanticTokens;
}
function omitVars(rawTheme) {
  const {
    __cssMap,
    __cssVars,
    __breakpoints,
    ...cleanTheme
  } = rawTheme;
  return cleanTheme;
}

// src/create-theme-vars/flatten-tokens.ts

function flattenTokens({
  tokens: tokens2,
  semanticTokens
}) {
  var _a, _b;
  const tokenEntries = Object.entries((_a = flatten(tokens2)) != null ? _a : {}).map(([token, value]) => {
    const enhancedToken = {
      isSemantic: false,
      value
    };
    return [token, enhancedToken];
  });
  const semanticTokenEntries = Object.entries((_b = flatten(semanticTokens, 1)) != null ? _b : {}).map(([token, value]) => {
    const enhancedToken = {
      isSemantic: true,
      value
    };
    return [token, enhancedToken];
  });
  return Object.fromEntries([...tokenEntries, ...semanticTokenEntries]);
}
function flatten(target, maxDepth = Infinity) {
  if (!(0, _sharedUtils.isObject)(target) && !Array.isArray(target) || !maxDepth) {
    return target;
  }
  return Object.entries(target).reduce((result, [key, value]) => {
    if ((0, _sharedUtils.isObject)(value) || Array.isArray(value)) {
      Object.entries(flatten(value, maxDepth - 1)).forEach(([childKey, childValue]) => {
        result[`${key}.${childKey}`] = childValue;
      });
    } else {
      result[key] = value;
    }
    return result;
  }, {});
}

// src/create-theme-vars/to-css-var.ts
function toCSSVar(rawTheme) {
  var _a;
  const theme = omitVars(rawTheme);
  const tokens2 = extractTokens(theme);
  const semanticTokens = extractSemanticTokens(theme);
  const flatTokens = flattenTokens({
    tokens: tokens2,
    semanticTokens
  });
  const cssVarPrefix = (_a = theme.config) == null ? void 0 : _a.cssVarPrefix;
  const {
    cssMap,
    cssVars
  } = createThemeVars(flatTokens, {
    cssVarPrefix
  });
  const defaultCssVars = {
    "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-ring-offset-width": "0px",
    "--chakra-ring-offset-color": "#fff",
    "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
    "--chakra-ring-offset-shadow": "0 0 #0000",
    "--chakra-ring-shadow": "0 0 #0000",
    "--chakra-space-x-reverse": "0",
    "--chakra-space-y-reverse": "0"
  };
  Object.assign(theme, {
    __cssVars: {
      ...defaultCssVars,
      ...cssVars
    },
    __cssMap: cssMap,
    __breakpoints: analyzeBreakpoints(theme.breakpoints)
  });
  return theme;
}

// src/css.ts

var systemProps = (0, _lodash.default)({}, background, border, color, flexbox, layout, filter, ring, interactivity, grid, others, position, effect, space, scroll, typography, textDecoration, transform, list, transition);
exports.systemProps = systemProps;
var layoutSystem = Object.assign({}, space, layout, flexbox, grid, position);
var layoutPropNames = Object.keys(layoutSystem);
exports.layoutPropNames = layoutPropNames;
var propNames = [...Object.keys(systemProps), ...pseudoPropNames];
exports.propNames = propNames;
var styleProps = {
  ...systemProps,
  ...pseudoSelectors
};
var isStyleProp = prop => prop in styleProps;

// src/utils/expand-responsive.ts
exports.isStyleProp = isStyleProp;
var expandResponsive = styles => theme => {
  if (!theme.__breakpoints) return styles;
  const {
    isResponsive,
    toArrayValue,
    media: medias
  } = theme.__breakpoints;
  const computedStyles = {};
  for (const key in styles) {
    let value = (0, _sharedUtils.runIfFn)(styles[key], theme);
    if (value == null) continue;
    value = (0, _sharedUtils.isObject)(value) && isResponsive(value) ? toArrayValue(value) : value;
    if (!Array.isArray(value)) {
      computedStyles[key] = value;
      continue;
    }
    const queries = value.slice(0, medias.length).length;
    for (let index = 0; index < queries; index += 1) {
      const media = medias == null ? void 0 : medias[index];
      if (!media) {
        computedStyles[key] = value[index];
        continue;
      }
      computedStyles[media] = computedStyles[media] || {};
      if (value[index] == null) {
        continue;
      }
      computedStyles[media][key] = value[index];
    }
  }
  return computedStyles;
};

// src/utils/split-by-comma.ts
function splitByComma(value) {
  const chunks = [];
  let chunk = "";
  let inParens = false;
  for (let i = 0; i < value.length; i++) {
    const char = value[i];
    if (char === "(") {
      inParens = true;
      chunk += char;
    } else if (char === ")") {
      inParens = false;
      chunk += char;
    } else if (char === "," && !inParens) {
      chunks.push(chunk);
      chunk = "";
    } else {
      chunk += char;
    }
  }
  chunk = chunk.trim();
  if (chunk) {
    chunks.push(chunk);
  }
  return chunks;
}

// src/css.ts
function isCssVar2(value) {
  return /^var\(--.+\)$/.test(value);
}
var isCSSVariableTokenValue = (key, value) => key.startsWith("--") && typeof value === "string" && !isCssVar2(value);
var resolveTokenValue = (theme, value) => {
  var _a, _b;
  if (value == null) return value;
  const getVar = val => {
    var _a2, _b2;
    return (_b2 = (_a2 = theme.__cssMap) == null ? void 0 : _a2[val]) == null ? void 0 : _b2.varRef;
  };
  const getValue = val => {
    var _a2;
    return (_a2 = getVar(val)) != null ? _a2 : val;
  };
  const [tokenValue, fallbackValue] = splitByComma(value);
  value = (_b = (_a = getVar(tokenValue)) != null ? _a : getValue(fallbackValue)) != null ? _b : getValue(value);
  return value;
};
function getCss(options) {
  const {
    configs = {},
    pseudos = {},
    theme
  } = options;
  const css2 = (stylesOrFn, nested = false) => {
    var _a, _b, _c;
    const _styles = (0, _sharedUtils.runIfFn)(stylesOrFn, theme);
    const styles = expandResponsive(_styles)(theme);
    let computedStyles = {};
    for (let key in styles) {
      const valueOrFn = styles[key];
      let value = (0, _sharedUtils.runIfFn)(valueOrFn, theme);
      if (key in pseudos) {
        key = pseudos[key];
      }
      if (isCSSVariableTokenValue(key, value)) {
        value = resolveTokenValue(theme, value);
      }
      let config = configs[key];
      if (config === true) {
        config = {
          property: key
        };
      }
      if ((0, _sharedUtils.isObject)(value)) {
        computedStyles[key] = (_a = computedStyles[key]) != null ? _a : {};
        computedStyles[key] = (0, _lodash.default)({}, computedStyles[key], css2(value, true));
        continue;
      }
      let rawValue = (_c = (_b = config == null ? void 0 : config.transform) == null ? void 0 : _b.call(config, value, theme, _styles)) != null ? _c : value;
      rawValue = (config == null ? void 0 : config.processResult) ? css2(rawValue, true) : rawValue;
      const configProperty = (0, _sharedUtils.runIfFn)(config == null ? void 0 : config.property, theme);
      if (!nested && (config == null ? void 0 : config.static)) {
        const staticStyles = (0, _sharedUtils.runIfFn)(config.static, theme);
        computedStyles = (0, _lodash.default)({}, computedStyles, staticStyles);
      }
      if (configProperty && Array.isArray(configProperty)) {
        for (const property of configProperty) {
          computedStyles[property] = rawValue;
        }
        continue;
      }
      if (configProperty) {
        if (configProperty === "&" && (0, _sharedUtils.isObject)(rawValue)) {
          computedStyles = (0, _lodash.default)({}, computedStyles, rawValue);
        } else {
          computedStyles[configProperty] = rawValue;
        }
        continue;
      }
      if ((0, _sharedUtils.isObject)(rawValue)) {
        computedStyles = (0, _lodash.default)({}, computedStyles, rawValue);
        continue;
      }
      computedStyles[key] = rawValue;
    }
    return computedStyles;
  };
  return css2;
}
var css = styles => theme => {
  const cssFn = getCss({
    theme,
    pseudos: pseudoSelectors,
    configs: systemProps
  });
  return cssFn(styles);
};

// src/define-styles.ts
exports.css = css;
function defineStyle(styles) {
  return styles;
}
function defineStyleConfig(config) {
  return config;
}
function createMultiStyleConfigHelpers(parts) {
  return {
    definePartsStyle(config) {
      return config;
    },
    defineMultiStyleConfig(config) {
      return {
        parts,
        ...config
      };
    }
  };
}

// src/style-config.ts

function normalize2(value, toArray) {
  if (Array.isArray(value)) return value;
  if ((0, _sharedUtils.isObject)(value)) return toArray(value);
  if (value != null) return [value];
}
function getNextIndex(values, i) {
  for (let j = i + 1; j < values.length; j++) {
    if (values[j] != null) return j;
  }
  return -1;
}
function createResolver(theme) {
  const breakpointUtil = theme.__breakpoints;
  return function resolver(config, prop, value, props) {
    var _a, _b;
    if (!breakpointUtil) return;
    const result = {};
    const normalized = normalize2(value, breakpointUtil.toArrayValue);
    if (!normalized) return result;
    const len = normalized.length;
    const isSingle = len === 1;
    const isMultipart = !!config.parts;
    for (let i = 0; i < len; i++) {
      const key = breakpointUtil.details[i];
      const nextKey = breakpointUtil.details[getNextIndex(normalized, i)];
      const query = toMediaQueryString(key.minW, nextKey == null ? void 0 : nextKey._minW);
      const styles = (0, _sharedUtils.runIfFn)((_a = config[prop]) == null ? void 0 : _a[normalized[i]], props);
      if (!styles) continue;
      if (isMultipart) {
        (_b = config.parts) == null ? void 0 : _b.forEach(part => {
          (0, _lodash.default)(result, {
            [part]: isSingle ? styles[part] : {
              [query]: styles[part]
            }
          });
        });
        continue;
      }
      if (!isMultipart) {
        if (isSingle) (0, _lodash.default)(result, styles);else result[query] = styles;
        continue;
      }
      result[query] = styles;
    }
    return result;
  };
}
function resolveStyleConfig(config) {
  return props => {
    var _a;
    const {
      variant,
      size,
      theme
    } = props;
    const recipe = createResolver(theme);
    return (0, _lodash.default)({}, (0, _sharedUtils.runIfFn)((_a = config.baseStyle) != null ? _a : {}, props), recipe(config, "sizes", size, props), recipe(config, "variants", variant, props));
  };
}

// src/get-css-var.ts
function getCSSVar(theme, scale, value) {
  var _a, _b, _c;
  return (_c = (_b = (_a = theme.__cssMap) == null ? void 0 : _a[`${scale}.${value}`]) == null ? void 0 : _b.varRef) != null ? _c : value;
}

// src/theming-props.ts
function omitThemingProps(props) {
  return omit(props, ["styleConfig", "size", "variant", "colorScheme"]);
}
},{"@chakra-ui/shared-utils":"gghr","lodash.mergewith":"fWTD"}],"wG6q":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isChakraTheme = isChakraTheme;
exports.requiredChakraThemeKeys = void 0;
var _sharedUtils = require("@chakra-ui/shared-utils");
// src/utils/is-chakra-theme.ts

var requiredChakraThemeKeys = ["borders", "breakpoints", "colors", "components", "config", "direction", "fonts", "fontSizes", "fontWeights", "letterSpacings", "lineHeights", "radii", "shadows", "sizes", "space", "styles", "transition", "zIndices"];
exports.requiredChakraThemeKeys = requiredChakraThemeKeys;
function isChakraTheme(unit) {
  if (!(0, _sharedUtils.isObject)(unit)) {
    return false;
  }
  return requiredChakraThemeKeys.every(propertyName => Object.prototype.hasOwnProperty.call(unit, propertyName));
}
},{"@chakra-ui/shared-utils":"gghr"}],"wnRJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.z_index_default = void 0;
// src/foundations/z-index.ts
var zIndices = {
  hide: -1,
  auto: "auto",
  base: 0,
  docked: 10,
  dropdown: 1e3,
  sticky: 1100,
  banner: 1200,
  overlay: 1300,
  modal: 1400,
  popover: 1500,
  skipLink: 1600,
  toast: 1700,
  tooltip: 1800
};
var z_index_default = zIndices;
exports.z_index_default = z_index_default;
},{}],"sRYL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.breakpoints_default = void 0;
// src/foundations/breakpoints.ts
var breakpoints = {
  base: "0em",
  sm: "30em",
  md: "48em",
  lg: "62em",
  xl: "80em",
  "2xl": "96em"
};
var breakpoints_default = breakpoints;
exports.breakpoints_default = breakpoints_default;
},{}],"SHk9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.colors_default = void 0;
// src/foundations/colors.ts
var colors = {
  transparent: "transparent",
  current: "currentColor",
  black: "#000000",
  white: "#FFFFFF",
  whiteAlpha: {
    50: "rgba(255, 255, 255, 0.04)",
    100: "rgba(255, 255, 255, 0.06)",
    200: "rgba(255, 255, 255, 0.08)",
    300: "rgba(255, 255, 255, 0.16)",
    400: "rgba(255, 255, 255, 0.24)",
    500: "rgba(255, 255, 255, 0.36)",
    600: "rgba(255, 255, 255, 0.48)",
    700: "rgba(255, 255, 255, 0.64)",
    800: "rgba(255, 255, 255, 0.80)",
    900: "rgba(255, 255, 255, 0.92)"
  },
  blackAlpha: {
    50: "rgba(0, 0, 0, 0.04)",
    100: "rgba(0, 0, 0, 0.06)",
    200: "rgba(0, 0, 0, 0.08)",
    300: "rgba(0, 0, 0, 0.16)",
    400: "rgba(0, 0, 0, 0.24)",
    500: "rgba(0, 0, 0, 0.36)",
    600: "rgba(0, 0, 0, 0.48)",
    700: "rgba(0, 0, 0, 0.64)",
    800: "rgba(0, 0, 0, 0.80)",
    900: "rgba(0, 0, 0, 0.92)"
  },
  gray: {
    50: "#F7FAFC",
    100: "#EDF2F7",
    200: "#E2E8F0",
    300: "#CBD5E0",
    400: "#A0AEC0",
    500: "#718096",
    600: "#4A5568",
    700: "#2D3748",
    800: "#1A202C",
    900: "#171923"
  },
  red: {
    50: "#FFF5F5",
    100: "#FED7D7",
    200: "#FEB2B2",
    300: "#FC8181",
    400: "#F56565",
    500: "#E53E3E",
    600: "#C53030",
    700: "#9B2C2C",
    800: "#822727",
    900: "#63171B"
  },
  orange: {
    50: "#FFFAF0",
    100: "#FEEBC8",
    200: "#FBD38D",
    300: "#F6AD55",
    400: "#ED8936",
    500: "#DD6B20",
    600: "#C05621",
    700: "#9C4221",
    800: "#7B341E",
    900: "#652B19"
  },
  yellow: {
    50: "#FFFFF0",
    100: "#FEFCBF",
    200: "#FAF089",
    300: "#F6E05E",
    400: "#ECC94B",
    500: "#D69E2E",
    600: "#B7791F",
    700: "#975A16",
    800: "#744210",
    900: "#5F370E"
  },
  green: {
    50: "#F0FFF4",
    100: "#C6F6D5",
    200: "#9AE6B4",
    300: "#68D391",
    400: "#48BB78",
    500: "#38A169",
    600: "#2F855A",
    700: "#276749",
    800: "#22543D",
    900: "#1C4532"
  },
  teal: {
    50: "#E6FFFA",
    100: "#B2F5EA",
    200: "#81E6D9",
    300: "#4FD1C5",
    400: "#38B2AC",
    500: "#319795",
    600: "#2C7A7B",
    700: "#285E61",
    800: "#234E52",
    900: "#1D4044"
  },
  blue: {
    50: "#ebf8ff",
    100: "#bee3f8",
    200: "#90cdf4",
    300: "#63b3ed",
    400: "#4299e1",
    500: "#3182ce",
    600: "#2b6cb0",
    700: "#2c5282",
    800: "#2a4365",
    900: "#1A365D"
  },
  cyan: {
    50: "#EDFDFD",
    100: "#C4F1F9",
    200: "#9DECF9",
    300: "#76E4F7",
    400: "#0BC5EA",
    500: "#00B5D8",
    600: "#00A3C4",
    700: "#0987A0",
    800: "#086F83",
    900: "#065666"
  },
  purple: {
    50: "#FAF5FF",
    100: "#E9D8FD",
    200: "#D6BCFA",
    300: "#B794F4",
    400: "#9F7AEA",
    500: "#805AD5",
    600: "#6B46C1",
    700: "#553C9A",
    800: "#44337A",
    900: "#322659"
  },
  pink: {
    50: "#FFF5F7",
    100: "#FED7E2",
    200: "#FBB6CE",
    300: "#F687B3",
    400: "#ED64A6",
    500: "#D53F8C",
    600: "#B83280",
    700: "#97266D",
    800: "#702459",
    900: "#521B41"
  },
  linkedin: {
    50: "#E8F4F9",
    100: "#CFEDFB",
    200: "#9BDAF3",
    300: "#68C7EC",
    400: "#34B3E4",
    500: "#00A0DC",
    600: "#008CC9",
    700: "#0077B5",
    800: "#005E93",
    900: "#004471"
  },
  facebook: {
    50: "#E8F4F9",
    100: "#D9DEE9",
    200: "#B7C2DA",
    300: "#6482C0",
    400: "#4267B2",
    500: "#385898",
    600: "#314E89",
    700: "#29487D",
    800: "#223B67",
    900: "#1E355B"
  },
  messenger: {
    50: "#D0E6FF",
    100: "#B9DAFF",
    200: "#A2CDFF",
    300: "#7AB8FF",
    400: "#2E90FF",
    500: "#0078FF",
    600: "#0063D1",
    700: "#0052AC",
    800: "#003C7E",
    900: "#002C5C"
  },
  whatsapp: {
    50: "#dffeec",
    100: "#b9f5d0",
    200: "#90edb3",
    300: "#65e495",
    400: "#3cdd78",
    500: "#22c35e",
    600: "#179848",
    700: "#0c6c33",
    800: "#01421c",
    900: "#001803"
  },
  twitter: {
    50: "#E5F4FD",
    100: "#C8E9FB",
    200: "#A8DCFA",
    300: "#83CDF7",
    400: "#57BBF5",
    500: "#1DA1F2",
    600: "#1A94DA",
    700: "#1681BF",
    800: "#136B9E",
    900: "#0D4D71"
  },
  telegram: {
    50: "#E3F2F9",
    100: "#C5E4F3",
    200: "#A2D4EC",
    300: "#7AC1E4",
    400: "#47A9DA",
    500: "#0088CC",
    600: "#007AB8",
    700: "#006BA1",
    800: "#005885",
    900: "#003F5E"
  }
};
var colors_default = colors;
exports.colors_default = colors_default;
},{}],"Jqut":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.radius_default = void 0;
// src/foundations/radius.ts
var radii = {
  none: "0",
  sm: "0.125rem",
  base: "0.25rem",
  md: "0.375rem",
  lg: "0.5rem",
  xl: "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  full: "9999px"
};
var radius_default = radii;
exports.radius_default = radius_default;
},{}],"Fejh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shadows_default = void 0;
// src/foundations/shadows.ts
var shadows = {
  xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
  sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
  base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
  md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
  lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
  xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
  "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
  outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
  inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
  none: "none",
  "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
};
var shadows_default = shadows;
exports.shadows_default = shadows_default;
},{}],"bX2e":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transition_default = void 0;
// src/foundations/transition.ts
var transitionProperty = {
  common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
  colors: "background-color, border-color, color, fill, stroke",
  dimensions: "width, height",
  position: "left, right, top, bottom",
  background: "background-color, background-image, background-position"
};
var transitionTimingFunction = {
  "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
  "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
};
var transitionDuration = {
  "ultra-fast": "50ms",
  faster: "100ms",
  fast: "150ms",
  normal: "200ms",
  slow: "300ms",
  slower: "400ms",
  "ultra-slow": "500ms"
};
var transition = {
  property: transitionProperty,
  easing: transitionTimingFunction,
  duration: transitionDuration
};
var transition_default = transition;
exports.transition_default = transition_default;
},{}],"v9FE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.blur_default = void 0;
// src/foundations/blur.ts
var blur = {
  none: 0,
  sm: "4px",
  base: "8px",
  md: "12px",
  lg: "16px",
  xl: "24px",
  "2xl": "40px",
  "3xl": "64px"
};
var blur_default = blur;
exports.blur_default = blur_default;
},{}],"vHn7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.borders_default = void 0;
// src/foundations/borders.ts
var borders = {
  none: 0,
  "1px": "1px solid",
  "2px": "2px solid",
  "4px": "4px solid",
  "8px": "8px solid"
};
var borders_default = borders;
exports.borders_default = borders_default;
},{}],"Gx0t":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typography_default = void 0;
// src/foundations/typography.ts
var typography = {
  letterSpacings: {
    tighter: "-0.05em",
    tight: "-0.025em",
    normal: "0",
    wide: "0.025em",
    wider: "0.05em",
    widest: "0.1em"
  },
  lineHeights: {
    normal: "normal",
    none: 1,
    shorter: 1.25,
    short: 1.375,
    base: 1.5,
    tall: 1.625,
    taller: "2",
    "3": ".75rem",
    "4": "1rem",
    "5": "1.25rem",
    "6": "1.5rem",
    "7": "1.75rem",
    "8": "2rem",
    "9": "2.25rem",
    "10": "2.5rem"
  },
  fontWeights: {
    hairline: 100,
    thin: 200,
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    black: 900
  },
  fonts: {
    heading: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    body: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    mono: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  },
  fontSizes: {
    "3xs": "0.45rem",
    "2xs": "0.625rem",
    xs: "0.75rem",
    sm: "0.875rem",
    md: "1rem",
    lg: "1.125rem",
    xl: "1.25rem",
    "2xl": "1.5rem",
    "3xl": "1.875rem",
    "4xl": "2.25rem",
    "5xl": "3rem",
    "6xl": "3.75rem",
    "7xl": "4.5rem",
    "8xl": "6rem",
    "9xl": "8rem"
  }
};
var typography_default = typography;
exports.typography_default = typography_default;
},{}],"sz2D":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spacing = void 0;
// src/foundations/spacing.ts
var spacing = {
  px: "1px",
  0.5: "0.125rem",
  1: "0.25rem",
  1.5: "0.375rem",
  2: "0.5rem",
  2.5: "0.625rem",
  3: "0.75rem",
  3.5: "0.875rem",
  4: "1rem",
  5: "1.25rem",
  6: "1.5rem",
  7: "1.75rem",
  8: "2rem",
  9: "2.25rem",
  10: "2.5rem",
  12: "3rem",
  14: "3.5rem",
  16: "4rem",
  20: "5rem",
  24: "6rem",
  28: "7rem",
  32: "8rem",
  36: "9rem",
  40: "10rem",
  44: "11rem",
  48: "12rem",
  52: "13rem",
  56: "14rem",
  60: "15rem",
  64: "16rem",
  72: "18rem",
  80: "20rem",
  96: "24rem"
};
exports.spacing = spacing;
},{}],"HfnR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sizes_default = void 0;
var _chunkG3IFUAY = require("./chunk-G3IFUAY5.mjs");
// src/foundations/sizes.ts
var largeSizes = {
  max: "max-content",
  min: "min-content",
  full: "100%",
  "3xs": "14rem",
  "2xs": "16rem",
  xs: "20rem",
  sm: "24rem",
  md: "28rem",
  lg: "32rem",
  xl: "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "8xl": "90rem",
  prose: "60ch"
};
var container = {
  sm: "640px",
  md: "768px",
  lg: "1024px",
  xl: "1280px"
};
var sizes = {
  ..._chunkG3IFUAY.spacing,
  ...largeSizes,
  container
};
var sizes_default = sizes;
exports.sizes_default = sizes_default;
},{"./chunk-G3IFUAY5.mjs":"sz2D"}],"j0ne":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.foundations = void 0;
var _chunk7OKLMD4V = require("./chunk-7OKLMD4V.mjs");
var _chunkDDAHWWWN = require("./chunk-DDAHWWWN.mjs");
var _chunkC7H5GWRZ = require("./chunk-C7H5GWRZ.mjs");
var _chunk4REDROSM = require("./chunk-4REDROSM.mjs");
var _chunkDJNGX4VH = require("./chunk-DJNGX4VH.mjs");
var _chunkAU77DZXY = require("./chunk-AU77DZXY.mjs");
var _chunkOLDNEXT = require("./chunk-OLDNEXT6.mjs");
var _chunkZV5E32CG = require("./chunk-ZV5E32CG.mjs");
var _chunkHOOF7HHD = require("./chunk-HOOF7HHD.mjs");
var _chunkX4JBRTE = require("./chunk-X4JBRTE2.mjs");
var _chunkG3IFUAY = require("./chunk-G3IFUAY5.mjs");
// src/foundations/index.ts
var foundations = {
  breakpoints: _chunkDDAHWWWN.breakpoints_default,
  zIndices: _chunk7OKLMD4V.z_index_default,
  radii: _chunk4REDROSM.radius_default,
  blur: _chunkOLDNEXT.blur_default,
  colors: _chunkC7H5GWRZ.colors_default,
  ..._chunkHOOF7HHD.typography_default,
  sizes: _chunkX4JBRTE.sizes_default,
  shadows: _chunkDJNGX4VH.shadows_default,
  space: _chunkG3IFUAY.spacing,
  borders: _chunkZV5E32CG.borders_default,
  transition: _chunkAU77DZXY.transition_default
};
exports.foundations = foundations;
},{"./chunk-7OKLMD4V.mjs":"wnRJ","./chunk-DDAHWWWN.mjs":"sRYL","./chunk-C7H5GWRZ.mjs":"SHk9","./chunk-4REDROSM.mjs":"Jqut","./chunk-DJNGX4VH.mjs":"Fejh","./chunk-AU77DZXY.mjs":"bX2e","./chunk-OLDNEXT6.mjs":"v9FE","./chunk-ZV5E32CG.mjs":"vHn7","./chunk-HOOF7HHD.mjs":"Gx0t","./chunk-X4JBRTE2.mjs":"HfnR","./chunk-G3IFUAY5.mjs":"sz2D"}],"YTOm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.anatomy = anatomy;
// src/anatomy.ts
function anatomy(name, map = {}) {
  let called = false;
  function assert() {
    if (!called) {
      called = true;
      return;
    }
    throw new Error("[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?");
  }
  function parts(...values) {
    assert();
    for (const part of values) {
      ;
      map[part] = toPart(part);
    }
    return anatomy(name, map);
  }
  function extend(...parts2) {
    for (const part of parts2) {
      if (part in map) continue;
      map[part] = toPart(part);
    }
    return anatomy(name, map);
  }
  function selectors() {
    const value = Object.fromEntries(Object.entries(map).map(([key, part]) => [key, part.selector]));
    return value;
  }
  function classnames() {
    const value = Object.fromEntries(Object.entries(map).map(([key, part]) => [key, part.className]));
    return value;
  }
  function toPart(part) {
    const el = ["container", "root"].includes(part != null ? part : "") ? [name] : [name, part];
    const attr = el.filter(Boolean).join("__");
    const className = `chakra-${attr}`;
    const partObj = {
      className,
      selector: `.${className}`,
      toString: () => part
    };
    return partObj;
  }
  const __type = {};
  return {
    parts,
    toPart,
    extend,
    selectors,
    classnames,
    get keys() {
      return Object.keys(map);
    },
    __type
  };
}
},{}],"aC6o":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tagAnatomy = exports.tabsAnatomy = exports.tableAnatomy = exports.switchAnatomy = exports.statAnatomy = exports.sliderAnatomy = exports.selectAnatomy = exports.radioAnatomy = exports.progressAnatomy = exports.popoverAnatomy = exports.pinInputAnatomy = exports.numberInputAnatomy = exports.modalAnatomy = exports.menuAnatomy = exports.listAnatomy = exports.inputAnatomy = exports.formErrorAnatomy = exports.formAnatomy = exports.editableAnatomy = exports.drawerAnatomy = exports.circularProgressAnatomy = exports.checkboxAnatomy = exports.cardAnatomy = exports.buttonAnatomy = exports.breadcrumbAnatomy = exports.avatarAnatomy = exports.alertAnatomy = exports.accordionAnatomy = void 0;
var _chunkZN6IUO2A = require("./chunk-ZN6IUO2A.mjs");
// src/components.ts
var accordionAnatomy = (0, _chunkZN6IUO2A.anatomy)("accordion").parts("root", "container", "button", "panel").extend("icon");
exports.accordionAnatomy = accordionAnatomy;
var alertAnatomy = (0, _chunkZN6IUO2A.anatomy)("alert").parts("title", "description", "container").extend("icon", "spinner");
exports.alertAnatomy = alertAnatomy;
var avatarAnatomy = (0, _chunkZN6IUO2A.anatomy)("avatar").parts("label", "badge", "container").extend("excessLabel", "group");
exports.avatarAnatomy = avatarAnatomy;
var breadcrumbAnatomy = (0, _chunkZN6IUO2A.anatomy)("breadcrumb").parts("link", "item", "container").extend("separator");
exports.breadcrumbAnatomy = breadcrumbAnatomy;
var buttonAnatomy = (0, _chunkZN6IUO2A.anatomy)("button").parts();
exports.buttonAnatomy = buttonAnatomy;
var checkboxAnatomy = (0, _chunkZN6IUO2A.anatomy)("checkbox").parts("control", "icon", "container").extend("label");
exports.checkboxAnatomy = checkboxAnatomy;
var circularProgressAnatomy = (0, _chunkZN6IUO2A.anatomy)("progress").parts("track", "filledTrack").extend("label");
exports.circularProgressAnatomy = circularProgressAnatomy;
var drawerAnatomy = (0, _chunkZN6IUO2A.anatomy)("drawer").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
exports.drawerAnatomy = drawerAnatomy;
var editableAnatomy = (0, _chunkZN6IUO2A.anatomy)("editable").parts("preview", "input", "textarea");
exports.editableAnatomy = editableAnatomy;
var formAnatomy = (0, _chunkZN6IUO2A.anatomy)("form").parts("container", "requiredIndicator", "helperText");
exports.formAnatomy = formAnatomy;
var formErrorAnatomy = (0, _chunkZN6IUO2A.anatomy)("formError").parts("text", "icon");
exports.formErrorAnatomy = formErrorAnatomy;
var inputAnatomy = (0, _chunkZN6IUO2A.anatomy)("input").parts("addon", "field", "element");
exports.inputAnatomy = inputAnatomy;
var listAnatomy = (0, _chunkZN6IUO2A.anatomy)("list").parts("container", "item", "icon");
exports.listAnatomy = listAnatomy;
var menuAnatomy = (0, _chunkZN6IUO2A.anatomy)("menu").parts("button", "list", "item").extend("groupTitle", "command", "divider");
exports.menuAnatomy = menuAnatomy;
var modalAnatomy = (0, _chunkZN6IUO2A.anatomy)("modal").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
exports.modalAnatomy = modalAnatomy;
var numberInputAnatomy = (0, _chunkZN6IUO2A.anatomy)("numberinput").parts("root", "field", "stepperGroup", "stepper");
exports.numberInputAnatomy = numberInputAnatomy;
var pinInputAnatomy = (0, _chunkZN6IUO2A.anatomy)("pininput").parts("field");
exports.pinInputAnatomy = pinInputAnatomy;
var popoverAnatomy = (0, _chunkZN6IUO2A.anatomy)("popover").parts("content", "header", "body", "footer").extend("popper", "arrow", "closeButton");
exports.popoverAnatomy = popoverAnatomy;
var progressAnatomy = (0, _chunkZN6IUO2A.anatomy)("progress").parts("label", "filledTrack", "track");
exports.progressAnatomy = progressAnatomy;
var radioAnatomy = (0, _chunkZN6IUO2A.anatomy)("radio").parts("container", "control", "label");
exports.radioAnatomy = radioAnatomy;
var selectAnatomy = (0, _chunkZN6IUO2A.anatomy)("select").parts("field", "icon");
exports.selectAnatomy = selectAnatomy;
var sliderAnatomy = (0, _chunkZN6IUO2A.anatomy)("slider").parts("container", "track", "thumb", "filledTrack", "mark");
exports.sliderAnatomy = sliderAnatomy;
var statAnatomy = (0, _chunkZN6IUO2A.anatomy)("stat").parts("container", "label", "helpText", "number", "icon");
exports.statAnatomy = statAnatomy;
var switchAnatomy = (0, _chunkZN6IUO2A.anatomy)("switch").parts("container", "track", "thumb");
exports.switchAnatomy = switchAnatomy;
var tableAnatomy = (0, _chunkZN6IUO2A.anatomy)("table").parts("table", "thead", "tbody", "tr", "th", "td", "tfoot", "caption");
exports.tableAnatomy = tableAnatomy;
var tabsAnatomy = (0, _chunkZN6IUO2A.anatomy)("tabs").parts("root", "tab", "tablist", "tabpanel", "tabpanels", "indicator");
exports.tabsAnatomy = tabsAnatomy;
var tagAnatomy = (0, _chunkZN6IUO2A.anatomy)("tag").parts("container", "label", "closeButton");
exports.tagAnatomy = tagAnatomy;
var cardAnatomy = (0, _chunkZN6IUO2A.anatomy)("card").parts("container", "header", "body", "footer");
exports.cardAnatomy = cardAnatomy;
},{"./chunk-ZN6IUO2A.mjs":"YTOm"}],"WJBG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "accordionAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.accordionAnatomy;
  }
});
Object.defineProperty(exports, "alertAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.alertAnatomy;
  }
});
Object.defineProperty(exports, "anatomy", {
  enumerable: true,
  get: function () {
    return _chunkZN6IUO2A.anatomy;
  }
});
Object.defineProperty(exports, "avatarAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.avatarAnatomy;
  }
});
Object.defineProperty(exports, "breadcrumbAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.breadcrumbAnatomy;
  }
});
Object.defineProperty(exports, "buttonAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.buttonAnatomy;
  }
});
Object.defineProperty(exports, "cardAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.cardAnatomy;
  }
});
Object.defineProperty(exports, "checkboxAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.checkboxAnatomy;
  }
});
Object.defineProperty(exports, "circularProgressAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.circularProgressAnatomy;
  }
});
Object.defineProperty(exports, "drawerAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.drawerAnatomy;
  }
});
Object.defineProperty(exports, "editableAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.editableAnatomy;
  }
});
Object.defineProperty(exports, "formAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.formAnatomy;
  }
});
Object.defineProperty(exports, "formErrorAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.formErrorAnatomy;
  }
});
Object.defineProperty(exports, "inputAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.inputAnatomy;
  }
});
Object.defineProperty(exports, "listAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.listAnatomy;
  }
});
Object.defineProperty(exports, "menuAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.menuAnatomy;
  }
});
Object.defineProperty(exports, "modalAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.modalAnatomy;
  }
});
Object.defineProperty(exports, "numberInputAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.numberInputAnatomy;
  }
});
Object.defineProperty(exports, "pinInputAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.pinInputAnatomy;
  }
});
Object.defineProperty(exports, "popoverAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.popoverAnatomy;
  }
});
Object.defineProperty(exports, "progressAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.progressAnatomy;
  }
});
Object.defineProperty(exports, "radioAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.radioAnatomy;
  }
});
Object.defineProperty(exports, "selectAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.selectAnatomy;
  }
});
Object.defineProperty(exports, "sliderAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.sliderAnatomy;
  }
});
Object.defineProperty(exports, "statAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.statAnatomy;
  }
});
Object.defineProperty(exports, "switchAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.switchAnatomy;
  }
});
Object.defineProperty(exports, "tableAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.tableAnatomy;
  }
});
Object.defineProperty(exports, "tabsAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.tabsAnatomy;
  }
});
Object.defineProperty(exports, "tagAnatomy", {
  enumerable: true,
  get: function () {
    return _chunkHAKT6JCA.tagAnatomy;
  }
});
var _chunkHAKT6JCA = require("./chunk-HAKT6JCA.mjs");
var _chunkZN6IUO2A = require("./chunk-ZN6IUO2A.mjs");
},{"./chunk-HAKT6JCA.mjs":"aC6o","./chunk-ZN6IUO2A.mjs":"YTOm"}],"GQZa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorError = void 0;
exports.adjustHue = adjustHue;
exports.darken = darken;
exports.desaturate = desaturate;
exports.getContrast = getContrast;
exports.getLuminance = getLuminance;
exports.getScale = getScale;
exports.guard = guard;
exports.hasBadContrast = hasBadContrast;
exports.hsla = hsla;
exports.lighten = lighten;
exports.mix = mix;
exports.opacify = opacify;
exports.parseToHsla = parseToHsla;
exports.parseToRgba = parseToRgba;
exports.readableColor = readableColor;
exports.readableColorIsBlack = readableColorIsBlack;
exports.rgba = rgba;
exports.saturate = saturate;
exports.toHex = toHex;
exports.toHsla = toHsla;
exports.toRgba = toRgba;
exports.transparentize = transparentize;
/**
 * A simple guard function:
 *
 * ```js
 * Math.min(Math.max(low, value), high)
 * ```
 */
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
class ColorError extends Error {
  constructor(color) {
    super(`Failed to parse color: "${color}"`);
  }
}
var ColorError$1 = ColorError;

/**
 * Parses a color into red, gree, blue, alpha parts
 *
 * @param color the input color. Can be a RGB, RBGA, HSL, HSLA, or named color
 */
exports.ColorError = ColorError$1;
function parseToRgba(color) {
  if (typeof color !== 'string') throw new ColorError$1(color);
  if (color.trim().toLowerCase() === 'transparent') return [0, 0, 0, 0];
  let normalizedColor = color.trim();
  normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map(x => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || 'f', 2), 16) / 255];
  }
  const hexMatch = hexRegex.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map(x => parseInt(x, 16)), parseInt(arr[3] || 'ff', 16) / 255];
  }
  const rgbaMatch = rgbaRegex.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map(x => parseInt(x, 10)), parseFloat(arr[3] || '1')];
  }
  const hslaMatch = hslaRegex.exec(normalizedColor);
  if (hslaMatch) {
    const [h, s, l, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s) !== s) throw new ColorError$1(color);
    if (guard(0, 100, l) !== l) throw new ColorError$1(color);
    return [...hslToRgb(h, s, l), a || 1];
  }
  throw new ColorError$1(color);
}
function hash(str) {
  let hash = 5381;
  let i = str.length;
  while (i) {
    hash = hash * 33 ^ str.charCodeAt(--i);
  }
  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */

  return (hash >>> 0) % 2341;
}
const colorToInt = x => parseInt(x.replace(/_/g, ''), 36);
const compressedColorMap = '1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm'.split(' ').reduce((acc, next) => {
  const key = colorToInt(next.substring(0, 3));
  const hex = colorToInt(next.substring(3)).toString(16); // NOTE: padStart could be used here but it breaks Node 6 compat
  // https://github.com/ricokahler/color2k/issues/351

  let prefix = '';
  for (let i = 0; i < 6 - hex.length; i++) {
    prefix += '0';
  }
  acc[key] = `${prefix}${hex}`;
  return acc;
}, {});
/**
 * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
 */

function nameToHex(color) {
  const normalizedColorName = color.toLowerCase().trim();
  const result = compressedColorMap[hash(normalizedColorName)];
  if (!result) throw new ColorError$1(color);
  return `#${result}`;
}
const r = (str, amount) => Array.from(Array(amount)).map(() => str).join('');
const reducedHexRegex = new RegExp(`^#${r('([a-f0-9])', 3)}([a-f0-9])?$`, 'i');
const hexRegex = new RegExp(`^#${r('([a-f0-9]{2})', 3)}([a-f0-9]{2})?$`, 'i');
const rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(',\\s*(\\d+)\\s*', 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, 'i');
const hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
const namedColorRegex = /^[a-z]+$/i;
const roundColor = color => {
  return Math.round(color * 255);
};
const hslToRgb = (hue, saturation, lightness) => {
  let l = lightness / 100;
  if (saturation === 0) {
    // achromatic
    return [l, l, l].map(roundColor);
  } // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV

  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};

// taken from:
/**
 * Parses a color in hue, saturation, lightness, and the alpha channel.
 *
 * Hue is a number between 0 and 360, saturation, lightness, and alpha are
 * decimal percentages between 0 and 1
 */

function parseToHsla(color) {
  const [red, green, blue, alpha] = parseToRgba(color).map((value, index) =>
  // 3rd index is alpha channel which is already normalized
  index === 3 ? value : value / 255);
  const max = Math.max(red, green, blue);
  const min = Math.min(red, green, blue);
  const lightness = (max + min) / 2; // achromatic

  if (max === min) return [0, 0, lightness, alpha];
  const delta = max - min;
  const saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);
  const hue = 60 * (red === max ? (green - blue) / delta + (green < blue ? 6 : 0) : green === max ? (blue - red) / delta + 2 : (red - green) / delta + 4);
  return [hue, saturation, lightness, alpha];
}

/**
 * Takes in hsla parts and constructs an hsla string
 *
 * @param hue The color circle (from 0 to 360) - 0 (or 360) is red, 120 is green, 240 is blue
 * @param saturation Percentage of saturation, given as a decimal between 0 and 1
 * @param lightness Percentage of lightness, given as a decimal between 0 and 1
 * @param alpha Percentage of opacity, given as a decimal between 0 and 1
 */

function hsla(hue, saturation, lightness, alpha) {
  return `hsla(${(hue % 360).toFixed()}, ${guard(0, 100, saturation * 100).toFixed()}%, ${guard(0, 100, lightness * 100).toFixed()}%, ${parseFloat(guard(0, 1, alpha).toFixed(3))})`;
}

/**
 * Adjusts the current hue of the color by the given degrees. Wraps around when
 * over 360.
 *
 * @param color input color
 * @param degrees degrees to adjust the input color, accepts degree integers
 * (0 - 360) and wraps around on overflow
 */

function adjustHue(color, degrees) {
  const [h, s, l, a] = parseToHsla(color);
  return hsla(h + degrees, s, l, a);
}

/**
 * Darkens using lightness. This is equivalent to subtracting the lightness
 * from the L in HSL.
 *
 * @param amount The amount to darken, given as a decimal between 0 and 1
 */

function darken(color, amount) {
  const [hue, saturation, lightness, alpha] = parseToHsla(color);
  return hsla(hue, saturation, lightness - amount, alpha);
}

/**
 * Desaturates the input color by the given amount via subtracting from the `s`
 * in `hsla`.
 *
 * @param amount The amount to desaturate, given as a decimal between 0 and 1
 */

function desaturate(color, amount) {
  const [h, s, l, a] = parseToHsla(color);
  return hsla(h, s - amount, l, a);
}

// https://github.com/styled-components/polished/blob/0764c982551b487469043acb56281b0358b3107b/src/color/getLuminance.js

/**
 * Returns a number (float) representing the luminance of a color.
 */

function getLuminance(color) {
  if (color === 'transparent') return 0;
  function f(x) {
    const channel = x / 255;
    return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
  }
  const [r, g, b] = parseToRgba(color);
  return 0.2126 * f(r) + 0.7152 * f(g) + 0.0722 * f(b);
}

// taken from:
/**
 * Returns the contrast ratio between two colors based on
 * [W3's recommended equation for calculating contrast](http://www.w3.org/TR/WCAG20/#contrast-ratiodef).
 */

function getContrast(color1, color2) {
  const luminance1 = getLuminance(color1);
  const luminance2 = getLuminance(color2);
  return luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05);
}

/**
 * Takes in rgba parts and returns an rgba string
 *
 * @param red The amount of red in the red channel, given in a number between 0 and 255 inclusive
 * @param green The amount of green in the red channel, given in a number between 0 and 255 inclusive
 * @param blue The amount of blue in the red channel, given in a number between 0 and 255 inclusive
 * @param alpha Percentage of opacity, given as a decimal between 0 and 1
 */

function rgba(red, green, blue, alpha) {
  return `rgba(${guard(0, 255, red).toFixed()}, ${guard(0, 255, green).toFixed()}, ${guard(0, 255, blue).toFixed()}, ${parseFloat(guard(0, 1, alpha).toFixed(3))})`;
}

/**
 * Mixes two colors together. Taken from sass's implementation.
 */

function mix(color1, color2, weight) {
  const normalize = (n, index) =>
  // 3rd index is alpha channel which is already normalized
  index === 3 ? n : n / 255;
  const [r1, g1, b1, a1] = parseToRgba(color1).map(normalize);
  const [r2, g2, b2, a2] = parseToRgba(color2).map(normalize); // The formula is copied from the original Sass implementation:
  // http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method

  const alphaDelta = a2 - a1;
  const normalizedWeight = weight * 2 - 1;
  const combinedWeight = normalizedWeight * alphaDelta === -1 ? normalizedWeight : normalizedWeight + alphaDelta / (1 + normalizedWeight * alphaDelta);
  const weight2 = (combinedWeight + 1) / 2;
  const weight1 = 1 - weight2;
  const r = (r1 * weight1 + r2 * weight2) * 255;
  const g = (g1 * weight1 + g2 * weight2) * 255;
  const b = (b1 * weight1 + b2 * weight2) * 255;
  const a = a2 * weight + a1 * (1 - weight);
  return rgba(r, g, b, a);
}

/**
 * Given a series colors, this function will return a `scale(x)` function that
 * accepts a percentage as a decimal between 0 and 1 and returns the color at
 * that percentage in the scale.
 *
 * ```js
 * const scale = getScale('red', 'yellow', 'green');
 * console.log(scale(0)); // rgba(255, 0, 0, 1)
 * console.log(scale(0.5)); // rgba(255, 255, 0, 1)
 * console.log(scale(1)); // rgba(0, 128, 0, 1)
 * ```
 *
 * If you'd like to limit the domain and range like chroma-js, we recommend
 * wrapping scale again.
 *
 * ```js
 * const _scale = getScale('red', 'yellow', 'green');
 * const scale = x => _scale(x / 100);
 *
 * console.log(scale(0)); // rgba(255, 0, 0, 1)
 * console.log(scale(50)); // rgba(255, 255, 0, 1)
 * console.log(scale(100)); // rgba(0, 128, 0, 1)
 * ```
 */

function getScale(...colors) {
  return n => {
    const lastIndex = colors.length - 1;
    const lowIndex = guard(0, lastIndex, Math.floor(n * lastIndex));
    const highIndex = guard(0, lastIndex, Math.ceil(n * lastIndex));
    const color1 = colors[lowIndex];
    const color2 = colors[highIndex];
    const unit = 1 / lastIndex;
    const weight = (n - unit * lowIndex) / unit;
    return mix(color1, color2, weight);
  };
}
const guidelines = {
  decorative: 1.5,
  readable: 3,
  aa: 4.5,
  aaa: 7
};
/**
 * Returns whether or not a color has bad contrast against a background
 * according to a given standard.
 */

function hasBadContrast(color, standard = 'aa', background = '#fff') {
  return getContrast(color, background) < guidelines[standard];
}

/**
 * Lightens a color by a given amount. This is equivalent to
 * `darken(color, -amount)`
 *
 * @param amount The amount to darken, given as a decimal between 0 and 1
 */

function lighten(color, amount) {
  return darken(color, -amount);
}

/**
 * Takes in a color and makes it more transparent by convert to `rgba` and
 * decreasing the amount in the alpha channel.
 *
 * @param amount The amount to increase the transparency by, given as a decimal between 0 and 1
 */

function transparentize(color, amount) {
  const [r, g, b, a] = parseToRgba(color);
  return rgba(r, g, b, a - amount);
}

/**
 * Takes a color and un-transparentizes it. Equivalent to
 * `transparentize(color, -amount)`
 *
 * @param amount The amount to increase the opacity by, given as a decimal between 0 and 1
 */

function opacify(color, amount) {
  return transparentize(color, -amount);
}

/**
 * An alternative function to `readableColor`. Returns whether or not the 
 * readable color (i.e. the color to be place on top the input color) should be
 * black.
 */

function readableColorIsBlack(color) {
  return getLuminance(color) > 0.179;
}

/**
 * Returns black or white for best contrast depending on the luminosity of the
 * given color.
 */

function readableColor(color) {
  return readableColorIsBlack(color) ? '#000' : '#fff';
}

/**
 * Saturates a color by converting it to `hsl` and increasing the saturation
 * amount. Equivalent to `desaturate(color, -amount)`
 * 
 * @param color Input color
 * @param amount The amount to darken, given as a decimal between 0 and 1
 */

function saturate(color, amount) {
  return desaturate(color, -amount);
}

/**
 * Takes in any color and returns it as a hex code.
 */

function toHex(color) {
  const [r, g, b, a] = parseToRgba(color);
  let hex = x => {
    const h = guard(0, 255, x).toString(16); // NOTE: padStart could be used here but it breaks Node 6 compat
    // https://github.com/ricokahler/color2k/issues/351

    return h.length === 1 ? `0${h}` : h;
  };
  return `#${hex(r)}${hex(g)}${hex(b)}${a < 1 ? hex(Math.round(a * 255)) : ''}`;
}

/**
 * Takes in any color and returns it as an rgba string.
 */

function toRgba(color) {
  return rgba(...parseToRgba(color));
}

/**
 * Takes in any color and returns it as an hsla string.
 */

function toHsla(color) {
  return hsla(...parseToHsla(color));
}
},{}],"MwVG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.darken = exports.contrast = exports.complementary = exports.blacken = void 0;
exports.generateStripe = generateStripe;
exports.isLight = exports.isDark = exports.isAccessible = exports.getColor = void 0;
exports.isReadable = isReadable;
exports.lighten = void 0;
exports.randomColor = randomColor;
exports.readability = readability;
exports.whiten = exports.transparentize = exports.tone = void 0;
var _color2k = require("color2k");
// src/color.ts

// ../../../node_modules/.pnpm/dlv@1.1.3/node_modules/dlv/dist/dlv.es.js
function dlv_es_default(t, e, l, n, r) {
  for (e = e.split ? e.split(".") : e, n = 0; n < e.length; n++) t = t ? t[e[n]] : r;
  return t === r ? l : t;
}

// src/color.ts
var isEmptyObject = obj => Object.keys(obj).length === 0;
var getColor = (theme, color, fallback) => {
  const hex = dlv_es_default(theme, `colors.${color}`, color);
  try {
    (0, _color2k.toHex)(hex);
    return hex;
  } catch {
    return fallback != null ? fallback : "#000000";
  }
};
exports.getColor = getColor;
var getBrightness = color => {
  const [r, g, b] = (0, _color2k.parseToRgba)(color);
  return (r * 299 + g * 587 + b * 114) / 1e3;
};
var tone = color => theme => {
  const hex = getColor(theme, color);
  const brightness = getBrightness(hex);
  const isDark2 = brightness < 128;
  return isDark2 ? "dark" : "light";
};
exports.tone = tone;
var isDark = color => theme => tone(color)(theme) === "dark";
exports.isDark = isDark;
var isLight = color => theme => tone(color)(theme) === "light";
exports.isLight = isLight;
var transparentize = (color, opacity) => theme => {
  const raw = getColor(theme, color);
  return (0, _color2k.transparentize)(raw, 1 - opacity);
};
exports.transparentize = transparentize;
var whiten = (color, amount) => theme => {
  const raw = getColor(theme, color);
  return (0, _color2k.toHex)((0, _color2k.mix)(raw, "#fff", amount));
};
exports.whiten = whiten;
var blacken = (color, amount) => theme => {
  const raw = getColor(theme, color);
  return (0, _color2k.toHex)((0, _color2k.mix)(raw, "#000", amount));
};
exports.blacken = blacken;
var darken = (color, amount) => theme => {
  const raw = getColor(theme, color);
  return (0, _color2k.toHex)((0, _color2k.darken)(raw, amount));
};
exports.darken = darken;
var lighten = (color, amount) => theme => {
  const raw = getColor(theme, color);
  (0, _color2k.toHex)((0, _color2k.lighten)(raw, amount));
};
exports.lighten = lighten;
var contrast = (fg, bg) => theme => (0, _color2k.getContrast)(getColor(theme, bg), getColor(theme, fg));
exports.contrast = contrast;
var isAccessible = (textColor, bgColor, options) => theme => isReadable(getColor(theme, bgColor), getColor(theme, textColor), options);
exports.isAccessible = isAccessible;
function isReadable(color1, color2, wcag2 = {
  level: "AA",
  size: "small"
}) {
  var _a, _b;
  const readabilityLevel = readability(color1, color2);
  switch (((_a = wcag2.level) != null ? _a : "AA") + ((_b = wcag2.size) != null ? _b : "small")) {
    case "AAsmall":
    case "AAAlarge":
      return readabilityLevel >= 4.5;
    case "AAlarge":
      return readabilityLevel >= 3;
    case "AAAsmall":
      return readabilityLevel >= 7;
    default:
      return false;
  }
}
function readability(color1, color2) {
  return (Math.max((0, _color2k.getLuminance)(color1), (0, _color2k.getLuminance)(color2)) + 0.05) / (Math.min((0, _color2k.getLuminance)(color1), (0, _color2k.getLuminance)(color2)) + 0.05);
}
var complementary = color => theme => {
  const raw = getColor(theme, color);
  const hsl = (0, _color2k.parseToHsla)(raw);
  const complementHsl = Object.assign(hsl, [(hsl[0] + 180) % 360]);
  return (0, _color2k.toHex)((0, _color2k.hsla)(...complementHsl));
};
exports.complementary = complementary;
function generateStripe(size = "1rem", color = "rgba(255, 255, 255, 0.15)") {
  return {
    backgroundImage: `linear-gradient(
    45deg,
    ${color} 25%,
    transparent 25%,
    transparent 50%,
    ${color} 50%,
    ${color} 75%,
    transparent 75%,
    transparent
  )`,
    backgroundSize: `${size} ${size}`
  };
}
var randomHex = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
function randomColor(opts) {
  const fallback = randomHex();
  if (!opts || isEmptyObject(opts)) {
    return fallback;
  }
  if (opts.string && opts.colors) {
    return randomColorFromList(opts.string, opts.colors);
  }
  if (opts.string && !opts.colors) {
    return randomColorFromString(opts.string);
  }
  if (opts.colors && !opts.string) {
    return randomFromList(opts.colors);
  }
  return fallback;
}
function randomColorFromString(str) {
  let hash = 0;
  if (str.length === 0) return hash.toString();
  for (let i = 0; i < str.length; i += 1) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
    hash = hash & hash;
  }
  let color = "#";
  for (let j = 0; j < 3; j += 1) {
    const value = hash >> j * 8 & 255;
    color += `00${value.toString(16)}`.substr(-2);
  }
  return color;
}
function randomColorFromList(str, list) {
  let index = 0;
  if (str.length === 0) return list[0];
  for (let i = 0; i < str.length; i += 1) {
    index = str.charCodeAt(i) + ((index << 5) - index);
    index = index & index;
  }
  index = (index % list.length + list.length) % list.length;
  return list[index];
}
function randomFromList(list) {
  return list[Math.floor(Math.random() * list.length)];
}
},{"color2k":"GQZa"}],"LEDy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mode = mode;
exports.orient = orient;
// src/component.ts
function mode(light, dark) {
  return props => props.colorMode === "dark" ? dark : light;
}
function orient(options) {
  const {
    orientation,
    vertical,
    horizontal
  } = options;
  if (!orientation) return {};
  return orientation === "vertical" ? vertical : horizontal;
}
},{}],"p9SV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBreakpoints = void 0;
var _sharedUtils = require("@chakra-ui/shared-utils");
// src/create-breakpoints.ts

var createBreakpoints = config => {
  (0, _sharedUtils.warn)({
    condition: true,
    message: [`[chakra-ui]: createBreakpoints(...) will be deprecated pretty soon`, `simply pass the breakpoints as an object. Remove the createBreakpoints(..) call`].join("")
  });
  return {
    base: "0em",
    ...config
  };
};
exports.createBreakpoints = createBreakpoints;
},{"@chakra-ui/shared-utils":"gghr"}],"q5xM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calc = void 0;
var _sharedUtils = require("@chakra-ui/shared-utils");
// src/css-calc.ts

function toRef(operand) {
  if ((0, _sharedUtils.isObject)(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpr = (operator, ...operands) => operands.map(toRef).join(` ${operator} `).replace(/calc/g, "");
var add = (...operands) => `calc(${toExpr("+", ...operands)})`;
var subtract = (...operands) => `calc(${toExpr("-", ...operands)})`;
var multiply = (...operands) => `calc(${toExpr("*", ...operands)})`;
var divide = (...operands) => `calc(${toExpr("/", ...operands)})`;
var negate = x => {
  const value = toRef(x);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
var calc = Object.assign(x => ({
  add: (...operands) => calc(add(x, ...operands)),
  subtract: (...operands) => calc(subtract(x, ...operands)),
  multiply: (...operands) => calc(multiply(x, ...operands)),
  divide: (...operands) => calc(divide(x, ...operands)),
  negate: () => calc(negate(x)),
  toString: () => x.toString()
}), {
  add,
  subtract,
  multiply,
  divide,
  negate
});
exports.calc = calc;
},{"@chakra-ui/shared-utils":"gghr"}],"HkGD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addPrefix = addPrefix;
exports.cssVar = cssVar;
exports.isDecimal = isDecimal;
exports.toVar = toVar;
exports.toVarRef = toVarRef;
// src/css-var.ts
function isDecimal(value) {
  return !Number.isInteger(parseFloat(value.toString()));
}
function replaceWhiteSpace(value, replaceValue = "-") {
  return value.replace(/\s+/g, replaceValue);
}
function escape(value) {
  const valueStr = replaceWhiteSpace(value.toString());
  if (valueStr.includes("\\.")) return value;
  return isDecimal(value) ? valueStr.replace(".", `\\.`) : value;
}
function addPrefix(value, prefix = "") {
  return [prefix, escape(value)].filter(Boolean).join("-");
}
function toVarRef(name, fallback) {
  return `var(${escape(name)}${fallback ? `, ${fallback}` : ""})`;
}
function toVar(value, prefix = "") {
  return `--${addPrefix(value, prefix)}`;
}
function cssVar(name, options) {
  const cssVariable = toVar(name, options == null ? void 0 : options.prefix);
  return {
    variable: cssVariable,
    reference: toVarRef(cssVariable, getFallback(options == null ? void 0 : options.fallback))
  };
}
function getFallback(fallback) {
  if (typeof fallback === "string") return fallback;
  return fallback == null ? void 0 : fallback.reference;
}
},{}],"TjB8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "addPrefix", {
  enumerable: true,
  get: function () {
    return _chunk7SOXEYKO.addPrefix;
  }
});
Object.defineProperty(exports, "anatomy", {
  enumerable: true,
  get: function () {
    return _anatomy.anatomy;
  }
});
Object.defineProperty(exports, "blacken", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.blacken;
  }
});
Object.defineProperty(exports, "calc", {
  enumerable: true,
  get: function () {
    return _chunkE3OBLH5E.calc;
  }
});
Object.defineProperty(exports, "complementary", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.complementary;
  }
});
Object.defineProperty(exports, "contrast", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.contrast;
  }
});
Object.defineProperty(exports, "createBreakpoints", {
  enumerable: true,
  get: function () {
    return _chunk4T5CIMY.createBreakpoints;
  }
});
Object.defineProperty(exports, "cssVar", {
  enumerable: true,
  get: function () {
    return _chunk7SOXEYKO.cssVar;
  }
});
Object.defineProperty(exports, "darken", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.darken;
  }
});
Object.defineProperty(exports, "generateStripe", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.generateStripe;
  }
});
Object.defineProperty(exports, "getColor", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.getColor;
  }
});
Object.defineProperty(exports, "isAccessible", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.isAccessible;
  }
});
Object.defineProperty(exports, "isDark", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.isDark;
  }
});
Object.defineProperty(exports, "isDecimal", {
  enumerable: true,
  get: function () {
    return _chunk7SOXEYKO.isDecimal;
  }
});
Object.defineProperty(exports, "isLight", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.isLight;
  }
});
Object.defineProperty(exports, "isReadable", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.isReadable;
  }
});
Object.defineProperty(exports, "lighten", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.lighten;
  }
});
Object.defineProperty(exports, "mode", {
  enumerable: true,
  get: function () {
    return _chunk7P3W45AB.mode;
  }
});
Object.defineProperty(exports, "orient", {
  enumerable: true,
  get: function () {
    return _chunk7P3W45AB.orient;
  }
});
Object.defineProperty(exports, "randomColor", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.randomColor;
  }
});
Object.defineProperty(exports, "readability", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.readability;
  }
});
Object.defineProperty(exports, "toVar", {
  enumerable: true,
  get: function () {
    return _chunk7SOXEYKO.toVar;
  }
});
Object.defineProperty(exports, "toVarRef", {
  enumerable: true,
  get: function () {
    return _chunk7SOXEYKO.toVarRef;
  }
});
Object.defineProperty(exports, "tone", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.tone;
  }
});
Object.defineProperty(exports, "transparentize", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.transparentize;
  }
});
Object.defineProperty(exports, "whiten", {
  enumerable: true,
  get: function () {
    return _chunk4RZ5NGUS.whiten;
  }
});
var _chunk4RZ5NGUS = require("./chunk-4RZ5NGUS.mjs");
var _chunk7P3W45AB = require("./chunk-7P3W45AB.mjs");
var _chunk4T5CIMY = require("./chunk-4T5CIMY5.mjs");
var _chunkE3OBLH5E = require("./chunk-E3OBLH5E.mjs");
var _chunk7SOXEYKO = require("./chunk-7SOXEYKO.mjs");
var _anatomy = require("@chakra-ui/anatomy");
},{"./chunk-4RZ5NGUS.mjs":"MwVG","./chunk-7P3W45AB.mjs":"LEDy","./chunk-4T5CIMY5.mjs":"p9SV","./chunk-E3OBLH5E.mjs":"q5xM","./chunk-7SOXEYKO.mjs":"HkGD","@chakra-ui/anatomy":"WJBG"}],"PMz3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.switchTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/switch.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.switchAnatomy.keys);
var $width = (0, _themeTools.cssVar)("switch-track-width");
var $height = (0, _themeTools.cssVar)("switch-track-height");
var $diff = (0, _themeTools.cssVar)("switch-track-diff");
var diffValue = _themeTools.calc.subtract($width, $height);
var $translateX = (0, _themeTools.cssVar)("switch-thumb-x");
var $bg = (0, _themeTools.cssVar)("switch-bg");
var baseStyleTrack = (0, _styledSystem.defineStyle)(props => {
  const {
    colorScheme: c
  } = props;
  return {
    borderRadius: "full",
    p: "0.5",
    width: [$width.reference],
    height: [$height.reference],
    transitionProperty: "common",
    transitionDuration: "fast",
    [$bg.variable]: "colors.gray.300",
    _dark: {
      [$bg.variable]: "colors.whiteAlpha.400"
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    _checked: {
      [$bg.variable]: `colors.${c}.500`,
      _dark: {
        [$bg.variable]: `colors.${c}.200`
      }
    },
    bg: $bg.reference
  };
});
var baseStyleThumb = (0, _styledSystem.defineStyle)({
  bg: "white",
  transitionProperty: "transform",
  transitionDuration: "normal",
  borderRadius: "inherit",
  width: [$height.reference],
  height: [$height.reference],
  _checked: {
    transform: `translateX(${$translateX.reference})`
  }
});
var baseStyle = definePartsStyle(props => ({
  container: {
    [$diff.variable]: diffValue,
    [$translateX.variable]: $diff.reference,
    _rtl: {
      [$translateX.variable]: (0, _themeTools.calc)($diff).negate().toString()
    }
  },
  track: baseStyleTrack(props),
  thumb: baseStyleThumb
}));
var sizes = {
  sm: definePartsStyle({
    container: {
      [$width.variable]: "1.375rem",
      [$height.variable]: "sizes.3"
    }
  }),
  md: definePartsStyle({
    container: {
      [$width.variable]: "1.875rem",
      [$height.variable]: "sizes.4"
    }
  }),
  lg: definePartsStyle({
    container: {
      [$width.variable]: "2.875rem",
      [$height.variable]: "sizes.6"
    }
  })
};
var switchTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
exports.switchTheme = switchTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"H5lk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tableTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/table.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.tableAnatomy.keys);
var baseStyle = definePartsStyle({
  table: {
    fontVariantNumeric: "lining-nums tabular-nums",
    borderCollapse: "collapse",
    width: "full"
  },
  th: {
    fontFamily: "heading",
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: "wider",
    textAlign: "start"
  },
  td: {
    textAlign: "start"
  },
  caption: {
    mt: 4,
    fontFamily: "heading",
    textAlign: "center",
    fontWeight: "medium"
  }
});
var numericStyles = (0, _styledSystem.defineStyle)({
  "&[data-is-numeric=true]": {
    textAlign: "end"
  }
});
var variantSimple = definePartsStyle(props => {
  const {
    colorScheme: c
  } = props;
  return {
    th: {
      color: (0, _themeTools.mode)("gray.600", "gray.400")(props),
      borderBottom: "1px",
      borderColor: (0, _themeTools.mode)(`${c}.100`, `${c}.700`)(props),
      ...numericStyles
    },
    td: {
      borderBottom: "1px",
      borderColor: (0, _themeTools.mode)(`${c}.100`, `${c}.700`)(props),
      ...numericStyles
    },
    caption: {
      color: (0, _themeTools.mode)("gray.600", "gray.100")(props)
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: {
            borderBottomWidth: 0
          }
        }
      }
    }
  };
});
var variantStripe = definePartsStyle(props => {
  const {
    colorScheme: c
  } = props;
  return {
    th: {
      color: (0, _themeTools.mode)("gray.600", "gray.400")(props),
      borderBottom: "1px",
      borderColor: (0, _themeTools.mode)(`${c}.100`, `${c}.700`)(props),
      ...numericStyles
    },
    td: {
      borderBottom: "1px",
      borderColor: (0, _themeTools.mode)(`${c}.100`, `${c}.700`)(props),
      ...numericStyles
    },
    caption: {
      color: (0, _themeTools.mode)("gray.600", "gray.100")(props)
    },
    tbody: {
      tr: {
        "&:nth-of-type(odd)": {
          "th, td": {
            borderBottomWidth: "1px",
            borderColor: (0, _themeTools.mode)(`${c}.100`, `${c}.700`)(props)
          },
          td: {
            background: (0, _themeTools.mode)(`${c}.100`, `${c}.700`)(props)
          }
        }
      }
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: {
            borderBottomWidth: 0
          }
        }
      }
    }
  };
});
var variants = {
  simple: variantSimple,
  striped: variantStripe,
  unstyled: (0, _styledSystem.defineStyle)({})
};
var sizes = {
  sm: definePartsStyle({
    th: {
      px: "4",
      py: "1",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "4",
      py: "2",
      fontSize: "sm",
      lineHeight: "4"
    },
    caption: {
      px: "4",
      py: "2",
      fontSize: "xs"
    }
  }),
  md: definePartsStyle({
    th: {
      px: "6",
      py: "3",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "6",
      py: "4",
      lineHeight: "5"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "sm"
    }
  }),
  lg: definePartsStyle({
    th: {
      px: "8",
      py: "4",
      lineHeight: "5",
      fontSize: "sm"
    },
    td: {
      px: "8",
      py: "5",
      lineHeight: "6"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "md"
    }
  })
};
var tableTheme = defineMultiStyleConfig({
  baseStyle,
  variants,
  sizes,
  defaultProps: {
    variant: "simple",
    size: "md",
    colorScheme: "gray"
  }
});
exports.tableTheme = tableTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"glOQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tabsTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/tabs.ts

var $fg = (0, _styledSystem.cssVar)("tabs-color");
var $bg = (0, _styledSystem.cssVar)("tabs-bg");
var $border = (0, _styledSystem.cssVar)("tabs-border-color");
var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.tabsAnatomy.keys);
var baseStyleRoot = (0, _styledSystem.defineStyle)(props => {
  const {
    orientation
  } = props;
  return {
    display: orientation === "vertical" ? "flex" : "block"
  };
});
var baseStyleTab = (0, _styledSystem.defineStyle)(props => {
  const {
    isFitted
  } = props;
  return {
    flex: isFitted ? 1 : void 0,
    transitionProperty: "common",
    transitionDuration: "normal",
    _focusVisible: {
      zIndex: 1,
      boxShadow: "outline"
    },
    _disabled: {
      cursor: "not-allowed",
      opacity: 0.4
    }
  };
});
var baseStyleTablist = (0, _styledSystem.defineStyle)(props => {
  const {
    align = "start",
    orientation
  } = props;
  const alignments = {
    end: "flex-end",
    center: "center",
    start: "flex-start"
  };
  return {
    justifyContent: alignments[align],
    flexDirection: orientation === "vertical" ? "column" : "row"
  };
});
var baseStyleTabpanel = (0, _styledSystem.defineStyle)({
  p: 4
});
var baseStyle = definePartsStyle(props => ({
  root: baseStyleRoot(props),
  tab: baseStyleTab(props),
  tablist: baseStyleTablist(props),
  tabpanel: baseStyleTabpanel
}));
var sizes = {
  sm: definePartsStyle({
    tab: {
      py: 1,
      px: 4,
      fontSize: "sm"
    }
  }),
  md: definePartsStyle({
    tab: {
      fontSize: "md",
      py: 2,
      px: 4
    }
  }),
  lg: definePartsStyle({
    tab: {
      fontSize: "lg",
      py: 3,
      px: 4
    }
  })
};
var variantLine = definePartsStyle(props => {
  const {
    colorScheme: c,
    orientation
  } = props;
  const isVertical = orientation === "vertical";
  const borderProp = orientation === "vertical" ? "borderStart" : "borderBottom";
  const marginProp = isVertical ? "marginStart" : "marginBottom";
  return {
    tablist: {
      [borderProp]: "2px solid",
      borderColor: "inherit"
    },
    tab: {
      [borderProp]: "2px solid",
      borderColor: "transparent",
      [marginProp]: "-2px",
      _selected: {
        [$fg.variable]: `colors.${c}.600`,
        _dark: {
          [$fg.variable]: `colors.${c}.300`
        },
        borderColor: "currentColor"
      },
      _active: {
        [$bg.variable]: "colors.gray.200",
        _dark: {
          [$bg.variable]: "colors.whiteAlpha.300"
        }
      },
      _disabled: {
        _active: {
          bg: "none"
        }
      },
      color: $fg.reference,
      bg: $bg.reference
    }
  };
});
var variantEnclosed = definePartsStyle(props => {
  const {
    colorScheme: c
  } = props;
  return {
    tab: {
      borderTopRadius: "md",
      border: "1px solid",
      borderColor: "transparent",
      mb: "-1px",
      [$border.variable]: "transparent",
      _selected: {
        [$fg.variable]: `colors.${c}.600`,
        [$border.variable]: `colors.white`,
        _dark: {
          [$fg.variable]: `colors.${c}.300`,
          [$border.variable]: `colors.gray.800`
        },
        borderColor: "inherit",
        borderBottomColor: $border.reference
      },
      color: $fg.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
});
var variantEnclosedColored = definePartsStyle(props => {
  const {
    colorScheme: c
  } = props;
  return {
    tab: {
      border: "1px solid",
      borderColor: "inherit",
      [$bg.variable]: "colors.gray.50",
      _dark: {
        [$bg.variable]: "colors.whiteAlpha.50"
      },
      mb: "-1px",
      _notLast: {
        marginEnd: "-1px"
      },
      _selected: {
        [$bg.variable]: "colors.white",
        [$fg.variable]: `colors.${c}.600`,
        _dark: {
          [$bg.variable]: "colors.gray.800",
          [$fg.variable]: `colors.${c}.300`
        },
        borderColor: "inherit",
        borderTopColor: "currentColor",
        borderBottomColor: "transparent"
      },
      color: $fg.reference,
      bg: $bg.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
});
var variantSoftRounded = definePartsStyle(props => {
  const {
    colorScheme: c,
    theme
  } = props;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      color: "gray.600",
      _selected: {
        color: (0, _themeTools.getColor)(theme, `${c}.700`),
        bg: (0, _themeTools.getColor)(theme, `${c}.100`)
      }
    }
  };
});
var variantSolidRounded = definePartsStyle(props => {
  const {
    colorScheme: c
  } = props;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      [$fg.variable]: "colors.gray.600",
      _dark: {
        [$fg.variable]: "inherit"
      },
      _selected: {
        [$fg.variable]: "colors.white",
        [$bg.variable]: `colors.${c}.600`,
        _dark: {
          [$fg.variable]: "colors.gray.800",
          [$bg.variable]: `colors.${c}.300`
        }
      },
      color: $fg.reference,
      bg: $bg.reference
    }
  };
});
var variantUnstyled = definePartsStyle({});
var variants = {
  line: variantLine,
  enclosed: variantEnclosed,
  "enclosed-colored": variantEnclosedColored,
  "soft-rounded": variantSoftRounded,
  "solid-rounded": variantSolidRounded,
  unstyled: variantUnstyled
};
var tabsTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  variants,
  defaultProps: {
    size: "md",
    variant: "line",
    colorScheme: "blue"
  }
});
exports.tabsTheme = tabsTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"x70Z":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.badgeTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/badge.ts

var baseStyle = (0, _styledSystem.defineStyle)({
  px: 1,
  textTransform: "uppercase",
  fontSize: "xs",
  borderRadius: "sm",
  fontWeight: "bold"
});
var $bg = (0, _styledSystem.cssVar)("badge-bg");
var $fg = (0, _styledSystem.cssVar)("badge-color");
var variantSolid = (0, _styledSystem.defineStyle)(props => {
  const {
    colorScheme: c,
    theme
  } = props;
  const dark = (0, _themeTools.transparentize)(`${c}.500`, 0.6)(theme);
  return {
    [$bg.variable]: `colors.${c}.500`,
    [$fg.variable]: `colors.white`,
    _dark: {
      [$bg.variable]: dark,
      [$fg.variable]: `colors.whiteAlpha.800`
    },
    bg: $bg.reference,
    color: $fg.reference
  };
});
var variantSubtle = (0, _styledSystem.defineStyle)(props => {
  const {
    colorScheme: c,
    theme
  } = props;
  const darkBg = (0, _themeTools.transparentize)(`${c}.200`, 0.16)(theme);
  return {
    [$bg.variable]: `colors.${c}.100`,
    [$fg.variable]: `colors.${c}.800`,
    _dark: {
      [$bg.variable]: darkBg,
      [$fg.variable]: `colors.${c}.200`
    },
    bg: $bg.reference,
    color: $fg.reference
  };
});
var variantOutline = (0, _styledSystem.defineStyle)(props => {
  const {
    colorScheme: c,
    theme
  } = props;
  const darkColor = (0, _themeTools.transparentize)(`${c}.200`, 0.8)(theme);
  return {
    [$fg.variable]: `colors.${c}.500`,
    _dark: {
      [$fg.variable]: darkColor
    },
    color: $fg.reference,
    boxShadow: `inset 0 0 0px 1px ${$fg.reference}`
  };
});
var variants = {
  solid: variantSolid,
  subtle: variantSubtle,
  outline: variantOutline
};
var badgeTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle,
  variants,
  defaultProps: {
    variant: "subtle",
    colorScheme: "gray"
  }
});
exports.badgeTheme = badgeTheme;
},{"@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"XXT2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tagTheme = void 0;
var _chunkUTUD2BXK = require("./chunk-UTUD2BXK.mjs");
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/tag.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.tagAnatomy.keys);
var baseStyleContainer = (0, _styledSystem.defineStyle)({
  fontWeight: "medium",
  lineHeight: 1.2,
  outline: 0,
  borderRadius: "md",
  _focusVisible: {
    boxShadow: "outline"
  }
});
var baseStyleLabel = (0, _styledSystem.defineStyle)({
  lineHeight: 1.2,
  overflow: "visible"
});
var baseStyleCloseButton = (0, _styledSystem.defineStyle)({
  fontSize: "lg",
  w: "5",
  h: "5",
  transitionProperty: "common",
  transitionDuration: "normal",
  borderRadius: "full",
  marginStart: "1.5",
  marginEnd: "-1",
  opacity: 0.5,
  _disabled: {
    opacity: 0.4
  },
  _focusVisible: {
    boxShadow: "outline",
    bg: "rgba(0, 0, 0, 0.14)"
  },
  _hover: {
    opacity: 0.8
  },
  _active: {
    opacity: 1
  }
});
var baseStyle = definePartsStyle({
  container: baseStyleContainer,
  label: baseStyleLabel,
  closeButton: baseStyleCloseButton
});
var sizes = {
  sm: definePartsStyle({
    container: {
      minH: "5",
      minW: "5",
      fontSize: "xs",
      px: "2"
    },
    closeButton: {
      marginEnd: "-2px",
      marginStart: "0.35rem"
    }
  }),
  md: definePartsStyle({
    container: {
      minH: "6",
      minW: "6",
      fontSize: "sm",
      px: "2"
    }
  }),
  lg: definePartsStyle({
    container: {
      minH: "8",
      minW: "8",
      fontSize: "md",
      px: "3"
    }
  })
};
var variants = {
  subtle: definePartsStyle(props => {
    var _a;
    return {
      container: (_a = _chunkUTUD2BXK.badgeTheme.variants) == null ? void 0 : _a.subtle(props)
    };
  }),
  solid: definePartsStyle(props => {
    var _a;
    return {
      container: (_a = _chunkUTUD2BXK.badgeTheme.variants) == null ? void 0 : _a.solid(props)
    };
  }),
  outline: definePartsStyle(props => {
    var _a;
    return {
      container: (_a = _chunkUTUD2BXK.badgeTheme.variants) == null ? void 0 : _a.outline(props)
    };
  })
};
var tagTheme = defineMultiStyleConfig({
  variants,
  baseStyle,
  sizes,
  defaultProps: {
    size: "md",
    variant: "subtle",
    colorScheme: "gray"
  }
});
exports.tagTheme = tagTheme;
},{"./chunk-UTUD2BXK.mjs":"x70Z","@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"Jhk8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inputTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/input.ts

var {
  definePartsStyle,
  defineMultiStyleConfig
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.inputAnatomy.keys);
var baseStyle = definePartsStyle({
  field: {
    width: "100%",
    minWidth: 0,
    outline: 0,
    position: "relative",
    appearance: "none",
    transitionProperty: "common",
    transitionDuration: "normal",
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    }
  }
});
var size = {
  lg: (0, _styledSystem.defineStyle)({
    fontSize: "lg",
    px: "4",
    h: "12",
    borderRadius: "md"
  }),
  md: (0, _styledSystem.defineStyle)({
    fontSize: "md",
    px: "4",
    h: "10",
    borderRadius: "md"
  }),
  sm: (0, _styledSystem.defineStyle)({
    fontSize: "sm",
    px: "3",
    h: "8",
    borderRadius: "sm"
  }),
  xs: (0, _styledSystem.defineStyle)({
    fontSize: "xs",
    px: "2",
    h: "6",
    borderRadius: "sm"
  })
};
var sizes = {
  lg: definePartsStyle({
    field: size.lg,
    addon: size.lg
  }),
  md: definePartsStyle({
    field: size.md,
    addon: size.md
  }),
  sm: definePartsStyle({
    field: size.sm,
    addon: size.sm
  }),
  xs: definePartsStyle({
    field: size.xs,
    addon: size.xs
  })
};
function getDefaults(props) {
  const {
    focusBorderColor: fc,
    errorBorderColor: ec
  } = props;
  return {
    focusBorderColor: fc || (0, _themeTools.mode)("blue.500", "blue.300")(props),
    errorBorderColor: ec || (0, _themeTools.mode)("red.500", "red.300")(props)
  };
}
var variantOutline = definePartsStyle(props => {
  const {
    theme
  } = props;
  const {
    focusBorderColor: fc,
    errorBorderColor: ec
  } = getDefaults(props);
  return {
    field: {
      border: "1px solid",
      borderColor: "inherit",
      bg: "inherit",
      _hover: {
        borderColor: (0, _themeTools.mode)("gray.300", "whiteAlpha.400")(props)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: (0, _themeTools.getColor)(theme, ec),
        boxShadow: `0 0 0 1px ${(0, _themeTools.getColor)(theme, ec)}`
      },
      _focusVisible: {
        zIndex: 1,
        borderColor: (0, _themeTools.getColor)(theme, fc),
        boxShadow: `0 0 0 1px ${(0, _themeTools.getColor)(theme, fc)}`
      }
    },
    addon: {
      border: "1px solid",
      borderColor: (0, _themeTools.mode)("inherit", "whiteAlpha.50")(props),
      bg: (0, _themeTools.mode)("gray.100", "whiteAlpha.300")(props)
    }
  };
});
var variantFilled = definePartsStyle(props => {
  const {
    theme
  } = props;
  const {
    focusBorderColor: fc,
    errorBorderColor: ec
  } = getDefaults(props);
  return {
    field: {
      border: "2px solid",
      borderColor: "transparent",
      bg: (0, _themeTools.mode)("gray.100", "whiteAlpha.50")(props),
      _hover: {
        bg: (0, _themeTools.mode)("gray.200", "whiteAlpha.100")(props)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: (0, _themeTools.getColor)(theme, ec)
      },
      _focusVisible: {
        bg: "transparent",
        borderColor: (0, _themeTools.getColor)(theme, fc)
      }
    },
    addon: {
      border: "2px solid",
      borderColor: "transparent",
      bg: (0, _themeTools.mode)("gray.100", "whiteAlpha.50")(props)
    }
  };
});
var variantFlushed = definePartsStyle(props => {
  const {
    theme
  } = props;
  const {
    focusBorderColor: fc,
    errorBorderColor: ec
  } = getDefaults(props);
  return {
    field: {
      borderBottom: "1px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent",
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: (0, _themeTools.getColor)(theme, ec),
        boxShadow: `0px 1px 0px 0px ${(0, _themeTools.getColor)(theme, ec)}`
      },
      _focusVisible: {
        borderColor: (0, _themeTools.getColor)(theme, fc),
        boxShadow: `0px 1px 0px 0px ${(0, _themeTools.getColor)(theme, fc)}`
      }
    },
    addon: {
      borderBottom: "2px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent"
    }
  };
});
var variantUnstyled = definePartsStyle({
  field: {
    bg: "transparent",
    px: "0",
    height: "auto"
  },
  addon: {
    bg: "transparent",
    px: "0",
    height: "auto"
  }
});
var variants = {
  outline: variantOutline,
  filled: variantFilled,
  flushed: variantFlushed,
  unstyled: variantUnstyled
};
var inputTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  variants,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
});
exports.inputTheme = inputTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"Nr0Z":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.textareaTheme = void 0;
var _chunkWFLWAEKG = require("./chunk-WFLWAEKG.mjs");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/textarea.ts

var _a;
var baseStyle = (0, _styledSystem.defineStyle)({
  ...((_a = _chunkWFLWAEKG.inputTheme.baseStyle) == null ? void 0 : _a.field),
  paddingY: "2",
  minHeight: "20",
  lineHeight: "short",
  verticalAlign: "top"
});
var _a2, _b;
var variants = {
  outline: (0, _styledSystem.defineStyle)(props => {
    var _a4, _b3;
    return (_b3 = (_a4 = _chunkWFLWAEKG.inputTheme.variants) == null ? void 0 : _a4.outline(props).field) != null ? _b3 : {};
  }),
  flushed: (0, _styledSystem.defineStyle)(props => {
    var _a4, _b3;
    return (_b3 = (_a4 = _chunkWFLWAEKG.inputTheme.variants) == null ? void 0 : _a4.flushed(props).field) != null ? _b3 : {};
  }),
  filled: (0, _styledSystem.defineStyle)(props => {
    var _a4, _b3;
    return (_b3 = (_a4 = _chunkWFLWAEKG.inputTheme.variants) == null ? void 0 : _a4.filled(props).field) != null ? _b3 : {};
  }),
  unstyled: (_b = (_a2 = _chunkWFLWAEKG.inputTheme.variants) == null ? void 0 : _a2.unstyled.field) != null ? _b : {}
};
var _a3, _b2, _c, _d, _e, _f, _g, _h;
var sizes = {
  xs: (_b2 = (_a3 = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _a3.xs.field) != null ? _b2 : {},
  sm: (_d = (_c = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _c.sm.field) != null ? _d : {},
  md: (_f = (_e = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _e.md.field) != null ? _f : {},
  lg: (_h = (_g = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _g.lg.field) != null ? _h : {}
};
var textareaTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle,
  sizes,
  variants,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
});
exports.textareaTheme = textareaTheme;
},{"./chunk-WFLWAEKG.mjs":"Jhk8","@chakra-ui/styled-system":"asJy"}],"XkiA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tooltipTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/tooltip.ts

var $bg = (0, _themeTools.cssVar)("tooltip-bg");
var $fg = (0, _themeTools.cssVar)("tooltip-fg");
var $arrowBg = (0, _themeTools.cssVar)("popper-arrow-bg");
var baseStyle = (0, _styledSystem.defineStyle)({
  bg: $bg.reference,
  color: $fg.reference,
  [$bg.variable]: "colors.gray.700",
  [$fg.variable]: "colors.whiteAlpha.900",
  _dark: {
    [$bg.variable]: "colors.gray.300",
    [$fg.variable]: "colors.gray.900"
  },
  [$arrowBg.variable]: $bg.reference,
  px: "2",
  py: "0.5",
  borderRadius: "sm",
  fontWeight: "medium",
  fontSize: "sm",
  boxShadow: "md",
  maxW: "xs",
  zIndex: "tooltip"
});
var tooltipTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle
});
exports.tooltipTheme = tooltipTheme;
},{"@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"K0Fm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.progressTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/progress.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.progressAnatomy.keys);
var filledStyle = (0, _styledSystem.defineStyle)(props => {
  const {
    colorScheme: c,
    theme: t,
    isIndeterminate,
    hasStripe
  } = props;
  const stripeStyle = (0, _themeTools.mode)((0, _themeTools.generateStripe)(), (0, _themeTools.generateStripe)("1rem", "rgba(0,0,0,0.1)"))(props);
  const bgColor = (0, _themeTools.mode)(`${c}.500`, `${c}.200`)(props);
  const gradient = `linear-gradient(
    to right,
    transparent 0%,
    ${(0, _themeTools.getColor)(t, bgColor)} 50%,
    transparent 100%
  )`;
  const addStripe = !isIndeterminate && hasStripe;
  return {
    ...(addStripe && stripeStyle),
    ...(isIndeterminate ? {
      bgImage: gradient
    } : {
      bgColor
    })
  };
});
var baseStyleLabel = (0, _styledSystem.defineStyle)({
  lineHeight: "1",
  fontSize: "0.25em",
  fontWeight: "bold",
  color: "white"
});
var baseStyleTrack = (0, _styledSystem.defineStyle)(props => {
  return {
    bg: (0, _themeTools.mode)("gray.100", "whiteAlpha.300")(props)
  };
});
var baseStyleFilledTrack = (0, _styledSystem.defineStyle)(props => {
  return {
    transitionProperty: "common",
    transitionDuration: "slow",
    ...filledStyle(props)
  };
});
var baseStyle = definePartsStyle(props => ({
  label: baseStyleLabel,
  filledTrack: baseStyleFilledTrack(props),
  track: baseStyleTrack(props)
}));
var sizes = {
  xs: definePartsStyle({
    track: {
      h: "1"
    }
  }),
  sm: definePartsStyle({
    track: {
      h: "2"
    }
  }),
  md: definePartsStyle({
    track: {
      h: "3"
    }
  }),
  lg: definePartsStyle({
    track: {
      h: "4"
    }
  })
};
var progressTheme = defineMultiStyleConfig({
  sizes,
  baseStyle,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
exports.progressTheme = progressTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"isoW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runIfFn = runIfFn;
// src/utils/run-if-fn.ts
var isFunction = value => typeof value === "function";
function runIfFn(valueOrFn, ...args) {
  return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}
},{}],"Av4x":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkboxTheme = void 0;
var _chunkEBS47JIL = require("./chunk-EBS47JIL.mjs");
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/checkbox.ts

var {
  definePartsStyle,
  defineMultiStyleConfig
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.checkboxAnatomy.keys);
var $size = (0, _styledSystem.cssVar)("checkbox-size");
var baseStyleControl = (0, _styledSystem.defineStyle)(props => {
  const {
    colorScheme: c
  } = props;
  return {
    w: $size.reference,
    h: $size.reference,
    transitionProperty: "box-shadow",
    transitionDuration: "normal",
    border: "2px solid",
    borderRadius: "sm",
    borderColor: "inherit",
    color: "white",
    _checked: {
      bg: (0, _themeTools.mode)(`${c}.500`, `${c}.200`)(props),
      borderColor: (0, _themeTools.mode)(`${c}.500`, `${c}.200`)(props),
      color: (0, _themeTools.mode)("white", "gray.900")(props),
      _hover: {
        bg: (0, _themeTools.mode)(`${c}.600`, `${c}.300`)(props),
        borderColor: (0, _themeTools.mode)(`${c}.600`, `${c}.300`)(props)
      },
      _disabled: {
        borderColor: (0, _themeTools.mode)("gray.200", "transparent")(props),
        bg: (0, _themeTools.mode)("gray.200", "whiteAlpha.300")(props),
        color: (0, _themeTools.mode)("gray.500", "whiteAlpha.500")(props)
      }
    },
    _indeterminate: {
      bg: (0, _themeTools.mode)(`${c}.500`, `${c}.200`)(props),
      borderColor: (0, _themeTools.mode)(`${c}.500`, `${c}.200`)(props),
      color: (0, _themeTools.mode)("white", "gray.900")(props)
    },
    _disabled: {
      bg: (0, _themeTools.mode)("gray.100", "whiteAlpha.100")(props),
      borderColor: (0, _themeTools.mode)("gray.100", "transparent")(props)
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _invalid: {
      borderColor: (0, _themeTools.mode)("red.500", "red.300")(props)
    }
  };
});
var baseStyleContainer = (0, _styledSystem.defineStyle)({
  _disabled: {
    cursor: "not-allowed"
  }
});
var baseStyleLabel = (0, _styledSystem.defineStyle)({
  userSelect: "none",
  _disabled: {
    opacity: 0.4
  }
});
var baseStyleIcon = (0, _styledSystem.defineStyle)({
  transitionProperty: "transform",
  transitionDuration: "normal"
});
var baseStyle = definePartsStyle(props => ({
  icon: baseStyleIcon,
  container: baseStyleContainer,
  control: (0, _chunkEBS47JIL.runIfFn)(baseStyleControl, props),
  label: baseStyleLabel
}));
var sizes = {
  sm: definePartsStyle({
    control: {
      [$size.variable]: "sizes.3"
    },
    label: {
      fontSize: "sm"
    },
    icon: {
      fontSize: "3xs"
    }
  }),
  md: definePartsStyle({
    control: {
      [$size.variable]: "sizes.4"
    },
    label: {
      fontSize: "md"
    },
    icon: {
      fontSize: "2xs"
    }
  }),
  lg: definePartsStyle({
    control: {
      [$size.variable]: "sizes.5"
    },
    label: {
      fontSize: "lg"
    },
    icon: {
      fontSize: "2xs"
    }
  })
};
var checkboxTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
exports.checkboxTheme = checkboxTheme;
},{"./chunk-EBS47JIL.mjs":"isoW","@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"lr9M":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.radioTheme = void 0;
var _chunk3XG4KRSA = require("./chunk-3XG4KRSA.mjs");
var _chunkEBS47JIL = require("./chunk-EBS47JIL.mjs");
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/radio.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.radioAnatomy.keys);
var baseStyleControl = (0, _styledSystem.defineStyle)(props => {
  var _a;
  const controlStyle = (_a = (0, _chunkEBS47JIL.runIfFn)(_chunk3XG4KRSA.checkboxTheme.baseStyle, props)) == null ? void 0 : _a.control;
  return {
    ...controlStyle,
    borderRadius: "full",
    _checked: {
      ...(controlStyle == null ? void 0 : controlStyle["_checked"]),
      _before: {
        content: `""`,
        display: "inline-block",
        pos: "relative",
        w: "50%",
        h: "50%",
        borderRadius: "50%",
        bg: "currentColor"
      }
    }
  };
});
var baseStyle = definePartsStyle(props => {
  var _a, _b, _c, _d;
  return {
    label: (_b = (_a = _chunk3XG4KRSA.checkboxTheme).baseStyle) == null ? void 0 : _b.call(_a, props).label,
    container: (_d = (_c = _chunk3XG4KRSA.checkboxTheme).baseStyle) == null ? void 0 : _d.call(_c, props).container,
    control: baseStyleControl(props)
  };
});
var sizes = {
  md: definePartsStyle({
    control: {
      w: "4",
      h: "4"
    },
    label: {
      fontSize: "md"
    }
  }),
  lg: definePartsStyle({
    control: {
      w: "5",
      h: "5"
    },
    label: {
      fontSize: "lg"
    }
  }),
  sm: definePartsStyle({
    control: {
      width: "3",
      height: "3"
    },
    label: {
      fontSize: "sm"
    }
  })
};
var radioTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
exports.radioTheme = radioTheme;
},{"./chunk-3XG4KRSA.mjs":"Av4x","./chunk-EBS47JIL.mjs":"isoW","@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"Qjgu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectTheme = void 0;
var _chunkWFLWAEKG = require("./chunk-WFLWAEKG.mjs");
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/select.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.selectAnatomy.keys);
var $bg = (0, _styledSystem.cssVar)("select-bg");
var _a;
var baseStyleField = (0, _styledSystem.defineStyle)({
  ...((_a = _chunkWFLWAEKG.inputTheme.baseStyle) == null ? void 0 : _a.field),
  appearance: "none",
  paddingBottom: "1px",
  lineHeight: "normal",
  bg: $bg.reference,
  [$bg.variable]: "colors.white",
  _dark: {
    [$bg.variable]: "colors.gray.700"
  },
  "> option, > optgroup": {
    bg: $bg.reference
  }
});
var baseStyleIcon = (0, _styledSystem.defineStyle)({
  width: "6",
  height: "100%",
  insetEnd: "2",
  position: "relative",
  color: "currentColor",
  fontSize: "xl",
  _disabled: {
    opacity: 0.5
  }
});
var baseStyle = definePartsStyle({
  field: baseStyleField,
  icon: baseStyleIcon
});
var iconSpacing = (0, _styledSystem.defineStyle)({
  paddingInlineEnd: "8"
});
var _a2, _b, _c, _d, _e, _f, _g, _h;
var sizes = {
  lg: {
    ...((_a2 = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _a2.lg),
    field: {
      ...((_b = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _b.lg.field),
      ...iconSpacing
    }
  },
  md: {
    ...((_c = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _c.md),
    field: {
      ...((_d = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _d.md.field),
      ...iconSpacing
    }
  },
  sm: {
    ...((_e = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _e.sm),
    field: {
      ...((_f = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _f.sm.field),
      ...iconSpacing
    }
  },
  xs: {
    ...((_g = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _g.xs),
    field: {
      ...((_h = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _h.xs.field),
      ...iconSpacing
    },
    icon: {
      insetEnd: "1"
    }
  }
};
var selectTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  variants: _chunkWFLWAEKG.inputTheme.variants,
  defaultProps: _chunkWFLWAEKG.inputTheme.defaultProps
});
exports.selectTheme = selectTheme;
},{"./chunk-WFLWAEKG.mjs":"Jhk8","@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"dbBx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.skeletonTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/skeleton.ts

var $startColor = (0, _styledSystem.cssVar)("skeleton-start-color");
var $endColor = (0, _styledSystem.cssVar)("skeleton-end-color");
var baseStyle = (0, _styledSystem.defineStyle)({
  [$startColor.variable]: "colors.gray.100",
  [$endColor.variable]: "colors.gray.400",
  _dark: {
    [$startColor.variable]: "colors.gray.800",
    [$endColor.variable]: "colors.gray.600"
  },
  background: $startColor.reference,
  borderColor: $endColor.reference,
  opacity: 0.7,
  borderRadius: "sm"
});
var skeletonTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle
});
exports.skeletonTheme = skeletonTheme;
},{"@chakra-ui/styled-system":"asJy"}],"EUAN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.skipLinkTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/skip-link.ts

var $bg = (0, _styledSystem.cssVar)("skip-link-bg");
var baseStyle = (0, _styledSystem.defineStyle)({
  borderRadius: "md",
  fontWeight: "semibold",
  _focusVisible: {
    boxShadow: "outline",
    padding: "4",
    position: "fixed",
    top: "6",
    insetStart: "6",
    [$bg.variable]: "colors.white",
    _dark: {
      [$bg.variable]: "colors.gray.700"
    },
    bg: $bg.reference
  }
});
var skipLinkTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle
});
exports.skipLinkTheme = skipLinkTheme;
},{"@chakra-ui/styled-system":"asJy"}],"AgTr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sliderTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/slider.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.sliderAnatomy.keys);
var $thumbSize = (0, _styledSystem.cssVar)("slider-thumb-size");
var $trackSize = (0, _styledSystem.cssVar)("slider-track-size");
var $bg = (0, _styledSystem.cssVar)("slider-bg");
var baseStyleContainer = (0, _styledSystem.defineStyle)(props => {
  const {
    orientation
  } = props;
  return {
    display: "inline-block",
    position: "relative",
    cursor: "pointer",
    _disabled: {
      opacity: 0.6,
      cursor: "default",
      pointerEvents: "none"
    },
    ...(0, _themeTools.orient)({
      orientation,
      vertical: {
        h: "100%"
      },
      horizontal: {
        w: "100%"
      }
    })
  };
});
var baseStyleTrack = (0, _styledSystem.defineStyle)(props => {
  const orientationStyles = (0, _themeTools.orient)({
    orientation: props.orientation,
    horizontal: {
      h: $trackSize.reference
    },
    vertical: {
      w: $trackSize.reference
    }
  });
  return {
    ...orientationStyles,
    overflow: "hidden",
    borderRadius: "sm",
    [$bg.variable]: "colors.gray.200",
    _dark: {
      [$bg.variable]: "colors.whiteAlpha.200"
    },
    _disabled: {
      [$bg.variable]: "colors.gray.300",
      _dark: {
        [$bg.variable]: "colors.whiteAlpha.300"
      }
    },
    bg: $bg.reference
  };
});
var baseStyleThumb = (0, _styledSystem.defineStyle)(props => {
  const {
    orientation
  } = props;
  const orientationStyle = (0, _themeTools.orient)({
    orientation,
    vertical: {
      left: "50%",
      transform: `translateX(-50%)`,
      _active: {
        transform: `translateX(-50%) scale(1.15)`
      }
    },
    horizontal: {
      top: "50%",
      transform: `translateY(-50%)`,
      _active: {
        transform: `translateY(-50%) scale(1.15)`
      }
    }
  });
  return {
    ...orientationStyle,
    w: $thumbSize.reference,
    h: $thumbSize.reference,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    outline: 0,
    zIndex: 1,
    borderRadius: "full",
    bg: "white",
    boxShadow: "base",
    border: "1px solid",
    borderColor: "transparent",
    transitionProperty: "transform",
    transitionDuration: "normal",
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      bg: "gray.300"
    }
  };
});
var baseStyleFilledTrack = (0, _styledSystem.defineStyle)(props => {
  const {
    colorScheme: c
  } = props;
  return {
    width: "inherit",
    height: "inherit",
    [$bg.variable]: `colors.${c}.500`,
    _dark: {
      [$bg.variable]: `colors.${c}.200`
    },
    bg: $bg.reference
  };
});
var baseStyle = definePartsStyle(props => ({
  container: baseStyleContainer(props),
  track: baseStyleTrack(props),
  thumb: baseStyleThumb(props),
  filledTrack: baseStyleFilledTrack(props)
}));
var sizeLg = definePartsStyle({
  container: {
    [$thumbSize.variable]: `sizes.4`,
    [$trackSize.variable]: `sizes.1`
  }
});
var sizeMd = definePartsStyle({
  container: {
    [$thumbSize.variable]: `sizes.3.5`,
    [$trackSize.variable]: `sizes.1`
  }
});
var sizeSm = definePartsStyle({
  container: {
    [$thumbSize.variable]: `sizes.2.5`,
    [$trackSize.variable]: `sizes.0.5`
  }
});
var sizes = {
  lg: sizeLg,
  md: sizeMd,
  sm: sizeSm
};
var sliderTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
exports.sliderTheme = sliderTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"HvyO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spinnerTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/spinner.ts

var $size = (0, _themeTools.cssVar)("spinner-size");
var baseStyle = (0, _styledSystem.defineStyle)({
  width: [$size.reference],
  height: [$size.reference]
});
var sizes = {
  xs: (0, _styledSystem.defineStyle)({
    [$size.variable]: "sizes.3"
  }),
  sm: (0, _styledSystem.defineStyle)({
    [$size.variable]: "sizes.4"
  }),
  md: (0, _styledSystem.defineStyle)({
    [$size.variable]: "sizes.6"
  }),
  lg: (0, _styledSystem.defineStyle)({
    [$size.variable]: "sizes.8"
  }),
  xl: (0, _styledSystem.defineStyle)({
    [$size.variable]: "sizes.12"
  })
};
var spinnerTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle,
  sizes,
  defaultProps: {
    size: "md"
  }
});
exports.spinnerTheme = spinnerTheme;
},{"@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"oqsG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.statTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/stat.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.statAnatomy.keys);
var baseStyleLabel = (0, _styledSystem.defineStyle)({
  fontWeight: "medium"
});
var baseStyleHelpText = (0, _styledSystem.defineStyle)({
  opacity: 0.8,
  marginBottom: "2"
});
var baseStyleNumber = (0, _styledSystem.defineStyle)({
  verticalAlign: "baseline",
  fontWeight: "semibold"
});
var baseStyleIcon = (0, _styledSystem.defineStyle)({
  marginEnd: 1,
  w: "3.5",
  h: "3.5",
  verticalAlign: "middle"
});
var baseStyle = definePartsStyle({
  container: {},
  label: baseStyleLabel,
  helpText: baseStyleHelpText,
  number: baseStyleNumber,
  icon: baseStyleIcon
});
var sizes = {
  md: definePartsStyle({
    label: {
      fontSize: "sm"
    },
    helpText: {
      fontSize: "sm"
    },
    number: {
      fontSize: "2xl"
    }
  })
};
var statTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  defaultProps: {
    size: "md"
  }
});
exports.statTheme = statTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"cvmg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.kbdTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/kbd.ts

var $bg = (0, _styledSystem.cssVar)("kbd-bg");
var baseStyle = (0, _styledSystem.defineStyle)({
  [$bg.variable]: "colors.gray.100",
  _dark: {
    [$bg.variable]: "colors.whiteAlpha.100"
  },
  bg: $bg.reference,
  borderRadius: "md",
  borderWidth: "1px",
  borderBottomWidth: "3px",
  fontSize: "0.8em",
  fontWeight: "bold",
  lineHeight: "normal",
  px: "0.4em",
  whiteSpace: "nowrap"
});
var kbdTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle
});
exports.kbdTheme = kbdTheme;
},{"@chakra-ui/styled-system":"asJy"}],"CPSY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linkTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/link.ts

var baseStyle = (0, _styledSystem.defineStyle)({
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  cursor: "pointer",
  textDecoration: "none",
  outline: "none",
  color: "inherit",
  _hover: {
    textDecoration: "underline"
  },
  _focusVisible: {
    boxShadow: "outline"
  }
});
var linkTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle
});
exports.linkTheme = linkTheme;
},{"@chakra-ui/styled-system":"asJy"}],"Bb0Q":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.listTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/list.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.listAnatomy.keys);
var baseStyleIcon = (0, _styledSystem.defineStyle)({
  marginEnd: "2",
  display: "inline",
  verticalAlign: "text-bottom"
});
var baseStyle = definePartsStyle({
  icon: baseStyleIcon
});
var listTheme = defineMultiStyleConfig({
  baseStyle
});
exports.listTheme = listTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"vtD2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.menuTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/menu.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.menuAnatomy.keys);
var $bg = (0, _styledSystem.cssVar)("menu-bg");
var $shadow = (0, _styledSystem.cssVar)("menu-shadow");
var baseStyleList = (0, _styledSystem.defineStyle)({
  [$bg.variable]: "#fff",
  [$shadow.variable]: "shadows.sm",
  _dark: {
    [$bg.variable]: "colors.gray.700",
    [$shadow.variable]: "shadows.dark-lg"
  },
  color: "inherit",
  minW: "3xs",
  py: "2",
  zIndex: 1,
  borderRadius: "md",
  borderWidth: "1px",
  bg: $bg.reference,
  boxShadow: $shadow.reference
});
var baseStyleItem = (0, _styledSystem.defineStyle)({
  py: "1.5",
  px: "3",
  transitionProperty: "background",
  transitionDuration: "ultra-fast",
  transitionTimingFunction: "ease-in",
  _focus: {
    [$bg.variable]: "colors.gray.100",
    _dark: {
      [$bg.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [$bg.variable]: "colors.gray.200",
    _dark: {
      [$bg.variable]: "colors.whiteAlpha.200"
    }
  },
  _expanded: {
    [$bg.variable]: "colors.gray.100",
    _dark: {
      [$bg.variable]: "colors.whiteAlpha.100"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  bg: $bg.reference
});
var baseStyleGroupTitle = (0, _styledSystem.defineStyle)({
  mx: 4,
  my: 2,
  fontWeight: "semibold",
  fontSize: "sm"
});
var baseStyleCommand = (0, _styledSystem.defineStyle)({
  opacity: 0.6
});
var baseStyleDivider = (0, _styledSystem.defineStyle)({
  border: 0,
  borderBottom: "1px solid",
  borderColor: "inherit",
  my: "2",
  opacity: 0.6
});
var baseStyleButton = (0, _styledSystem.defineStyle)({
  transitionProperty: "common",
  transitionDuration: "normal"
});
var baseStyle = definePartsStyle({
  button: baseStyleButton,
  list: baseStyleList,
  item: baseStyleItem,
  groupTitle: baseStyleGroupTitle,
  command: baseStyleCommand,
  divider: baseStyleDivider
});
var menuTheme = defineMultiStyleConfig({
  baseStyle
});
exports.menuTheme = menuTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"nyxv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.modalTheme = void 0;
var _chunkEBS47JIL = require("./chunk-EBS47JIL.mjs");
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/modal.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.modalAnatomy.keys);
var baseStyleOverlay = (0, _styledSystem.defineStyle)({
  bg: "blackAlpha.600",
  zIndex: "modal"
});
var baseStyleDialogContainer = (0, _styledSystem.defineStyle)(props => {
  const {
    isCentered,
    scrollBehavior
  } = props;
  return {
    display: "flex",
    zIndex: "modal",
    justifyContent: "center",
    alignItems: isCentered ? "center" : "flex-start",
    overflow: scrollBehavior === "inside" ? "hidden" : "auto",
    overscrollBehaviorY: "none"
  };
});
var baseStyleDialog = (0, _styledSystem.defineStyle)(props => {
  const {
    scrollBehavior
  } = props;
  return {
    borderRadius: "md",
    bg: (0, _themeTools.mode)("white", "gray.700")(props),
    color: "inherit",
    my: "16",
    zIndex: "modal",
    maxH: scrollBehavior === "inside" ? "calc(100% - 7.5rem)" : void 0,
    boxShadow: (0, _themeTools.mode)("lg", "dark-lg")(props)
  };
});
var baseStyleHeader = (0, _styledSystem.defineStyle)({
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
});
var baseStyleCloseButton = (0, _styledSystem.defineStyle)({
  position: "absolute",
  top: "2",
  insetEnd: "3"
});
var baseStyleBody = (0, _styledSystem.defineStyle)(props => {
  const {
    scrollBehavior
  } = props;
  return {
    px: "6",
    py: "2",
    flex: "1",
    overflow: scrollBehavior === "inside" ? "auto" : void 0
  };
});
var baseStyleFooter = (0, _styledSystem.defineStyle)({
  px: "6",
  py: "4"
});
var baseStyle = definePartsStyle(props => ({
  overlay: baseStyleOverlay,
  dialogContainer: (0, _chunkEBS47JIL.runIfFn)(baseStyleDialogContainer, props),
  dialog: (0, _chunkEBS47JIL.runIfFn)(baseStyleDialog, props),
  header: baseStyleHeader,
  closeButton: baseStyleCloseButton,
  body: (0, _chunkEBS47JIL.runIfFn)(baseStyleBody, props),
  footer: baseStyleFooter
}));
function getSize(value) {
  if (value === "full") {
    return definePartsStyle({
      dialog: {
        maxW: "100vw",
        minH: "$100vh",
        my: "0",
        borderRadius: "0"
      }
    });
  }
  return definePartsStyle({
    dialog: {
      maxW: value
    }
  });
}
var sizes = {
  xs: getSize("xs"),
  sm: getSize("sm"),
  md: getSize("md"),
  lg: getSize("lg"),
  xl: getSize("xl"),
  "2xl": getSize("2xl"),
  "3xl": getSize("3xl"),
  "4xl": getSize("4xl"),
  "5xl": getSize("5xl"),
  "6xl": getSize("6xl"),
  full: getSize("full")
};
var modalTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  defaultProps: {
    size: "md"
  }
});
exports.modalTheme = modalTheme;
},{"./chunk-EBS47JIL.mjs":"isoW","@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"UHqo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.numberInputTheme = void 0;
var _chunkHOOF7HHD = require("./chunk-HOOF7HHD.mjs");
var _chunkWFLWAEKG = require("./chunk-WFLWAEKG.mjs");
var _chunkEBS47JIL = require("./chunk-EBS47JIL.mjs");
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/number-input.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.numberInputAnatomy.keys);
var $stepperWidth = (0, _themeTools.cssVar)("number-input-stepper-width");
var $inputPadding = (0, _themeTools.cssVar)("number-input-input-padding");
var inputPaddingValue = (0, _themeTools.calc)($stepperWidth).add("0.5rem").toString();
var $bg = (0, _themeTools.cssVar)("number-input-bg");
var $fg = (0, _themeTools.cssVar)("number-input-color");
var $border = (0, _themeTools.cssVar)("number-input-border-color");
var baseStyleRoot = (0, _styledSystem.defineStyle)({
  [$stepperWidth.variable]: "sizes.6",
  [$inputPadding.variable]: inputPaddingValue
});
var baseStyleField = (0, _styledSystem.defineStyle)(props => {
  var _a, _b;
  return (_b = (_a = (0, _chunkEBS47JIL.runIfFn)(_chunkWFLWAEKG.inputTheme.baseStyle, props)) == null ? void 0 : _a.field) != null ? _b : {};
});
var baseStyleStepperGroup = (0, _styledSystem.defineStyle)({
  width: $stepperWidth.reference
});
var baseStyleStepper = (0, _styledSystem.defineStyle)({
  borderStart: "1px solid",
  borderStartColor: $border.reference,
  color: $fg.reference,
  bg: $bg.reference,
  [$fg.variable]: "colors.chakra-body-text",
  [$border.variable]: "colors.chakra-border-color",
  _dark: {
    [$fg.variable]: "colors.whiteAlpha.800",
    [$border.variable]: "colors.whiteAlpha.300"
  },
  _active: {
    [$bg.variable]: "colors.gray.200",
    _dark: {
      [$bg.variable]: "colors.whiteAlpha.300"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  }
});
var baseStyle = definePartsStyle(props => {
  var _a;
  return {
    root: baseStyleRoot,
    field: (_a = (0, _chunkEBS47JIL.runIfFn)(baseStyleField, props)) != null ? _a : {},
    stepperGroup: baseStyleStepperGroup,
    stepper: baseStyleStepper
  };
});
function getSize(size) {
  var _a, _b, _c;
  const sizeStyle = (_a = _chunkWFLWAEKG.inputTheme.sizes) == null ? void 0 : _a[size];
  const radius = {
    lg: "md",
    md: "md",
    sm: "sm",
    xs: "sm"
  };
  const _fontSize = (_c = (_b = sizeStyle.field) == null ? void 0 : _b.fontSize) != null ? _c : "md";
  const fontSize = _chunkHOOF7HHD.typography_default.fontSizes[_fontSize];
  return definePartsStyle({
    field: {
      ...sizeStyle.field,
      paddingInlineEnd: $inputPadding.reference,
      verticalAlign: "top"
    },
    stepper: {
      fontSize: (0, _themeTools.calc)(fontSize).multiply(0.75).toString(),
      _first: {
        borderTopEndRadius: radius[size]
      },
      _last: {
        borderBottomEndRadius: radius[size],
        mt: "-1px",
        borderTopWidth: 1
      }
    }
  });
}
var sizes = {
  xs: getSize("xs"),
  sm: getSize("sm"),
  md: getSize("md"),
  lg: getSize("lg")
};
var numberInputTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  variants: _chunkWFLWAEKG.inputTheme.variants,
  defaultProps: _chunkWFLWAEKG.inputTheme.defaultProps
});
exports.numberInputTheme = numberInputTheme;
},{"./chunk-HOOF7HHD.mjs":"Gx0t","./chunk-WFLWAEKG.mjs":"Jhk8","./chunk-EBS47JIL.mjs":"isoW","@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"vOFq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pinInputTheme = void 0;
var _chunkWFLWAEKG = require("./chunk-WFLWAEKG.mjs");
var _chunkEBS47JIL = require("./chunk-EBS47JIL.mjs");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/pin-input.ts

var _a;
var baseStyle = (0, _styledSystem.defineStyle)({
  ...((_a = _chunkWFLWAEKG.inputTheme.baseStyle) == null ? void 0 : _a.field),
  textAlign: "center"
});
var sizes = {
  lg: (0, _styledSystem.defineStyle)({
    fontSize: "lg",
    w: 12,
    h: 12,
    borderRadius: "md"
  }),
  md: (0, _styledSystem.defineStyle)({
    fontSize: "md",
    w: 10,
    h: 10,
    borderRadius: "md"
  }),
  sm: (0, _styledSystem.defineStyle)({
    fontSize: "sm",
    w: 8,
    h: 8,
    borderRadius: "sm"
  }),
  xs: (0, _styledSystem.defineStyle)({
    fontSize: "xs",
    w: 6,
    h: 6,
    borderRadius: "sm"
  })
};
var _a2, _b;
var variants = {
  outline: (0, _styledSystem.defineStyle)(props => {
    var _a3, _b2, _c;
    return (_c = (_b2 = (0, _chunkEBS47JIL.runIfFn)((_a3 = _chunkWFLWAEKG.inputTheme.variants) == null ? void 0 : _a3.outline, props)) == null ? void 0 : _b2.field) != null ? _c : {};
  }),
  flushed: (0, _styledSystem.defineStyle)(props => {
    var _a3, _b2, _c;
    return (_c = (_b2 = (0, _chunkEBS47JIL.runIfFn)((_a3 = _chunkWFLWAEKG.inputTheme.variants) == null ? void 0 : _a3.flushed, props)) == null ? void 0 : _b2.field) != null ? _c : {};
  }),
  filled: (0, _styledSystem.defineStyle)(props => {
    var _a3, _b2, _c;
    return (_c = (_b2 = (0, _chunkEBS47JIL.runIfFn)((_a3 = _chunkWFLWAEKG.inputTheme.variants) == null ? void 0 : _a3.filled, props)) == null ? void 0 : _b2.field) != null ? _c : {};
  }),
  unstyled: (_b = (_a2 = _chunkWFLWAEKG.inputTheme.variants) == null ? void 0 : _a2.unstyled.field) != null ? _b : {}
};
var pinInputTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle,
  sizes,
  variants,
  defaultProps: _chunkWFLWAEKG.inputTheme.defaultProps
});
exports.pinInputTheme = pinInputTheme;
},{"./chunk-WFLWAEKG.mjs":"Jhk8","./chunk-EBS47JIL.mjs":"isoW","@chakra-ui/styled-system":"asJy"}],"CCrX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.popoverTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/popover.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.popoverAnatomy.keys);
var $popperBg = (0, _themeTools.cssVar)("popper-bg");
var $arrowBg = (0, _themeTools.cssVar)("popper-arrow-bg");
var $arrowShadowColor = (0, _themeTools.cssVar)("popper-arrow-shadow-color");
var baseStylePopper = (0, _styledSystem.defineStyle)({
  zIndex: 10
});
var baseStyleContent = (0, _styledSystem.defineStyle)({
  [$popperBg.variable]: `colors.white`,
  bg: $popperBg.reference,
  [$arrowBg.variable]: $popperBg.reference,
  [$arrowShadowColor.variable]: `colors.gray.200`,
  _dark: {
    [$popperBg.variable]: `colors.gray.700`,
    [$arrowShadowColor.variable]: `colors.whiteAlpha.300`
  },
  width: "xs",
  border: "1px solid",
  borderColor: "inherit",
  borderRadius: "md",
  boxShadow: "sm",
  zIndex: "inherit",
  _focusVisible: {
    outline: 0,
    boxShadow: "outline"
  }
});
var baseStyleHeader = (0, _styledSystem.defineStyle)({
  px: 3,
  py: 2,
  borderBottomWidth: "1px"
});
var baseStyleBody = (0, _styledSystem.defineStyle)({
  px: 3,
  py: 2
});
var baseStyleFooter = (0, _styledSystem.defineStyle)({
  px: 3,
  py: 2,
  borderTopWidth: "1px"
});
var baseStyleCloseButton = (0, _styledSystem.defineStyle)({
  position: "absolute",
  borderRadius: "md",
  top: 1,
  insetEnd: 2,
  padding: 2
});
var baseStyle = definePartsStyle({
  popper: baseStylePopper,
  content: baseStyleContent,
  header: baseStyleHeader,
  body: baseStyleBody,
  footer: baseStyleFooter,
  closeButton: baseStyleCloseButton
});
var popoverTheme = defineMultiStyleConfig({
  baseStyle
});
exports.popoverTheme = popoverTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"xDw3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawerTheme = void 0;
var _chunkEBS47JIL = require("./chunk-EBS47JIL.mjs");
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/drawer.ts

var {
  definePartsStyle,
  defineMultiStyleConfig
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.drawerAnatomy.keys);
var $bg = (0, _styledSystem.cssVar)("drawer-bg");
var $bs = (0, _styledSystem.cssVar)("drawer-box-shadow");
function getSize(value) {
  if (value === "full") {
    return definePartsStyle({
      dialog: {
        maxW: "100vw",
        h: "100vh"
      }
    });
  }
  return definePartsStyle({
    dialog: {
      maxW: value
    }
  });
}
var baseStyleOverlay = (0, _styledSystem.defineStyle)({
  bg: "blackAlpha.600",
  zIndex: "overlay"
});
var baseStyleDialogContainer = (0, _styledSystem.defineStyle)({
  display: "flex",
  zIndex: "modal",
  justifyContent: "center"
});
var baseStyleDialog = (0, _styledSystem.defineStyle)(props => {
  const {
    isFullHeight
  } = props;
  return {
    ...(isFullHeight && {
      height: "100vh"
    }),
    zIndex: "modal",
    maxH: "100vh",
    color: "inherit",
    [$bg.variable]: "colors.white",
    [$bs.variable]: "shadows.lg",
    _dark: {
      [$bg.variable]: "colors.gray.700",
      [$bs.variable]: "shadows.dark-lg"
    },
    bg: $bg.reference,
    boxShadow: $bs.reference
  };
});
var baseStyleHeader = (0, _styledSystem.defineStyle)({
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
});
var baseStyleCloseButton = (0, _styledSystem.defineStyle)({
  position: "absolute",
  top: "2",
  insetEnd: "3"
});
var baseStyleBody = (0, _styledSystem.defineStyle)({
  px: "6",
  py: "2",
  flex: "1",
  overflow: "auto"
});
var baseStyleFooter = (0, _styledSystem.defineStyle)({
  px: "6",
  py: "4"
});
var baseStyle = definePartsStyle(props => ({
  overlay: baseStyleOverlay,
  dialogContainer: baseStyleDialogContainer,
  dialog: (0, _chunkEBS47JIL.runIfFn)(baseStyleDialog, props),
  header: baseStyleHeader,
  closeButton: baseStyleCloseButton,
  body: baseStyleBody,
  footer: baseStyleFooter
}));
var sizes = {
  xs: getSize("xs"),
  sm: getSize("md"),
  md: getSize("lg"),
  lg: getSize("2xl"),
  xl: getSize("4xl"),
  full: getSize("full")
};
var drawerTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  defaultProps: {
    size: "xs"
  }
});
exports.drawerTheme = drawerTheme;
},{"./chunk-EBS47JIL.mjs":"isoW","@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"a1kl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.editableTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/editable.ts

var {
  definePartsStyle,
  defineMultiStyleConfig
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.editableAnatomy.keys);
var baseStylePreview = (0, _styledSystem.defineStyle)({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal"
});
var baseStyleInput = (0, _styledSystem.defineStyle)({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: {
    boxShadow: "outline"
  },
  _placeholder: {
    opacity: 0.6
  }
});
var baseStyleTextarea = (0, _styledSystem.defineStyle)({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: {
    boxShadow: "outline"
  },
  _placeholder: {
    opacity: 0.6
  }
});
var baseStyle = definePartsStyle({
  preview: baseStylePreview,
  input: baseStyleInput,
  textarea: baseStyleTextarea
});
var editableTheme = defineMultiStyleConfig({
  baseStyle
});
exports.editableTheme = editableTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"BXzG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/form-control.ts

var {
  definePartsStyle,
  defineMultiStyleConfig
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.formAnatomy.keys);
var $fg = (0, _styledSystem.cssVar)("form-control-color");
var baseStyleRequiredIndicator = (0, _styledSystem.defineStyle)({
  marginStart: "1",
  [$fg.variable]: "colors.red.500",
  _dark: {
    [$fg.variable]: "colors.red.300"
  },
  color: $fg.reference
});
var baseStyleHelperText = (0, _styledSystem.defineStyle)({
  mt: "2",
  [$fg.variable]: "colors.gray.600",
  _dark: {
    [$fg.variable]: "colors.whiteAlpha.600"
  },
  color: $fg.reference,
  lineHeight: "normal",
  fontSize: "sm"
});
var baseStyle = definePartsStyle({
  container: {
    width: "100%",
    position: "relative"
  },
  requiredIndicator: baseStyleRequiredIndicator,
  helperText: baseStyleHelperText
});
var formTheme = defineMultiStyleConfig({
  baseStyle
});
exports.formTheme = formTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"PrQI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formErrorTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/form-error.ts

var {
  definePartsStyle,
  defineMultiStyleConfig
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.formErrorAnatomy.keys);
var $fg = (0, _styledSystem.cssVar)("form-error-color");
var baseStyleText = (0, _styledSystem.defineStyle)({
  [$fg.variable]: `colors.red.500`,
  _dark: {
    [$fg.variable]: `colors.red.300`
  },
  color: $fg.reference,
  mt: "2",
  fontSize: "sm",
  lineHeight: "normal"
});
var baseStyleIcon = (0, _styledSystem.defineStyle)({
  marginEnd: "0.5em",
  [$fg.variable]: `colors.red.500`,
  _dark: {
    [$fg.variable]: `colors.red.300`
  },
  color: $fg.reference
});
var baseStyle = definePartsStyle({
  text: baseStyleText,
  icon: baseStyleIcon
});
var formErrorTheme = defineMultiStyleConfig({
  baseStyle
});
exports.formErrorTheme = formErrorTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"Naby":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formLabelTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/form-label.ts

var baseStyle = (0, _styledSystem.defineStyle)({
  fontSize: "md",
  marginEnd: "3",
  mb: "2",
  fontWeight: "medium",
  transitionProperty: "common",
  transitionDuration: "normal",
  opacity: 1,
  _disabled: {
    opacity: 0.4
  }
});
var formLabelTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle
});
exports.formLabelTheme = formLabelTheme;
},{"@chakra-ui/styled-system":"asJy"}],"z8JN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.headingTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/heading.ts

var baseStyle = (0, _styledSystem.defineStyle)({
  fontFamily: "heading",
  fontWeight: "bold"
});
var sizes = {
  "4xl": (0, _styledSystem.defineStyle)({
    fontSize: ["6xl", null, "7xl"],
    lineHeight: 1
  }),
  "3xl": (0, _styledSystem.defineStyle)({
    fontSize: ["5xl", null, "6xl"],
    lineHeight: 1
  }),
  "2xl": (0, _styledSystem.defineStyle)({
    fontSize: ["4xl", null, "5xl"],
    lineHeight: [1.2, null, 1]
  }),
  xl: (0, _styledSystem.defineStyle)({
    fontSize: ["3xl", null, "4xl"],
    lineHeight: [1.33, null, 1.2]
  }),
  lg: (0, _styledSystem.defineStyle)({
    fontSize: ["2xl", null, "3xl"],
    lineHeight: [1.33, null, 1.2]
  }),
  md: (0, _styledSystem.defineStyle)({
    fontSize: "xl",
    lineHeight: 1.2
  }),
  sm: (0, _styledSystem.defineStyle)({
    fontSize: "md",
    lineHeight: 1.2
  }),
  xs: (0, _styledSystem.defineStyle)({
    fontSize: "sm",
    lineHeight: 1.2
  })
};
var headingTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle,
  sizes,
  defaultProps: {
    size: "xl"
  }
});
exports.headingTheme = headingTheme;
},{"@chakra-ui/styled-system":"asJy"}],"OJpn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.breadcrumbTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/breadcrumb.ts

var {
  defineMultiStyleConfig,
  definePartsStyle
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.breadcrumbAnatomy.keys);
var baseStyleLink = (0, _styledSystem.defineStyle)({
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  cursor: "pointer",
  textDecoration: "none",
  outline: "none",
  color: "inherit",
  _hover: {
    textDecoration: "underline"
  },
  _focusVisible: {
    boxShadow: "outline"
  }
});
var baseStyle = definePartsStyle({
  link: baseStyleLink
});
var breadcrumbTheme = defineMultiStyleConfig({
  baseStyle
});
exports.breadcrumbTheme = breadcrumbTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"E1Uy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buttonTheme = void 0;
var _chunkEBS47JIL = require("./chunk-EBS47JIL.mjs");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/button.ts

var baseStyle = (0, _styledSystem.defineStyle)({
  lineHeight: "1.2",
  borderRadius: "md",
  fontWeight: "semibold",
  transitionProperty: "common",
  transitionDuration: "normal",
  _focusVisible: {
    boxShadow: "outline"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    _disabled: {
      bg: "initial"
    }
  }
});
var variantGhost = (0, _styledSystem.defineStyle)(props => {
  const {
    colorScheme: c,
    theme
  } = props;
  if (c === "gray") {
    return {
      color: (0, _themeTools.mode)(`inherit`, `whiteAlpha.900`)(props),
      _hover: {
        bg: (0, _themeTools.mode)(`gray.100`, `whiteAlpha.200`)(props)
      },
      _active: {
        bg: (0, _themeTools.mode)(`gray.200`, `whiteAlpha.300`)(props)
      }
    };
  }
  const darkHoverBg = (0, _themeTools.transparentize)(`${c}.200`, 0.12)(theme);
  const darkActiveBg = (0, _themeTools.transparentize)(`${c}.200`, 0.24)(theme);
  return {
    color: (0, _themeTools.mode)(`${c}.600`, `${c}.200`)(props),
    bg: "transparent",
    _hover: {
      bg: (0, _themeTools.mode)(`${c}.50`, darkHoverBg)(props)
    },
    _active: {
      bg: (0, _themeTools.mode)(`${c}.100`, darkActiveBg)(props)
    }
  };
});
var variantOutline = (0, _styledSystem.defineStyle)(props => {
  const {
    colorScheme: c
  } = props;
  const borderColor = (0, _themeTools.mode)(`gray.200`, `whiteAlpha.300`)(props);
  return {
    border: "1px solid",
    borderColor: c === "gray" ? borderColor : "currentColor",
    ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": {
      marginEnd: "-1px"
    },
    ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": {
      marginBottom: "-1px"
    },
    ...(0, _chunkEBS47JIL.runIfFn)(variantGhost, props)
  };
});
var accessibleColorMap = {
  yellow: {
    bg: "yellow.400",
    color: "black",
    hoverBg: "yellow.500",
    activeBg: "yellow.600"
  },
  cyan: {
    bg: "cyan.400",
    color: "black",
    hoverBg: "cyan.500",
    activeBg: "cyan.600"
  }
};
var variantSolid = (0, _styledSystem.defineStyle)(props => {
  var _a;
  const {
    colorScheme: c
  } = props;
  if (c === "gray") {
    const bg2 = (0, _themeTools.mode)(`gray.100`, `whiteAlpha.200`)(props);
    return {
      bg: bg2,
      _hover: {
        bg: (0, _themeTools.mode)(`gray.200`, `whiteAlpha.300`)(props),
        _disabled: {
          bg: bg2
        }
      },
      _active: {
        bg: (0, _themeTools.mode)(`gray.300`, `whiteAlpha.400`)(props)
      }
    };
  }
  const {
    bg = `${c}.500`,
    color = "white",
    hoverBg = `${c}.600`,
    activeBg = `${c}.700`
  } = (_a = accessibleColorMap[c]) != null ? _a : {};
  const background = (0, _themeTools.mode)(bg, `${c}.200`)(props);
  return {
    bg: background,
    color: (0, _themeTools.mode)(color, `gray.800`)(props),
    _hover: {
      bg: (0, _themeTools.mode)(hoverBg, `${c}.300`)(props),
      _disabled: {
        bg: background
      }
    },
    _active: {
      bg: (0, _themeTools.mode)(activeBg, `${c}.400`)(props)
    }
  };
});
var variantLink = (0, _styledSystem.defineStyle)(props => {
  const {
    colorScheme: c
  } = props;
  return {
    padding: 0,
    height: "auto",
    lineHeight: "normal",
    verticalAlign: "baseline",
    color: (0, _themeTools.mode)(`${c}.500`, `${c}.200`)(props),
    _hover: {
      textDecoration: "underline",
      _disabled: {
        textDecoration: "none"
      }
    },
    _active: {
      color: (0, _themeTools.mode)(`${c}.700`, `${c}.500`)(props)
    }
  };
});
var variantUnstyled = (0, _styledSystem.defineStyle)({
  bg: "none",
  color: "inherit",
  display: "inline",
  lineHeight: "inherit",
  m: "0",
  p: "0"
});
var variants = {
  ghost: variantGhost,
  outline: variantOutline,
  solid: variantSolid,
  link: variantLink,
  unstyled: variantUnstyled
};
var sizes = {
  lg: (0, _styledSystem.defineStyle)({
    h: "12",
    minW: "12",
    fontSize: "lg",
    px: "6"
  }),
  md: (0, _styledSystem.defineStyle)({
    h: "10",
    minW: "10",
    fontSize: "md",
    px: "4"
  }),
  sm: (0, _styledSystem.defineStyle)({
    h: "8",
    minW: "8",
    fontSize: "sm",
    px: "3"
  }),
  xs: (0, _styledSystem.defineStyle)({
    h: "6",
    minW: "6",
    fontSize: "xs",
    px: "2"
  })
};
var buttonTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle,
  variants,
  sizes,
  defaultProps: {
    variant: "solid",
    size: "md",
    colorScheme: "gray"
  }
});
exports.buttonTheme = buttonTheme;
},{"./chunk-EBS47JIL.mjs":"isoW","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"rFqp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cardTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/card.ts

var {
  definePartsStyle,
  defineMultiStyleConfig
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.cardAnatomy.keys);
var $bg = (0, _styledSystem.cssVar)("card-bg");
var $padding = (0, _styledSystem.cssVar)("card-padding");
var baseStyle = definePartsStyle({
  container: {
    [$bg.variable]: "chakra-body-bg",
    backgroundColor: $bg.reference,
    color: "chakra-body-text"
  },
  body: {
    padding: $padding.reference,
    flex: "1 1 0%"
  },
  header: {
    padding: $padding.reference
  },
  footer: {
    padding: $padding.reference
  }
});
var sizes = {
  sm: definePartsStyle({
    container: {
      borderRadius: "base",
      [$padding.variable]: "space.3"
    }
  }),
  md: definePartsStyle({
    container: {
      borderRadius: "md",
      [$padding.variable]: "space.5"
    }
  }),
  lg: definePartsStyle({
    container: {
      borderRadius: "xl",
      [$padding.variable]: "space.7"
    }
  })
};
var variants = {
  elevated: definePartsStyle({
    container: {
      boxShadow: "base",
      _dark: {
        [$bg.variable]: "colors.gray.700"
      }
    }
  }),
  outline: definePartsStyle({
    container: {
      borderWidth: "1px",
      borderColor: "chakra-border-color"
    }
  }),
  filled: definePartsStyle({
    container: {
      [$bg.variable]: "colors.chakra-subtle-bg"
    }
  }),
  unstyled: {
    body: {
      padding: 0
    },
    header: {
      padding: 0
    },
    footer: {
      padding: 0
    }
  }
};
var cardTheme = defineMultiStyleConfig({
  baseStyle,
  variants,
  sizes,
  defaultProps: {
    variant: "elevated",
    size: "md"
  }
});
exports.cardTheme = cardTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"FyLI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.closeButtonTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/close-button.ts

var $size = (0, _themeTools.cssVar)("close-button-size");
var $bg = (0, _themeTools.cssVar)("close-button-bg");
var baseStyle = (0, _styledSystem.defineStyle)({
  w: [$size.reference],
  h: [$size.reference],
  borderRadius: "md",
  transitionProperty: "common",
  transitionDuration: "normal",
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    [$bg.variable]: "colors.blackAlpha.100",
    _dark: {
      [$bg.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [$bg.variable]: "colors.blackAlpha.200",
    _dark: {
      [$bg.variable]: "colors.whiteAlpha.200"
    }
  },
  _focusVisible: {
    boxShadow: "outline"
  },
  bg: $bg.reference
});
var sizes = {
  lg: (0, _styledSystem.defineStyle)({
    [$size.variable]: "sizes.10",
    fontSize: "md"
  }),
  md: (0, _styledSystem.defineStyle)({
    [$size.variable]: "sizes.8",
    fontSize: "xs"
  }),
  sm: (0, _styledSystem.defineStyle)({
    [$size.variable]: "sizes.6",
    fontSize: "2xs"
  })
};
var closeButtonTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle,
  sizes,
  defaultProps: {
    size: "md"
  }
});
exports.closeButtonTheme = closeButtonTheme;
},{"@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"vBay":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.codeTheme = void 0;
var _chunkUTUD2BXK = require("./chunk-UTUD2BXK.mjs");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/code.ts

var {
  variants,
  defaultProps
} = _chunkUTUD2BXK.badgeTheme;
var baseStyle = (0, _styledSystem.defineStyle)({
  fontFamily: "mono",
  fontSize: "sm",
  px: "0.2em",
  borderRadius: "sm"
});
var codeTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle,
  variants,
  defaultProps
});
exports.codeTheme = codeTheme;
},{"./chunk-UTUD2BXK.mjs":"x70Z","@chakra-ui/styled-system":"asJy"}],"pRDP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.containerTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/container.ts

var baseStyle = (0, _styledSystem.defineStyle)({
  w: "100%",
  mx: "auto",
  maxW: "prose",
  px: "4"
});
var containerTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle
});
exports.containerTheme = containerTheme;
},{"@chakra-ui/styled-system":"asJy"}],"mpzZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dividerTheme = void 0;
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/divider.ts

var baseStyle = (0, _styledSystem.defineStyle)({
  opacity: 0.6,
  borderColor: "inherit"
});
var variantSolid = (0, _styledSystem.defineStyle)({
  borderStyle: "solid"
});
var variantDashed = (0, _styledSystem.defineStyle)({
  borderStyle: "dashed"
});
var variants = {
  solid: variantSolid,
  dashed: variantDashed
};
var dividerTheme = (0, _styledSystem.defineStyleConfig)({
  baseStyle,
  variants,
  defaultProps: {
    variant: "solid"
  }
});
exports.dividerTheme = dividerTheme;
},{"@chakra-ui/styled-system":"asJy"}],"TEBj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.accordionTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
// src/components/accordion.ts

var {
  definePartsStyle,
  defineMultiStyleConfig
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.accordionAnatomy.keys);
var baseStyleContainer = (0, _styledSystem.defineStyle)({
  borderTopWidth: "1px",
  borderColor: "inherit",
  _last: {
    borderBottomWidth: "1px"
  }
});
var baseStyleButton = (0, _styledSystem.defineStyle)({
  transitionProperty: "common",
  transitionDuration: "normal",
  fontSize: "md",
  _focusVisible: {
    boxShadow: "outline"
  },
  _hover: {
    bg: "blackAlpha.50"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  px: "4",
  py: "2"
});
var baseStylePanel = (0, _styledSystem.defineStyle)({
  pt: "2",
  px: "4",
  pb: "5"
});
var baseStyleIcon = (0, _styledSystem.defineStyle)({
  fontSize: "1.25em"
});
var baseStyle = definePartsStyle({
  container: baseStyleContainer,
  button: baseStyleButton,
  panel: baseStylePanel,
  icon: baseStyleIcon
});
var accordionTheme = defineMultiStyleConfig({
  baseStyle
});
exports.accordionTheme = accordionTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy"}],"GwXK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.alertTheme = void 0;
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/alert.ts

var {
  definePartsStyle,
  defineMultiStyleConfig
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.alertAnatomy.keys);
var $fg = (0, _styledSystem.cssVar)("alert-fg");
var $bg = (0, _styledSystem.cssVar)("alert-bg");
var baseStyle = definePartsStyle({
  container: {
    bg: $bg.reference,
    px: "4",
    py: "3"
  },
  title: {
    fontWeight: "bold",
    lineHeight: "6",
    marginEnd: "2"
  },
  description: {
    lineHeight: "6"
  },
  icon: {
    color: $fg.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "6"
  },
  spinner: {
    color: $fg.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "5"
  }
});
function getBg(props) {
  const {
    theme,
    colorScheme: c
  } = props;
  const darkBg = (0, _themeTools.transparentize)(`${c}.200`, 0.16)(theme);
  return {
    light: `colors.${c}.100`,
    dark: darkBg
  };
}
var variantSubtle = definePartsStyle(props => {
  const {
    colorScheme: c
  } = props;
  const bg = getBg(props);
  return {
    container: {
      [$fg.variable]: `colors.${c}.500`,
      [$bg.variable]: bg.light,
      _dark: {
        [$fg.variable]: `colors.${c}.200`,
        [$bg.variable]: bg.dark
      }
    }
  };
});
var variantLeftAccent = definePartsStyle(props => {
  const {
    colorScheme: c
  } = props;
  const bg = getBg(props);
  return {
    container: {
      [$fg.variable]: `colors.${c}.500`,
      [$bg.variable]: bg.light,
      _dark: {
        [$fg.variable]: `colors.${c}.200`,
        [$bg.variable]: bg.dark
      },
      paddingStart: "3",
      borderStartWidth: "4px",
      borderStartColor: $fg.reference
    }
  };
});
var variantTopAccent = definePartsStyle(props => {
  const {
    colorScheme: c
  } = props;
  const bg = getBg(props);
  return {
    container: {
      [$fg.variable]: `colors.${c}.500`,
      [$bg.variable]: bg.light,
      _dark: {
        [$fg.variable]: `colors.${c}.200`,
        [$bg.variable]: bg.dark
      },
      pt: "2",
      borderTopWidth: "4px",
      borderTopColor: $fg.reference
    }
  };
});
var variantSolid = definePartsStyle(props => {
  const {
    colorScheme: c
  } = props;
  return {
    container: {
      [$fg.variable]: `colors.white`,
      [$bg.variable]: `colors.${c}.500`,
      _dark: {
        [$fg.variable]: `colors.gray.900`,
        [$bg.variable]: `colors.${c}.200`
      },
      color: $fg.reference
    }
  };
});
var variants = {
  subtle: variantSubtle,
  "left-accent": variantLeftAccent,
  "top-accent": variantTopAccent,
  solid: variantSolid
};
var alertTheme = defineMultiStyleConfig({
  baseStyle,
  variants,
  defaultProps: {
    variant: "subtle",
    colorScheme: "blue"
  }
});
exports.alertTheme = alertTheme;
},{"@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"ppFM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.avatarTheme = void 0;
var _chunkX4JBRTE = require("./chunk-X4JBRTE2.mjs");
var _chunkEBS47JIL = require("./chunk-EBS47JIL.mjs");
var _anatomy = require("@chakra-ui/anatomy");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeTools = require("@chakra-ui/theme-tools");
// src/components/avatar.ts

var {
  definePartsStyle,
  defineMultiStyleConfig
} = (0, _styledSystem.createMultiStyleConfigHelpers)(_anatomy.avatarAnatomy.keys);
var $border = (0, _styledSystem.cssVar)("avatar-border-color");
var $bg = (0, _styledSystem.cssVar)("avatar-bg");
var baseStyleBadge = (0, _styledSystem.defineStyle)({
  borderRadius: "full",
  border: "0.2em solid",
  [$border.variable]: "white",
  _dark: {
    [$border.variable]: "colors.gray.800"
  },
  borderColor: $border.reference
});
var baseStyleExcessLabel = (0, _styledSystem.defineStyle)({
  [$bg.variable]: "colors.gray.200",
  _dark: {
    [$bg.variable]: "colors.whiteAlpha.400"
  },
  bgColor: $bg.reference
});
var $avatarBg = (0, _styledSystem.cssVar)("avatar-background");
var baseStyleContainer = (0, _styledSystem.defineStyle)(props => {
  const {
    name,
    theme
  } = props;
  const bg = name ? (0, _themeTools.randomColor)({
    string: name
  }) : "colors.gray.400";
  const isBgDark = (0, _themeTools.isDark)(bg)(theme);
  let color = "white";
  if (!isBgDark) color = "gray.800";
  return {
    bg: $avatarBg.reference,
    "&:not([data-loaded])": {
      [$avatarBg.variable]: bg
    },
    color,
    [$border.variable]: "colors.white",
    _dark: {
      [$border.variable]: "colors.gray.800"
    },
    borderColor: $border.reference,
    verticalAlign: "top"
  };
});
var baseStyle = definePartsStyle(props => ({
  badge: (0, _chunkEBS47JIL.runIfFn)(baseStyleBadge, props),
  excessLabel: (0, _chunkEBS47JIL.runIfFn)(baseStyleExcessLabel, props),
  container: (0, _chunkEBS47JIL.runIfFn)(baseStyleContainer, props)
}));
function getSize(size) {
  const themeSize = size !== "100%" ? _chunkX4JBRTE.sizes_default[size] : void 0;
  return definePartsStyle({
    container: {
      width: size,
      height: size,
      fontSize: `calc(${themeSize != null ? themeSize : size} / 2.5)`
    },
    excessLabel: {
      width: size,
      height: size
    },
    label: {
      fontSize: `calc(${themeSize != null ? themeSize : size} / 2.5)`,
      lineHeight: size !== "100%" ? themeSize != null ? themeSize : size : void 0
    }
  });
}
var sizes = {
  "2xs": getSize(4),
  xs: getSize(6),
  sm: getSize(8),
  md: getSize(12),
  lg: getSize(16),
  xl: getSize(24),
  "2xl": getSize(32),
  full: getSize("100%")
};
var avatarTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  defaultProps: {
    size: "md"
  }
});
exports.avatarTheme = avatarTheme;
},{"./chunk-X4JBRTE2.mjs":"HfnR","./chunk-EBS47JIL.mjs":"isoW","@chakra-ui/anatomy":"WJBG","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-tools":"TjB8"}],"nV6y":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.components = void 0;
var _chunkKGFPXNP = require("./chunk-KGFPXNP4.mjs");
var _chunkWHSEAAWU = require("./chunk-WHSEAAWU.mjs");
var _chunkRBQSCDLK = require("./chunk-RBQSCDLK.mjs");
var _chunkJWDMXB2N = require("./chunk-JWDMXB2N.mjs");
var _chunkOIGZPHLT = require("./chunk-OIGZPHLT.mjs");
var _chunk6Y3UQESG = require("./chunk-6Y3UQESG.mjs");
var _chunkVGCCECBM = require("./chunk-VGCCECBM.mjs");
var _chunkJDPWIQ7H = require("./chunk-JDPWIQ7H.mjs");
var _chunkV3RHVDKJ = require("./chunk-V3RHVDKJ.mjs");
var _chunkYSULOCDF = require("./chunk-YSULOCDF.mjs");
var _chunkRSEFU3LC = require("./chunk-RSEFU3LC.mjs");
var _chunkIBL46MNN = require("./chunk-IBL46MNN.mjs");
var _chunkY6RR3LE = require("./chunk-Y6RR3LE6.mjs");
var _chunkEY6ACYQS = require("./chunk-EY6ACYQS.mjs");
var _chunkVQ2DUS6J = require("./chunk-VQ2DUS6J.mjs");
var _chunk2T5TO72C = require("./chunk-2T5TO72C.mjs");
var _chunkAQJ6AIMN = require("./chunk-AQJ6AIMN.mjs");
var _chunkFIWRYWVW = require("./chunk-FIWRYWVW.mjs");
var _chunkHCMWF4U = require("./chunk-HCMWF4U4.mjs");
var _chunkXNRZTTJ = require("./chunk-XNRZTTJ2.mjs");
var _chunkQW3Z4V = require("./chunk-QW3Z4V42.mjs");
var _chunkYJYMWHG = require("./chunk-YJYMWHG4.mjs");
var _chunkPQSF5PVS = require("./chunk-PQSF5PVS.mjs");
var _chunkYZVOF4MP = require("./chunk-YZVOF4MP.mjs");
var _chunkRUW3STUO = require("./chunk-RUW3STUO.mjs");
var _chunkD55YRTLZ = require("./chunk-D55YRTLZ.mjs");
var _chunkOYCZTG3L = require("./chunk-OYCZTG3L.mjs");
var _chunkX4O3JXYB = require("./chunk-X4O3JXYB.mjs");
var _chunkWFLWAEKG = require("./chunk-WFLWAEKG.mjs");
var _chunkGLS227WS = require("./chunk-GLS227WS.mjs");
var _chunkAP3MTUHH = require("./chunk-AP3MTUHH.mjs");
var _chunk6K6YYJ2N = require("./chunk-6K6YYJ2N.mjs");
var _chunk3XG4KRSA = require("./chunk-3XG4KRSA.mjs");
var _chunkC4P5PUHY = require("./chunk-C4P5PUHY.mjs");
var _chunkLOVLFPS = require("./chunk-LOVLFPS5.mjs");
var _chunkNDGGJV = require("./chunk-NDGGJV23.mjs");
var _chunk5Z4IVOU = require("./chunk-5Z4IVOU3.mjs");
var _chunkT276HDLM = require("./chunk-T276HDLM.mjs");
var _chunkYOXAUO7A = require("./chunk-YOXAUO7A.mjs");
var _chunkO7XTKHT = require("./chunk-O7XTKHT6.mjs");
var _chunkUTUD2BXK = require("./chunk-UTUD2BXK.mjs");
// src/components/index.ts
var components = {
  Accordion: _chunkT276HDLM.accordionTheme,
  Alert: _chunkYOXAUO7A.alertTheme,
  Avatar: _chunkO7XTKHT.avatarTheme,
  Badge: _chunkUTUD2BXK.badgeTheme,
  Breadcrumb: _chunkGLS227WS.breadcrumbTheme,
  Button: _chunkAP3MTUHH.buttonTheme,
  Checkbox: _chunk3XG4KRSA.checkboxTheme,
  CloseButton: _chunkC4P5PUHY.closeButtonTheme,
  Code: _chunkLOVLFPS.codeTheme,
  Container: _chunkNDGGJV.containerTheme,
  Divider: _chunk5Z4IVOU.dividerTheme,
  Drawer: _chunkPQSF5PVS.drawerTheme,
  Editable: _chunkYZVOF4MP.editableTheme,
  Form: _chunkRUW3STUO.formTheme,
  FormError: _chunkD55YRTLZ.formErrorTheme,
  FormLabel: _chunkOYCZTG3L.formLabelTheme,
  Heading: _chunkX4O3JXYB.headingTheme,
  Input: _chunkWFLWAEKG.inputTheme,
  Kbd: _chunkVQ2DUS6J.kbdTheme,
  Link: _chunk2T5TO72C.linkTheme,
  List: _chunkAQJ6AIMN.listTheme,
  Menu: _chunkFIWRYWVW.menuTheme,
  Modal: _chunkHCMWF4U.modalTheme,
  NumberInput: _chunkXNRZTTJ.numberInputTheme,
  PinInput: _chunkQW3Z4V.pinInputTheme,
  Popover: _chunkYJYMWHG.popoverTheme,
  Progress: _chunkVGCCECBM.progressTheme,
  Radio: _chunkJDPWIQ7H.radioTheme,
  Select: _chunkV3RHVDKJ.selectTheme,
  Skeleton: _chunkYSULOCDF.skeletonTheme,
  SkipLink: _chunkRSEFU3LC.skipLinkTheme,
  Slider: _chunkIBL46MNN.sliderTheme,
  Spinner: _chunkY6RR3LE.spinnerTheme,
  Stat: _chunkEY6ACYQS.statTheme,
  Switch: _chunkKGFPXNP.switchTheme,
  Table: _chunkWHSEAAWU.tableTheme,
  Tabs: _chunkRBQSCDLK.tabsTheme,
  Tag: _chunkJWDMXB2N.tagTheme,
  Textarea: _chunkOIGZPHLT.textareaTheme,
  Tooltip: _chunk6Y3UQESG.tooltipTheme,
  Card: _chunk6K6YYJ2N.cardTheme
};
exports.components = components;
},{"./chunk-KGFPXNP4.mjs":"PMz3","./chunk-WHSEAAWU.mjs":"H5lk","./chunk-RBQSCDLK.mjs":"glOQ","./chunk-JWDMXB2N.mjs":"XXT2","./chunk-OIGZPHLT.mjs":"Nr0Z","./chunk-6Y3UQESG.mjs":"XkiA","./chunk-VGCCECBM.mjs":"K0Fm","./chunk-JDPWIQ7H.mjs":"lr9M","./chunk-V3RHVDKJ.mjs":"Qjgu","./chunk-YSULOCDF.mjs":"dbBx","./chunk-RSEFU3LC.mjs":"EUAN","./chunk-IBL46MNN.mjs":"AgTr","./chunk-Y6RR3LE6.mjs":"HvyO","./chunk-EY6ACYQS.mjs":"oqsG","./chunk-VQ2DUS6J.mjs":"cvmg","./chunk-2T5TO72C.mjs":"CPSY","./chunk-AQJ6AIMN.mjs":"Bb0Q","./chunk-FIWRYWVW.mjs":"vtD2","./chunk-HCMWF4U4.mjs":"nyxv","./chunk-XNRZTTJ2.mjs":"UHqo","./chunk-QW3Z4V42.mjs":"vOFq","./chunk-YJYMWHG4.mjs":"CCrX","./chunk-PQSF5PVS.mjs":"xDw3","./chunk-YZVOF4MP.mjs":"a1kl","./chunk-RUW3STUO.mjs":"BXzG","./chunk-D55YRTLZ.mjs":"PrQI","./chunk-OYCZTG3L.mjs":"Naby","./chunk-X4O3JXYB.mjs":"z8JN","./chunk-WFLWAEKG.mjs":"Jhk8","./chunk-GLS227WS.mjs":"OJpn","./chunk-AP3MTUHH.mjs":"E1Uy","./chunk-6K6YYJ2N.mjs":"rFqp","./chunk-3XG4KRSA.mjs":"Av4x","./chunk-C4P5PUHY.mjs":"FyLI","./chunk-LOVLFPS5.mjs":"vBay","./chunk-NDGGJV23.mjs":"pRDP","./chunk-5Z4IVOU3.mjs":"mpzZ","./chunk-T276HDLM.mjs":"TEBj","./chunk-YOXAUO7A.mjs":"GwXK","./chunk-O7XTKHT6.mjs":"ppFM","./chunk-UTUD2BXK.mjs":"x70Z"}],"Owq9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.semanticTokens = void 0;
// src/semantic-tokens.ts
var semanticTokens = {
  colors: {
    "chakra-body-text": {
      _light: "gray.800",
      _dark: "whiteAlpha.900"
    },
    "chakra-body-bg": {
      _light: "white",
      _dark: "gray.800"
    },
    "chakra-border-color": {
      _light: "gray.200",
      _dark: "whiteAlpha.300"
    },
    "chakra-subtle-bg": {
      _light: "gray.100",
      _dark: "gray.700"
    },
    "chakra-placeholder-color": {
      _light: "gray.500",
      _dark: "whiteAlpha.400"
    }
  }
};
exports.semanticTokens = semanticTokens;
},{}],"hvgs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.styles = void 0;
// src/styles.ts
var styles = {
  global: {
    body: {
      fontFamily: "body",
      color: "chakra-body-text",
      bg: "chakra-body-bg",
      transitionProperty: "background-color",
      transitionDuration: "normal",
      lineHeight: "base"
    },
    "*::placeholder": {
      color: "chakra-placeholder-color"
    },
    "*, *::before, &::after": {
      borderColor: "chakra-border-color",
      wordWrap: "break-word"
    }
  }
};
exports.styles = styles;
},{}],"MnNi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.baseTheme = void 0;
Object.defineProperty(exports, "isChakraTheme", {
  enumerable: true,
  get: function () {
    return _chunkA6NK776R.isChakraTheme;
  }
});
Object.defineProperty(exports, "requiredChakraThemeKeys", {
  enumerable: true,
  get: function () {
    return _chunkA6NK776R.requiredChakraThemeKeys;
  }
});
exports.theme = void 0;
var _chunkA6NK776R = require("./chunk-A6NK776R.mjs");
var _chunk6S44RLTW = require("./chunk-6S44RLTW.mjs");
require("./chunk-7OKLMD4V.mjs");
require("./chunk-DDAHWWWN.mjs");
require("./chunk-C7H5GWRZ.mjs");
require("./chunk-4REDROSM.mjs");
require("./chunk-DJNGX4VH.mjs");
require("./chunk-AU77DZXY.mjs");
require("./chunk-OLDNEXT6.mjs");
require("./chunk-ZV5E32CG.mjs");
var _chunkLRLJFACU = require("./chunk-LRLJFACU.mjs");
require("./chunk-KGFPXNP4.mjs");
require("./chunk-WHSEAAWU.mjs");
require("./chunk-RBQSCDLK.mjs");
require("./chunk-JWDMXB2N.mjs");
require("./chunk-OIGZPHLT.mjs");
require("./chunk-6Y3UQESG.mjs");
require("./chunk-VGCCECBM.mjs");
require("./chunk-JDPWIQ7H.mjs");
require("./chunk-V3RHVDKJ.mjs");
require("./chunk-YSULOCDF.mjs");
require("./chunk-RSEFU3LC.mjs");
require("./chunk-IBL46MNN.mjs");
require("./chunk-Y6RR3LE6.mjs");
require("./chunk-EY6ACYQS.mjs");
require("./chunk-VQ2DUS6J.mjs");
require("./chunk-2T5TO72C.mjs");
require("./chunk-AQJ6AIMN.mjs");
require("./chunk-FIWRYWVW.mjs");
require("./chunk-HCMWF4U4.mjs");
require("./chunk-XNRZTTJ2.mjs");
require("./chunk-HOOF7HHD.mjs");
require("./chunk-QW3Z4V42.mjs");
require("./chunk-YJYMWHG4.mjs");
require("./chunk-PQSF5PVS.mjs");
require("./chunk-YZVOF4MP.mjs");
require("./chunk-RUW3STUO.mjs");
require("./chunk-D55YRTLZ.mjs");
require("./chunk-OYCZTG3L.mjs");
require("./chunk-X4O3JXYB.mjs");
require("./chunk-WFLWAEKG.mjs");
require("./chunk-GLS227WS.mjs");
require("./chunk-AP3MTUHH.mjs");
require("./chunk-6K6YYJ2N.mjs");
require("./chunk-3XG4KRSA.mjs");
require("./chunk-C4P5PUHY.mjs");
require("./chunk-LOVLFPS5.mjs");
require("./chunk-NDGGJV23.mjs");
require("./chunk-5Z4IVOU3.mjs");
var _chunkHZX2OI7F = require("./chunk-HZX2OI7F.mjs");
var _chunkI4WK6NDQ = require("./chunk-I4WK6NDQ.mjs");
require("./chunk-RT7D5LFX.mjs");
require("./chunk-T276HDLM.mjs");
require("./chunk-YOXAUO7A.mjs");
require("./chunk-O7XTKHT6.mjs");
require("./chunk-X4JBRTE2.mjs");
require("./chunk-G3IFUAY5.mjs");
require("./chunk-EBS47JIL.mjs");
require("./chunk-UTUD2BXK.mjs");
// src/index.ts
var direction = "ltr";
var config = {
  useSystemColorMode: false,
  initialColorMode: "light",
  cssVarPrefix: "chakra"
};
var theme = {
  semanticTokens: _chunkHZX2OI7F.semanticTokens,
  direction,
  ..._chunk6S44RLTW.foundations,
  components: _chunkLRLJFACU.components,
  styles: _chunkI4WK6NDQ.styles,
  config
};
exports.theme = theme;
var src_default = theme;
exports.default = src_default;
var baseTheme = {
  semanticTokens: _chunkHZX2OI7F.semanticTokens,
  direction,
  components: {},
  ..._chunk6S44RLTW.foundations,
  styles: _chunkI4WK6NDQ.styles,
  config
};
exports.baseTheme = baseTheme;
},{"./chunk-A6NK776R.mjs":"wG6q","./chunk-6S44RLTW.mjs":"j0ne","./chunk-7OKLMD4V.mjs":"wnRJ","./chunk-DDAHWWWN.mjs":"sRYL","./chunk-C7H5GWRZ.mjs":"SHk9","./chunk-4REDROSM.mjs":"Jqut","./chunk-DJNGX4VH.mjs":"Fejh","./chunk-AU77DZXY.mjs":"bX2e","./chunk-OLDNEXT6.mjs":"v9FE","./chunk-ZV5E32CG.mjs":"vHn7","./chunk-LRLJFACU.mjs":"nV6y","./chunk-KGFPXNP4.mjs":"PMz3","./chunk-WHSEAAWU.mjs":"H5lk","./chunk-RBQSCDLK.mjs":"glOQ","./chunk-JWDMXB2N.mjs":"XXT2","./chunk-OIGZPHLT.mjs":"Nr0Z","./chunk-6Y3UQESG.mjs":"XkiA","./chunk-VGCCECBM.mjs":"K0Fm","./chunk-JDPWIQ7H.mjs":"lr9M","./chunk-V3RHVDKJ.mjs":"Qjgu","./chunk-YSULOCDF.mjs":"dbBx","./chunk-RSEFU3LC.mjs":"EUAN","./chunk-IBL46MNN.mjs":"AgTr","./chunk-Y6RR3LE6.mjs":"HvyO","./chunk-EY6ACYQS.mjs":"oqsG","./chunk-VQ2DUS6J.mjs":"cvmg","./chunk-2T5TO72C.mjs":"CPSY","./chunk-AQJ6AIMN.mjs":"Bb0Q","./chunk-FIWRYWVW.mjs":"vtD2","./chunk-HCMWF4U4.mjs":"nyxv","./chunk-XNRZTTJ2.mjs":"UHqo","./chunk-HOOF7HHD.mjs":"Gx0t","./chunk-QW3Z4V42.mjs":"vOFq","./chunk-YJYMWHG4.mjs":"CCrX","./chunk-PQSF5PVS.mjs":"xDw3","./chunk-YZVOF4MP.mjs":"a1kl","./chunk-RUW3STUO.mjs":"BXzG","./chunk-D55YRTLZ.mjs":"PrQI","./chunk-OYCZTG3L.mjs":"Naby","./chunk-X4O3JXYB.mjs":"z8JN","./chunk-WFLWAEKG.mjs":"Jhk8","./chunk-GLS227WS.mjs":"OJpn","./chunk-AP3MTUHH.mjs":"E1Uy","./chunk-6K6YYJ2N.mjs":"rFqp","./chunk-3XG4KRSA.mjs":"Av4x","./chunk-C4P5PUHY.mjs":"FyLI","./chunk-LOVLFPS5.mjs":"vBay","./chunk-NDGGJV23.mjs":"pRDP","./chunk-5Z4IVOU3.mjs":"mpzZ","./chunk-HZX2OI7F.mjs":"Owq9","./chunk-I4WK6NDQ.mjs":"hvgs","./chunk-RT7D5LFX.mjs":"Tnu0","./chunk-T276HDLM.mjs":"TEBj","./chunk-YOXAUO7A.mjs":"GwXK","./chunk-O7XTKHT6.mjs":"ppFM","./chunk-X4JBRTE2.mjs":"HfnR","./chunk-G3IFUAY5.mjs":"sz2D","./chunk-EBS47JIL.mjs":"isoW","./chunk-UTUD2BXK.mjs":"x70Z"}],"rJQz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extendTheme = exports.extendBaseTheme = void 0;
exports.mergeThemeOverride = mergeThemeOverride;
var _theme = require("@chakra-ui/theme");
var _lodash = _interopRequireDefault(require("lodash.mergewith"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// src/extend-theme.ts

function isFunction(value) {
  return typeof value === "function";
}
function pipe(...fns) {
  return v => fns.reduce((a, b) => b(a), v);
}
var createExtendTheme = theme2 => {
  return function extendTheme2(...extensions) {
    let overrides = [...extensions];
    let activeTheme = extensions[extensions.length - 1];
    if ((0, _theme.isChakraTheme)(activeTheme) && overrides.length > 1) {
      overrides = overrides.slice(0, overrides.length - 1);
    } else {
      activeTheme = theme2;
    }
    return pipe(...overrides.map(extension => prevTheme => isFunction(extension) ? extension(prevTheme) : mergeThemeOverride(prevTheme, extension)))(activeTheme);
  };
};
var extendTheme = createExtendTheme(_theme.theme);
exports.extendTheme = extendTheme;
var extendBaseTheme = createExtendTheme(_theme.baseTheme);
exports.extendBaseTheme = extendBaseTheme;
function mergeThemeOverride(...overrides) {
  return (0, _lodash.default)({}, ...overrides, mergeThemeCustomizer);
}
function mergeThemeCustomizer(source, override, key, object) {
  if ((isFunction(source) || isFunction(override)) && Object.prototype.hasOwnProperty.call(object, key)) {
    return (...args) => {
      const sourceValue = isFunction(source) ? source(...args) : source;
      const overrideValue = isFunction(override) ? override(...args) : override;
      return (0, _lodash.default)({}, sourceValue, overrideValue, mergeThemeCustomizer);
    };
  }
  return void 0;
}
},{"@chakra-ui/theme":"MnNi","lodash.mergewith":"fWTD"}],"gvtD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withDefaultColorScheme = withDefaultColorScheme;
var _chunkAQYX3YP = require("./chunk-AQYX3YP4.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
// src/theme-extensions/with-default-color-scheme.ts

function withDefaultColorScheme({
  colorScheme,
  components
}) {
  return theme => {
    let names = Object.keys(theme.components || {});
    if (Array.isArray(components)) {
      names = components;
    } else if ((0, _sharedUtils.isObject)(components)) {
      names = Object.keys(components);
    }
    return (0, _chunkAQYX3YP.mergeThemeOverride)(theme, {
      components: Object.fromEntries(names.map(componentName => {
        const withColorScheme = {
          defaultProps: {
            colorScheme
          }
        };
        return [componentName, withColorScheme];
      }))
    });
  };
}
},{"./chunk-AQYX3YP4.mjs":"rJQz","@chakra-ui/shared-utils":"gghr"}],"B7xf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withDefaultSize = withDefaultSize;
var _chunkAQYX3YP = require("./chunk-AQYX3YP4.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
// src/theme-extensions/with-default-size.ts

function withDefaultSize({
  size,
  components
}) {
  return theme => {
    let names = Object.keys(theme.components || {});
    if (Array.isArray(components)) {
      names = components;
    } else if ((0, _sharedUtils.isObject)(components)) {
      names = Object.keys(components);
    }
    return (0, _chunkAQYX3YP.mergeThemeOverride)(theme, {
      components: Object.fromEntries(names.map(componentName => {
        const withSize = {
          defaultProps: {
            size
          }
        };
        return [componentName, withSize];
      }))
    });
  };
}
},{"./chunk-AQYX3YP4.mjs":"rJQz","@chakra-ui/shared-utils":"gghr"}],"Ss7A":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withDefaultVariant = withDefaultVariant;
var _chunkAQYX3YP = require("./chunk-AQYX3YP4.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
// src/theme-extensions/with-default-variant.ts

function withDefaultVariant({
  variant,
  components
}) {
  return theme => {
    let names = Object.keys(theme.components || {});
    if (Array.isArray(components)) {
      names = components;
    } else if ((0, _sharedUtils.isObject)(components)) {
      names = Object.keys(components);
    }
    return (0, _chunkAQYX3YP.mergeThemeOverride)(theme, {
      components: Object.fromEntries(names.map(componentName => {
        const withVariant = {
          defaultProps: {
            variant
          }
        };
        return [componentName, withVariant];
      }))
    });
  };
}
},{"./chunk-AQYX3YP4.mjs":"rJQz","@chakra-ui/shared-utils":"gghr"}],"ONnJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withDefaultProps = withDefaultProps;
var _chunkDFL6DXJX = require("./chunk-DFL6DXJX.mjs");
var _chunkYKDMERD = require("./chunk-YKDMERD6.mjs");
var _chunkHA5PBA4B = require("./chunk-HA5PBA4B.mjs");
var _chunkAQYX3YP = require("./chunk-AQYX3YP4.mjs");
// src/theme-extensions/with-default-props.ts
function pipe(...fns) {
  return v => fns.reduce((a, b) => b(a), v);
}
function withDefaultProps({
  defaultProps: {
    colorScheme,
    variant,
    size
  },
  components
}) {
  const identity = t => t;
  const fns = [colorScheme ? (0, _chunkDFL6DXJX.withDefaultColorScheme)({
    colorScheme,
    components
  }) : identity, size ? (0, _chunkYKDMERD.withDefaultSize)({
    size,
    components
  }) : identity, variant ? (0, _chunkHA5PBA4B.withDefaultVariant)({
    variant,
    components
  }) : identity];
  return theme => (0, _chunkAQYX3YP.mergeThemeOverride)(pipe(...fns)(theme));
}
},{"./chunk-DFL6DXJX.mjs":"gvtD","./chunk-YKDMERD6.mjs":"B7xf","./chunk-HA5PBA4B.mjs":"Ss7A","./chunk-AQYX3YP4.mjs":"rJQz"}],"KCKL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "extendBaseTheme", {
  enumerable: true,
  get: function () {
    return _chunkAQYX3YP.extendBaseTheme;
  }
});
Object.defineProperty(exports, "extendTheme", {
  enumerable: true,
  get: function () {
    return _chunkAQYX3YP.extendTheme;
  }
});
Object.defineProperty(exports, "mergeThemeOverride", {
  enumerable: true,
  get: function () {
    return _chunkAQYX3YP.mergeThemeOverride;
  }
});
Object.defineProperty(exports, "withDefaultColorScheme", {
  enumerable: true,
  get: function () {
    return _chunkDFL6DXJX.withDefaultColorScheme;
  }
});
Object.defineProperty(exports, "withDefaultProps", {
  enumerable: true,
  get: function () {
    return _chunkUONXFRGI.withDefaultProps;
  }
});
Object.defineProperty(exports, "withDefaultSize", {
  enumerable: true,
  get: function () {
    return _chunkYKDMERD.withDefaultSize;
  }
});
Object.defineProperty(exports, "withDefaultVariant", {
  enumerable: true,
  get: function () {
    return _chunkHA5PBA4B.withDefaultVariant;
  }
});
require("./chunk-SUJGGKVT.mjs");
var _chunkUONXFRGI = require("./chunk-UONXFRGI.mjs");
var _chunkDFL6DXJX = require("./chunk-DFL6DXJX.mjs");
var _chunkYKDMERD = require("./chunk-YKDMERD6.mjs");
var _chunkHA5PBA4B = require("./chunk-HA5PBA4B.mjs");
var _chunkAQYX3YP = require("./chunk-AQYX3YP4.mjs");
},{"./chunk-SUJGGKVT.mjs":"Tnu0","./chunk-UONXFRGI.mjs":"ONnJ","./chunk-DFL6DXJX.mjs":"gvtD","./chunk-YKDMERD6.mjs":"B7xf","./chunk-HA5PBA4B.mjs":"Ss7A","./chunk-AQYX3YP4.mjs":"rJQz"}],"cvb8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDomEvent = addDomEvent;
exports.ariaAttr = void 0;
exports.canUseDOM = canUseDOM;
exports.contains = contains;
exports.dataAttr = exports.cx = void 0;
exports.getActiveElement = getActiveElement;
exports.getEventWindow = getEventWindow;
exports.getOwnerDocument = getOwnerDocument;
exports.getOwnerWindow = getOwnerWindow;
exports.getRelatedTarget = getRelatedTarget;
exports.isBrowser = void 0;
exports.isElement = isElement;
exports.isHTMLElement = isHTMLElement;
exports.isRightClick = isRightClick;
exports.normalizeEventKey = normalizeEventKey;
// src/dom.ts
function isElement(el) {
  return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
}
function isHTMLElement(el) {
  var _a;
  if (!isElement(el)) {
    return false;
  }
  const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
  return el instanceof win.HTMLElement;
}
function getOwnerWindow(node) {
  var _a, _b;
  return isElement(node) ? (_b = (_a = getOwnerDocument(node)) == null ? void 0 : _a.defaultView) != null ? _b : window : window;
}
function getOwnerDocument(node) {
  var _a;
  return isElement(node) ? (_a = node.ownerDocument) != null ? _a : document : document;
}
function getEventWindow(event) {
  var _a;
  return (_a = event.view) != null ? _a : window;
}
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var isBrowser = /* @__PURE__ */canUseDOM();
exports.isBrowser = isBrowser;
var dataAttr = condition => condition ? "" : void 0;
exports.dataAttr = dataAttr;
var ariaAttr = condition => condition ? true : void 0;
exports.ariaAttr = ariaAttr;
var cx = (...classNames) => classNames.filter(Boolean).join(" ");
exports.cx = cx;
function getActiveElement(node) {
  const doc = getOwnerDocument(node);
  return doc == null ? void 0 : doc.activeElement;
}
function contains(parent, child) {
  if (!parent) return false;
  return parent === child || parent.contains(child);
}
function addDomEvent(target, eventName, handler, options) {
  target.addEventListener(eventName, handler, options);
  return () => {
    target.removeEventListener(eventName, handler, options);
  };
}
function normalizeEventKey(event) {
  const {
    key,
    keyCode
  } = event;
  const isArrowKey = keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0;
  const eventKey = isArrowKey ? `Arrow${key}` : key;
  return eventKey;
}
function getRelatedTarget(event) {
  var _a, _b;
  const target = (_a = event.target) != null ? _a : event.currentTarget;
  const activeElement = getActiveElement(target);
  return (_b = event.relatedTarget) != null ? _b : activeElement;
}
function isRightClick(event) {
  return event.button !== 0;
}
},{}],"TbMI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.detectBrowser = detectBrowser;
exports.detectDeviceType = detectDeviceType;
exports.detectOS = detectOS;
exports.detectTouch = detectTouch;
var _chunkO3SWHQEE = require("./chunk-O3SWHQEE.mjs");
// src/user-agent.ts
function getUserAgentBrowser(navigator) {
  const {
    userAgent: ua,
    vendor
  } = navigator;
  const android = /(android)/i.test(ua);
  switch (true) {
    case /CriOS/.test(ua):
      return "Chrome for iOS";
    case /Edg\//.test(ua):
      return "Edge";
    case android && /Silk\//.test(ua):
      return "Silk";
    case /Chrome/.test(ua) && /Google Inc/.test(vendor):
      return "Chrome";
    case /Firefox\/\d+\.\d+$/.test(ua):
      return "Firefox";
    case android:
      return "AOSP";
    case /MSIE|Trident/.test(ua):
      return "IE";
    case /Safari/.test(navigator.userAgent) && /Apple Computer/.test(ua):
      return "Safari";
    case /AppleWebKit/.test(ua):
      return "WebKit";
    default:
      return null;
  }
}
function getUserAgentOS(navigator) {
  const {
    userAgent: ua,
    platform
  } = navigator;
  switch (true) {
    case /Android/.test(ua):
      return "Android";
    case /iPhone|iPad|iPod/.test(platform):
      return "iOS";
    case /Win/.test(platform):
      return "Windows";
    case /Mac/.test(platform):
      return "Mac";
    case /CrOS/.test(ua):
      return "Chrome OS";
    case /Firefox/.test(ua):
      return "Firefox OS";
    default:
      return null;
  }
}
function detectDeviceType(navigator) {
  const {
    userAgent: ua
  } = navigator;
  if (/(tablet)|(iPad)|(Nexus 9)/i.test(ua)) return "tablet";
  if (/(mobi)/i.test(ua)) return "phone";
  return "desktop";
}
function detectOS(os) {
  if (!_chunkO3SWHQEE.isBrowser) return false;
  return getUserAgentOS(window.navigator) === os;
}
function detectBrowser(browser) {
  if (!_chunkO3SWHQEE.isBrowser) return false;
  return getUserAgentBrowser(window.navigator) === browser;
}
function detectTouch() {
  if (!_chunkO3SWHQEE.isBrowser) return false;
  return window.ontouchstart === null && window.ontouchmove === null && window.ontouchend === null;
}
},{"./chunk-O3SWHQEE.mjs":"cvb8"}],"n3RM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _lodash.default;
  }
});
exports.fromEntries = exports.filterUndefined = void 0;
exports.get = get;
exports.getCSSVar = void 0;
exports.getWithDefault = getWithDefault;
exports.memoizedGet = exports.memoize = void 0;
exports.objectFilter = objectFilter;
exports.objectKeys = void 0;
exports.omit = omit;
exports.pick = pick;
exports.split = split;
var _lodash = _interopRequireDefault(require("lodash.mergewith"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// src/object.ts

function omit(object, keys) {
  const result = {};
  Object.keys(object).forEach(key => {
    if (keys.includes(key)) return;
    result[key] = object[key];
  });
  return result;
}
function pick(object, keys) {
  const result = {};
  keys.forEach(key => {
    if (key in object) {
      result[key] = object[key];
    }
  });
  return result;
}
function split(object, keys) {
  const picked = {};
  const omitted = {};
  Object.keys(object).forEach(key => {
    if (keys.includes(key)) {
      picked[key] = object[key];
    } else {
      omitted[key] = object[key];
    }
  });
  return [picked, omitted];
}
function get(obj, path, fallback, index) {
  const key = typeof path === "string" ? path.split(".") : [path];
  for (index = 0; index < key.length; index += 1) {
    if (!obj) break;
    obj = obj[key[index]];
  }
  return obj === void 0 ? fallback : obj;
}
var memoize = fn => {
  const cache = /* @__PURE__ */new WeakMap();
  const memoizedFn = (obj, path, fallback, index) => {
    if (typeof obj === "undefined") {
      return fn(obj, path, fallback);
    }
    if (!cache.has(obj)) {
      cache.set(obj, /* @__PURE__ */new Map());
    }
    const map = cache.get(obj);
    if (map.has(path)) {
      return map.get(path);
    }
    const value = fn(obj, path, fallback, index);
    map.set(path, value);
    return value;
  };
  return memoizedFn;
};
exports.memoize = memoize;
var memoizedGet = memoize(get);
exports.memoizedGet = memoizedGet;
function getWithDefault(path, scale) {
  return memoizedGet(scale, path, path);
}
function objectFilter(object, fn) {
  const result = {};
  Object.keys(object).forEach(key => {
    const value = object[key];
    const shouldPass = fn(value, key, object);
    if (shouldPass) {
      result[key] = value;
    }
  });
  return result;
}
var filterUndefined = object => objectFilter(object, val => val !== null && val !== void 0);
exports.filterUndefined = filterUndefined;
var objectKeys = obj => Object.keys(obj);
exports.objectKeys = objectKeys;
var fromEntries = entries => entries.reduce((carry, [key, value]) => {
  carry[key] = value;
  return carry;
}, {});
exports.fromEntries = fromEntries;
var getCSSVar = (theme, scale, value) => {
  var _a, _b, _c;
  return (_c = (_b = (_a = theme.__cssMap) == null ? void 0 : _a[`${scale}.${value}`]) == null ? void 0 : _b.varRef) != null ? _c : value;
};
exports.getCSSVar = getCSSVar;
},{"lodash.mergewith":"fWTD"}],"SQeD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__TEST__ = exports.__DEV__ = void 0;
exports.isArray = isArray;
exports.isCssVar = isCssVar;
exports.isDefined = isDefined;
exports.isEmpty = isEmpty;
exports.isEmptyArray = isEmptyArray;
exports.isEmptyObject = isEmptyObject;
exports.isFunction = isFunction;
exports.isInputEvent = isInputEvent;
exports.isNotEmptyObject = isNotEmptyObject;
exports.isNotNumber = isNotNumber;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isNumeric = isNumeric;
exports.isObject = isObject;
exports.isRefObject = isRefObject;
exports.isString = isString;
exports.isUndefined = isUndefined;
// src/assertion.ts
function isNumber(value) {
  return typeof value === "number";
}
function isNotNumber(value) {
  return typeof value !== "number" || Number.isNaN(value) || !Number.isFinite(value);
}
function isNumeric(value) {
  return value != null && value - parseFloat(value) + 1 >= 0;
}
function isArray(value) {
  return Array.isArray(value);
}
function isEmptyArray(value) {
  return isArray(value) && value.length === 0;
}
function isFunction(value) {
  return typeof value === "function";
}
function isDefined(value) {
  return typeof value !== "undefined" && value !== void 0;
}
function isUndefined(value) {
  return typeof value === "undefined" || value === void 0;
}
function isObject(value) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function") && !isArray(value);
}
function isEmptyObject(value) {
  return isObject(value) && Object.keys(value).length === 0;
}
function isNotEmptyObject(value) {
  return value && !isEmptyObject(value);
}
function isNull(value) {
  return value == null;
}
function isString(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}
function isCssVar(value) {
  return /^var\(--.+\)$/.test(value);
}
function isEmpty(value) {
  if (isArray(value)) return isEmptyArray(value);
  if (isObject(value)) return isEmptyObject(value);
  if (value == null || value === "") return true;
  return false;
}
var __DEV__ = "production" !== "production";
exports.__DEV__ = __DEV__;
var __TEST__ = "production" === "test";
exports.__TEST__ = __TEST__;
function isRefObject(val) {
  return "current" in val;
}
function isInputEvent(value) {
  return value && isObject(value) && isObject(value.target);
}
},{}],"XPK8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.walkObject = walkObject;
var _chunkYTQ3XZ3T = require("./chunk-YTQ3XZ3T.mjs");
var _chunkY5FGD7DM = require("./chunk-Y5FGD7DM.mjs");
// src/walk-object.ts
function walkObject(target, predicate) {
  function inner(value, path = []) {
    if ((0, _chunkY5FGD7DM.isArray)(value)) {
      return value.map((item, index) => inner(item, [...path, String(index)]));
    }
    if ((0, _chunkY5FGD7DM.isObject)(value)) {
      return (0, _chunkYTQ3XZ3T.fromEntries)(Object.entries(value).map(([key, child]) => [key, inner(child, [...path, key])]));
    }
    return predicate(value, path);
  }
  return inner(target);
}
},{"./chunk-YTQ3XZ3T.mjs":"n3RM","./chunk-Y5FGD7DM.mjs":"SQeD"}],"GabY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.determineLazyBehavior = determineLazyBehavior;
// src/lazy.ts
function determineLazyBehavior(options) {
  const {
    hasBeenSelected,
    isLazy,
    isSelected,
    lazyBehavior = "unmount"
  } = options;
  if (!isLazy) return true;
  if (isSelected) return true;
  if (lazyBehavior === "keepMounted" && hasBeenSelected) return true;
  return false;
}
},{}],"Ymut":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.callAll = callAll;
exports.callAllHandlers = callAllHandlers;
exports.compose = void 0;
exports.distance = distance;
exports.noop = exports.error = void 0;
exports.once = once;
exports.pipe = void 0;
exports.runIfFn = runIfFn;
exports.warn = void 0;
var _chunkY5FGD7DM = require("./chunk-Y5FGD7DM.mjs");
// src/function.ts
function runIfFn(valueOrFn, ...args) {
  return (0, _chunkY5FGD7DM.isFunction)(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}
function callAllHandlers(...fns) {
  return function func(event) {
    fns.some(fn => {
      fn == null ? void 0 : fn(event);
      return event == null ? void 0 : event.defaultPrevented;
    });
  };
}
function callAll(...fns) {
  return function mergedFn(arg) {
    fns.forEach(fn => {
      fn == null ? void 0 : fn(arg);
    });
  };
}
var compose = (fn1, ...fns) => fns.reduce((f1, f2) => (...args) => f1(f2(...args)), fn1);
exports.compose = compose;
function once(fn) {
  let result;
  return function func(...args) {
    if (fn) {
      result = fn.apply(this, args);
      fn = null;
    }
    return result;
  };
}
var noop = () => {};
exports.noop = noop;
var warn = /* @__PURE__ */once(options => () => {
  const {
    condition,
    message
  } = options;
  if (condition && _chunkY5FGD7DM.__DEV__) {
    console.warn(message);
  }
});
exports.warn = warn;
var error = /* @__PURE__ */once(options => () => {
  const {
    condition,
    message
  } = options;
  if (condition && _chunkY5FGD7DM.__DEV__) {
    console.error(message);
  }
});
exports.error = error;
var pipe = (...fns) => v => fns.reduce((a, b) => b(a), v);
exports.pipe = pipe;
var distance1D = (a, b) => Math.abs(a - b);
var isPoint = point => "x" in point && "y" in point;
function distance(a, b) {
  if ((0, _chunkY5FGD7DM.isNumber)(a) && (0, _chunkY5FGD7DM.isNumber)(b)) {
    return distance1D(a, b);
  }
  if (isPoint(a) && isPoint(b)) {
    const xDelta = distance1D(a.x, b.x);
    const yDelta = distance1D(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }
  return 0;
}
},{"./chunk-Y5FGD7DM.mjs":"SQeD"}],"kuee":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clampValue = clampValue;
exports.countDecimalPlaces = countDecimalPlaces;
exports.minSafeInteger = exports.maxSafeInteger = void 0;
exports.percentToValue = percentToValue;
exports.roundValueToStep = roundValueToStep;
exports.toPrecision = toPrecision;
exports.valueToPercent = valueToPercent;
var _chunkM3TFMUOL = require("./chunk-M3TFMUOL.mjs");
var _chunkY5FGD7DM = require("./chunk-Y5FGD7DM.mjs");
// src/number.ts
var minSafeInteger = Number.MIN_SAFE_INTEGER || -9007199254740991;
exports.minSafeInteger = minSafeInteger;
var maxSafeInteger = Number.MAX_SAFE_INTEGER || 9007199254740991;
exports.maxSafeInteger = maxSafeInteger;
function toNumber(value) {
  const num = parseFloat(value);
  return (0, _chunkY5FGD7DM.isNotNumber)(num) ? 0 : num;
}
function toPrecision(value, precision) {
  let nextValue = toNumber(value);
  const scaleFactor = 10 ** (precision != null ? precision : 10);
  nextValue = Math.round(nextValue * scaleFactor) / scaleFactor;
  return precision ? nextValue.toFixed(precision) : nextValue.toString();
}
function countDecimalPlaces(value) {
  if (!Number.isFinite(value)) return 0;
  let e = 1;
  let p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
}
function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}
function percentToValue(percent, min, max) {
  return (max - min) * percent + min;
}
function roundValueToStep(value, from, step) {
  const nextValue = Math.round((value - from) / step) * step + from;
  const precision = countDecimalPlaces(step);
  return toPrecision(nextValue, precision);
}
function clampValue(value, min, max) {
  if (value == null) return value;
  (0, _chunkM3TFMUOL.warn)({
    condition: max < min,
    message: "clamp: max cannot be less than min"
  });
  return Math.min(Math.max(value, min), max);
}
},{"./chunk-M3TFMUOL.mjs":"Ymut","./chunk-Y5FGD7DM.mjs":"SQeD"}],"vc7r":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addPointerEvent = addPointerEvent;
exports.extractEventInfo = extractEventInfo;
exports.getPointerEventName = getPointerEventName;
exports.getViewportPointFromEvent = getViewportPointFromEvent;
exports.isMouseEvent = isMouseEvent;
exports.isMultiTouchEvent = isMultiTouchEvent;
exports.isTouchEvent = isTouchEvent;
exports.wrapPointerEventHandler = void 0;
var _chunkO3SWHQEE = require("./chunk-O3SWHQEE.mjs");
// src/pointer-event.ts
function isMouseEvent(event) {
  const win = (0, _chunkO3SWHQEE.getEventWindow)(event);
  if (typeof win.PointerEvent !== "undefined" && event instanceof win.PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof win.MouseEvent;
}
function isTouchEvent(event) {
  const hasTouches = !!event.touches;
  return hasTouches;
}
function filterPrimaryPointer(eventHandler) {
  return event => {
    const win = (0, _chunkO3SWHQEE.getEventWindow)(event);
    const isMouseEvent2 = event instanceof win.MouseEvent;
    const isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
var defaultPagePoint = {
  pageX: 0,
  pageY: 0
};
function pointFromTouch(e, pointType = "page") {
  const primaryTouch = e.touches[0] || e.changedTouches[0];
  const point = primaryTouch || defaultPagePoint;
  return {
    x: point[`${pointType}X`],
    y: point[`${pointType}Y`]
  };
}
function pointFromMouse(point, pointType = "page") {
  return {
    x: point[`${pointType}X`],
    y: point[`${pointType}Y`]
  };
}
function extractEventInfo(event, pointType = "page") {
  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
function getViewportPointFromEvent(event) {
  return extractEventInfo(event, "client");
}
var wrapPointerEventHandler = (handler, shouldFilterPrimaryPointer = false) => {
  const listener = event => handler(event, extractEventInfo(event));
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
};
exports.wrapPointerEventHandler = wrapPointerEventHandler;
var supportsPointerEvents = () => _chunkO3SWHQEE.isBrowser && window.onpointerdown === null;
var supportsTouchEvents = () => _chunkO3SWHQEE.isBrowser && window.ontouchstart === null;
var supportsMouseEvents = () => _chunkO3SWHQEE.isBrowser && window.onmousedown === null;
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name) {
  if (supportsPointerEvents()) {
    return name;
  }
  if (supportsTouchEvents()) {
    return touchEventNames[name];
  }
  if (supportsMouseEvents()) {
    return mouseEventNames[name];
  }
  return name;
}
function addPointerEvent(target, eventName, handler, options) {
  return (0, _chunkO3SWHQEE.addDomEvent)(target, getPointerEventName(eventName), wrapPointerEventHandler(handler, eventName === "pointerdown"), options);
}
function isMultiTouchEvent(event) {
  return isTouchEvent(event) && event.touches.length > 1;
}
},{"./chunk-O3SWHQEE.mjs":"cvb8"}],"e2uv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__publicField = void 0;
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
exports.__publicField = __publicField;
},{}],"lAmd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onNextFrame = exports.defaultTimestep = void 0;
var defaultTimestep = 1 / 60 * 1000;
exports.defaultTimestep = defaultTimestep;
var getCurrentTime = typeof performance !== "undefined" ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
var onNextFrame = typeof window !== "undefined" ? function (callback) {
  return window.requestAnimationFrame(callback);
} : function (callback) {
  return setTimeout(function () {
    return callback(getCurrentTime());
  }, defaultTimestep);
};
exports.onNextFrame = onNextFrame;
},{}],"ReRg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRenderStep = createRenderStep;
function createRenderStep(runNextFrame) {
  var toRun = [];
  var toRunNextFrame = [];
  var numToRun = 0;
  var isProcessing = false;
  var toKeepAlive = new WeakSet();
  var step = {
    schedule: function (callback, keepAlive, immediate) {
      if (keepAlive === void 0) {
        keepAlive = false;
      }
      if (immediate === void 0) {
        immediate = false;
      }
      var addToCurrentFrame = immediate && isProcessing;
      var buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive) toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing) numToRun = toRun.length;
      }
      return callback;
    },
    cancel: function (callback) {
      var index = toRunNextFrame.indexOf(callback);
      if (index !== -1) toRunNextFrame.splice(index, 1);
      toKeepAlive.delete(callback);
    },
    process: function (frameData) {
      var _a;
      isProcessing = true;
      _a = [toRunNextFrame, toRun], toRun = _a[0], toRunNextFrame = _a[1];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (var i = 0; i < numToRun; i++) {
          var callback = toRun[i];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame();
          }
        }
      }
      isProcessing = false;
    }
  };
  return step;
}
},{}],"pBGv":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};
},{}],"V2xU":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFrameData = exports.flushSync = exports.default = exports.cancelSync = void 0;
var _onNextFrame = require("./on-next-frame.js");
var _createRenderStep = require("./create-render-step.js");
var maxElapsed = 40;
var useDefaultElapsed = true;
var runNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = ["read", "update", "preRender", "render", "postRender"];
var steps = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {
  acc[key] = (0, _createRenderStep.createRenderStep)(function () {
    return runNextFrame = true;
  });
  return acc;
}, {});
var sync = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {
  var step = steps[key];
  acc[key] = function (process, keepAlive, immediate) {
    if (keepAlive === void 0) {
      keepAlive = false;
    }
    if (immediate === void 0) {
      immediate = false;
    }
    if (!runNextFrame) startLoop();
    return step.schedule(process, keepAlive, immediate);
  };
  return acc;
}, {});
var cancelSync = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
exports.cancelSync = cancelSync;
var flushSync = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {
  acc[key] = function () {
    return steps[key].process(frame);
  };
  return acc;
}, {});
exports.flushSync = flushSync;
var processStep = function (stepId) {
  return steps[stepId].process(frame);
};
var processFrame = function (timestamp) {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? _onNextFrame.defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    (0, _onNextFrame.onNextFrame)(processFrame);
  }
};
var startLoop = function () {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing) (0, _onNextFrame.onNextFrame)(processFrame);
};
var getFrameData = function () {
  return frame;
};
exports.getFrameData = getFrameData;
var _default = sync;
exports.default = _default;
},{"./on-next-frame.js":"lAmd","./create-render-step.js":"ReRg","process":"pBGv"}],"Fv3i":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PanSession = void 0;
var _chunkLCE7F24A = require("./chunk-LCE7F24A.mjs");
var _chunkO3SWHQEE = require("./chunk-O3SWHQEE.mjs");
var _chunkM3TFMUOL = require("./chunk-M3TFMUOL.mjs");
var _chunkNHABU = require("./chunk-NHABU752.mjs");
var _framesync = _interopRequireWildcard(require("framesync"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// src/pan-event.ts

var PanSession = class {
  constructor(event, handlers, threshold) {
    (0, _chunkNHABU.__publicField)(this, "history", []);
    (0, _chunkNHABU.__publicField)(this, "startEvent", null);
    (0, _chunkNHABU.__publicField)(this, "lastEvent", null);
    (0, _chunkNHABU.__publicField)(this, "lastEventInfo", null);
    (0, _chunkNHABU.__publicField)(this, "handlers", {});
    (0, _chunkNHABU.__publicField)(this, "removeListeners", _chunkM3TFMUOL.noop);
    (0, _chunkNHABU.__publicField)(this, "threshold", 3);
    (0, _chunkNHABU.__publicField)(this, "win");
    (0, _chunkNHABU.__publicField)(this, "updatePoint", () => {
      if (!(this.lastEvent && this.lastEventInfo)) return;
      const info = getPanInfo(this.lastEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = (0, _chunkM3TFMUOL.distance)(info.offset, {
        x: 0,
        y: 0
      }) >= this.threshold;
      if (!isPanStarted && !isDistancePastThreshold) return;
      const {
        timestamp
      } = (0, _framesync.getFrameData)();
      this.history.push({
        ...info.point,
        timestamp
      });
      const {
        onStart,
        onMove
      } = this.handlers;
      if (!isPanStarted) {
        onStart == null ? void 0 : onStart(this.lastEvent, info);
        this.startEvent = this.lastEvent;
      }
      onMove == null ? void 0 : onMove(this.lastEvent, info);
    });
    (0, _chunkNHABU.__publicField)(this, "onPointerMove", (event, info) => {
      this.lastEvent = event;
      this.lastEventInfo = info;
      if ((0, _chunkLCE7F24A.isMouseEvent)(event) && event.buttons === 0) {
        this.onPointerUp(event, info);
        return;
      }
      _framesync.default.update(this.updatePoint, true);
    });
    (0, _chunkNHABU.__publicField)(this, "onPointerUp", (event, info) => {
      const panInfo = getPanInfo(info, this.history);
      const {
        onEnd,
        onSessionEnd
      } = this.handlers;
      onSessionEnd == null ? void 0 : onSessionEnd(event, panInfo);
      this.end();
      if (!onEnd || !this.startEvent) return;
      onEnd == null ? void 0 : onEnd(event, panInfo);
    });
    this.win = (0, _chunkO3SWHQEE.getEventWindow)(event);
    if ((0, _chunkLCE7F24A.isMultiTouchEvent)(event)) return;
    this.handlers = handlers;
    if (threshold) {
      this.threshold = threshold;
    }
    event.stopPropagation();
    event.preventDefault();
    const info = (0, _chunkLCE7F24A.extractEventInfo)(event);
    const {
      timestamp
    } = (0, _framesync.getFrameData)();
    this.history = [{
      ...info.point,
      timestamp
    }];
    const {
      onSessionStart
    } = handlers;
    onSessionStart == null ? void 0 : onSessionStart(event, getPanInfo(info, this.history));
    this.removeListeners = (0, _chunkM3TFMUOL.pipe)((0, _chunkLCE7F24A.addPointerEvent)(this.win, "pointermove", this.onPointerMove), (0, _chunkLCE7F24A.addPointerEvent)(this.win, "pointerup", this.onPointerUp), (0, _chunkLCE7F24A.addPointerEvent)(this.win, "pointercancel", this.onPointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    var _a;
    (_a = this.removeListeners) == null ? void 0 : _a.call(this);
    _framesync.cancelSync.update(this.updatePoint);
  }
};
exports.PanSession = PanSession;
function subtractPoint(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}
function startPanPoint(history) {
  return history[0];
}
function lastPanPoint(history) {
  return history[history.length - 1];
}
function getPanInfo(info, history) {
  return {
    point: info.point,
    delta: subtractPoint(info.point, lastPanPoint(history)),
    offset: subtractPoint(info.point, startPanPoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
var toMilliseconds = seconds => seconds * 1e3;
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return {
      x: 0,
      y: 0
    };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return {
      x: 0,
      y: 0
    };
  }
  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time === 0) {
    return {
      x: 0,
      y: 0
    };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
},{"./chunk-LCE7F24A.mjs":"vc7r","./chunk-O3SWHQEE.mjs":"cvb8","./chunk-M3TFMUOL.mjs":"Ymut","./chunk-NHABU752.mjs":"e2uv","framesync":"V2xU"}],"iUZP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addItem = addItem;
exports.chunk = chunk;
exports.getFirstItem = getFirstItem;
exports.getLastItem = getLastItem;
exports.getNextIndex = getNextIndex;
exports.getNextItem = getNextItem;
exports.getNextItemFromSearch = getNextItemFromSearch;
exports.getPrevIndex = getPrevIndex;
exports.getPrevItem = getPrevItem;
exports.removeIndex = removeIndex;
exports.removeItem = removeItem;
// src/array.ts
function getFirstItem(array) {
  return array != null && array.length ? array[0] : void 0;
}
function getLastItem(array) {
  const length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
function getPrevItem(index, array, loop = true) {
  const prevIndex = getPrevIndex(index, array.length, loop);
  return array[prevIndex];
}
function getNextItem(index, array, loop = true) {
  const nextIndex = getNextIndex(index, array.length, 1, loop);
  return array[nextIndex];
}
function removeIndex(array, index) {
  return array.filter((_, idx) => idx !== index);
}
function addItem(array, item) {
  return [...array, item];
}
function removeItem(array, item) {
  return array.filter(eachItem => eachItem !== item);
}
function getNextIndex(currentIndex, length, step = 1, loop = true) {
  const lastIndex = length - 1;
  if (currentIndex === -1) {
    return step > 0 ? 0 : lastIndex;
  }
  const nextIndex = currentIndex + step;
  if (nextIndex < 0) {
    return loop ? lastIndex : 0;
  }
  if (nextIndex >= length) {
    if (loop) return 0;
    return currentIndex > length ? length : currentIndex;
  }
  return nextIndex;
}
function getPrevIndex(index, count, loop = true) {
  return getNextIndex(index, count, -1, loop);
}
function chunk(array, size) {
  return array.reduce((rows, currentValue, index) => {
    if (index % size === 0) {
      rows.push([currentValue]);
    } else {
      rows[rows.length - 1].push(currentValue);
    }
    return rows;
  }, []);
}
function getNextItemFromSearch(items, searchString, itemToString, currentItem) {
  if (searchString == null) {
    return currentItem;
  }
  if (!currentItem) {
    const foundItem = items.find(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()));
    return foundItem;
  }
  const matchingItems = items.filter(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()));
  if (matchingItems.length > 0) {
    let nextIndex;
    if (matchingItems.includes(currentItem)) {
      const currentIndex = matchingItems.indexOf(currentItem);
      nextIndex = currentIndex + 1;
      if (nextIndex === matchingItems.length) {
        nextIndex = 0;
      }
      return matchingItems[nextIndex];
    }
    nextIndex = items.indexOf(matchingItems[0]);
    return items[nextIndex];
  }
  return currentItem;
}
},{}],"cx7y":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayToObjectNotation = arrayToObjectNotation;
exports.isCustomBreakpoint = exports.breakpoints = void 0;
exports.isResponsiveObjectLike = isResponsiveObjectLike;
exports.mapResponsive = mapResponsive;
exports.objectToArrayNotation = objectToArrayNotation;
var _chunkYTQ3XZ3T = require("./chunk-YTQ3XZ3T.mjs");
var _chunkYTAYUX3P = require("./chunk-YTAYUX3P.mjs");
var _chunkY5FGD7DM = require("./chunk-Y5FGD7DM.mjs");
// src/responsive.ts
var breakpoints = Object.freeze(["base", "sm", "md", "lg", "xl", "2xl"]);
exports.breakpoints = breakpoints;
function mapResponsive(prop, mapper) {
  if ((0, _chunkY5FGD7DM.isArray)(prop)) {
    return prop.map(item => {
      if (item === null) {
        return null;
      }
      return mapper(item);
    });
  }
  if ((0, _chunkY5FGD7DM.isObject)(prop)) {
    return (0, _chunkYTQ3XZ3T.objectKeys)(prop).reduce((result, key) => {
      result[key] = mapper(prop[key]);
      return result;
    }, {});
  }
  if (prop != null) {
    return mapper(prop);
  }
  return null;
}
function objectToArrayNotation(obj, bps = breakpoints) {
  const result = bps.map(br => {
    var _a;
    return (_a = obj[br]) != null ? _a : null;
  });
  while ((0, _chunkYTAYUX3P.getLastItem)(result) === null) {
    result.pop();
  }
  return result;
}
function arrayToObjectNotation(values, bps = breakpoints) {
  const result = {};
  values.forEach((value, index) => {
    const key = bps[index];
    if (value == null) return;
    result[key] = value;
  });
  return result;
}
function isResponsiveObjectLike(obj, bps = breakpoints) {
  const keys = Object.keys(obj);
  return keys.length > 0 && keys.every(key => bps.includes(key));
}
var isCustomBreakpoint = maybeBreakpoint => Number.isNaN(Number(maybeBreakpoint));
exports.isCustomBreakpoint = isCustomBreakpoint;
},{"./chunk-YTQ3XZ3T.mjs":"n3RM","./chunk-YTAYUX3P.mjs":"iUZP","./chunk-Y5FGD7DM.mjs":"SQeD"}],"h8Hy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.analyzeBreakpoints = analyzeBreakpoints;
exports.px = px;
exports.toMediaQueryString = toMediaQueryString;
var _chunkYTQ3XZ3T = require("./chunk-YTQ3XZ3T.mjs");
var _chunkYTAYUX3P = require("./chunk-YTAYUX3P.mjs");
var _chunkY5FGD7DM = require("./chunk-Y5FGD7DM.mjs");
// src/breakpoint.ts
function analyzeCSSValue(value) {
  const num = parseFloat(value.toString());
  const unit = value.toString().replace(String(num), "");
  return {
    unitless: !unit,
    value: num,
    unit
  };
}
function px(value) {
  if (value == null) return value;
  const {
    unitless
  } = analyzeCSSValue(value);
  return unitless || (0, _chunkY5FGD7DM.isNumber)(value) ? `${value}px` : value;
}
var sortByBreakpointValue = (a, b) => parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;
var sortBps = breakpoints => (0, _chunkYTQ3XZ3T.fromEntries)(Object.entries(breakpoints).sort(sortByBreakpointValue));
function normalize(breakpoints) {
  const sorted = sortBps(breakpoints);
  return Object.assign(Object.values(sorted), sorted);
}
function keys(breakpoints) {
  const value = Object.keys(sortBps(breakpoints));
  return new Set(value);
}
function subtract(value) {
  var _a;
  if (!value) return value;
  value = (_a = px(value)) != null ? _a : value;
  const factor = value.endsWith("px") ? -0.02 : -0.01;
  return (0, _chunkY5FGD7DM.isNumber)(value) ? `${value + factor}` : value.replace(/(\d+\.?\d*)/u, m => `${parseFloat(m) + factor}`);
}
function toMediaQueryString(min, max) {
  const query = ["@media screen"];
  if (min) query.push("and", `(min-width: ${px(min)})`);
  if (max) query.push("and", `(max-width: ${px(max)})`);
  return query.join(" ");
}
function analyzeBreakpoints(breakpoints) {
  var _a;
  if (!breakpoints) return null;
  breakpoints.base = (_a = breakpoints.base) != null ? _a : "0px";
  const normalized = normalize(breakpoints);
  const queries = Object.entries(breakpoints).sort(sortByBreakpointValue).map(([breakpoint, minW], index, entry) => {
    var _a2;
    let [, maxW] = (_a2 = entry[index + 1]) != null ? _a2 : [];
    maxW = parseFloat(maxW) > 0 ? subtract(maxW) : void 0;
    return {
      _minW: subtract(minW),
      breakpoint,
      minW,
      maxW,
      maxWQuery: toMediaQueryString(null, maxW),
      minWQuery: toMediaQueryString(minW),
      minMaxQuery: toMediaQueryString(minW, maxW)
    };
  });
  const _keys = keys(breakpoints);
  const _keysArr = Array.from(_keys.values());
  return {
    keys: _keys,
    normalized,
    isResponsive(test) {
      const keys2 = Object.keys(test);
      return keys2.length > 0 && keys2.every(key => _keys.has(key));
    },
    asObject: sortBps(breakpoints),
    asArray: normalize(breakpoints),
    details: queries,
    media: [null, ...normalized.map(minW => toMediaQueryString(minW)).slice(1)],
    toArrayValue(test) {
      if (!(0, _chunkY5FGD7DM.isObject)(test)) {
        throw new Error("toArrayValue: value must be an object");
      }
      const result = _keysArr.map(bp => {
        var _a2;
        return (_a2 = test[bp]) != null ? _a2 : null;
      });
      while ((0, _chunkYTAYUX3P.getLastItem)(result) === null) {
        result.pop();
      }
      return result;
    },
    toObjectValue(test) {
      if (!Array.isArray(test)) {
        throw new Error("toObjectValue: value must be an array");
      }
      return test.reduce((acc, value, index) => {
        const key = _keysArr[index];
        if (key != null && value != null) acc[key] = value;
        return acc;
      }, {});
    }
  };
}
},{"./chunk-YTQ3XZ3T.mjs":"n3RM","./chunk-YTAYUX3P.mjs":"iUZP","./chunk-Y5FGD7DM.mjs":"SQeD"}],"yhvP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasDisplayNone = void 0;
exports.hasFocusWithin = hasFocusWithin;
exports.hasTabIndex = exports.hasNegativeTabIndex = void 0;
exports.isActiveElement = isActiveElement;
exports.isContentEditable = isContentEditable;
exports.isDisabled = isDisabled;
exports.isFocusable = isFocusable;
exports.isHidden = isHidden;
exports.isInputElement = isInputElement;
exports.isTabbable = isTabbable;
var _chunkO3SWHQEE = require("./chunk-O3SWHQEE.mjs");
// src/tabbable.ts
var hasDisplayNone = element => window.getComputedStyle(element).display === "none";
exports.hasDisplayNone = hasDisplayNone;
var hasTabIndex = element => element.hasAttribute("tabindex");
exports.hasTabIndex = hasTabIndex;
var hasNegativeTabIndex = element => hasTabIndex(element) && element.tabIndex === -1;
exports.hasNegativeTabIndex = hasNegativeTabIndex;
function isDisabled(element) {
  return Boolean(element.getAttribute("disabled")) === true || Boolean(element.getAttribute("aria-disabled")) === true;
}
function isInputElement(element) {
  return (0, _chunkO3SWHQEE.isHTMLElement)(element) && element.localName === "input" && "select" in element;
}
function isActiveElement(element) {
  const doc = (0, _chunkO3SWHQEE.isHTMLElement)(element) ? (0, _chunkO3SWHQEE.getOwnerDocument)(element) : document;
  return doc.activeElement === element;
}
function hasFocusWithin(element) {
  if (!document.activeElement) return false;
  return element.contains(document.activeElement);
}
function isHidden(element) {
  if (element.parentElement && isHidden(element.parentElement)) return true;
  return element.hidden;
}
function isContentEditable(element) {
  const value = element.getAttribute("contenteditable");
  return value !== "false" && value != null;
}
function isFocusable(element) {
  if (!(0, _chunkO3SWHQEE.isHTMLElement)(element) || isHidden(element) || isDisabled(element)) {
    return false;
  }
  const {
    localName
  } = element;
  const focusableTags = ["input", "select", "textarea", "button"];
  if (focusableTags.indexOf(localName) >= 0) return true;
  const others = {
    a: () => element.hasAttribute("href"),
    audio: () => element.hasAttribute("controls"),
    video: () => element.hasAttribute("controls")
  };
  if (localName in others) {
    return others[localName]();
  }
  if (isContentEditable(element)) return true;
  return hasTabIndex(element);
}
function isTabbable(element) {
  if (!element) return false;
  return (0, _chunkO3SWHQEE.isHTMLElement)(element) && isFocusable(element) && !hasNegativeTabIndex(element);
}
},{"./chunk-O3SWHQEE.mjs":"cvb8"}],"obnL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.closest = closest;
exports.focusNextTabbable = focusNextTabbable;
exports.focusPreviousTabbable = focusPreviousTabbable;
exports.getAllFocusable = getAllFocusable;
exports.getAllTabbable = getAllTabbable;
exports.getFirstFocusable = getFirstFocusable;
exports.getFirstTabbableIn = getFirstTabbableIn;
exports.getLastTabbableIn = getLastTabbableIn;
exports.getNextTabbable = getNextTabbable;
exports.getPreviousTabbable = getPreviousTabbable;
var _chunkP6S57EDQ = require("./chunk-P6S57EDQ.mjs");
var _chunkO3SWHQEE = require("./chunk-O3SWHQEE.mjs");
// src/dom-query.ts
var focusableElList = ["input:not(:disabled):not([disabled])", "select:not(:disabled):not([disabled])", "textarea:not(:disabled):not([disabled])", "embed", "iframe", "object", "a[href]", "area[href]", "button:not(:disabled):not([disabled])", "[tabindex]", "audio[controls]", "video[controls]", "*[tabindex]:not([aria-disabled])", "*[contenteditable]"];
var focusableElSelector = focusableElList.join();
var isVisible = el => el.offsetWidth > 0 && el.offsetHeight > 0;
function getAllFocusable(container) {
  const focusableEls = Array.from(container.querySelectorAll(focusableElSelector));
  focusableEls.unshift(container);
  return focusableEls.filter(el => (0, _chunkP6S57EDQ.isFocusable)(el) && isVisible(el));
}
function getFirstFocusable(container) {
  const allFocusable = getAllFocusable(container);
  return allFocusable.length ? allFocusable[0] : null;
}
function getAllTabbable(container, fallbackToFocusable) {
  const allFocusable = Array.from(container.querySelectorAll(focusableElSelector));
  const allTabbable = allFocusable.filter(_chunkP6S57EDQ.isTabbable);
  if ((0, _chunkP6S57EDQ.isTabbable)(container)) {
    allTabbable.unshift(container);
  }
  if (!allTabbable.length && fallbackToFocusable) {
    return allFocusable;
  }
  return allTabbable;
}
function getFirstTabbableIn(container, fallbackToFocusable) {
  const [first] = getAllTabbable(container, fallbackToFocusable);
  return first || null;
}
function getLastTabbableIn(container, fallbackToFocusable) {
  const allTabbable = getAllTabbable(container, fallbackToFocusable);
  return allTabbable[allTabbable.length - 1] || null;
}
function getNextTabbable(container, fallbackToFocusable) {
  const allFocusable = getAllFocusable(container);
  const index = allFocusable.indexOf(document.activeElement);
  const slice = allFocusable.slice(index + 1);
  return slice.find(_chunkP6S57EDQ.isTabbable) || allFocusable.find(_chunkP6S57EDQ.isTabbable) || (fallbackToFocusable ? slice[0] : null);
}
function getPreviousTabbable(container, fallbackToFocusable) {
  const allFocusable = getAllFocusable(container).reverse();
  const index = allFocusable.indexOf(document.activeElement);
  const slice = allFocusable.slice(index + 1);
  return slice.find(_chunkP6S57EDQ.isTabbable) || allFocusable.find(_chunkP6S57EDQ.isTabbable) || (fallbackToFocusable ? slice[0] : null);
}
function focusNextTabbable(container, fallbackToFocusable) {
  const nextTabbable = getNextTabbable(container, fallbackToFocusable);
  if (nextTabbable && (0, _chunkO3SWHQEE.isHTMLElement)(nextTabbable)) {
    nextTabbable.focus();
  }
}
function focusPreviousTabbable(container, fallbackToFocusable) {
  const previousTabbable = getPreviousTabbable(container, fallbackToFocusable);
  if (previousTabbable && (0, _chunkO3SWHQEE.isHTMLElement)(previousTabbable)) {
    previousTabbable.focus();
  }
}
function matches(element, selectors) {
  if ("matches" in element) return element.matches(selectors);
  if ("msMatchesSelector" in element) return element.msMatchesSelector(selectors);
  return element.webkitMatchesSelector(selectors);
}
function closest(element, selectors) {
  if ("closest" in element) return element.closest(selectors);
  do {
    if (matches(element, selectors)) return element;
    element = element.parentElement || element.parentNode;
  } while (element !== null && element.nodeType === 1);
  return null;
}
},{"./chunk-P6S57EDQ.mjs":"yhvP","./chunk-O3SWHQEE.mjs":"cvb8"}],"jnpN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flatten = flatten;
var _chunkY5FGD7DM = require("./chunk-Y5FGD7DM.mjs");
// src/flatten.ts
function flatten(target, maxDepth = Infinity) {
  if (!(0, _chunkY5FGD7DM.isObject)(target) && !Array.isArray(target) || !maxDepth) {
    return target;
  }
  return Object.entries(target).reduce((result, [key, value]) => {
    if ((0, _chunkY5FGD7DM.isObject)(value) || (0, _chunkY5FGD7DM.isArray)(value)) {
      Object.entries(flatten(value, maxDepth - 1)).forEach(([childKey, childValue]) => {
        result[`${key}.${childKey}`] = childValue;
      });
    } else {
      result[key] = value;
    }
    return result;
  }, {});
}
},{"./chunk-Y5FGD7DM.mjs":"SQeD"}],"Ej6T":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.focus = focus;
var _chunkP6S57EDQ = require("./chunk-P6S57EDQ.mjs");
var _chunkO3SWHQEE = require("./chunk-O3SWHQEE.mjs");
var _chunkM3TFMUOL = require("./chunk-M3TFMUOL.mjs");
// src/focus.ts
function focus(element, options = {}) {
  const {
    isActive = _chunkP6S57EDQ.isActiveElement,
    nextTick,
    preventScroll = true,
    selectTextIfInput = true
  } = options;
  if (!element || isActive(element)) return -1;
  function triggerFocus() {
    if (!element) {
      (0, _chunkM3TFMUOL.warn)({
        condition: true,
        message: "[chakra-ui]: can't call focus() on `null` or `undefined` element"
      });
      return;
    }
    if (supportsPreventScroll()) {
      element.focus({
        preventScroll
      });
    } else {
      element.focus();
      if (preventScroll) {
        const scrollableElements = getScrollableElements(element);
        restoreScrollPosition(scrollableElements);
      }
    }
    if (selectTextIfInput) {
      if ((0, _chunkP6S57EDQ.isInputElement)(element)) {
        element.select();
      } else if ("setSelectionRange" in element) {
        const el = element;
        el.setSelectionRange(el.value.length, el.value.length);
      }
    }
  }
  if (nextTick) {
    return requestAnimationFrame(triggerFocus);
  }
  triggerFocus();
  return -1;
}
var supportsPreventScrollCached = null;
function supportsPreventScroll() {
  if (supportsPreventScrollCached == null) {
    supportsPreventScrollCached = false;
    try {
      const div = document.createElement("div");
      div.focus({
        get preventScroll() {
          supportsPreventScrollCached = true;
          return true;
        }
      });
    } catch (e) {}
  }
  return supportsPreventScrollCached;
}
function getScrollableElements(element) {
  var _a;
  const doc = (0, _chunkO3SWHQEE.getOwnerDocument)(element);
  const win = (_a = doc.defaultView) != null ? _a : window;
  let parent = element.parentNode;
  const scrollableElements = [];
  const rootScrollingElement = doc.scrollingElement || doc.documentElement;
  while (parent instanceof win.HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {
      scrollableElements.push({
        element: parent,
        scrollTop: parent.scrollTop,
        scrollLeft: parent.scrollLeft
      });
    }
    parent = parent.parentNode;
  }
  if (rootScrollingElement instanceof win.HTMLElement) {
    scrollableElements.push({
      element: rootScrollingElement,
      scrollTop: rootScrollingElement.scrollTop,
      scrollLeft: rootScrollingElement.scrollLeft
    });
  }
  return scrollableElements;
}
function restoreScrollPosition(scrollableElements) {
  for (const {
    element,
    scrollTop,
    scrollLeft
  } of scrollableElements) {
    element.scrollTop = scrollTop;
    element.scrollLeft = scrollLeft;
  }
}
},{"./chunk-P6S57EDQ.mjs":"yhvP","./chunk-O3SWHQEE.mjs":"cvb8","./chunk-M3TFMUOL.mjs":"Ymut"}],"bfQg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = invariant;
var isProduction = "production" === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === 'function' ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}
},{}],"G7Xl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withScroll = exports.shrink = exports.offset = exports.getRect = exports.getBox = exports.expand = exports.createBox = exports.calculateBox = void 0;
var _tinyInvariant = _interopRequireDefault(require("tiny-invariant"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var getRect = function getRect(_ref) {
  var top = _ref.top,
    right = _ref.right,
    bottom = _ref.bottom,
    left = _ref.left;
  var width = right - left;
  var height = bottom - top;
  var rect = {
    top: top,
    right: right,
    bottom: bottom,
    left: left,
    width: width,
    height: height,
    x: left,
    y: top,
    center: {
      x: (right + left) / 2,
      y: (bottom + top) / 2
    }
  };
  return rect;
};
exports.getRect = getRect;
var expand = function expand(target, expandBy) {
  return {
    top: target.top - expandBy.top,
    left: target.left - expandBy.left,
    bottom: target.bottom + expandBy.bottom,
    right: target.right + expandBy.right
  };
};
exports.expand = expand;
var shrink = function shrink(target, shrinkBy) {
  return {
    top: target.top + shrinkBy.top,
    left: target.left + shrinkBy.left,
    bottom: target.bottom - shrinkBy.bottom,
    right: target.right - shrinkBy.right
  };
};
exports.shrink = shrink;
var shift = function shift(target, shiftBy) {
  return {
    top: target.top + shiftBy.y,
    left: target.left + shiftBy.x,
    bottom: target.bottom + shiftBy.y,
    right: target.right + shiftBy.x
  };
};
var noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var createBox = function createBox(_ref2) {
  var borderBox = _ref2.borderBox,
    _ref2$margin = _ref2.margin,
    margin = _ref2$margin === void 0 ? noSpacing : _ref2$margin,
    _ref2$border = _ref2.border,
    border = _ref2$border === void 0 ? noSpacing : _ref2$border,
    _ref2$padding = _ref2.padding,
    padding = _ref2$padding === void 0 ? noSpacing : _ref2$padding;
  var marginBox = getRect(expand(borderBox, margin));
  var paddingBox = getRect(shrink(borderBox, border));
  var contentBox = getRect(shrink(paddingBox, padding));
  return {
    marginBox: marginBox,
    borderBox: getRect(borderBox),
    paddingBox: paddingBox,
    contentBox: contentBox,
    margin: margin,
    border: border,
    padding: padding
  };
};
exports.createBox = createBox;
var parse = function parse(raw) {
  var value = raw.slice(0, -2);
  var suffix = raw.slice(-2);
  if (suffix !== 'px') {
    return 0;
  }
  var result = Number(value);
  !!isNaN(result) ? "production" !== "production" ? (0, _tinyInvariant.default)(false, "Could not parse value [raw: " + raw + ", without suffix: " + value + "]") : (0, _tinyInvariant.default)(false) : void 0;
  return result;
};
var getWindowScroll = function getWindowScroll() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
var offset = function offset(original, change) {
  var borderBox = original.borderBox,
    border = original.border,
    margin = original.margin,
    padding = original.padding;
  var shifted = shift(borderBox, change);
  return createBox({
    borderBox: shifted,
    border: border,
    margin: margin,
    padding: padding
  });
};
exports.offset = offset;
var withScroll = function withScroll(original, scroll) {
  if (scroll === void 0) {
    scroll = getWindowScroll();
  }
  return offset(original, scroll);
};
exports.withScroll = withScroll;
var calculateBox = function calculateBox(borderBox, styles) {
  var margin = {
    top: parse(styles.marginTop),
    right: parse(styles.marginRight),
    bottom: parse(styles.marginBottom),
    left: parse(styles.marginLeft)
  };
  var padding = {
    top: parse(styles.paddingTop),
    right: parse(styles.paddingRight),
    bottom: parse(styles.paddingBottom),
    left: parse(styles.paddingLeft)
  };
  var border = {
    top: parse(styles.borderTopWidth),
    right: parse(styles.borderRightWidth),
    bottom: parse(styles.borderBottomWidth),
    left: parse(styles.borderLeftWidth)
  };
  return createBox({
    borderBox: borderBox,
    margin: margin,
    padding: padding,
    border: border
  });
};
exports.calculateBox = calculateBox;
var getBox = function getBox(el) {
  var borderBox = el.getBoundingClientRect();
  var styles = window.getComputedStyle(el);
  return calculateBox(borderBox, styles);
};
exports.getBox = getBox;
},{"tiny-invariant":"bfQg"}],"Yp4B":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  detectBrowser: true,
  detectDeviceType: true,
  detectOS: true,
  detectTouch: true,
  walkObject: true,
  determineLazyBehavior: true,
  clampValue: true,
  countDecimalPlaces: true,
  maxSafeInteger: true,
  minSafeInteger: true,
  percentToValue: true,
  roundValueToStep: true,
  toPrecision: true,
  valueToPercent: true,
  PanSession: true,
  addPointerEvent: true,
  extractEventInfo: true,
  getPointerEventName: true,
  getViewportPointFromEvent: true,
  isMouseEvent: true,
  isMultiTouchEvent: true,
  isTouchEvent: true,
  wrapPointerEventHandler: true,
  arrayToObjectNotation: true,
  breakpoints: true,
  isCustomBreakpoint: true,
  isResponsiveObjectLike: true,
  mapResponsive: true,
  objectToArrayNotation: true,
  analyzeBreakpoints: true,
  px: true,
  toMediaQueryString: true,
  mergeWith: true,
  filterUndefined: true,
  fromEntries: true,
  get: true,
  getCSSVar: true,
  getWithDefault: true,
  memoize: true,
  memoizedGet: true,
  objectFilter: true,
  objectKeys: true,
  omit: true,
  pick: true,
  split: true,
  addItem: true,
  chunk: true,
  getFirstItem: true,
  getLastItem: true,
  getNextIndex: true,
  getNextItem: true,
  getNextItemFromSearch: true,
  getPrevIndex: true,
  getPrevItem: true,
  removeIndex: true,
  removeItem: true,
  closest: true,
  focusNextTabbable: true,
  focusPreviousTabbable: true,
  getAllFocusable: true,
  getAllTabbable: true,
  getFirstFocusable: true,
  getFirstTabbableIn: true,
  getLastTabbableIn: true,
  getNextTabbable: true,
  getPreviousTabbable: true,
  flatten: true,
  focus: true,
  hasDisplayNone: true,
  hasFocusWithin: true,
  hasNegativeTabIndex: true,
  hasTabIndex: true,
  isActiveElement: true,
  isContentEditable: true,
  isDisabled: true,
  isFocusable: true,
  isHidden: true,
  isInputElement: true,
  isTabbable: true,
  addDomEvent: true,
  ariaAttr: true,
  canUseDOM: true,
  contains: true,
  cx: true,
  dataAttr: true,
  getActiveElement: true,
  getEventWindow: true,
  getOwnerDocument: true,
  getOwnerWindow: true,
  getRelatedTarget: true,
  isBrowser: true,
  isElement: true,
  isHTMLElement: true,
  isRightClick: true,
  normalizeEventKey: true,
  callAll: true,
  callAllHandlers: true,
  compose: true,
  distance: true,
  error: true,
  noop: true,
  once: true,
  pipe: true,
  runIfFn: true,
  warn: true,
  __DEV__: true,
  __TEST__: true,
  isArray: true,
  isCssVar: true,
  isDefined: true,
  isEmpty: true,
  isEmptyArray: true,
  isEmptyObject: true,
  isFunction: true,
  isInputEvent: true,
  isNotEmptyObject: true,
  isNotNumber: true,
  isNull: true,
  isNumber: true,
  isNumeric: true,
  isObject: true,
  isRefObject: true,
  isString: true,
  isUndefined: true
};
Object.defineProperty(exports, "PanSession", {
  enumerable: true,
  get: function () {
    return _chunkSV3JYFGC.PanSession;
  }
});
Object.defineProperty(exports, "__DEV__", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.__DEV__;
  }
});
Object.defineProperty(exports, "__TEST__", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.__TEST__;
  }
});
Object.defineProperty(exports, "addDomEvent", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.addDomEvent;
  }
});
Object.defineProperty(exports, "addItem", {
  enumerable: true,
  get: function () {
    return _chunkYTAYUX3P.addItem;
  }
});
Object.defineProperty(exports, "addPointerEvent", {
  enumerable: true,
  get: function () {
    return _chunkLCE7F24A.addPointerEvent;
  }
});
Object.defineProperty(exports, "analyzeBreakpoints", {
  enumerable: true,
  get: function () {
    return _chunkFDX7JCYE.analyzeBreakpoints;
  }
});
Object.defineProperty(exports, "ariaAttr", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.ariaAttr;
  }
});
Object.defineProperty(exports, "arrayToObjectNotation", {
  enumerable: true,
  get: function () {
    return _chunkFGAEJGLB.arrayToObjectNotation;
  }
});
Object.defineProperty(exports, "breakpoints", {
  enumerable: true,
  get: function () {
    return _chunkFGAEJGLB.breakpoints;
  }
});
Object.defineProperty(exports, "callAll", {
  enumerable: true,
  get: function () {
    return _chunkM3TFMUOL.callAll;
  }
});
Object.defineProperty(exports, "callAllHandlers", {
  enumerable: true,
  get: function () {
    return _chunkM3TFMUOL.callAllHandlers;
  }
});
Object.defineProperty(exports, "canUseDOM", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.canUseDOM;
  }
});
Object.defineProperty(exports, "chunk", {
  enumerable: true,
  get: function () {
    return _chunkYTAYUX3P.chunk;
  }
});
Object.defineProperty(exports, "clampValue", {
  enumerable: true,
  get: function () {
    return _chunkYAFHXCR.clampValue;
  }
});
Object.defineProperty(exports, "closest", {
  enumerable: true,
  get: function () {
    return _chunk5LUSIWEA.closest;
  }
});
Object.defineProperty(exports, "compose", {
  enumerable: true,
  get: function () {
    return _chunkM3TFMUOL.compose;
  }
});
Object.defineProperty(exports, "contains", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.contains;
  }
});
Object.defineProperty(exports, "countDecimalPlaces", {
  enumerable: true,
  get: function () {
    return _chunkYAFHXCR.countDecimalPlaces;
  }
});
Object.defineProperty(exports, "cx", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.cx;
  }
});
Object.defineProperty(exports, "dataAttr", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.dataAttr;
  }
});
Object.defineProperty(exports, "detectBrowser", {
  enumerable: true,
  get: function () {
    return _chunkDGFLLHTM.detectBrowser;
  }
});
Object.defineProperty(exports, "detectDeviceType", {
  enumerable: true,
  get: function () {
    return _chunkDGFLLHTM.detectDeviceType;
  }
});
Object.defineProperty(exports, "detectOS", {
  enumerable: true,
  get: function () {
    return _chunkDGFLLHTM.detectOS;
  }
});
Object.defineProperty(exports, "detectTouch", {
  enumerable: true,
  get: function () {
    return _chunkDGFLLHTM.detectTouch;
  }
});
Object.defineProperty(exports, "determineLazyBehavior", {
  enumerable: true,
  get: function () {
    return _chunkXHETS.determineLazyBehavior;
  }
});
Object.defineProperty(exports, "distance", {
  enumerable: true,
  get: function () {
    return _chunkM3TFMUOL.distance;
  }
});
Object.defineProperty(exports, "error", {
  enumerable: true,
  get: function () {
    return _chunkM3TFMUOL.error;
  }
});
Object.defineProperty(exports, "extractEventInfo", {
  enumerable: true,
  get: function () {
    return _chunkLCE7F24A.extractEventInfo;
  }
});
Object.defineProperty(exports, "filterUndefined", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.filterUndefined;
  }
});
Object.defineProperty(exports, "flatten", {
  enumerable: true,
  get: function () {
    return _chunkW5Y7LCVY.flatten;
  }
});
Object.defineProperty(exports, "focus", {
  enumerable: true,
  get: function () {
    return _chunkQKXRP2IX.focus;
  }
});
Object.defineProperty(exports, "focusNextTabbable", {
  enumerable: true,
  get: function () {
    return _chunk5LUSIWEA.focusNextTabbable;
  }
});
Object.defineProperty(exports, "focusPreviousTabbable", {
  enumerable: true,
  get: function () {
    return _chunk5LUSIWEA.focusPreviousTabbable;
  }
});
Object.defineProperty(exports, "fromEntries", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.fromEntries;
  }
});
Object.defineProperty(exports, "get", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.get;
  }
});
Object.defineProperty(exports, "getActiveElement", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.getActiveElement;
  }
});
Object.defineProperty(exports, "getAllFocusable", {
  enumerable: true,
  get: function () {
    return _chunk5LUSIWEA.getAllFocusable;
  }
});
Object.defineProperty(exports, "getAllTabbable", {
  enumerable: true,
  get: function () {
    return _chunk5LUSIWEA.getAllTabbable;
  }
});
Object.defineProperty(exports, "getCSSVar", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.getCSSVar;
  }
});
Object.defineProperty(exports, "getEventWindow", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.getEventWindow;
  }
});
Object.defineProperty(exports, "getFirstFocusable", {
  enumerable: true,
  get: function () {
    return _chunk5LUSIWEA.getFirstFocusable;
  }
});
Object.defineProperty(exports, "getFirstItem", {
  enumerable: true,
  get: function () {
    return _chunkYTAYUX3P.getFirstItem;
  }
});
Object.defineProperty(exports, "getFirstTabbableIn", {
  enumerable: true,
  get: function () {
    return _chunk5LUSIWEA.getFirstTabbableIn;
  }
});
Object.defineProperty(exports, "getLastItem", {
  enumerable: true,
  get: function () {
    return _chunkYTAYUX3P.getLastItem;
  }
});
Object.defineProperty(exports, "getLastTabbableIn", {
  enumerable: true,
  get: function () {
    return _chunk5LUSIWEA.getLastTabbableIn;
  }
});
Object.defineProperty(exports, "getNextIndex", {
  enumerable: true,
  get: function () {
    return _chunkYTAYUX3P.getNextIndex;
  }
});
Object.defineProperty(exports, "getNextItem", {
  enumerable: true,
  get: function () {
    return _chunkYTAYUX3P.getNextItem;
  }
});
Object.defineProperty(exports, "getNextItemFromSearch", {
  enumerable: true,
  get: function () {
    return _chunkYTAYUX3P.getNextItemFromSearch;
  }
});
Object.defineProperty(exports, "getNextTabbable", {
  enumerable: true,
  get: function () {
    return _chunk5LUSIWEA.getNextTabbable;
  }
});
Object.defineProperty(exports, "getOwnerDocument", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.getOwnerDocument;
  }
});
Object.defineProperty(exports, "getOwnerWindow", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.getOwnerWindow;
  }
});
Object.defineProperty(exports, "getPointerEventName", {
  enumerable: true,
  get: function () {
    return _chunkLCE7F24A.getPointerEventName;
  }
});
Object.defineProperty(exports, "getPrevIndex", {
  enumerable: true,
  get: function () {
    return _chunkYTAYUX3P.getPrevIndex;
  }
});
Object.defineProperty(exports, "getPrevItem", {
  enumerable: true,
  get: function () {
    return _chunkYTAYUX3P.getPrevItem;
  }
});
Object.defineProperty(exports, "getPreviousTabbable", {
  enumerable: true,
  get: function () {
    return _chunk5LUSIWEA.getPreviousTabbable;
  }
});
Object.defineProperty(exports, "getRelatedTarget", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.getRelatedTarget;
  }
});
Object.defineProperty(exports, "getViewportPointFromEvent", {
  enumerable: true,
  get: function () {
    return _chunkLCE7F24A.getViewportPointFromEvent;
  }
});
Object.defineProperty(exports, "getWithDefault", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.getWithDefault;
  }
});
Object.defineProperty(exports, "hasDisplayNone", {
  enumerable: true,
  get: function () {
    return _chunkP6S57EDQ.hasDisplayNone;
  }
});
Object.defineProperty(exports, "hasFocusWithin", {
  enumerable: true,
  get: function () {
    return _chunkP6S57EDQ.hasFocusWithin;
  }
});
Object.defineProperty(exports, "hasNegativeTabIndex", {
  enumerable: true,
  get: function () {
    return _chunkP6S57EDQ.hasNegativeTabIndex;
  }
});
Object.defineProperty(exports, "hasTabIndex", {
  enumerable: true,
  get: function () {
    return _chunkP6S57EDQ.hasTabIndex;
  }
});
Object.defineProperty(exports, "isActiveElement", {
  enumerable: true,
  get: function () {
    return _chunkP6S57EDQ.isActiveElement;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isArray;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.isBrowser;
  }
});
Object.defineProperty(exports, "isContentEditable", {
  enumerable: true,
  get: function () {
    return _chunkP6S57EDQ.isContentEditable;
  }
});
Object.defineProperty(exports, "isCssVar", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isCssVar;
  }
});
Object.defineProperty(exports, "isCustomBreakpoint", {
  enumerable: true,
  get: function () {
    return _chunkFGAEJGLB.isCustomBreakpoint;
  }
});
Object.defineProperty(exports, "isDefined", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isDefined;
  }
});
Object.defineProperty(exports, "isDisabled", {
  enumerable: true,
  get: function () {
    return _chunkP6S57EDQ.isDisabled;
  }
});
Object.defineProperty(exports, "isElement", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.isElement;
  }
});
Object.defineProperty(exports, "isEmpty", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isEmpty;
  }
});
Object.defineProperty(exports, "isEmptyArray", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isEmptyArray;
  }
});
Object.defineProperty(exports, "isEmptyObject", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isEmptyObject;
  }
});
Object.defineProperty(exports, "isFocusable", {
  enumerable: true,
  get: function () {
    return _chunkP6S57EDQ.isFocusable;
  }
});
Object.defineProperty(exports, "isFunction", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isFunction;
  }
});
Object.defineProperty(exports, "isHTMLElement", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.isHTMLElement;
  }
});
Object.defineProperty(exports, "isHidden", {
  enumerable: true,
  get: function () {
    return _chunkP6S57EDQ.isHidden;
  }
});
Object.defineProperty(exports, "isInputElement", {
  enumerable: true,
  get: function () {
    return _chunkP6S57EDQ.isInputElement;
  }
});
Object.defineProperty(exports, "isInputEvent", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isInputEvent;
  }
});
Object.defineProperty(exports, "isMouseEvent", {
  enumerable: true,
  get: function () {
    return _chunkLCE7F24A.isMouseEvent;
  }
});
Object.defineProperty(exports, "isMultiTouchEvent", {
  enumerable: true,
  get: function () {
    return _chunkLCE7F24A.isMultiTouchEvent;
  }
});
Object.defineProperty(exports, "isNotEmptyObject", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isNotEmptyObject;
  }
});
Object.defineProperty(exports, "isNotNumber", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isNotNumber;
  }
});
Object.defineProperty(exports, "isNull", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isNull;
  }
});
Object.defineProperty(exports, "isNumber", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isNumber;
  }
});
Object.defineProperty(exports, "isNumeric", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isNumeric;
  }
});
Object.defineProperty(exports, "isObject", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isObject;
  }
});
Object.defineProperty(exports, "isRefObject", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isRefObject;
  }
});
Object.defineProperty(exports, "isResponsiveObjectLike", {
  enumerable: true,
  get: function () {
    return _chunkFGAEJGLB.isResponsiveObjectLike;
  }
});
Object.defineProperty(exports, "isRightClick", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.isRightClick;
  }
});
Object.defineProperty(exports, "isString", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isString;
  }
});
Object.defineProperty(exports, "isTabbable", {
  enumerable: true,
  get: function () {
    return _chunkP6S57EDQ.isTabbable;
  }
});
Object.defineProperty(exports, "isTouchEvent", {
  enumerable: true,
  get: function () {
    return _chunkLCE7F24A.isTouchEvent;
  }
});
Object.defineProperty(exports, "isUndefined", {
  enumerable: true,
  get: function () {
    return _chunkY5FGD7DM.isUndefined;
  }
});
Object.defineProperty(exports, "mapResponsive", {
  enumerable: true,
  get: function () {
    return _chunkFGAEJGLB.mapResponsive;
  }
});
Object.defineProperty(exports, "maxSafeInteger", {
  enumerable: true,
  get: function () {
    return _chunkYAFHXCR.maxSafeInteger;
  }
});
Object.defineProperty(exports, "memoize", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.memoize;
  }
});
Object.defineProperty(exports, "memoizedGet", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.memoizedGet;
  }
});
Object.defineProperty(exports, "mergeWith", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.default;
  }
});
Object.defineProperty(exports, "minSafeInteger", {
  enumerable: true,
  get: function () {
    return _chunkYAFHXCR.minSafeInteger;
  }
});
Object.defineProperty(exports, "noop", {
  enumerable: true,
  get: function () {
    return _chunkM3TFMUOL.noop;
  }
});
Object.defineProperty(exports, "normalizeEventKey", {
  enumerable: true,
  get: function () {
    return _chunkO3SWHQEE.normalizeEventKey;
  }
});
Object.defineProperty(exports, "objectFilter", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.objectFilter;
  }
});
Object.defineProperty(exports, "objectKeys", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.objectKeys;
  }
});
Object.defineProperty(exports, "objectToArrayNotation", {
  enumerable: true,
  get: function () {
    return _chunkFGAEJGLB.objectToArrayNotation;
  }
});
Object.defineProperty(exports, "omit", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.omit;
  }
});
Object.defineProperty(exports, "once", {
  enumerable: true,
  get: function () {
    return _chunkM3TFMUOL.once;
  }
});
Object.defineProperty(exports, "percentToValue", {
  enumerable: true,
  get: function () {
    return _chunkYAFHXCR.percentToValue;
  }
});
Object.defineProperty(exports, "pick", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.pick;
  }
});
Object.defineProperty(exports, "pipe", {
  enumerable: true,
  get: function () {
    return _chunkM3TFMUOL.pipe;
  }
});
Object.defineProperty(exports, "px", {
  enumerable: true,
  get: function () {
    return _chunkFDX7JCYE.px;
  }
});
Object.defineProperty(exports, "removeIndex", {
  enumerable: true,
  get: function () {
    return _chunkYTAYUX3P.removeIndex;
  }
});
Object.defineProperty(exports, "removeItem", {
  enumerable: true,
  get: function () {
    return _chunkYTAYUX3P.removeItem;
  }
});
Object.defineProperty(exports, "roundValueToStep", {
  enumerable: true,
  get: function () {
    return _chunkYAFHXCR.roundValueToStep;
  }
});
Object.defineProperty(exports, "runIfFn", {
  enumerable: true,
  get: function () {
    return _chunkM3TFMUOL.runIfFn;
  }
});
Object.defineProperty(exports, "split", {
  enumerable: true,
  get: function () {
    return _chunkYTQ3XZ3T.split;
  }
});
Object.defineProperty(exports, "toMediaQueryString", {
  enumerable: true,
  get: function () {
    return _chunkFDX7JCYE.toMediaQueryString;
  }
});
Object.defineProperty(exports, "toPrecision", {
  enumerable: true,
  get: function () {
    return _chunkYAFHXCR.toPrecision;
  }
});
Object.defineProperty(exports, "valueToPercent", {
  enumerable: true,
  get: function () {
    return _chunkYAFHXCR.valueToPercent;
  }
});
Object.defineProperty(exports, "walkObject", {
  enumerable: true,
  get: function () {
    return _chunkDVFODTG.walkObject;
  }
});
Object.defineProperty(exports, "warn", {
  enumerable: true,
  get: function () {
    return _chunkM3TFMUOL.warn;
  }
});
Object.defineProperty(exports, "wrapPointerEventHandler", {
  enumerable: true,
  get: function () {
    return _chunkLCE7F24A.wrapPointerEventHandler;
  }
});
require("./chunk-WBQAMGXK.mjs");
var _chunkDGFLLHTM = require("./chunk-DGFLLHTM.mjs");
var _chunkDVFODTG = require("./chunk-DVFODTG7.mjs");
var _chunkXHETS = require("./chunk-XHETS734.mjs");
var _chunkYAFHXCR = require("./chunk-YAFHXCR4.mjs");
var _chunkSV3JYFGC = require("./chunk-SV3JYFGC.mjs");
var _chunkLCE7F24A = require("./chunk-LCE7F24A.mjs");
var _chunkFGAEJGLB = require("./chunk-FGAEJGLB.mjs");
var _chunkFDX7JCYE = require("./chunk-FDX7JCYE.mjs");
var _chunkYTQ3XZ3T = _interopRequireWildcard(require("./chunk-YTQ3XZ3T.mjs"));
var _chunkYTAYUX3P = require("./chunk-YTAYUX3P.mjs");
var _chunk5LUSIWEA = require("./chunk-5LUSIWEA.mjs");
var _chunkW5Y7LCVY = require("./chunk-W5Y7LCVY.mjs");
var _chunkQKXRP2IX = require("./chunk-QKXRP2IX.mjs");
var _chunkP6S57EDQ = require("./chunk-P6S57EDQ.mjs");
var _chunkO3SWHQEE = require("./chunk-O3SWHQEE.mjs");
var _chunkM3TFMUOL = require("./chunk-M3TFMUOL.mjs");
var _chunkY5FGD7DM = require("./chunk-Y5FGD7DM.mjs");
require("./chunk-NHABU752.mjs");
var _cssBoxModel = require("css-box-model");
Object.keys(_cssBoxModel).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _cssBoxModel[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cssBoxModel[key];
    }
  });
});
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./chunk-WBQAMGXK.mjs":"Tnu0","./chunk-DGFLLHTM.mjs":"TbMI","./chunk-DVFODTG7.mjs":"XPK8","./chunk-XHETS734.mjs":"GabY","./chunk-YAFHXCR4.mjs":"kuee","./chunk-SV3JYFGC.mjs":"Fv3i","./chunk-LCE7F24A.mjs":"vc7r","./chunk-FGAEJGLB.mjs":"cx7y","./chunk-FDX7JCYE.mjs":"h8Hy","./chunk-YTQ3XZ3T.mjs":"n3RM","./chunk-YTAYUX3P.mjs":"iUZP","./chunk-5LUSIWEA.mjs":"obnL","./chunk-W5Y7LCVY.mjs":"jnpN","./chunk-QKXRP2IX.mjs":"Ej6T","./chunk-P6S57EDQ.mjs":"yhvP","./chunk-O3SWHQEE.mjs":"cvb8","./chunk-M3TFMUOL.mjs":"Ymut","./chunk-Y5FGD7DM.mjs":"SQeD","./chunk-NHABU752.mjs":"e2uv","css-box-model":"G7Xl"}],"e5DK":[function(require,module,exports) {
/* global Map:readonly, Set:readonly, ArrayBuffer:readonly */

var hasElementType = typeof Element !== 'undefined';
var hasMap = typeof Map === 'function';
var hasSet = typeof Set === 'function';
var hasArrayBuffer = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView;

// Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js

function equal(a, b) {
  // START: fast-deep-equal es6/index.js 3.1.1
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    // START: Modifications:
    // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code
    //    to co-exist with es5.
    // 2. Replace `for of` with es5 compliant iteration using `for`.
    //    Basically, take:
    //
    //    ```js
    //    for (i of a.entries())
    //      if (!b.has(i[0])) return false;
    //    ```
    //
    //    ... and convert to:
    //
    //    ```js
    //    it = a.entries();
    //    while (!(i = it.next()).done)
    //      if (!b.has(i.value[0])) return false;
    //    ```
    //
    //    **Note**: `i` access switches to `i.value`.
    var it;
    if (hasMap && (a instanceof Map) && (b instanceof Map)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!equal(i.value[1], b.get(i.value[0]))) return false;
      return true;
    }

    if (hasSet && (a instanceof Set) && (b instanceof Set)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      return true;
    }
    // END: Modifications

    if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (a[i] !== b[i]) return false;
      return true;
    }

    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    // END: fast-deep-equal

    // START: react-fast-compare
    // custom handling for DOM elements
    if (hasElementType && a instanceof Element) return false;

    // custom handling for React/Preact
    for (i = length; i-- !== 0;) {
      if ((keys[i] === '_owner' || keys[i] === '__v' || keys[i] === '__o') && a.$$typeof) {
        // React-specific: avoid traversing React elements' _owner
        // Preact-specific: avoid traversing Preact elements' __v and __o
        //    __v = $_original / $_vnode
        //    __o = $_owner
        // These properties contain circular references and are not needed when
        // comparing the actual elements (and not their owners)
        // .$$typeof and ._store on just reasonable markers of elements

        continue;
      }

      // all other properties should be traversed as usual
      if (!equal(a[keys[i]], b[keys[i]])) return false;
    }
    // END: react-fast-compare

    // START: fast-deep-equal
    return true;
  }

  return a !== a && b !== b;
}
// end fast-deep-equal

module.exports = function isEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if (((error.message || '').match(/stack|recursion/i))) {
      // warn on circular references, don't crash
      // browsers give this different errors name and messages:
      // chrome/safari: "RangeError", "Maximum call stack size exceeded"
      // firefox: "InternalError", too much recursion"
      // edge: "Error", "Out of stack space"
      console.warn('react-fast-compare cannot handle circular refs');
      return false;
    }
    // some other error. we should definitely know about these
    throw error;
  }
};

},{}],"CxTb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useComponentStyles__unstable = useComponentStyles__unstable;
exports.useMultiStyleConfig = useMultiStyleConfig;
exports.useStyleConfig = useStyleConfig;
var _chunk7V3ZYTH = require("./chunk-7V3ZYTH7.mjs");
var _styledSystem = require("@chakra-ui/styled-system");
var _themeUtils = require("@chakra-ui/theme-utils");
var _utils = require("@chakra-ui/utils");
var _react = require("react");
var _reactFastCompare = _interopRequireDefault(require("react-fast-compare"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// src/use-style-config.ts

function useStyleConfigImpl(themeKey, props = {}) {
  var _a;
  const {
    styleConfig: styleConfigProp,
    ...rest
  } = props;
  const {
    theme,
    colorMode
  } = (0, _chunk7V3ZYTH.useChakra)();
  const themeStyleConfig = themeKey ? (0, _utils.memoizedGet)(theme, `components.${themeKey}`) : void 0;
  const styleConfig = styleConfigProp || themeStyleConfig;
  const mergedProps = (0, _utils.mergeWith)({
    theme,
    colorMode
  }, (_a = styleConfig == null ? void 0 : styleConfig.defaultProps) != null ? _a : {}, (0, _utils.filterUndefined)((0, _utils.omit)(rest, ["children"])));
  const stylesRef = (0, _react.useRef)({});
  if (styleConfig) {
    const getStyles = (0, _styledSystem.resolveStyleConfig)(styleConfig);
    const styles = getStyles(mergedProps);
    const isStyleEqual = (0, _reactFastCompare.default)(stylesRef.current, styles);
    if (!isStyleEqual) {
      stylesRef.current = styles;
    }
  }
  return stylesRef.current;
}
function useStyleConfig(themeKey, props = {}) {
  return useStyleConfigImpl(themeKey, props);
}
function useMultiStyleConfig(themeKey, props = {}) {
  return useStyleConfigImpl(themeKey, props);
}
function useComponentStyles__unstable(themeKey, props) {
  var _a;
  const {
    baseConfig,
    ...restProps
  } = props;
  const {
    theme
  } = (0, _chunk7V3ZYTH.useChakra)();
  const overrides = (_a = theme.components) == null ? void 0 : _a[themeKey];
  const styleConfig = overrides ? (0, _themeUtils.mergeThemeOverride)(overrides, baseConfig) : baseConfig;
  return useStyleConfigImpl(null, {
    ...restProps,
    styleConfig
  });
}
},{"./chunk-7V3ZYTH7.mjs":"pItx","@chakra-ui/styled-system":"asJy","@chakra-ui/theme-utils":"KCKL","@chakra-ui/utils":"Yp4B","react":"n8MK","react-fast-compare":"e5DK"}],"AWjP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldForwardProp = shouldForwardProp;
var _styledSystem = require("@chakra-ui/styled-system");
// src/should-forward-prop.ts

var allPropNames = /* @__PURE__ */new Set([..._styledSystem.propNames, "textStyle", "layerStyle", "apply", "noOfLines", "focusBorderColor", "errorBorderColor", "as", "__css", "css", "sx"]);
var validHTMLProps = /* @__PURE__ */new Set(["htmlWidth", "htmlHeight", "htmlSize"]);
function shouldForwardProp(prop) {
  return validHTMLProps.has(prop) || !allPropNames.has(prop);
}
},{"@chakra-ui/styled-system":"asJy"}],"ZRYH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _memoize = _interopRequireDefault(require("@emotion/memoize"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */(0, _memoize.default)(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */ && prop.charCodeAt(1) === 110
  /* n */ && prop.charCodeAt(2) < 91;
}
/* Z+1 */);
var _default = isPropValid;
exports.default = _default;
},{"@emotion/memoize":"z7su"}],"ntsN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/extends"));
var _react = require("react");
var _isPropValid = _interopRequireDefault(require("@emotion/is-prop-valid"));
var _react2 = require("@emotion/react");
var _utils = require("@emotion/utils");
var _serialize = require("@emotion/serialize");
var _useInsertionEffectWithFallbacks = require("@emotion/use-insertion-effect-with-fallbacks");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var testOmitPropsOnStringTag = _isPropValid.default;
var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
  return key !== 'theme';
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
  return typeof tag === 'string' &&
  // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
  var shouldForwardProp;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== 'function' && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
    serialized = _ref.serialized,
    isStringTag = _ref.isStringTag;
  (0, _utils.registerStyles)(cache, serialized, isStringTag);
  var rules = (0, _useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback)(function () {
    return (0, _utils.insertStyles)(cache, serialized, isStringTag);
  });
  return null;
};
var createStyled = function createStyled(tag, options) {
  if ("production" !== 'production') {
    if (tag === undefined) {
      throw new Error('You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.');
    }
  }
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== undefined) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp('as');
  return function () {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== undefined) {
      styles.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === undefined) {
      styles.push.apply(styles, args);
    } else {
      if ("production" !== 'production' && args[0][0] === undefined) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles.push(args[0][0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        if ("production" !== 'production' && args[0][i] === undefined) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
        }
        styles.push(args[i], args[0][i]);
      }
    } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class

    var Styled = (0, _react2.withEmotionCache)(function (props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = '';
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = (0, _react.useContext)(_react2.ThemeContext);
      }
      if (typeof props.className === 'string') {
        className = (0, _utils.getRegisteredStyles)(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = (0, _serialize.serializeStyles)(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== undefined) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === 'as') continue;
        if (
        // $FlowFixMe
        finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /*#__PURE__*/(0, _react.createElement)(_react.Fragment, null, /*#__PURE__*/(0, _react.createElement)(Insertion, {
        cache: cache,
        serialized: serialized,
        isStringTag: typeof FinalTag === 'string'
      }), /*#__PURE__*/(0, _react.createElement)(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, 'toString', {
      value: function value() {
        if (targetClassName === undefined && "production" !== 'production') {
          return 'NO_COMPONENT_SELECTOR';
        } // $FlowFixMe: coerce undefined to string

        return "." + targetClassName;
      }
    });
    Styled.withComponent = function (nextTag, nextOptions) {
      return createStyled(nextTag, (0, _extends2.default)({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles);
    };
    return Styled;
  };
};
var _default = createStyled;
exports.default = _default;
},{"@babel/runtime/helpers/esm/extends":"SpjQ","react":"n8MK","@emotion/is-prop-valid":"ZRYH","@emotion/react":"cUkA","@emotion/utils":"QVCr","@emotion/serialize":"YZxA","@emotion/use-insertion-effect-with-fallbacks":"ucFO"}],"Noql":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("@babel/runtime/helpers/extends");
require("react");
require("@emotion/is-prop-valid");
var _emotionStyledBaseBrowserEsm = _interopRequireDefault(require("../base/dist/emotion-styled-base.browser.esm.js"));
require("@emotion/react");
require("@emotion/utils");
require("@emotion/serialize");
require("@emotion/use-insertion-effect-with-fallbacks");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr',
// SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];
var newStyled = _emotionStyledBaseBrowserEsm.default.bind();
tags.forEach(function (tagName) {
  // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type
  newStyled[tagName] = newStyled(tagName);
});
var _default = newStyled;
exports.default = _default;
},{"@babel/runtime/helpers/extends":"dLyZ","react":"n8MK","@emotion/is-prop-valid":"ZRYH","../base/dist/emotion-styled-base.browser.esm.js":"ntsN","@emotion/react":"cUkA","@emotion/utils":"QVCr","@emotion/serialize":"YZxA","@emotion/use-insertion-effect-with-fallbacks":"ucFO"}],"HNBZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.styled = styled;
exports.toCSSObject = void 0;
var _chunk3JUGYQRQ = require("./chunk-3JUGYQRQ.mjs");
var _colorMode = require("@chakra-ui/color-mode");
var _styledSystem = require("@chakra-ui/styled-system");
var _utils = require("@chakra-ui/utils");
var _styled = _interopRequireDefault(require("@emotion/styled"));
var _react = _interopRequireDefault(require("react"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// src/system.ts

var toCSSObject = ({
  baseStyle
}) => props => {
  const {
    theme,
    css: cssProp,
    __css,
    sx,
    ...rest
  } = props;
  const styleProps = (0, _utils.objectFilter)(rest, (_, prop) => (0, _styledSystem.isStyleProp)(prop));
  const finalBaseStyle = (0, _utils.runIfFn)(baseStyle, props);
  const finalStyles = Object.assign({}, __css, finalBaseStyle, (0, _utils.filterUndefined)(styleProps), sx);
  const computedCSS = (0, _styledSystem.css)(finalStyles)(props.theme);
  return cssProp ? [computedCSS, cssProp] : computedCSS;
};
exports.toCSSObject = toCSSObject;
function styled(component, options) {
  const {
    baseStyle,
    ...styledOptions
  } = options != null ? options : {};
  if (!styledOptions.shouldForwardProp) {
    styledOptions.shouldForwardProp = _chunk3JUGYQRQ.shouldForwardProp;
  }
  const styleObject = toCSSObject({
    baseStyle
  });
  const Component = (0, _styled.default)(component, styledOptions)(styleObject);
  const chakraComponent = _react.default.forwardRef(function ChakraComponent(props, ref) {
    const {
      colorMode,
      forced
    } = (0, _colorMode.useColorMode)();
    return _react.default.createElement(Component, {
      ref,
      "data-theme": forced ? colorMode : void 0,
      ...props
    });
  });
  return chakraComponent;
}
},{"./chunk-3JUGYQRQ.mjs":"AWjP","@chakra-ui/color-mode":"x8lr","@chakra-ui/styled-system":"asJy","@chakra-ui/utils":"Yp4B","@emotion/styled":"Noql","react":"n8MK"}],"gDV3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chakra = void 0;
var _chunkBGZY2EMZ = require("./chunk-BGZY2EMZ.mjs");
// src/factory.ts
function factory() {
  const cache = /* @__PURE__ */new Map();
  return new Proxy(_chunkBGZY2EMZ.styled, {
    apply(target, thisArg, argArray) {
      return (0, _chunkBGZY2EMZ.styled)(...argArray);
    },
    get(_, element) {
      if (!cache.has(element)) {
        cache.set(element, (0, _chunkBGZY2EMZ.styled)(element));
      }
      return cache.get(element);
    }
  });
}
var chakra = factory();
exports.chakra = chakra;
},{"./chunk-BGZY2EMZ.mjs":"HNBZ"}],"G8hc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forwardRef = forwardRef;
var _react = require("react");
// src/forward-ref.tsx

function forwardRef(component) {
  return (0, _react.forwardRef)(component);
}
},{"react":"n8MK"}],"iE8U":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValidChildren = getValidChildren;
var _react = require("react");
// src/children.ts

function getValidChildren(children) {
  return _react.Children.toArray(children).filter(child => (0, _react.isValidElement)(child));
}
},{"react":"n8MK"}],"g46H":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createContext = createContext;
var _react = require("react");
// src/context.ts

function createContext(options = {}) {
  const {
    strict = true,
    errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
    name
  } = options;
  const Context = (0, _react.createContext)(void 0);
  Context.displayName = name;
  function useContext() {
    var _a;
    const context = (0, _react.useContext)(Context);
    if (!context && strict) {
      const error = new Error(errorMessage);
      error.name = "ContextError";
      (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, error, useContext);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext, Context];
}
},{"react":"n8MK"}],"nKxL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assignRef = assignRef;
exports.mergeRefs = mergeRefs;
var _utils = require("@chakra-ui/utils");
// src/refs.ts

function assignRef(ref, value) {
  if (ref == null) return;
  if ((0, _utils.isFunction)(ref)) {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function mergeRefs(...refs) {
  return node => {
    refs.forEach(ref => assignRef(ref, node));
  };
}
},{"@chakra-ui/utils":"Yp4B"}],"pwET":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assignRef", {
  enumerable: true,
  get: function () {
    return _chunkA3EAUGIL.assignRef;
  }
});
Object.defineProperty(exports, "createContext", {
  enumerable: true,
  get: function () {
    return _chunkITIKTQWJ.createContext;
  }
});
Object.defineProperty(exports, "getValidChildren", {
  enumerable: true,
  get: function () {
    return _chunkIH2MM24A.getValidChildren;
  }
});
Object.defineProperty(exports, "mergeRefs", {
  enumerable: true,
  get: function () {
    return _chunkA3EAUGIL.mergeRefs;
  }
});
var _chunkIH2MM24A = require("./chunk-IH2MM24A.mjs");
var _chunkITIKTQWJ = require("./chunk-ITIKTQWJ.mjs");
var _chunkA3EAUGIL = require("./chunk-A3EAUGIL.mjs");
require("./chunk-WBQAMGXK.mjs");
},{"./chunk-IH2MM24A.mjs":"iE8U","./chunk-ITIKTQWJ.mjs":"g46H","./chunk-A3EAUGIL.mjs":"nKxL","./chunk-WBQAMGXK.mjs":"Tnu0"}],"ltVL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CSSVars = CSSVars;
exports.GlobalStyle = GlobalStyle;
exports.StylesProvider = void 0;
exports.ThemeProvider = ThemeProvider;
exports.createStylesContext = createStylesContext;
exports.useStyles = void 0;
var _colorMode = require("@chakra-ui/color-mode");
var _reactUtils = require("@chakra-ui/react-utils");
var _styledSystem = require("@chakra-ui/styled-system");
var _utils = require("@chakra-ui/utils");
var _react = require("@emotion/react");
var _react2 = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/providers.tsx

function ThemeProvider(props) {
  const {
    cssVarsRoot,
    theme,
    children
  } = props;
  const computedTheme = (0, _react2.useMemo)(() => (0, _styledSystem.toCSSVar)(theme), [theme]);
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_react.ThemeProvider, {
    theme: computedTheme,
    children: [/* @__PURE__ */(0, _jsxRuntime.jsx)(CSSVars, {
      root: cssVarsRoot
    }), children]
  });
}
function CSSVars({
  root = ":host, :root"
}) {
  const selector = [root, `[data-theme]`].join(",");
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_react.Global, {
    styles: theme => ({
      [selector]: theme.__cssVars
    })
  });
}
var [StylesProvider, useStyles] = (0, _reactUtils.createContext)({
  name: "StylesContext",
  errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
});
exports.useStyles = useStyles;
exports.StylesProvider = StylesProvider;
function createStylesContext(componentName) {
  return (0, _reactUtils.createContext)({
    name: `${componentName}StylesContext`,
    errorMessage: `useStyles: "styles" is undefined. Seems you forgot to wrap the components in "<${componentName} />" `
  });
}
function GlobalStyle() {
  const {
    colorMode
  } = (0, _colorMode.useColorMode)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_react.Global, {
    styles: theme => {
      const styleObjectOrFn = (0, _utils.memoizedGet)(theme, "styles.global");
      const globalStyles = (0, _utils.runIfFn)(styleObjectOrFn, {
        theme,
        colorMode
      });
      if (!globalStyles) return void 0;
      const styles = (0, _styledSystem.css)(globalStyles)(theme);
      return styles;
    }
  });
}
},{"@chakra-ui/color-mode":"x8lr","@chakra-ui/react-utils":"pwET","@chakra-ui/styled-system":"asJy","@chakra-ui/utils":"Yp4B","@emotion/react":"cUkA","react":"n8MK","react/jsx-runtime":"plwR"}],"ogbg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  useComponentStyles__unstable: true,
  useMultiStyleConfig: true,
  useStyleConfig: true,
  chakra: true,
  forwardRef: true,
  getToken: true,
  useChakra: true,
  useToken: true,
  useTheme: true,
  CSSVars: true,
  GlobalStyle: true,
  StylesProvider: true,
  ThemeProvider: true,
  createStylesContext: true,
  useStyles: true,
  styled: true,
  toCSSObject: true,
  shouldForwardProp: true,
  keyframes: true
};
Object.defineProperty(exports, "CSSVars", {
  enumerable: true,
  get: function () {
    return _chunk3ZTTLJBV.CSSVars;
  }
});
Object.defineProperty(exports, "GlobalStyle", {
  enumerable: true,
  get: function () {
    return _chunk3ZTTLJBV.GlobalStyle;
  }
});
Object.defineProperty(exports, "StylesProvider", {
  enumerable: true,
  get: function () {
    return _chunk3ZTTLJBV.StylesProvider;
  }
});
Object.defineProperty(exports, "ThemeProvider", {
  enumerable: true,
  get: function () {
    return _chunk3ZTTLJBV.ThemeProvider;
  }
});
Object.defineProperty(exports, "chakra", {
  enumerable: true,
  get: function () {
    return _chunkAWN3GBLH.chakra;
  }
});
Object.defineProperty(exports, "createStylesContext", {
  enumerable: true,
  get: function () {
    return _chunk3ZTTLJBV.createStylesContext;
  }
});
Object.defineProperty(exports, "forwardRef", {
  enumerable: true,
  get: function () {
    return _chunkQEVFQ4EU.forwardRef;
  }
});
Object.defineProperty(exports, "getToken", {
  enumerable: true,
  get: function () {
    return _chunk7V3ZYTH.getToken;
  }
});
Object.defineProperty(exports, "keyframes", {
  enumerable: true,
  get: function () {
    return _react.keyframes;
  }
});
Object.defineProperty(exports, "shouldForwardProp", {
  enumerable: true,
  get: function () {
    return _chunk3JUGYQRQ.shouldForwardProp;
  }
});
Object.defineProperty(exports, "styled", {
  enumerable: true,
  get: function () {
    return _chunkBGZY2EMZ.styled;
  }
});
Object.defineProperty(exports, "toCSSObject", {
  enumerable: true,
  get: function () {
    return _chunkBGZY2EMZ.toCSSObject;
  }
});
Object.defineProperty(exports, "useChakra", {
  enumerable: true,
  get: function () {
    return _chunk7V3ZYTH.useChakra;
  }
});
Object.defineProperty(exports, "useComponentStyles__unstable", {
  enumerable: true,
  get: function () {
    return _chunkT2VHL7RE.useComponentStyles__unstable;
  }
});
Object.defineProperty(exports, "useMultiStyleConfig", {
  enumerable: true,
  get: function () {
    return _chunkT2VHL7RE.useMultiStyleConfig;
  }
});
Object.defineProperty(exports, "useStyleConfig", {
  enumerable: true,
  get: function () {
    return _chunkT2VHL7RE.useStyleConfig;
  }
});
Object.defineProperty(exports, "useStyles", {
  enumerable: true,
  get: function () {
    return _chunk3ZTTLJBV.useStyles;
  }
});
Object.defineProperty(exports, "useTheme", {
  enumerable: true,
  get: function () {
    return _chunkNLMMK76H.useTheme;
  }
});
Object.defineProperty(exports, "useToken", {
  enumerable: true,
  get: function () {
    return _chunk7V3ZYTH.useToken;
  }
});
var _chunkT2VHL7RE = require("./chunk-T2VHL7RE.mjs");
var _chunkAWN3GBLH = require("./chunk-AWN3GBLH.mjs");
var _chunkQEVFQ4EU = require("./chunk-QEVFQ4EU.mjs");
var _chunk7V3ZYTH = require("./chunk-7V3ZYTH7.mjs");
var _chunkNLMMK76H = require("./chunk-NLMMK76H.mjs");
var _chunk3ZTTLJBV = require("./chunk-3ZTTLJBV.mjs");
var _chunkBGZY2EMZ = require("./chunk-BGZY2EMZ.mjs");
var _chunk3JUGYQRQ = require("./chunk-3JUGYQRQ.mjs");
require("./chunk-WBEJV2FA.mjs");
var _colorMode = require("@chakra-ui/color-mode");
Object.keys(_colorMode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _colorMode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _colorMode[key];
    }
  });
});
var _styledSystem = require("@chakra-ui/styled-system");
Object.keys(_styledSystem).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _styledSystem[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _styledSystem[key];
    }
  });
});
var _react = require("@emotion/react");
},{"./chunk-T2VHL7RE.mjs":"CxTb","./chunk-AWN3GBLH.mjs":"gDV3","./chunk-QEVFQ4EU.mjs":"G8hc","./chunk-7V3ZYTH7.mjs":"pItx","./chunk-NLMMK76H.mjs":"mp9o","./chunk-3ZTTLJBV.mjs":"ltVL","./chunk-BGZY2EMZ.mjs":"HNBZ","./chunk-3JUGYQRQ.mjs":"AWjP","./chunk-WBEJV2FA.mjs":"Tnu0","@chakra-ui/color-mode":"x8lr","@chakra-ui/styled-system":"asJy","@emotion/react":"cUkA"}],"zW5I":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ssrDocument = void 0;
// src/mock-document.ts
var doc = {
  body: {
    classList: {
      add() {},
      remove() {}
    }
  },
  addEventListener() {},
  removeEventListener() {},
  activeElement: {
    blur() {},
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {}
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName() {
        return [];
      }
    };
  }
};
var ssrDocument = doc;
exports.ssrDocument = ssrDocument;
},{}],"k5BI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ssrWindow = void 0;
var _chunk2GW6Q5BU = require("./chunk-2GW6Q5BU.mjs");
// src/mock-window.ts
var noop = () => {};
var win = {
  document: _chunk2GW6Q5BU.ssrDocument,
  navigator: {
    userAgent: ""
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener: noop,
  removeEventListener: noop,
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  matchMedia() {
    return {
      matches: false,
      addListener: noop,
      removeListener: noop
    };
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === "undefined") {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === "undefined") return;
    clearTimeout(id);
  },
  setTimeout: () => 0,
  clearTimeout: noop,
  setInterval: () => 0,
  clearInterval: noop
};
var ssrWindow = win;
exports.ssrWindow = ssrWindow;
},{"./chunk-2GW6Q5BU.mjs":"zW5I"}],"eeLJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnvironmentProvider = EnvironmentProvider;
exports.useEnvironment = useEnvironment;
var _chunkTGVXP7CR = require("./chunk-TGVXP7CR.mjs");
var _chunk2GW6Q5BU = require("./chunk-2GW6Q5BU.mjs");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/env.tsx

var mockEnv = {
  window: _chunkTGVXP7CR.ssrWindow,
  document: _chunk2GW6Q5BU.ssrDocument
};
var defaultEnv = typeof window !== "undefined" ? {
  window,
  document
} : mockEnv;
var EnvironmentContext = (0, _react.createContext)(defaultEnv);
EnvironmentContext.displayName = "EnvironmentContext";
function useEnvironment() {
  return (0, _react.useContext)(EnvironmentContext);
}
function EnvironmentProvider(props) {
  const {
    children,
    environment: environmentProp
  } = props;
  const [node, setNode] = (0, _react.useState)(null);
  const [mounted, setMounted] = (0, _react.useState)(false);
  (0, _react.useEffect)(() => setMounted(true), []);
  const context = (0, _react.useMemo)(() => {
    if (environmentProp) {
      return environmentProp;
    }
    const doc = node == null ? void 0 : node.ownerDocument;
    const win = node == null ? void 0 : node.ownerDocument.defaultView;
    const env = doc ? {
      document: doc,
      window: win
    } : defaultEnv;
    return env;
  }, [node, environmentProp]);
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(EnvironmentContext.Provider, {
    value: context,
    children: [children, !environmentProp && mounted && /* @__PURE__ */(0, _jsxRuntime.jsx)("span", {
      id: "__chakra_env",
      hidden: true,
      ref: el => {
        (0, _react.startTransition)(() => {
          if (el) setNode(el);
        });
      }
    })]
  });
}
EnvironmentProvider.displayName = "EnvironmentProvider";
},{"./chunk-TGVXP7CR.mjs":"k5BI","./chunk-2GW6Q5BU.mjs":"zW5I","react":"n8MK","react/jsx-runtime":"plwR"}],"v0AH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "EnvironmentProvider", {
  enumerable: true,
  get: function () {
    return _chunkDNC4K5KS.EnvironmentProvider;
  }
});
Object.defineProperty(exports, "useEnvironment", {
  enumerable: true,
  get: function () {
    return _chunkDNC4K5KS.useEnvironment;
  }
});
var _chunkDNC4K5KS = require("./chunk-DNC4K5KS.mjs");
require("./chunk-TGVXP7CR.mjs");
require("./chunk-2GW6Q5BU.mjs");
},{"./chunk-DNC4K5KS.mjs":"eeLJ","./chunk-TGVXP7CR.mjs":"k5BI","./chunk-2GW6Q5BU.mjs":"zW5I"}],"wNsx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChakraProvider = void 0;
var _cssReset = require("@chakra-ui/css-reset");
var _portal = require("@chakra-ui/portal");
var _system = require("@chakra-ui/system");
var _reactEnv = require("@chakra-ui/react-env");
var _jsxRuntime = require("react/jsx-runtime");
// src/chakra-provider.tsx

var ChakraProvider = props => {
  const {
    children,
    colorModeManager,
    portalZIndex,
    resetCSS = true,
    theme = {},
    environment,
    cssVarsRoot
  } = props;
  const _children = /* @__PURE__ */(0, _jsxRuntime.jsx)(_reactEnv.EnvironmentProvider, {
    environment,
    children
  });
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.ThemeProvider, {
    theme,
    cssVarsRoot,
    children: /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.ColorModeProvider, {
      colorModeManager,
      options: theme.config,
      children: [resetCSS ? /* @__PURE__ */(0, _jsxRuntime.jsx)(_cssReset.CSSReset, {}) : /* @__PURE__ */(0, _jsxRuntime.jsx)(_cssReset.CSSPolyfill, {}), /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.GlobalStyle, {}), portalZIndex ? /* @__PURE__ */(0, _jsxRuntime.jsx)(_portal.PortalManager, {
        zIndex: portalZIndex,
        children: _children
      }) : _children]
    })
  });
};
exports.ChakraProvider = ChakraProvider;
},{"@chakra-ui/css-reset":"oD4r","@chakra-ui/portal":"HPzc","@chakra-ui/system":"ogbg","@chakra-ui/react-env":"v0AH","react/jsx-runtime":"plwR"}],"B8pe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ChakraProvider", {
  enumerable: true,
  get: function () {
    return _chunkD2K5YHXV.ChakraProvider;
  }
});
var _chunkD2K5YHXV = require("./chunk-D2K5YHXV.mjs");
},{"./chunk-D2K5YHXV.mjs":"wNsx"}],"jgcb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findById = void 0;
exports.findToast = findToast;
exports.getToastListStyle = getToastListStyle;
exports.getToastPosition = getToastPosition;
exports.getToastStyle = getToastStyle;
exports.isVisible = void 0;
// src/toast.utils.ts
var findById = (arr, id) => arr.find(toast => toast.id === id);
exports.findById = findById;
function findToast(toasts, id) {
  const position = getToastPosition(toasts, id);
  const index = position ? toasts[position].findIndex(toast => toast.id === id) : -1;
  return {
    position,
    index
  };
}
function getToastPosition(toasts, id) {
  for (const [position, values] of Object.entries(toasts)) {
    if (findById(values, id)) {
      return position;
    }
  }
}
var isVisible = (toasts, id) => !!getToastPosition(toasts, id);
exports.isVisible = isVisible;
function getToastStyle(position) {
  const isRighty = position.includes("right");
  const isLefty = position.includes("left");
  let alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  return {
    display: "flex",
    flexDirection: "column",
    alignItems
  };
}
function getToastListStyle(position) {
  const isTopOrBottom = position === "top" || position === "bottom";
  const margin = isTopOrBottom ? "0 auto" : void 0;
  const top = position.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0;
  const bottom = position.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0;
  const right = !position.includes("left") ? "env(safe-area-inset-right, 0px)" : void 0;
  const left = !position.includes("right") ? "env(safe-area-inset-left, 0px)" : void 0;
  return {
    position: "fixed",
    zIndex: 5500,
    pointerEvents: "none",
    display: "flex",
    flexDirection: "column",
    margin,
    top,
    bottom,
    right,
    left
  };
}
},{}],"Haj3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getToastPlacement = getToastPlacement;
// src/toast.placement.ts
function getToastPlacement(position, dir) {
  var _a;
  const computedPosition = position != null ? position : "bottom";
  const logicals = {
    "top-start": {
      ltr: "top-left",
      rtl: "top-right"
    },
    "top-end": {
      ltr: "top-right",
      rtl: "top-left"
    },
    "bottom-start": {
      ltr: "bottom-left",
      rtl: "bottom-right"
    },
    "bottom-end": {
      ltr: "bottom-right",
      rtl: "bottom-left"
    }
  };
  const logical = logicals[computedPosition];
  return (_a = logical == null ? void 0 : logical[dir]) != null ? _a : computedPosition;
}
},{}],"eQTA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.icon_default = exports.Icon = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/icon.tsx

var fallbackIcon = {
  path: /* @__PURE__ */(0, _jsxRuntime.jsxs)("g", {
    stroke: "currentColor",
    strokeWidth: "1.5",
    children: [/* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
      strokeLinecap: "round",
      fill: "none",
      d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
    }), /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
      fill: "currentColor",
      strokeLinecap: "round",
      d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
    }), /* @__PURE__ */(0, _jsxRuntime.jsx)("circle", {
      fill: "none",
      strokeMiterlimit: "10",
      cx: "12",
      cy: "12",
      r: "11.25"
    })]
  }),
  viewBox: "0 0 24 24"
};
var Icon = (0, _system.forwardRef)((props, ref) => {
  const {
    as: element,
    viewBox,
    color = "currentColor",
    focusable = false,
    children,
    className,
    __css,
    ...rest
  } = props;
  const _className = (0, _sharedUtils.cx)("chakra-icon", className);
  const customStyles = (0, _system.useStyleConfig)("Icon", props);
  const styles = {
    w: "1em",
    h: "1em",
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: 0,
    color,
    ...__css,
    ...customStyles
  };
  const shared = {
    ref,
    focusable,
    className: _className,
    __css: styles
  };
  const _viewBox = viewBox != null ? viewBox : fallbackIcon.viewBox;
  if (element && typeof element !== "string") {
    return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.svg, {
      as: element,
      ...shared,
      ...rest
    });
  }
  const _path = children != null ? children : fallbackIcon.path;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.svg, {
    verticalAlign: "middle",
    viewBox: _viewBox,
    ...shared,
    ...rest,
    children: _path
  });
});
exports.Icon = Icon;
Icon.displayName = "Icon";
var icon_default = Icon;
exports.icon_default = icon_default;
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"hsnB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIcon = createIcon;
var _chunkDKFDJSXF = require("./chunk-DKFDJSXF.mjs");
var _system = require("@chakra-ui/system");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/create-icon.tsx

function createIcon(options) {
  const {
    viewBox = "0 0 24 24",
    d: pathDefinition,
    displayName,
    defaultProps = {}
  } = options;
  const path = _react.Children.toArray(options.path);
  const Comp = (0, _system.forwardRef)((props, ref) => /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkDKFDJSXF.Icon, {
    ref,
    viewBox,
    ...defaultProps,
    ...props,
    children: path.length ? path : /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
      fill: "currentColor",
      d: pathDefinition
    })
  }));
  Comp.displayName = displayName;
  return Comp;
}
},{"./chunk-DKFDJSXF.mjs":"eQTA","@chakra-ui/system":"ogbg","react":"n8MK","react/jsx-runtime":"plwR"}],"aPuf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Icon", {
  enumerable: true,
  get: function () {
    return _chunkDKFDJSXF.Icon;
  }
});
Object.defineProperty(exports, "createIcon", {
  enumerable: true,
  get: function () {
    return _chunkQODHG6BI.createIcon;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _chunkDKFDJSXF.icon_default;
  }
});
var _chunkQODHG6BI = require("./chunk-QODHG6BI.mjs");
var _chunkDKFDJSXF = require("./chunk-DKFDJSXF.mjs");
},{"./chunk-QODHG6BI.mjs":"hsnB","./chunk-DKFDJSXF.mjs":"eQTA"}],"UiNS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CheckIcon = CheckIcon;
exports.InfoIcon = InfoIcon;
exports.WarningIcon = WarningIcon;
var _icon = require("@chakra-ui/icon");
var _jsxRuntime = require("react/jsx-runtime");
// src/icons.tsx

function CheckIcon(props) {
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
    viewBox: "0 0 24 24",
    ...props,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
    })
  });
}
function InfoIcon(props) {
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
    viewBox: "0 0 24 24",
    ...props,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
    })
  });
}
function WarningIcon(props) {
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
    viewBox: "0 0 24 24",
    ...props,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
      fill: "currentColor",
      d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
    })
  });
}
},{"@chakra-ui/icon":"aPuf","react/jsx-runtime":"plwR"}],"VL5P":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spinner = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/spinner.tsx

var spin = (0, _system.keyframes)({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
var Spinner = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _system.useStyleConfig)("Spinner", props);
  const {
    label = "Loading...",
    thickness = "2px",
    speed = "0.45s",
    emptyColor = "transparent",
    className,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const _className = (0, _sharedUtils.cx)("chakra-spinner", className);
  const spinnerStyles = {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderRadius: "99999px",
    borderWidth: thickness,
    borderBottomColor: emptyColor,
    borderLeftColor: emptyColor,
    animation: `${spin} ${speed} linear infinite`,
    ...styles
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    __css: spinnerStyles,
    className: _className,
    ...rest,
    children: label && /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      srOnly: true,
      children: label
    })
  });
});
exports.Spinner = Spinner;
Spinner.displayName = "Spinner";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"tJmI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Spinner", {
  enumerable: true,
  get: function () {
    return _chunkNO6MRLPK.Spinner;
  }
});
var _chunkNO6MRLPK = require("./chunk-NO6MRLPK.mjs");
},{"./chunk-NO6MRLPK.mjs":"VL5P"}],"IBQ0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlertStylesProvider = exports.AlertProvider = void 0;
exports.getStatusColorScheme = getStatusColorScheme;
exports.getStatusIcon = getStatusIcon;
exports.useAlertStyles = exports.useAlertContext = void 0;
var _chunkR7JICMEA = require("./chunk-R7JICMEA.mjs");
var _reactContext = require("@chakra-ui/react-context");
var _spinner = require("@chakra-ui/spinner");
// src/alert-context.ts

var [AlertProvider, useAlertContext] = (0, _reactContext.createContext)({
  name: "AlertContext",
  hookName: "useAlertContext",
  providerName: "<Alert />"
});
exports.useAlertContext = useAlertContext;
exports.AlertProvider = AlertProvider;
var [AlertStylesProvider, useAlertStyles] = (0, _reactContext.createContext)({
  name: `AlertStylesContext`,
  hookName: `useAlertStyles`,
  providerName: "<Alert />"
});
exports.useAlertStyles = useAlertStyles;
exports.AlertStylesProvider = AlertStylesProvider;
var STATUSES = {
  info: {
    icon: _chunkR7JICMEA.InfoIcon,
    colorScheme: "blue"
  },
  warning: {
    icon: _chunkR7JICMEA.WarningIcon,
    colorScheme: "orange"
  },
  success: {
    icon: _chunkR7JICMEA.CheckIcon,
    colorScheme: "green"
  },
  error: {
    icon: _chunkR7JICMEA.WarningIcon,
    colorScheme: "red"
  },
  loading: {
    icon: _spinner.Spinner,
    colorScheme: "blue"
  }
};
function getStatusColorScheme(status) {
  return STATUSES[status].colorScheme;
}
function getStatusIcon(status) {
  return STATUSES[status].icon;
}
},{"./chunk-R7JICMEA.mjs":"UiNS","@chakra-ui/react-context":"lT23","@chakra-ui/spinner":"tJmI"}],"RUJV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlertDescription = void 0;
var _chunkFZCW3KO = require("./chunk-FZCW3KO4.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/alert-description.tsx

var AlertDescription = (0, _system.forwardRef)(function AlertDescription2(props, ref) {
  const styles = (0, _chunkFZCW3KO.useAlertStyles)();
  const descriptionStyles = {
    display: "inline",
    ...styles.description
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    ...props,
    className: (0, _sharedUtils.cx)("chakra-alert__desc", props.className),
    __css: descriptionStyles
  });
});
exports.AlertDescription = AlertDescription;
AlertDescription.displayName = "AlertDescription";
},{"./chunk-FZCW3KO4.mjs":"IBQ0","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"CXgl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlertIcon = AlertIcon;
var _chunkFZCW3KO = require("./chunk-FZCW3KO4.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/alert-icon.tsx

function AlertIcon(props) {
  const {
    status
  } = (0, _chunkFZCW3KO.useAlertContext)();
  const BaseIcon = (0, _chunkFZCW3KO.getStatusIcon)(status);
  const styles = (0, _chunkFZCW3KO.useAlertStyles)();
  const css = status === "loading" ? styles.spinner : styles.icon;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
    display: "inherit",
    ...props,
    className: (0, _sharedUtils.cx)("chakra-alert__icon", props.className),
    __css: css,
    children: props.children || /* @__PURE__ */(0, _jsxRuntime.jsx)(BaseIcon, {
      h: "100%",
      w: "100%"
    })
  });
}
AlertIcon.displayName = "AlertIcon";
},{"./chunk-FZCW3KO4.mjs":"IBQ0","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"Q90f":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlertTitle = void 0;
var _chunkFZCW3KO = require("./chunk-FZCW3KO4.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/alert-title.tsx

var AlertTitle = (0, _system.forwardRef)(function AlertTitle2(props, ref) {
  const styles = (0, _chunkFZCW3KO.useAlertStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    ...props,
    className: (0, _sharedUtils.cx)("chakra-alert__title", props.className),
    __css: styles.title
  });
});
exports.AlertTitle = AlertTitle;
AlertTitle.displayName = "AlertTitle";
},{"./chunk-FZCW3KO4.mjs":"IBQ0","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"FcD2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Alert = void 0;
var _chunkFZCW3KO = require("./chunk-FZCW3KO4.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/alert.tsx

var Alert = (0, _system.forwardRef)(function Alert2(props, ref) {
  var _a;
  const {
    status = "info",
    addRole = true,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const colorScheme = (_a = props.colorScheme) != null ? _a : (0, _chunkFZCW3KO.getStatusColorScheme)(status);
  const styles = (0, _system.useMultiStyleConfig)("Alert", {
    ...props,
    colorScheme
  });
  const alertStyles = {
    width: "100%",
    display: "flex",
    alignItems: "center",
    position: "relative",
    overflow: "hidden",
    ...styles.container
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkFZCW3KO.AlertProvider, {
    value: {
      status
    },
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkFZCW3KO.AlertStylesProvider, {
      value: styles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
        role: addRole ? "alert" : void 0,
        ref,
        ...rest,
        className: (0, _sharedUtils.cx)("chakra-alert", props.className),
        __css: alertStyles
      })
    })
  });
});
exports.Alert = Alert;
Alert.displayName = "Alert";
},{"./chunk-FZCW3KO4.mjs":"IBQ0","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"aC9K":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Alert", {
  enumerable: true,
  get: function () {
    return _chunkSBTIWJWJ.Alert;
  }
});
Object.defineProperty(exports, "AlertDescription", {
  enumerable: true,
  get: function () {
    return _chunkIAONL72B.AlertDescription;
  }
});
Object.defineProperty(exports, "AlertIcon", {
  enumerable: true,
  get: function () {
    return _chunk5STPMZN.AlertIcon;
  }
});
Object.defineProperty(exports, "AlertTitle", {
  enumerable: true,
  get: function () {
    return _chunkIFAZDFP.AlertTitle;
  }
});
Object.defineProperty(exports, "useAlertStyles", {
  enumerable: true,
  get: function () {
    return _chunkFZCW3KO.useAlertStyles;
  }
});
var _chunkIAONL72B = require("./chunk-IAONL72B.mjs");
var _chunk5STPMZN = require("./chunk-5STPMZN4.mjs");
var _chunkIFAZDFP = require("./chunk-IFAZDFP5.mjs");
var _chunkSBTIWJWJ = require("./chunk-SBTIWJWJ.mjs");
var _chunkFZCW3KO = require("./chunk-FZCW3KO4.mjs");
require("./chunk-R7JICMEA.mjs");
},{"./chunk-IAONL72B.mjs":"RUJV","./chunk-5STPMZN4.mjs":"CXgl","./chunk-IFAZDFP5.mjs":"Q90f","./chunk-SBTIWJWJ.mjs":"FcD2","./chunk-FZCW3KO4.mjs":"IBQ0","./chunk-R7JICMEA.mjs":"UiNS"}],"lKQL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CloseButton = void 0;
var _icon = require("@chakra-ui/icon");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/close-button.tsx

function CloseIcon(props) {
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
    focusable: "false",
    "aria-hidden": true,
    ...props,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
      fill: "currentColor",
      d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
    })
  });
}
var CloseButton = (0, _system.forwardRef)(function CloseButton2(props, ref) {
  const styles = (0, _system.useStyleConfig)("CloseButton", props);
  const {
    children,
    isDisabled,
    __css,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const baseStyle = {
    outline: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.button, {
    type: "button",
    "aria-label": "Close",
    ref,
    disabled: isDisabled,
    __css: {
      ...baseStyle,
      ...styles,
      ...__css
    },
    ...rest,
    children: children || /* @__PURE__ */(0, _jsxRuntime.jsx)(CloseIcon, {
      width: "1em",
      height: "1em"
    })
  });
});
exports.CloseButton = CloseButton;
CloseButton.displayName = "CloseButton";
},{"@chakra-ui/icon":"aPuf","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"pReG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CloseButton", {
  enumerable: true,
  get: function () {
    return _chunkDUEJD2BE.CloseButton;
  }
});
var _chunkDUEJD2BE = require("./chunk-DUEJD2BE.mjs");
},{"./chunk-DUEJD2BE.mjs":"lKQL"}],"YYXI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Toast = void 0;
exports.createRenderToast = createRenderToast;
exports.createToastFn = createToastFn;
exports.toastStore = void 0;
var _chunk5XWPESX = require("./chunk-5XWPESX6.mjs");
var _chunkF6QD4NSP = require("./chunk-F6QD4NSP.mjs");
var _alert = require("@chakra-ui/alert");
var _system = require("@chakra-ui/system");
var _closeButton = require("@chakra-ui/close-button");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/toast.tsx

// src/toast.store.ts
var initialState = {
  top: [],
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  bottom: [],
  "bottom-right": []
};
var toastStore = createStore(initialState);
exports.toastStore = toastStore;
function createStore(initialState2) {
  let state = initialState2;
  const listeners = /* @__PURE__ */new Set();
  const setState = setStateFn => {
    state = setStateFn(state);
    listeners.forEach(l => l());
  };
  return {
    getState: () => state,
    subscribe: listener => {
      listeners.add(listener);
      return () => {
        setState(() => initialState2);
        listeners.delete(listener);
      };
    },
    removeToast: (id, position) => {
      setState(prevState => ({
        ...prevState,
        [position]: prevState[position].filter(toast => toast.id != id)
      }));
    },
    notify: (message, options) => {
      const toast = createToast(message, options);
      const {
        position,
        id
      } = toast;
      setState(prevToasts => {
        var _a, _b;
        const isTop = position.includes("top");
        const toasts = isTop ? [toast, ...((_a = prevToasts[position]) != null ? _a : [])] : [...((_b = prevToasts[position]) != null ? _b : []), toast];
        return {
          ...prevToasts,
          [position]: toasts
        };
      });
      return id;
    },
    update: (id, options) => {
      if (!id) return;
      setState(prevState => {
        const nextState = {
          ...prevState
        };
        const {
          position,
          index
        } = (0, _chunk5XWPESX.findToast)(nextState, id);
        if (position && index !== -1) {
          nextState[position][index] = {
            ...nextState[position][index],
            ...options,
            message: createRenderToast(options)
          };
        }
        return nextState;
      });
    },
    closeAll: ({
      positions
    } = {}) => {
      setState(prev => {
        const allPositions = ["bottom", "bottom-right", "bottom-left", "top", "top-left", "top-right"];
        const positionsToClose = positions != null ? positions : allPositions;
        return positionsToClose.reduce((acc, position) => {
          acc[position] = prev[position].map(toast => ({
            ...toast,
            requestClose: true
          }));
          return acc;
        }, {
          ...prev
        });
      });
    },
    close: id => {
      setState(prevState => {
        const position = (0, _chunk5XWPESX.getToastPosition)(prevState, id);
        if (!position) return prevState;
        return {
          ...prevState,
          [position]: prevState[position].map(toast => {
            if (toast.id == id) {
              return {
                ...toast,
                requestClose: true
              };
            }
            return toast;
          })
        };
      });
    },
    isActive: id => Boolean((0, _chunk5XWPESX.findToast)(toastStore.getState(), id).position)
  };
}
var counter = 0;
function createToast(message, options = {}) {
  var _a, _b;
  counter += 1;
  const id = (_a = options.id) != null ? _a : counter;
  const position = (_b = options.position) != null ? _b : "bottom";
  return {
    id,
    message,
    position,
    duration: options.duration,
    onCloseComplete: options.onCloseComplete,
    onRequestRemove: () => toastStore.removeToast(String(id), position),
    status: options.status,
    requestClose: false,
    containerStyle: options.containerStyle
  };
}

// src/toast.tsx

var Toast = props => {
  const {
    status,
    variant = "solid",
    id,
    title,
    isClosable,
    onClose,
    description,
    icon
  } = props;
  const ids = id ? {
    root: `toast-${id}`,
    title: `toast-${id}-title`,
    description: `toast-${id}-description`
  } : void 0;
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_alert.Alert, {
    addRole: false,
    status,
    variant,
    id: ids == null ? void 0 : ids.root,
    alignItems: "start",
    borderRadius: "md",
    boxShadow: "lg",
    paddingEnd: 8,
    textAlign: "start",
    width: "auto",
    children: [/* @__PURE__ */(0, _jsxRuntime.jsx)(_alert.AlertIcon, {
      children: icon
    }), /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.div, {
      flex: "1",
      maxWidth: "100%",
      children: [title && /* @__PURE__ */(0, _jsxRuntime.jsx)(_alert.AlertTitle, {
        id: ids == null ? void 0 : ids.title,
        children: title
      }), description && /* @__PURE__ */(0, _jsxRuntime.jsx)(_alert.AlertDescription, {
        id: ids == null ? void 0 : ids.description,
        display: "block",
        children: description
      })]
    }), isClosable && /* @__PURE__ */(0, _jsxRuntime.jsx)(_closeButton.CloseButton, {
      size: "sm",
      onClick: onClose,
      position: "absolute",
      insetEnd: 1,
      top: 1
    })]
  });
};
exports.Toast = Toast;
function createRenderToast(options = {}) {
  const {
    render,
    toastComponent: ToastComponent = Toast
  } = options;
  const renderToast = props => {
    if (typeof render === "function") {
      return render({
        ...props,
        ...options
      });
    }
    return /* @__PURE__ */(0, _jsxRuntime.jsx)(ToastComponent, {
      ...props,
      ...options
    });
  };
  return renderToast;
}
function createToastFn(dir, defaultOptions) {
  const normalizeToastOptions = options => {
    var _a;
    return {
      ...defaultOptions,
      ...options,
      position: (0, _chunkF6QD4NSP.getToastPlacement)((_a = options == null ? void 0 : options.position) != null ? _a : defaultOptions == null ? void 0 : defaultOptions.position, dir)
    };
  };
  const toast = options => {
    const normalizedToastOptions = normalizeToastOptions(options);
    const Message = createRenderToast(normalizedToastOptions);
    return toastStore.notify(Message, normalizedToastOptions);
  };
  toast.update = (id, options) => {
    toastStore.update(id, normalizeToastOptions(options));
  };
  toast.promise = (promise, options) => {
    const id = toast({
      ...options.loading,
      status: "loading",
      duration: null
    });
    promise.then(data => toast.update(id, {
      status: "success",
      duration: 5e3,
      ...(0, _sharedUtils.runIfFn)(options.success, data)
    })).catch(error => toast.update(id, {
      status: "error",
      duration: 5e3,
      ...(0, _sharedUtils.runIfFn)(options.error, error)
    }));
  };
  toast.closeAll = toastStore.closeAll;
  toast.close = toastStore.close;
  toast.isActive = toastStore.isActive;
  return toast;
}
},{"./chunk-5XWPESX6.mjs":"jgcb","./chunk-F6QD4NSP.mjs":"Haj3","@chakra-ui/alert":"aC9K","@chakra-ui/system":"ogbg","@chakra-ui/close-button":"pReG","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"tFTP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useToast = useToast;
exports.use_toast_default = void 0;
var _chunkRANSABEB = require("./chunk-RANSABEB.mjs");
var _system = require("@chakra-ui/system");
var _react = require("react");
// src/use-toast.tsx

function useToast(defaultOptions) {
  const {
    theme
  } = (0, _system.useChakra)();
  return (0, _react.useMemo)(() => (0, _chunkRANSABEB.createToastFn)(theme.direction, defaultOptions), [defaultOptions, theme.direction]);
}
var use_toast_default = useToast;
exports.use_toast_default = use_toast_default;
},{"./chunk-RANSABEB.mjs":"YYXI","@chakra-ui/system":"ogbg","react":"n8MK"}],"PPhG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCallbackRef = useCallbackRef;
var _react = require("react");
// src/index.ts

function useCallbackRef(callback, deps = []) {
  const callbackRef = (0, _react.useRef)(callback);
  (0, _react.useEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, _react.useCallback)((...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, deps);
}
},{"react":"n8MK"}],"zBjX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTimeout = useTimeout;
var _react = require("react");
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
// src/index.ts

function useTimeout(callback, delay) {
  const fn = (0, _reactUseCallbackRef.useCallbackRef)(callback);
  (0, _react.useEffect)(() => {
    if (delay == null) return void 0;
    let timeoutId = null;
    timeoutId = window.setTimeout(() => {
      fn();
    }, delay);
    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [delay, fn]);
}
},{"react":"n8MK","@chakra-ui/react-use-callback-ref":"PPhG"}],"GqG2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useUpdateEffect = useUpdateEffect;
var _react = require("react");
// src/index.ts

function useUpdateEffect(callback, deps) {
  const renderCycleRef = (0, _react.useRef)(false);
  const effectCycleRef = (0, _react.useRef)(false);
  (0, _react.useEffect)(() => {
    const mounted = renderCycleRef.current;
    const run = mounted && effectCycleRef.current;
    if (run) {
      return callback();
    }
    effectCycleRef.current = true;
  }, deps);
  (0, _react.useEffect)(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
}
},{"react":"n8MK"}],"vCxL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__assign = void 0;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncValues = __asyncValues;
exports.__await = __await;
exports.__awaiter = __awaiter;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldIn = __classPrivateFieldIn;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__createBinding = void 0;
exports.__decorate = __decorate;
exports.__exportStar = __exportStar;
exports.__extends = __extends;
exports.__generator = __generator;
exports.__importDefault = __importDefault;
exports.__importStar = __importStar;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__metadata = __metadata;
exports.__param = __param;
exports.__read = __read;
exports.__rest = __rest;
exports.__spread = __spread;
exports.__spreadArray = __spreadArray;
exports.__spreadArrays = __spreadArrays;
exports.__values = __values;
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  exports.__assign = __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
exports.__assign = __assign;
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
var __createBinding = Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
};
exports.__createBinding = __createBinding;
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
    i,
    q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
    i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
;
var __setModuleDefault = Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
},{}],"A4AW":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.env = void 0;
/**
 * Browser-safe usage of process
 */
var defaultEnvironment = "production";
var env = typeof process === "undefined" || process.env === undefined ? defaultEnvironment : "production" || defaultEnvironment;
exports.env = env;
},{"process":"pBGv"}],"tAsV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.featureDefinitions = void 0;
exports.loadFeatures = loadFeatures;
var createDefinition = function (propNames) {
  return {
    isEnabled: function (props) {
      return propNames.some(function (name) {
        return !!props[name];
      });
    }
  };
};
var featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition(["animate", "exit", "variants", "whileHover", "whileTap", "whileFocus", "whileDrag", "whileInView"]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition(["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"]),
  inView: createDefinition(["whileInView", "onViewportEnter", "onViewportLeave"])
};
exports.featureDefinitions = featureDefinitions;
function loadFeatures(features) {
  for (var key in features) {
    if (features[key] === null) continue;
    if (key === "projectionNodeConstructor") {
      featureDefinitions.projectionNodeConstructor = features[key];
    } else {
      featureDefinitions[key].Component = features[key];
    }
  }
}
},{}],"KFGT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warning = exports.invariant = void 0;
var warning = function () {};
exports.warning = warning;
var invariant = function () {};
exports.invariant = invariant;
if ("production" !== 'production') {
  exports.warning = warning = function (check, message) {
    if (!check && typeof console !== 'undefined') {
      console.warn(message);
    }
  };
  exports.invariant = invariant = function (check, message) {
    if (!check) {
      throw new Error(message);
    }
  };
}
},{}],"Y8MD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LazyContext = void 0;
var _react = require("react");
var LazyContext = (0, _react.createContext)({
  strict: false
});
exports.LazyContext = LazyContext;
},{"react":"n8MK"}],"pq2W":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFeatures = useFeatures;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
var _process = require("../../utils/process.mjs");
var _definitions = require("./definitions.mjs");
var _heyListen = require("hey-listen");
var _LazyContext = require("../../context/LazyContext.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var featureNames = Object.keys(_definitions.featureDefinitions);
var numFeatures = featureNames.length;
/**
 * Load features via renderless components based on the provided MotionProps.
 */
function useFeatures(props, visualElement, preloadedFeatures) {
  var features = [];
  var lazyContext = (0, React.useContext)(_LazyContext.LazyContext);
  if (!visualElement) return null;
  /**
   * If we're in development mode, check to make sure we're not rendering a motion component
   * as a child of LazyMotion, as this will break the file-size benefits of using it.
   */
  if (_process.env !== "production" && preloadedFeatures && lazyContext.strict) {
    (0, _heyListen.invariant)(false, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");
  }
  for (var i = 0; i < numFeatures; i++) {
    var name_1 = featureNames[i];
    var _a = _definitions.featureDefinitions[name_1],
      isEnabled = _a.isEnabled,
      Component = _a.Component;
    /**
     * It might be possible in the future to use this moment to
     * dynamically request functionality. In initial tests this
     * was producing a lot of duplication amongst bundles.
     */
    if (isEnabled(props) && Component) {
      features.push(React.createElement(Component, (0, _tslib.__assign)({
        key: name_1
      }, props, {
        visualElement: visualElement
      })));
    }
  }
  return features;
}
},{"tslib":"vCxL","react":"n8MK","../../utils/process.mjs":"A4AW","./definitions.mjs":"tAsV","hey-listen":"KFGT","../../context/LazyContext.mjs":"Y8MD"}],"dtoU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MotionConfigContext = void 0;
var _react = require("react");
/**
 * @public
 */
var MotionConfigContext = (0, _react.createContext)({
  transformPagePoint: function (p) {
    return p;
  },
  isStatic: false,
  reducedMotion: "never"
});
exports.MotionConfigContext = MotionConfigContext;
},{"react":"n8MK"}],"rq4D":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MotionContext = void 0;
exports.useVisualElementContext = useVisualElementContext;
var _react = require("react");
var MotionContext = (0, _react.createContext)({});
exports.MotionContext = MotionContext;
function useVisualElementContext() {
  return (0, _react.useContext)(MotionContext).visualElement;
}
},{"react":"n8MK"}],"eYxR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PresenceContext = void 0;
var _react = require("react");
/**
 * @public
 */
var PresenceContext = (0, _react.createContext)(null);
exports.PresenceContext = PresenceContext;
},{"react":"n8MK"}],"Kkfx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBrowser = void 0;
var isBrowser = typeof document !== "undefined";
exports.isBrowser = isBrowser;
},{}],"tqWN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useIsomorphicLayoutEffect = void 0;
var _react = require("react");
var _isBrowser = require("./is-browser.mjs");
var useIsomorphicLayoutEffect = _isBrowser.isBrowser ? _react.useLayoutEffect : _react.useEffect;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
},{"react":"n8MK","./is-browser.mjs":"Kkfx"}],"Lmpf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useReducedMotion = useReducedMotion;
exports.useReducedMotionConfig = useReducedMotionConfig;
var _tslib = require("tslib");
var _react = require("react");
var _MotionConfigContext = require("../context/MotionConfigContext.mjs");
var _isBrowser = require("./is-browser.mjs");
// Does this device prefer reduced motion? Returns `null` server-side.
var prefersReducedMotion = {
  current: null
};
var hasDetected = false;
function initPrefersReducedMotion() {
  hasDetected = true;
  if (!_isBrowser.isBrowser) return;
  if (window.matchMedia) {
    var motionMediaQuery_1 = window.matchMedia("(prefers-reduced-motion)");
    var setReducedMotionPreferences = function () {
      return prefersReducedMotion.current = motionMediaQuery_1.matches;
    };
    motionMediaQuery_1.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
/**
 * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.
 *
 * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing
 * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.
 *
 * It will actively respond to changes and re-render your components with the latest setting.
 *
 * ```jsx
 * export function Sidebar({ isOpen }) {
 *   const shouldReduceMotion = useReducedMotion()
 *   const closedX = shouldReduceMotion ? 0 : "-100%"
 *
 *   return (
 *     <motion.div animate={{
 *       opacity: isOpen ? 1 : 0,
 *       x: isOpen ? 0 : closedX
 *     }} />
 *   )
 * }
 * ```
 *
 * @return boolean
 *
 * @public
 */
function useReducedMotion() {
  /**
   * Lazy initialisation of prefersReducedMotion
   */
  !hasDetected && initPrefersReducedMotion();
  var _a = (0, _tslib.__read)((0, _react.useState)(prefersReducedMotion.current), 1),
    shouldReduceMotion = _a[0];
  /**
   * TODO See if people miss automatically updating shouldReduceMotion setting
   */
  return shouldReduceMotion;
}
function useReducedMotionConfig() {
  var reducedMotionPreference = useReducedMotion();
  var reducedMotion = (0, _react.useContext)(_MotionConfigContext.MotionConfigContext).reducedMotion;
  if (reducedMotion === "never") {
    return false;
  } else if (reducedMotion === "always") {
    return true;
  } else {
    return reducedMotionPreference;
  }
}
},{"tslib":"vCxL","react":"n8MK","../context/MotionConfigContext.mjs":"dtoU","./is-browser.mjs":"Kkfx"}],"oANl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useVisualElement = useVisualElement;
var _react = require("react");
var _PresenceContext = require("../../context/PresenceContext.mjs");
var _index = require("../../context/MotionContext/index.mjs");
var _useIsomorphicEffect = require("../../utils/use-isomorphic-effect.mjs");
var _LazyContext = require("../../context/LazyContext.mjs");
var _useReducedMotion = require("../../utils/use-reduced-motion.mjs");
function useVisualElement(Component, visualState, props, createVisualElement) {
  var lazyContext = (0, _react.useContext)(_LazyContext.LazyContext);
  var parent = (0, _index.useVisualElementContext)();
  var presenceContext = (0, _react.useContext)(_PresenceContext.PresenceContext);
  var shouldReduceMotion = (0, _useReducedMotion.useReducedMotionConfig)();
  var visualElementRef = (0, _react.useRef)(undefined);
  /**
   * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
   */
  if (!createVisualElement) createVisualElement = lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState: visualState,
      parent: parent,
      props: props,
      presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,
      blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,
      shouldReduceMotion: shouldReduceMotion
    });
  }
  var visualElement = visualElementRef.current;
  (0, _useIsomorphicEffect.useIsomorphicLayoutEffect)(function () {
    visualElement === null || visualElement === void 0 ? void 0 : visualElement.syncRender();
  });
  (0, _react.useEffect)(function () {
    var _a;
    (_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();
  });
  (0, _useIsomorphicEffect.useIsomorphicLayoutEffect)(function () {
    return function () {
      return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount();
    };
  }, []);
  return visualElement;
}
},{"react":"n8MK","../../context/PresenceContext.mjs":"eYxR","../../context/MotionContext/index.mjs":"rq4D","../../utils/use-isomorphic-effect.mjs":"tqWN","../../context/LazyContext.mjs":"Y8MD","../../utils/use-reduced-motion.mjs":"Lmpf"}],"JqDl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isRefObject = isRefObject;
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
},{}],"fY2E":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMotionRef = useMotionRef;
var _react = require("react");
var _isRefObject = require("../../utils/is-ref-object.mjs");
/**
 * Creates a ref function that, when called, hydrates the provided
 * external ref and VisualElement.
 */
function useMotionRef(visualState, visualElement, externalRef) {
  return (0, _react.useCallback)(function (instance) {
    var _a;
    instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));
    if (visualElement) {
      instance ? visualElement.mount(instance) : visualElement.unmount();
    }
    if (externalRef) {
      if (typeof externalRef === "function") {
        externalRef(instance);
      } else if ((0, _isRefObject.isRefObject)(externalRef)) {
        externalRef.current = instance;
      }
    }
  },
  /**
   * Only pass a new ref callback to React if we've received a visual element
   * factory. Otherwise we'll be mounting/remounting every time externalRef
   * or other dependencies change.
   */
  [visualElement]);
}
},{"react":"n8MK","../../utils/is-ref-object.mjs":"JqDl"}],"B4V7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkIfControllingVariants = checkIfControllingVariants;
exports.checkIfVariantNode = checkIfVariantNode;
exports.isVariantLabel = isVariantLabel;
exports.isVariantLabels = isVariantLabels;
exports.resolveVariant = resolveVariant;
exports.resolveVariantFromProps = resolveVariantFromProps;
/**
 * Decides if the supplied variable is an array of variant labels
 */
function isVariantLabels(v) {
  return Array.isArray(v);
}
/**
 * Decides if the supplied variable is variant label
 */
function isVariantLabel(v) {
  return typeof v === "string" || isVariantLabels(v);
}
/**
 * Creates an object containing the latest state of every MotionValue on a VisualElement
 */
function getCurrent(visualElement) {
  var current = {};
  visualElement.forEachValue(function (value, key) {
    return current[key] = value.get();
  });
  return current;
}
/**
 * Creates an object containing the latest velocity of every MotionValue on a VisualElement
 */
function getVelocity(visualElement) {
  var velocity = {};
  visualElement.forEachValue(function (value, key) {
    return velocity[key] = value.getVelocity();
  });
  return velocity;
}
function resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {
  var _a;
  if (currentValues === void 0) {
    currentValues = {};
  }
  if (currentVelocity === void 0) {
    currentVelocity = {};
  }
  /**
   * If the variant definition is a function, resolve.
   */
  if (typeof definition === "function") {
    definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  /**
   * If the variant definition is a variant label, or
   * the function returned a variant label, resolve.
   */
  if (typeof definition === "string") {
    definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];
  }
  /**
   * At this point we've resolved both functions and variant labels,
   * but the resolved variant label might itself have been a function.
   * If so, resolve. This can only have returned a valid target object.
   */
  if (typeof definition === "function") {
    definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
function resolveVariant(visualElement, definition, custom) {
  var props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));
}
function checkIfControllingVariants(props) {
  var _a;
  return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === "function" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);
}
function checkIfVariantNode(props) {
  return Boolean(checkIfControllingVariants(props) || props.variants);
}
},{}],"YYEX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCurrentTreeVariants = getCurrentTreeVariants;
var _variants = require("../../render/utils/variants.mjs");
function getCurrentTreeVariants(props, context) {
  if ((0, _variants.checkIfControllingVariants)(props)) {
    var initial = props.initial,
      animate = props.animate;
    return {
      initial: initial === false || (0, _variants.isVariantLabel)(initial) ? initial : undefined,
      animate: (0, _variants.isVariantLabel)(animate) ? animate : undefined
    };
  }
  return props.inherit !== false ? context : {};
}
},{"../../render/utils/variants.mjs":"B4V7"}],"BQG5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCreateMotionContext = useCreateMotionContext;
var _react = require("react");
var _index = require("./index.mjs");
var _utils = require("./utils.mjs");
function useCreateMotionContext(props) {
  var _a = (0, _utils.getCurrentTreeVariants)(props, (0, _react.useContext)(_index.MotionContext)),
    initial = _a.initial,
    animate = _a.animate;
  return (0, _react.useMemo)(function () {
    return {
      initial: initial,
      animate: animate
    };
  }, [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
},{"react":"n8MK","./index.mjs":"rq4D","./utils.mjs":"YYEX"}],"XPaj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useConstant = useConstant;
var _react = require("react");
/**
 * Creates a constant value over the lifecycle of a component.
 *
 * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer
 * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`
 * you can ensure that initialisers don't execute twice or more.
 */
function useConstant(init) {
  var ref = (0, _react.useRef)(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
},{"react":"n8MK"}],"h6Mt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.globalProjectionState = void 0;
/**
 * This should only ever be modified on the client otherwise it'll
 * persist through server requests. If we need instanced states we
 * could lazy-init via root.
 */
var globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
exports.globalProjectionState = globalProjectionState;
},{}],"Jmst":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useProjectionId = useProjectionId;
var _useConstant = require("../../utils/use-constant.mjs");
var _state = require("./state.mjs");
var id = 1;
function useProjectionId() {
  return (0, _useConstant.useConstant)(function () {
    if (_state.globalProjectionState.hasEverUpdated) {
      return id++;
    }
  });
}
},{"../../utils/use-constant.mjs":"XPaj","./state.mjs":"h6Mt"}],"dh8B":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LayoutGroupContext = void 0;
var _react = require("react");
var LayoutGroupContext = (0, _react.createContext)({});
exports.LayoutGroupContext = LayoutGroupContext;
},{"react":"n8MK"}],"iF60":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwitchLayoutGroupContext = void 0;
var _react = require("react");
/**
 * Internal, exported only for usage in Framer
 */
var SwitchLayoutGroupContext = (0, _react.createContext)({});
exports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;
},{"react":"n8MK"}],"gjbt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useProjection = useProjection;
var _isRefObject = require("../../utils/is-ref-object.mjs");
var _react = require("react");
var _SwitchLayoutGroupContext = require("../../context/SwitchLayoutGroupContext.mjs");
function useProjection(projectionId, _a, visualElement, ProjectionNodeConstructor) {
  var _b;
  var layoutId = _a.layoutId,
    layout = _a.layout,
    drag = _a.drag,
    dragConstraints = _a.dragConstraints,
    layoutScroll = _a.layoutScroll;
  var initialPromotionConfig = (0, _react.useContext)(_SwitchLayoutGroupContext.SwitchLayoutGroupContext);
  if (!ProjectionNodeConstructor || !visualElement || (visualElement === null || visualElement === void 0 ? void 0 : visualElement.projection)) {
    return;
  }
  visualElement.projection = new ProjectionNodeConstructor(projectionId, visualElement.getLatestValues(), (_b = visualElement.parent) === null || _b === void 0 ? void 0 : _b.projection);
  visualElement.projection.setOptions({
    layoutId: layoutId,
    layout: layout,
    alwaysMeasureLayout: Boolean(drag) || dragConstraints && (0, _isRefObject.isRefObject)(dragConstraints),
    visualElement: visualElement,
    scheduleRender: function () {
      return visualElement.scheduleRender();
    },
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout === "string" ? layout : "both",
    initialPromotionConfig: initialPromotionConfig,
    layoutScroll: layoutScroll
  });
}
},{"../../utils/is-ref-object.mjs":"JqDl","react":"n8MK","../../context/SwitchLayoutGroupContext.mjs":"iF60"}],"Lh3e":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VisualElementHandler = void 0;
var _tslib = require("tslib");
var _react = _interopRequireDefault(require("react"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var VisualElementHandler = /** @class */function (_super) {
  (0, _tslib.__extends)(VisualElementHandler, _super);
  function VisualElementHandler() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * Update visual element props as soon as we know this update is going to be commited.
   */
  VisualElementHandler.prototype.getSnapshotBeforeUpdate = function () {
    this.updateProps();
    return null;
  };
  VisualElementHandler.prototype.componentDidUpdate = function () {};
  VisualElementHandler.prototype.updateProps = function () {
    var _a = this.props,
      visualElement = _a.visualElement,
      props = _a.props;
    if (visualElement) visualElement.setProps(props);
  };
  VisualElementHandler.prototype.render = function () {
    return this.props.children;
  };
  return VisualElementHandler;
}(_react.default.Component);
exports.VisualElementHandler = VisualElementHandler;
},{"tslib":"vCxL","react":"n8MK"}],"zTNr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMotionComponent = createMotionComponent;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
var _useFeatures = require("./features/use-features.mjs");
var _MotionConfigContext = require("../context/MotionConfigContext.mjs");
var _index = require("../context/MotionContext/index.mjs");
var _useVisualElement = require("./utils/use-visual-element.mjs");
var _useMotionRef = require("./utils/use-motion-ref.mjs");
var _create = require("../context/MotionContext/create.mjs");
var _definitions = require("./features/definitions.mjs");
var _isBrowser = require("../utils/is-browser.mjs");
var _id = require("../projection/node/id.mjs");
var _LayoutGroupContext = require("../context/LayoutGroupContext.mjs");
var _useProjection = require("./features/use-projection.mjs");
var _VisualElementHandler = require("./utils/VisualElementHandler.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Create a `motion` component.
 *
 * This function accepts a Component argument, which can be either a string (ie "div"
 * for `motion.div`), or an actual React component.
 *
 * Alongside this is a config option which provides a way of rendering the provided
 * component "offline", or outside the React render cycle.
 */
function createMotionComponent(_a) {
  var preloadedFeatures = _a.preloadedFeatures,
    createVisualElement = _a.createVisualElement,
    projectionNodeConstructor = _a.projectionNodeConstructor,
    useRender = _a.useRender,
    useVisualState = _a.useVisualState,
    Component = _a.Component;
  preloadedFeatures && (0, _definitions.loadFeatures)(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    var layoutId = useLayoutId(props);
    props = (0, _tslib.__assign)((0, _tslib.__assign)({}, props), {
      layoutId: layoutId
    });
    /**
     * If we're rendering in a static environment, we only visually update the component
     * as a result of a React-rerender rather than interactions or animations. This
     * means we don't need to load additional memory structures like VisualElement,
     * or any gesture/animation features.
     */
    var config = (0, React.useContext)(_MotionConfigContext.MotionConfigContext);
    var features = null;
    var context = (0, _create.useCreateMotionContext)(props);
    /**
     * Create a unique projection ID for this component. If a new component is added
     * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing
     * us to measure it as soon as any layout effect flushes pending layout animations.
     *
     * Performance note: It'd be better not to have to search the DOM for these elements.
     * For newly-entering components it could be enough to only correct treeScale, in which
     * case we could mount in a scale-correction mode. This wouldn't be enough for
     * shared element transitions however. Perhaps for those we could revert to a root node
     * that gets forceRendered and layout animations are triggered on its layout effect.
     */
    var projectionId = config.isStatic ? undefined : (0, _id.useProjectionId)();
    /**
     *
     */
    var visualState = useVisualState(props, config.isStatic);
    if (!config.isStatic && _isBrowser.isBrowser) {
      /**
       * Create a VisualElement for this component. A VisualElement provides a common
       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as
       * providing a way of rendering to these APIs outside of the React render loop
       * for more performant animations and interactions
       */
      context.visualElement = (0, _useVisualElement.useVisualElement)(Component, visualState, (0, _tslib.__assign)((0, _tslib.__assign)({}, config), props), createVisualElement);
      (0, _useProjection.useProjection)(projectionId, props, context.visualElement, projectionNodeConstructor || _definitions.featureDefinitions.projectionNodeConstructor);
      /**
       * Load Motion gesture and animation features. These are rendered as renderless
       * components so each feature can optionally make use of React lifecycle methods.
       */
      features = (0, _useFeatures.useFeatures)(props, context.visualElement, preloadedFeatures);
    }
    /**
     * The mount order and hierarchy is specific to ensure our element ref
     * is hydrated by the time features fire their effects.
     */
    return React.createElement(_VisualElementHandler.VisualElementHandler, {
      visualElement: context.visualElement,
      props: (0, _tslib.__assign)((0, _tslib.__assign)({}, config), props)
    }, features, React.createElement(_index.MotionContext.Provider, {
      value: context
    }, useRender(Component, props, projectionId, (0, _useMotionRef.useMotionRef)(visualState, context.visualElement, externalRef), visualState, config.isStatic, context.visualElement)));
  }
  return (0, React.forwardRef)(MotionComponent);
}
function useLayoutId(_a) {
  var _b;
  var layoutId = _a.layoutId;
  var layoutGroupId = (_b = (0, React.useContext)(_LayoutGroupContext.LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;
  return layoutGroupId && layoutId !== undefined ? layoutGroupId + "-" + layoutId : layoutId;
}
},{"tslib":"vCxL","react":"n8MK","./features/use-features.mjs":"pq2W","../context/MotionConfigContext.mjs":"dtoU","../context/MotionContext/index.mjs":"rq4D","./utils/use-visual-element.mjs":"oANl","./utils/use-motion-ref.mjs":"fY2E","../context/MotionContext/create.mjs":"BQG5","./features/definitions.mjs":"tAsV","../utils/is-browser.mjs":"Kkfx","../projection/node/id.mjs":"Jmst","../context/LayoutGroupContext.mjs":"dh8B","./features/use-projection.mjs":"gjbt","./utils/VisualElementHandler.mjs":"Lh3e"}],"dmfT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMotionProxy = createMotionProxy;
var _index = require("../../motion/index.mjs");
/**
 * Convert any React component into a `motion` component. The provided component
 * **must** use `React.forwardRef` to the underlying DOM component you want to animate.
 *
 * ```jsx
 * const Component = React.forwardRef((props, ref) => {
 *   return <div ref={ref} />
 * })
 *
 * const MotionComponent = motion(Component)
 * ```
 *
 * @public
 */
function createMotionProxy(createConfig) {
  function custom(Component, customMotionComponentConfig) {
    if (customMotionComponentConfig === void 0) {
      customMotionComponentConfig = {};
    }
    return (0, _index.createMotionComponent)(createConfig(Component, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom;
  }
  /**
   * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.
   * Rather than generating them anew every render.
   */
  var componentCache = new Map();
  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: function (_target, key) {
      /**
       * If this element doesn't exist in the component cache, create it and cache.
       */
      if (!componentCache.has(key)) {
        componentCache.set(key, custom(key));
      }
      return componentCache.get(key);
    }
  });
}
},{"../../motion/index.mjs":"zTNr"}],"U7GN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lowercaseSVGElements = void 0;
/**
 * We keep these listed seperately as we use the lowercase tag names as part
 * of the runtime bundle to detect SVG components
 */
var lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "svg", "switch", "symbol", "text", "tspan", "use", "view"];
exports.lowercaseSVGElements = lowercaseSVGElements;
},{}],"hj4I":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSVGComponent = isSVGComponent;
var _lowercaseElements = require("../../svg/lowercase-elements.mjs");
function isSVGComponent(Component) {
  if (
  /**
   * If it's not a string, it's a custom React component. Currently we only support
   * HTML custom React components.
   */
  typeof Component !== "string" ||
  /**
   * If it contains a dash, the element is a custom HTML webcomponent.
   */
  Component.includes("-")) {
    return false;
  } else if (
  /**
   * If it's in our list of lowercase SVG tags, it's an SVG component
   */
  _lowercaseElements.lowercaseSVGElements.indexOf(Component) > -1 ||
  /**
   * If it contains a capital letter, it's an SVG component
   */
  /[A-Z]/.test(Component)) {
    return true;
  }
  return false;
}
},{"../../svg/lowercase-elements.mjs":"U7GN"}],"PNTQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addScaleCorrector = addScaleCorrector;
exports.scaleCorrectors = void 0;
var scaleCorrectors = {};
exports.scaleCorrectors = scaleCorrectors;
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
},{}],"qPCc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTransformOriginProp = isTransformOriginProp;
exports.isTransformProp = isTransformProp;
exports.sortTransformProps = sortTransformProps;
exports.transformProps = exports.transformAxes = void 0;
/**
 * A list of all transformable axes. We'll use this list to generated a version
 * of each axes for each transform.
 */
var transformAxes = ["", "X", "Y", "Z"];
/**
 * An ordered array of each transformable value. By default, transform values
 * will be sorted to this order.
 */
exports.transformAxes = transformAxes;
var order = ["translate", "scale", "rotate", "skew"];
/**
 * Generate a list of every possible transform key.
 */
var transformProps = ["transformPerspective", "x", "y", "z"];
exports.transformProps = transformProps;
order.forEach(function (operationKey) {
  return transformAxes.forEach(function (axesKey) {
    return transformProps.push(operationKey + axesKey);
  });
});
/**
 * A function to use with Array.sort to sort transform keys by their default order.
 */
function sortTransformProps(a, b) {
  return transformProps.indexOf(a) - transformProps.indexOf(b);
}
/**
 * A quick lookup for transform props.
 */
var transformPropSet = new Set(transformProps);
function isTransformProp(key) {
  return transformPropSet.has(key);
}
/**
 * A quick lookup for transform origin props
 */
var transformOriginProps = new Set(["originX", "originY", "originZ"]);
function isTransformOriginProp(key) {
  return transformOriginProps.has(key);
}
},{}],"DvTT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isForcedMotionValue = isForcedMotionValue;
var _scaleCorrection = require("../../projection/styles/scale-correction.mjs");
var _transform = require("../../render/html/utils/transform.mjs");
function isForcedMotionValue(key, _a) {
  var layout = _a.layout,
    layoutId = _a.layoutId;
  return (0, _transform.isTransformProp)(key) || (0, _transform.isTransformOriginProp)(key) || (layout || layoutId !== undefined) && (!!_scaleCorrection.scaleCorrectors[key] || key === "opacity");
}
},{"../../projection/styles/scale-correction.mjs":"PNTQ","../../render/html/utils/transform.mjs":"qPCc"}],"XNB1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMotionValue = void 0;
var isMotionValue = function (value) {
  return Boolean(value !== null && typeof value === "object" && value.getVelocity);
};
exports.isMotionValue = isMotionValue;
},{}],"utsa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildTransform = buildTransform;
exports.buildTransformOrigin = buildTransformOrigin;
var _transform = require("./transform.mjs");
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
/**
 * Build a CSS transform style from individual x/y/scale etc properties.
 *
 * This outputs with a default order of transforms/scales/rotations, this can be customised by
 * providing a transformTemplate function.
 */
function buildTransform(_a, _b, transformIsDefault, transformTemplate) {
  var transform = _a.transform,
    transformKeys = _a.transformKeys;
  var _c = _b.enableHardwareAcceleration,
    enableHardwareAcceleration = _c === void 0 ? true : _c,
    _d = _b.allowTransformNone,
    allowTransformNone = _d === void 0 ? true : _d;
  // The transform string we're going to build into.
  var transformString = "";
  // Transform keys into their default order - this will determine the output order.
  transformKeys.sort(_transform.sortTransformProps);
  // Track whether the defined transform has a defined z so we don't add a
  // second to enable hardware acceleration
  var transformHasZ = false;
  // Loop over each transform and build them into transformString
  var numTransformKeys = transformKeys.length;
  for (var i = 0; i < numTransformKeys; i++) {
    var key = transformKeys[i];
    transformString += "".concat(translateAlias[key] || key, "(").concat(transform[key], ") ");
    if (key === "z") transformHasZ = true;
  }
  if (!transformHasZ && enableHardwareAcceleration) {
    transformString += "translateZ(0)";
  } else {
    transformString = transformString.trim();
  }
  // If we have a custom `transform` template, pass our transform values and
  // generated transformString to that before returning
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
/**
 * Build a transformOrigin style. Uses the same defaults as the browser for
 * undefined origins.
 */
function buildTransformOrigin(_a) {
  var _b = _a.originX,
    originX = _b === void 0 ? "50%" : _b,
    _c = _a.originY,
    originY = _c === void 0 ? "50%" : _c,
    _d = _a.originZ,
    originZ = _d === void 0 ? 0 : _d;
  return "".concat(originX, " ").concat(originY, " ").concat(originZ);
}
},{"./transform.mjs":"qPCc"}],"sTTH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCSSVariable = isCSSVariable;
/**
 * Returns true if the provided key is a CSS variable
 */
function isCSSVariable(key) {
  return key.startsWith("--");
}
},{}],"jWLG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValueAsType = void 0;
/**
 * Provided a value and a ValueType, returns the value as that value type.
 */
var getValueAsType = function (value, type) {
  return type && typeof value === "number" ? type.transform(value) : value;
};
exports.getValueAsType = getValueAsType;
},{}],"IX7L":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.floatRegex = exports.colorRegex = exports.clamp = void 0;
exports.isString = isString;
exports.singleColorRegex = exports.sanitize = void 0;
const clamp = (min, max) => v => Math.max(Math.min(v, max), min);
exports.clamp = clamp;
const sanitize = v => v % 1 ? Number(v.toFixed(5)) : v;
exports.sanitize = sanitize;
const floatRegex = /(-)?([\d]*\.?[\d])+/g;
exports.floatRegex = floatRegex;
const colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
exports.colorRegex = colorRegex;
const singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
exports.singleColorRegex = singleColorRegex;
function isString(v) {
  return typeof v === 'string';
}
},{}],"Qt8i":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scale = exports.number = exports.alpha = void 0;
var _utils = require("../utils.mjs");
const number = {
  test: v => typeof v === 'number',
  parse: parseFloat,
  transform: v => v
};
exports.number = number;
const alpha = Object.assign(Object.assign({}, number), {
  transform: (0, _utils.clamp)(0, 1)
});
exports.alpha = alpha;
const scale = Object.assign(Object.assign({}, number), {
  default: 1
});
exports.scale = scale;
},{"../utils.mjs":"IX7L"}],"KXQU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vw = exports.vh = exports.px = exports.progressPercentage = exports.percent = exports.degrees = void 0;
var _utils = require("../utils.mjs");
const createUnitType = unit => ({
  test: v => (0, _utils.isString)(v) && v.endsWith(unit) && v.split(' ').length === 1,
  parse: parseFloat,
  transform: v => `${v}${unit}`
});
const degrees = createUnitType('deg');
exports.degrees = degrees;
const percent = createUnitType('%');
exports.percent = percent;
const px = createUnitType('px');
exports.px = px;
const vh = createUnitType('vh');
exports.vh = vh;
const vw = createUnitType('vw');
exports.vw = vw;
const progressPercentage = Object.assign(Object.assign({}, percent), {
  parse: v => percent.parse(v) / 100,
  transform: v => percent.transform(v * 100)
});
exports.progressPercentage = progressPercentage;
},{"../utils.mjs":"IX7L"}],"h4xe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitColor = exports.isColorString = void 0;
var _utils = require("../utils.mjs");
const isColorString = (type, testProp) => v => {
  return Boolean((0, _utils.isString)(v) && _utils.singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));
};
exports.isColorString = isColorString;
const splitColor = (aName, bName, cName) => v => {
  if (!(0, _utils.isString)(v)) return v;
  const [a, b, c, alpha] = v.match(_utils.floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c),
    alpha: alpha !== undefined ? parseFloat(alpha) : 1
  };
};
exports.splitColor = splitColor;
},{"../utils.mjs":"IX7L"}],"Ym0R":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hsla = void 0;
var _index = require("../numbers/index.mjs");
var _units = require("../numbers/units.mjs");
var _utils = require("../utils.mjs");
var _utils2 = require("./utils.mjs");
const hsla = {
  test: (0, _utils2.isColorString)('hsl', 'hue'),
  parse: (0, _utils2.splitColor)('hue', 'saturation', 'lightness'),
  transform: ({
    hue,
    saturation,
    lightness,
    alpha: alpha$1 = 1
  }) => {
    return 'hsla(' + Math.round(hue) + ', ' + _units.percent.transform((0, _utils.sanitize)(saturation)) + ', ' + _units.percent.transform((0, _utils.sanitize)(lightness)) + ', ' + (0, _utils.sanitize)(_index.alpha.transform(alpha$1)) + ')';
  }
};
exports.hsla = hsla;
},{"../numbers/index.mjs":"Qt8i","../numbers/units.mjs":"KXQU","../utils.mjs":"IX7L","./utils.mjs":"h4xe"}],"oF5T":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rgba = exports.rgbUnit = void 0;
var _index = require("../numbers/index.mjs");
var _utils = require("../utils.mjs");
var _utils2 = require("./utils.mjs");
const clampRgbUnit = (0, _utils.clamp)(0, 255);
const rgbUnit = Object.assign(Object.assign({}, _index.number), {
  transform: v => Math.round(clampRgbUnit(v))
});
exports.rgbUnit = rgbUnit;
const rgba = {
  test: (0, _utils2.isColorString)('rgb', 'red'),
  parse: (0, _utils2.splitColor)('red', 'green', 'blue'),
  transform: ({
    red,
    green,
    blue,
    alpha: alpha$1 = 1
  }) => 'rgba(' + rgbUnit.transform(red) + ', ' + rgbUnit.transform(green) + ', ' + rgbUnit.transform(blue) + ', ' + (0, _utils.sanitize)(_index.alpha.transform(alpha$1)) + ')'
};
exports.rgba = rgba;
},{"../numbers/index.mjs":"Qt8i","../utils.mjs":"IX7L","./utils.mjs":"h4xe"}],"zOht":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hex = void 0;
var _rgba = require("./rgba.mjs");
var _utils = require("./utils.mjs");
function parseHex(v) {
  let r = '';
  let g = '';
  let b = '';
  let a = '';
  if (v.length > 5) {
    r = v.substr(1, 2);
    g = v.substr(3, 2);
    b = v.substr(5, 2);
    a = v.substr(7, 2);
  } else {
    r = v.substr(1, 1);
    g = v.substr(2, 1);
    b = v.substr(3, 1);
    a = v.substr(4, 1);
    r += r;
    g += g;
    b += b;
    a += a;
  }
  return {
    red: parseInt(r, 16),
    green: parseInt(g, 16),
    blue: parseInt(b, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
const hex = {
  test: (0, _utils.isColorString)('#'),
  parse: parseHex,
  transform: _rgba.rgba.transform
};
exports.hex = hex;
},{"./rgba.mjs":"oF5T","./utils.mjs":"h4xe"}],"nDpD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.color = void 0;
var _utils = require("../utils.mjs");
var _hex = require("./hex.mjs");
var _hsla = require("./hsla.mjs");
var _rgba = require("./rgba.mjs");
const color = {
  test: v => _rgba.rgba.test(v) || _hex.hex.test(v) || _hsla.hsla.test(v),
  parse: v => {
    if (_rgba.rgba.test(v)) {
      return _rgba.rgba.parse(v);
    } else if (_hsla.hsla.test(v)) {
      return _hsla.hsla.parse(v);
    } else {
      return _hex.hex.parse(v);
    }
  },
  transform: v => {
    return (0, _utils.isString)(v) ? v : v.hasOwnProperty('red') ? _rgba.rgba.transform(v) : _hsla.hsla.transform(v);
  }
};
exports.color = color;
},{"../utils.mjs":"IX7L","./hex.mjs":"zOht","./hsla.mjs":"Ym0R","./rgba.mjs":"oF5T"}],"ySVx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.complex = void 0;
var _index = require("../color/index.mjs");
var _index2 = require("../numbers/index.mjs");
var _utils = require("../utils.mjs");
const colorToken = '${c}';
const numberToken = '${n}';
function test(v) {
  var _a, _b, _c, _d;
  return isNaN(v) && (0, _utils.isString)(v) && ((_b = (_a = v.match(_utils.floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(_utils.colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;
}
function analyse(v) {
  if (typeof v === 'number') v = `${v}`;
  const values = [];
  let numColors = 0;
  const colors = v.match(_utils.colorRegex);
  if (colors) {
    numColors = colors.length;
    v = v.replace(_utils.colorRegex, colorToken);
    values.push(...colors.map(_index.color.parse));
  }
  const numbers = v.match(_utils.floatRegex);
  if (numbers) {
    v = v.replace(_utils.floatRegex, numberToken);
    values.push(...numbers.map(_index2.number.parse));
  }
  return {
    values,
    numColors,
    tokenised: v
  };
}
function parse(v) {
  return analyse(v).values;
}
function createTransformer(v) {
  const {
    values,
    numColors,
    tokenised
  } = analyse(v);
  const numValues = values.length;
  return v => {
    let output = tokenised;
    for (let i = 0; i < numValues; i++) {
      output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? _index.color.transform(v[i]) : (0, _utils.sanitize)(v[i]));
    }
    return output;
  };
}
const convertNumbersToZero = v => typeof v === 'number' ? 0 : v;
function getAnimatableNone(v) {
  const parsed = parse(v);
  const transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse,
  createTransformer,
  getAnimatableNone
};
exports.complex = complex;
},{"../color/index.mjs":"nDpD","../numbers/index.mjs":"Qt8i","../utils.mjs":"IX7L"}],"XbPa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filter = void 0;
var _index = require("./index.mjs");
var _utils = require("../utils.mjs");
const maxDefaults = new Set(['brightness', 'contrast', 'saturate', 'opacity']);
function applyDefaultFilter(v) {
  let [name, value] = v.slice(0, -1).split('(');
  if (name === 'drop-shadow') return v;
  const [number] = value.match(_utils.floatRegex) || [];
  if (!number) return v;
  const unit = value.replace(number, '');
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number !== value) defaultValue *= 100;
  return name + '(' + defaultValue + unit + ')';
}
const functionRegex = /([a-z-]*)\(.*?\)/g;
const filter = Object.assign(Object.assign({}, _index.complex), {
  getAnimatableNone: v => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(' ') : v;
  }
});
exports.filter = filter;
},{"./index.mjs":"ySVx","../utils.mjs":"IX7L"}],"vstm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "alpha", {
  enumerable: true,
  get: function () {
    return _index.alpha;
  }
});
Object.defineProperty(exports, "color", {
  enumerable: true,
  get: function () {
    return _index2.color;
  }
});
Object.defineProperty(exports, "complex", {
  enumerable: true,
  get: function () {
    return _index3.complex;
  }
});
Object.defineProperty(exports, "degrees", {
  enumerable: true,
  get: function () {
    return _units.degrees;
  }
});
Object.defineProperty(exports, "filter", {
  enumerable: true,
  get: function () {
    return _filter.filter;
  }
});
Object.defineProperty(exports, "hex", {
  enumerable: true,
  get: function () {
    return _hex.hex;
  }
});
Object.defineProperty(exports, "hsla", {
  enumerable: true,
  get: function () {
    return _hsla.hsla;
  }
});
Object.defineProperty(exports, "number", {
  enumerable: true,
  get: function () {
    return _index.number;
  }
});
Object.defineProperty(exports, "percent", {
  enumerable: true,
  get: function () {
    return _units.percent;
  }
});
Object.defineProperty(exports, "progressPercentage", {
  enumerable: true,
  get: function () {
    return _units.progressPercentage;
  }
});
Object.defineProperty(exports, "px", {
  enumerable: true,
  get: function () {
    return _units.px;
  }
});
Object.defineProperty(exports, "rgbUnit", {
  enumerable: true,
  get: function () {
    return _rgba.rgbUnit;
  }
});
Object.defineProperty(exports, "rgba", {
  enumerable: true,
  get: function () {
    return _rgba.rgba;
  }
});
Object.defineProperty(exports, "scale", {
  enumerable: true,
  get: function () {
    return _index.scale;
  }
});
Object.defineProperty(exports, "vh", {
  enumerable: true,
  get: function () {
    return _units.vh;
  }
});
Object.defineProperty(exports, "vw", {
  enumerable: true,
  get: function () {
    return _units.vw;
  }
});
var _index = require("./numbers/index.mjs");
var _units = require("./numbers/units.mjs");
var _hsla = require("./color/hsla.mjs");
var _rgba = require("./color/rgba.mjs");
var _hex = require("./color/hex.mjs");
var _index2 = require("./color/index.mjs");
var _index3 = require("./complex/index.mjs");
var _filter = require("./complex/filter.mjs");
},{"./numbers/index.mjs":"Qt8i","./numbers/units.mjs":"KXQU","./color/hsla.mjs":"Ym0R","./color/rgba.mjs":"oF5T","./color/hex.mjs":"zOht","./color/index.mjs":"nDpD","./complex/index.mjs":"ySVx","./complex/filter.mjs":"XbPa"}],"uuZ1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.int = void 0;
var _tslib = require("tslib");
var _styleValueTypes = require("style-value-types");
var int = (0, _tslib.__assign)((0, _tslib.__assign)({}, _styleValueTypes.number), {
  transform: Math.round
});
exports.int = int;
},{"tslib":"vCxL","style-value-types":"vstm"}],"hAFG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.numberValueTypes = void 0;
var _styleValueTypes = require("style-value-types");
var _typeInt = require("./type-int.mjs");
var numberValueTypes = {
  // Border props
  borderWidth: _styleValueTypes.px,
  borderTopWidth: _styleValueTypes.px,
  borderRightWidth: _styleValueTypes.px,
  borderBottomWidth: _styleValueTypes.px,
  borderLeftWidth: _styleValueTypes.px,
  borderRadius: _styleValueTypes.px,
  radius: _styleValueTypes.px,
  borderTopLeftRadius: _styleValueTypes.px,
  borderTopRightRadius: _styleValueTypes.px,
  borderBottomRightRadius: _styleValueTypes.px,
  borderBottomLeftRadius: _styleValueTypes.px,
  // Positioning props
  width: _styleValueTypes.px,
  maxWidth: _styleValueTypes.px,
  height: _styleValueTypes.px,
  maxHeight: _styleValueTypes.px,
  size: _styleValueTypes.px,
  top: _styleValueTypes.px,
  right: _styleValueTypes.px,
  bottom: _styleValueTypes.px,
  left: _styleValueTypes.px,
  // Spacing props
  padding: _styleValueTypes.px,
  paddingTop: _styleValueTypes.px,
  paddingRight: _styleValueTypes.px,
  paddingBottom: _styleValueTypes.px,
  paddingLeft: _styleValueTypes.px,
  margin: _styleValueTypes.px,
  marginTop: _styleValueTypes.px,
  marginRight: _styleValueTypes.px,
  marginBottom: _styleValueTypes.px,
  marginLeft: _styleValueTypes.px,
  // Transform props
  rotate: _styleValueTypes.degrees,
  rotateX: _styleValueTypes.degrees,
  rotateY: _styleValueTypes.degrees,
  rotateZ: _styleValueTypes.degrees,
  scale: _styleValueTypes.scale,
  scaleX: _styleValueTypes.scale,
  scaleY: _styleValueTypes.scale,
  scaleZ: _styleValueTypes.scale,
  skew: _styleValueTypes.degrees,
  skewX: _styleValueTypes.degrees,
  skewY: _styleValueTypes.degrees,
  distance: _styleValueTypes.px,
  translateX: _styleValueTypes.px,
  translateY: _styleValueTypes.px,
  translateZ: _styleValueTypes.px,
  x: _styleValueTypes.px,
  y: _styleValueTypes.px,
  z: _styleValueTypes.px,
  perspective: _styleValueTypes.px,
  transformPerspective: _styleValueTypes.px,
  opacity: _styleValueTypes.alpha,
  originX: _styleValueTypes.progressPercentage,
  originY: _styleValueTypes.progressPercentage,
  originZ: _styleValueTypes.px,
  // Misc
  zIndex: _typeInt.int,
  // SVG
  fillOpacity: _styleValueTypes.alpha,
  strokeOpacity: _styleValueTypes.alpha,
  numOctaves: _typeInt.int
};
exports.numberValueTypes = numberValueTypes;
},{"style-value-types":"vstm","./type-int.mjs":"uuZ1"}],"ZW60":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildHTMLStyles = buildHTMLStyles;
var _buildTransform = require("./build-transform.mjs");
var _isCssVariable = require("../../dom/utils/is-css-variable.mjs");
var _transform = require("./transform.mjs");
var _getAsType = require("../../dom/value-types/get-as-type.mjs");
var _number = require("../../dom/value-types/number.mjs");
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  var _a;
  var style = state.style,
    vars = state.vars,
    transform = state.transform,
    transformKeys = state.transformKeys,
    transformOrigin = state.transformOrigin;
  // Empty the transformKeys array. As we're throwing out refs to its items
  // this might not be as cheap as suspected. Maybe using the array as a buffer
  // with a manual incrementation would be better.
  transformKeys.length = 0;
  // Track whether we encounter any transform or transformOrigin values.
  var hasTransform = false;
  var hasTransformOrigin = false;
  // Does the calculated transform essentially equal "none"?
  var transformIsNone = true;
  /**
   * Loop over all our latest animated values and decide whether to handle them
   * as a style or CSS variable.
   *
   * Transforms and transform origins are kept seperately for further processing.
   */
  for (var key in latestValues) {
    var value = latestValues[key];
    /**
     * If this is a CSS variable we don't do any further processing.
     */
    if ((0, _isCssVariable.isCSSVariable)(key)) {
      vars[key] = value;
      continue;
    }
    // Convert the value to its default value type, ie 0 -> "0px"
    var valueType = _number.numberValueTypes[key];
    var valueAsType = (0, _getAsType.getValueAsType)(value, valueType);
    if ((0, _transform.isTransformProp)(key)) {
      // If this is a transform, flag to enable further transform processing
      hasTransform = true;
      transform[key] = valueAsType;
      transformKeys.push(key);
      // If we already know we have a non-default transform, early return
      if (!transformIsNone) continue;
      // Otherwise check to see if this is a default transform
      if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0)) transformIsNone = false;
    } else if ((0, _transform.isTransformOriginProp)(key)) {
      transformOrigin[key] = valueAsType;
      // If this is a transform origin, flag and enable further transform-origin processing
      hasTransformOrigin = true;
    } else {
      style[key] = valueAsType;
    }
  }
  if (hasTransform) {
    style.transform = (0, _buildTransform.buildTransform)(state, options, transformIsNone, transformTemplate);
  } else if (transformTemplate) {
    style.transform = transformTemplate({}, "");
  } else if (!latestValues.transform && style.transform) {
    style.transform = "none";
  }
  if (hasTransformOrigin) {
    style.transformOrigin = (0, _buildTransform.buildTransformOrigin)(transformOrigin);
  }
}
},{"./build-transform.mjs":"utsa","../../dom/utils/is-css-variable.mjs":"sTTH","./transform.mjs":"qPCc","../../dom/value-types/get-as-type.mjs":"jWLG","../../dom/value-types/number.mjs":"hAFG"}],"MRjv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHtmlRenderState = void 0;
var createHtmlRenderState = function () {
  return {
    style: {},
    transform: {},
    transformKeys: [],
    transformOrigin: {},
    vars: {}
  };
};
exports.createHtmlRenderState = createHtmlRenderState;
},{}],"U7W4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyRawValuesOnly = copyRawValuesOnly;
exports.useHTMLProps = useHTMLProps;
exports.useStyle = useStyle;
var _tslib = require("tslib");
var _react = require("react");
var _isForcedMotionValue = require("../../motion/utils/is-forced-motion-value.mjs");
var _isMotionValue = require("../../value/utils/is-motion-value.mjs");
var _buildStyles = require("./utils/build-styles.mjs");
var _createRenderState = require("./utils/create-render-state.mjs");
function copyRawValuesOnly(target, source, props) {
  for (var key in source) {
    if (!(0, _isMotionValue.isMotionValue)(source[key]) && !(0, _isForcedMotionValue.isForcedMotionValue)(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues(_a, visualState, isStatic) {
  var transformTemplate = _a.transformTemplate;
  return (0, _react.useMemo)(function () {
    var state = (0, _createRenderState.createHtmlRenderState)();
    (0, _buildStyles.buildHTMLStyles)(state, visualState, {
      enableHardwareAcceleration: !isStatic
    }, transformTemplate);
    var vars = state.vars,
      style = state.style;
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, vars), style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  var styleProp = props.style || {};
  var style = {};
  /**
   * Copy non-Motion Values straight into style
   */
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  if (props.transformValues) {
    style = props.transformValues(style);
  }
  return style;
}
function useHTMLProps(props, visualState, isStatic) {
  // The `any` isn't ideal but it is the type of createElement props argument
  var htmlProps = {};
  var style = useStyle(props, visualState, isStatic);
  if (Boolean(props.drag) && props.dragListener !== false) {
    // Disable the ghost element when a user drags
    htmlProps.draggable = false;
    // Disable text selection
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    // Disable scrolling on the draggable direction
    style.touchAction = props.drag === true ? "none" : "pan-".concat(props.drag === "x" ? "y" : "x");
  }
  htmlProps.style = style;
  return htmlProps;
}
},{"tslib":"vCxL","react":"n8MK","../../motion/utils/is-forced-motion-value.mjs":"DvTT","../../value/utils/is-motion-value.mjs":"XNB1","./utils/build-styles.mjs":"ZW60","./utils/create-render-state.mjs":"MRjv"}],"QzZB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isValidMotionProp = isValidMotionProp;
/**
 * A list of all valid MotionProps.
 *
 * @privateRemarks
 * This doesn't throw if a `MotionProp` name is missing - it should.
 */
var validMotionProps = new Set(["initial", "animate", "exit", "style", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "layout", "layoutId", "layoutDependency", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "drag", "dragControls", "dragListener", "dragConstraints", "dragDirectionLock", "dragSnapToOrigin", "_dragX", "_dragY", "dragElastic", "dragMomentum", "dragPropagation", "dragTransition", "whileDrag", "onPan", "onPanStart", "onPanEnd", "onPanSessionStart", "onTap", "onTapStart", "onTapCancel", "onHoverStart", "onHoverEnd", "whileFocus", "whileTap", "whileHover", "whileInView", "onViewportEnter", "onViewportLeave", "viewport", "layoutScroll"]);
/**
 * Check whether a prop name is a valid `MotionProp` key.
 *
 * @param key - Name of the property to check
 * @returns `true` is key is a valid `MotionProp`.
 *
 * @public
 */
function isValidMotionProp(key) {
  return validMotionProps.has(key);
}
},{}],"puaR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}
var _default = memoize;
exports.default = _default;
},{}],"dMlS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _memoize = _interopRequireDefault(require("@emotion/memoize"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var index = (0, _memoize.default)(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */ && prop.charCodeAt(1) === 110
  /* n */ && prop.charCodeAt(2) < 91;
}
/* Z+1 */);
var _default = index;
exports.default = _default;
},{"@emotion/memoize":"puaR"}],"Rt1I":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterProps = filterProps;
exports.loadExternalIsValidProp = loadExternalIsValidProp;
var _validProp = require("../../../motion/utils/valid-prop.mjs");
var shouldForward = function (key) {
  return !(0, _validProp.isValidMotionProp)(key);
};
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp) return;
  // Explicitly filter our events
  shouldForward = function (key) {
    return key.startsWith("on") ? !(0, _validProp.isValidMotionProp)(key) : isValidProp(key);
  };
}
/**
 * Emotion and Styled Components both allow users to pass through arbitrary props to their components
 * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which
 * of these should be passed to the underlying DOM node.
 *
 * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props
 * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props
 * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of
 * `@emotion/is-prop-valid`, however to fix this problem we need to use it.
 *
 * By making it an optionalDependency we can offer this functionality only in the situations where it's
 * actually required.
 */
try {
  /**
   * We attempt to import this package but require won't be defined in esm environments, in that case
   * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed
   * in favour of explicit injection.
   */
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a) {
  // We don't need to actually do anything here - the fallback is the existing `isPropValid`.
}
function filterProps(props, isDom, forwardMotionProps) {
  var filteredProps = {};
  for (var key in props) {
    if (shouldForward(key) || forwardMotionProps === true && (0, _validProp.isValidMotionProp)(key) || !isDom && !(0, _validProp.isValidMotionProp)(key) ||
    // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
},{"../../../motion/utils/valid-prop.mjs":"QzZB","@emotion/is-prop-valid":"dMlS"}],"r20h":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcSVGTransformOrigin = calcSVGTransformOrigin;
var _styleValueTypes = require("style-value-types");
function calcOrigin(origin, offset, size) {
  return typeof origin === "string" ? origin : _styleValueTypes.px.transform(offset + size * origin);
}
/**
 * The SVG transform origin defaults are different to CSS and is less intuitive,
 * so we use the measured dimensions of the SVG to reconcile these.
 */
function calcSVGTransformOrigin(dimensions, originX, originY) {
  var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return "".concat(pxOriginX, " ").concat(pxOriginY);
}
},{"style-value-types":"vstm"}],"gfek":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildSVGPath = buildSVGPath;
var _styleValueTypes = require("style-value-types");
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
/**
 * Build SVG path properties. Uses the path's measured length to convert
 * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset
 * and stroke-dasharray attributes.
 *
 * This function is mutative to reduce per-frame GC.
 */
function buildSVGPath(attrs, length, spacing, offset, useDashCase) {
  if (spacing === void 0) {
    spacing = 1;
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (useDashCase === void 0) {
    useDashCase = true;
  }
  // Normalise path length by setting SVG attribute pathLength to 1
  attrs.pathLength = 1;
  // We use dash case when setting attributes directly to the DOM node and camel case
  // when defining props on a React component.
  var keys = useDashCase ? dashKeys : camelKeys;
  // Build the dash offset
  attrs[keys.offset] = _styleValueTypes.px.transform(-offset);
  // Build the dash array
  var pathLength = _styleValueTypes.px.transform(length);
  var pathSpacing = _styleValueTypes.px.transform(spacing);
  attrs[keys.array] = "".concat(pathLength, " ").concat(pathSpacing);
}
},{"style-value-types":"vstm"}],"vHbP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildSVGAttrs = buildSVGAttrs;
var _tslib = require("tslib");
var _buildStyles = require("../../html/utils/build-styles.mjs");
var _transformOrigin = require("./transform-origin.mjs");
var _path = require("./path.mjs");
/**
 * Build SVG visual attrbutes, like cx and style.transform
 */
function buildSVGAttrs(state, _a, options, transformTemplate) {
  var attrX = _a.attrX,
    attrY = _a.attrY,
    originX = _a.originX,
    originY = _a.originY,
    pathLength = _a.pathLength,
    _b = _a.pathSpacing,
    pathSpacing = _b === void 0 ? 1 : _b,
    _c = _a.pathOffset,
    pathOffset = _c === void 0 ? 0 : _c,
    // This is object creation, which we try to avoid per-frame.
    latest = (0, _tslib.__rest)(_a, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
  (0, _buildStyles.buildHTMLStyles)(state, latest, options, transformTemplate);
  state.attrs = state.style;
  state.style = {};
  var attrs = state.attrs,
    style = state.style,
    dimensions = state.dimensions;
  /**
   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs
   * and copy it into style.
   */
  if (attrs.transform) {
    if (dimensions) style.transform = attrs.transform;
    delete attrs.transform;
  }
  // Parse transformOrigin
  if (dimensions && (originX !== undefined || originY !== undefined || style.transform)) {
    style.transformOrigin = (0, _transformOrigin.calcSVGTransformOrigin)(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);
  }
  // Treat x/y not as shortcuts but as actual attributes
  if (attrX !== undefined) attrs.x = attrX;
  if (attrY !== undefined) attrs.y = attrY;
  // Build SVG path if one has been defined
  if (pathLength !== undefined) {
    (0, _path.buildSVGPath)(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
},{"tslib":"vCxL","../../html/utils/build-styles.mjs":"ZW60","./transform-origin.mjs":"r20h","./path.mjs":"gfek"}],"RAmC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSvgRenderState = void 0;
var _tslib = require("tslib");
var _createRenderState = require("../../html/utils/create-render-state.mjs");
var createSvgRenderState = function () {
  return (0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _createRenderState.createHtmlRenderState)()), {
    attrs: {}
  });
};
exports.createSvgRenderState = createSvgRenderState;
},{"tslib":"vCxL","../../html/utils/create-render-state.mjs":"MRjv"}],"l8HE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSVGProps = useSVGProps;
var _tslib = require("tslib");
var _react = require("react");
var _useProps = require("../html/use-props.mjs");
var _buildAttrs = require("./utils/build-attrs.mjs");
var _createRenderState = require("./utils/create-render-state.mjs");
function useSVGProps(props, visualState) {
  var visualProps = (0, _react.useMemo)(function () {
    var state = (0, _createRenderState.createSvgRenderState)();
    (0, _buildAttrs.buildSVGAttrs)(state, visualState, {
      enableHardwareAcceleration: false
    }, props.transformTemplate);
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, state.attrs), {
      style: (0, _tslib.__assign)({}, state.style)
    });
  }, [visualState]);
  if (props.style) {
    var rawStyles = {};
    (0, _useProps.copyRawValuesOnly)(rawStyles, props.style, props);
    visualProps.style = (0, _tslib.__assign)((0, _tslib.__assign)({}, rawStyles), visualProps.style);
  }
  return visualProps;
}
},{"tslib":"vCxL","react":"n8MK","../html/use-props.mjs":"U7W4","./utils/build-attrs.mjs":"vHbP","./utils/create-render-state.mjs":"RAmC"}],"oLWJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createUseRender = createUseRender;
var _tslib = require("tslib");
var _react = require("react");
var _useProps = require("../html/use-props.mjs");
var _filterProps = require("./utils/filter-props.mjs");
var _isSvgComponent = require("./utils/is-svg-component.mjs");
var _useProps2 = require("../svg/use-props.mjs");
function createUseRender(forwardMotionProps) {
  if (forwardMotionProps === void 0) {
    forwardMotionProps = false;
  }
  var useRender = function (Component, props, projectionId, ref, _a, isStatic) {
    var latestValues = _a.latestValues;
    var useVisualProps = (0, _isSvgComponent.isSVGComponent)(Component) ? _useProps2.useSVGProps : _useProps.useHTMLProps;
    var visualProps = useVisualProps(props, latestValues, isStatic);
    var filteredProps = (0, _filterProps.filterProps)(props, typeof Component === "string", forwardMotionProps);
    var elementProps = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, filteredProps), visualProps), {
      ref: ref
    });
    if (projectionId) {
      elementProps["data-projection-id"] = projectionId;
    }
    return (0, _react.createElement)(Component, elementProps);
  };
  return useRender;
}
},{"tslib":"vCxL","react":"n8MK","../html/use-props.mjs":"U7W4","./utils/filter-props.mjs":"Rt1I","./utils/is-svg-component.mjs":"hj4I","../svg/use-props.mjs":"l8HE"}],"KZHC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.camelToDash = void 0;
var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = "$1-$2";
/**
 * Convert camelCase to dash-case properties.
 */
var camelToDash = function (str) {
  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};
exports.camelToDash = camelToDash;
},{}],"RWVZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderHTML = renderHTML;
function renderHTML(element, _a, styleProp, projection) {
  var style = _a.style,
    vars = _a.vars;
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  // Loop over any CSS variables and assign those.
  for (var key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
},{}],"Gyex":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.camelCaseAttributes = void 0;
/**
 * A set of attribute names that are always read/written as camel case.
 */
var camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength"]);
exports.camelCaseAttributes = camelCaseAttributes;
},{}],"UZy9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderSVG = renderSVG;
var _camelToDash = require("../../dom/utils/camel-to-dash.mjs");
var _render = require("../../html/utils/render.mjs");
var _camelCaseAttrs = require("./camel-case-attrs.mjs");
function renderSVG(element, renderState, _styleProp, projection) {
  (0, _render.renderHTML)(element, renderState, undefined, projection);
  for (var key in renderState.attrs) {
    element.setAttribute(!_camelCaseAttrs.camelCaseAttributes.has(key) ? (0, _camelToDash.camelToDash)(key) : key, renderState.attrs[key]);
  }
}
},{"../../dom/utils/camel-to-dash.mjs":"KZHC","../../html/utils/render.mjs":"RWVZ","./camel-case-attrs.mjs":"Gyex"}],"cLQp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scrapeMotionValuesFromProps = scrapeMotionValuesFromProps;
var _isForcedMotionValue = require("../../../motion/utils/is-forced-motion-value.mjs");
var _isMotionValue = require("../../../value/utils/is-motion-value.mjs");
function scrapeMotionValuesFromProps(props) {
  var style = props.style;
  var newValues = {};
  for (var key in style) {
    if ((0, _isMotionValue.isMotionValue)(style[key]) || (0, _isForcedMotionValue.isForcedMotionValue)(key, props)) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
},{"../../../motion/utils/is-forced-motion-value.mjs":"DvTT","../../../value/utils/is-motion-value.mjs":"XNB1"}],"ZKWc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scrapeMotionValuesFromProps = scrapeMotionValuesFromProps;
var _isMotionValue = require("../../../value/utils/is-motion-value.mjs");
var _scrapeMotionValues = require("../../html/utils/scrape-motion-values.mjs");
function scrapeMotionValuesFromProps(props) {
  var newValues = (0, _scrapeMotionValues.scrapeMotionValuesFromProps)(props);
  for (var key in props) {
    if ((0, _isMotionValue.isMotionValue)(props[key])) {
      var targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
},{"../../../value/utils/is-motion-value.mjs":"XNB1","../../html/utils/scrape-motion-values.mjs":"cLQp"}],"bI9v":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAnimationControls = isAnimationControls;
function isAnimationControls(v) {
  return typeof v === "object" && typeof v.start === "function";
}
},{}],"lbx8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isKeyframesTarget = void 0;
var isKeyframesTarget = function (v) {
  return Array.isArray(v);
};
exports.isKeyframesTarget = isKeyframesTarget;
},{}],"NhIh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveFinalValueInKeyframes = exports.isCustomValue = void 0;
var _isKeyframesTarget = require("../animation/utils/is-keyframes-target.mjs");
var isCustomValue = function (v) {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
exports.isCustomValue = isCustomValue;
var resolveFinalValueInKeyframes = function (v) {
  // TODO maybe throw if v.length - 1 is placeholder token?
  return (0, _isKeyframesTarget.isKeyframesTarget)(v) ? v[v.length - 1] || 0 : v;
};
exports.resolveFinalValueInKeyframes = resolveFinalValueInKeyframes;
},{"../animation/utils/is-keyframes-target.mjs":"lbx8"}],"MEus":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveMotionValue = resolveMotionValue;
var _resolveValue = require("../../utils/resolve-value.mjs");
var _isMotionValue = require("./is-motion-value.mjs");
/**
 * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself
 *
 * TODO: Remove and move to library
 */
function resolveMotionValue(value) {
  var unwrappedValue = (0, _isMotionValue.isMotionValue)(value) ? value.get() : value;
  return (0, _resolveValue.isCustomValue)(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
},{"../../utils/resolve-value.mjs":"NhIh","./is-motion-value.mjs":"XNB1"}],"b7cz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeUseVisualState = void 0;
var _tslib = require("tslib");
var _react = require("react");
var _isAnimationControls = require("../../animation/utils/is-animation-controls.mjs");
var _PresenceContext = require("../../context/PresenceContext.mjs");
var _variants = require("../../render/utils/variants.mjs");
var _useConstant = require("../../utils/use-constant.mjs");
var _resolveMotionValue = require("../../value/utils/resolve-motion-value.mjs");
var _index = require("../../context/MotionContext/index.mjs");
function makeState(_a, props, context, presenceContext) {
  var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps,
    createRenderState = _a.createRenderState,
    onMount = _a.onMount;
  var state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = function (instance) {
      return onMount(props, instance, state);
    };
  }
  return state;
}
var makeUseVisualState = function (config) {
  return function (props, isStatic) {
    var context = (0, _react.useContext)(_index.MotionContext);
    var presenceContext = (0, _react.useContext)(_PresenceContext.PresenceContext);
    return isStatic ? makeState(config, props, context, presenceContext) : (0, _useConstant.useConstant)(function () {
      return makeState(config, props, context, presenceContext);
    });
  };
};
exports.makeUseVisualState = makeUseVisualState;
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  var values = {};
  var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;
  var motionValues = scrapeMotionValues(props);
  for (var key in motionValues) {
    values[key] = (0, _resolveMotionValue.resolveMotionValue)(motionValues[key]);
  }
  var initial = props.initial,
    animate = props.animate;
  var isControllingVariants = (0, _variants.checkIfControllingVariants)(props);
  var isVariantNode = (0, _variants.checkIfVariantNode)(props);
  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {
    initial !== null && initial !== void 0 ? initial : initial = context.initial;
    animate !== null && animate !== void 0 ? animate : animate = context.animate;
  }
  var initialAnimationIsBlocked = blockInitialAnimation || initial === false;
  var variantToSet = initialAnimationIsBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !(0, _isAnimationControls.isAnimationControls)(variantToSet)) {
    var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach(function (definition) {
      var resolved = (0, _variants.resolveVariantFromProps)(props, definition);
      if (!resolved) return;
      var transitionEnd = resolved.transitionEnd;
      resolved.transition;
      var target = (0, _tslib.__rest)(resolved, ["transitionEnd", "transition"]);
      for (var key in target) {
        var valueTarget = target[key];
        if (Array.isArray(valueTarget)) {
          /**
           * Take final keyframe if the initial animation is blocked because
           * we want to initialise at the end of that blocked animation.
           */
          var index = initialAnimationIsBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index];
        }
        if (valueTarget !== null) {
          values[key] = valueTarget;
        }
      }
      for (var key in transitionEnd) values[key] = transitionEnd[key];
    });
  }
  return values;
}
},{"tslib":"vCxL","react":"n8MK","../../animation/utils/is-animation-controls.mjs":"bI9v","../../context/PresenceContext.mjs":"eYxR","../../render/utils/variants.mjs":"B4V7","../../utils/use-constant.mjs":"XPaj","../../value/utils/resolve-motion-value.mjs":"MEus","../../context/MotionContext/index.mjs":"rq4D"}],"qXKm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.svgMotionConfig = void 0;
var _render = require("./utils/render.mjs");
var _scrapeMotionValues = require("./utils/scrape-motion-values.mjs");
var _useVisualState = require("../../motion/utils/use-visual-state.mjs");
var _createRenderState = require("./utils/create-render-state.mjs");
var _buildAttrs = require("./utils/build-attrs.mjs");
var svgMotionConfig = {
  useVisualState: (0, _useVisualState.makeUseVisualState)({
    scrapeMotionValuesFromProps: _scrapeMotionValues.scrapeMotionValuesFromProps,
    createRenderState: _createRenderState.createSvgRenderState,
    onMount: function (props, instance, _a) {
      var renderState = _a.renderState,
        latestValues = _a.latestValues;
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e) {
        // Most likely trying to measure an unrendered element under Firefox
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      (0, _buildAttrs.buildSVGAttrs)(renderState, latestValues, {
        enableHardwareAcceleration: false
      }, props.transformTemplate);
      (0, _render.renderSVG)(instance, renderState);
    }
  })
};
exports.svgMotionConfig = svgMotionConfig;
},{"./utils/render.mjs":"UZy9","./utils/scrape-motion-values.mjs":"ZKWc","../../motion/utils/use-visual-state.mjs":"b7cz","./utils/create-render-state.mjs":"RAmC","./utils/build-attrs.mjs":"vHbP"}],"MDXU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.htmlMotionConfig = void 0;
var _useVisualState = require("../../motion/utils/use-visual-state.mjs");
var _scrapeMotionValues = require("./utils/scrape-motion-values.mjs");
var _createRenderState = require("./utils/create-render-state.mjs");
var htmlMotionConfig = {
  useVisualState: (0, _useVisualState.makeUseVisualState)({
    scrapeMotionValuesFromProps: _scrapeMotionValues.scrapeMotionValuesFromProps,
    createRenderState: _createRenderState.createHtmlRenderState
  })
};
exports.htmlMotionConfig = htmlMotionConfig;
},{"../../motion/utils/use-visual-state.mjs":"b7cz","./utils/scrape-motion-values.mjs":"cLQp","./utils/create-render-state.mjs":"MRjv"}],"Tc5g":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDomMotionConfig = createDomMotionConfig;
var _tslib = require("tslib");
var _isSvgComponent = require("./is-svg-component.mjs");
var _useRender = require("../use-render.mjs");
var _configMotion = require("../../svg/config-motion.mjs");
var _configMotion2 = require("../../html/config-motion.mjs");
function createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement, projectionNodeConstructor) {
  var _b = _a.forwardMotionProps,
    forwardMotionProps = _b === void 0 ? false : _b;
  var baseConfig = (0, _isSvgComponent.isSVGComponent)(Component) ? _configMotion.svgMotionConfig : _configMotion2.htmlMotionConfig;
  return (0, _tslib.__assign)((0, _tslib.__assign)({}, baseConfig), {
    preloadedFeatures: preloadedFeatures,
    useRender: (0, _useRender.createUseRender)(forwardMotionProps),
    createVisualElement: createVisualElement,
    projectionNodeConstructor: projectionNodeConstructor,
    Component: Component
  });
}
},{"tslib":"vCxL","./is-svg-component.mjs":"hj4I","../use-render.mjs":"oLWJ","../../svg/config-motion.mjs":"qXKm","../../html/config-motion.mjs":"MDXU"}],"gO5D":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimationType = void 0;
var AnimationType;
exports.AnimationType = AnimationType;
(function (AnimationType) {
  AnimationType["Animate"] = "animate";
  AnimationType["Hover"] = "whileHover";
  AnimationType["Tap"] = "whileTap";
  AnimationType["Drag"] = "whileDrag";
  AnimationType["Focus"] = "whileFocus";
  AnimationType["InView"] = "whileInView";
  AnimationType["Exit"] = "exit";
})(AnimationType || (exports.AnimationType = AnimationType = {}));
},{}],"QUBy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDomEvent = addDomEvent;
exports.useDomEvent = useDomEvent;
var _react = require("react");
function addDomEvent(target, eventName, handler, options) {
  if (options === void 0) {
    options = {
      passive: true
    };
  }
  target.addEventListener(eventName, handler, options);
  return function () {
    return target.removeEventListener(eventName, handler);
  };
}
/**
 * Attaches an event listener directly to the provided DOM element.
 *
 * Bypassing React's event system can be desirable, for instance when attaching non-passive
 * event handlers.
 *
 * ```jsx
 * const ref = useRef(null)
 *
 * useDomEvent(ref, 'wheel', onWheel, { passive: false })
 *
 * return <div ref={ref} />
 * ```
 *
 * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.
 * @param eventName - Name of the event you want listen for.
 * @param handler - Function to fire when receiving the event.
 * @param options - Options to pass to `Event.addEventListener`.
 *
 * @public
 */
function useDomEvent(ref, eventName, handler, options) {
  (0, _react.useEffect)(function () {
    var element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}
},{"react":"n8MK"}],"gdMN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFocusGesture = useFocusGesture;
var _types = require("../render/utils/types.mjs");
var _useDomEvent = require("../events/use-dom-event.mjs");
/**
 *
 * @param props
 * @param ref
 * @internal
 */
function useFocusGesture(_a) {
  var whileFocus = _a.whileFocus,
    visualElement = _a.visualElement;
  var onFocus = function () {
    var _a;
    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(_types.AnimationType.Focus, true);
  };
  var onBlur = function () {
    var _a;
    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(_types.AnimationType.Focus, false);
  };
  (0, _useDomEvent.useDomEvent)(visualElement, "focus", whileFocus ? onFocus : undefined);
  (0, _useDomEvent.useDomEvent)(visualElement, "blur", whileFocus ? onBlur : undefined);
}
},{"../render/utils/types.mjs":"gO5D","../events/use-dom-event.mjs":"QUBy"}],"xikS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMouseEvent = isMouseEvent;
exports.isTouchEvent = isTouchEvent;
function isMouseEvent(event) {
  // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.
  if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof MouseEvent;
}
function isTouchEvent(event) {
  var hasTouches = !!event.touches;
  return hasTouches;
}
},{}],"zZPj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractEventInfo = extractEventInfo;
exports.wrapHandler = void 0;
var _eventType = require("../gestures/utils/event-type.mjs");
/**
 * Filters out events not attached to the primary pointer (currently left mouse button)
 * @param eventHandler
 */
function filterPrimaryPointer(eventHandler) {
  return function (event) {
    var isMouseEvent = event instanceof MouseEvent;
    var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
var defaultPagePoint = {
  pageX: 0,
  pageY: 0
};
function pointFromTouch(e, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  var primaryTouch = e.touches[0] || e.changedTouches[0];
  var point = primaryTouch || defaultPagePoint;
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function pointFromMouse(point, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function extractEventInfo(event, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    point: (0, _eventType.isTouchEvent)(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
var wrapHandler = function (handler, shouldFilterPrimaryPointer) {
  if (shouldFilterPrimaryPointer === void 0) {
    shouldFilterPrimaryPointer = false;
  }
  var listener = function (event) {
    return handler(event, extractEventInfo(event));
  };
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
};
exports.wrapHandler = wrapHandler;
},{"../gestures/utils/event-type.mjs":"xikS"}],"SvE7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.supportsTouchEvents = exports.supportsPointerEvents = exports.supportsMouseEvents = void 0;
var _isBrowser = require("../utils/is-browser.mjs");
// We check for event support via functions in case they've been mocked by a testing suite.
var supportsPointerEvents = function () {
  return _isBrowser.isBrowser && window.onpointerdown === null;
};
exports.supportsPointerEvents = supportsPointerEvents;
var supportsTouchEvents = function () {
  return _isBrowser.isBrowser && window.ontouchstart === null;
};
exports.supportsTouchEvents = supportsTouchEvents;
var supportsMouseEvents = function () {
  return _isBrowser.isBrowser && window.onmousedown === null;
};
exports.supportsMouseEvents = supportsMouseEvents;
},{"../utils/is-browser.mjs":"Kkfx"}],"tW3y":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addPointerEvent = addPointerEvent;
exports.usePointerEvent = usePointerEvent;
var _useDomEvent = require("./use-dom-event.mjs");
var _eventInfo = require("./event-info.mjs");
var _utils = require("./utils.mjs");
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name) {
  if ((0, _utils.supportsPointerEvents)()) {
    return name;
  } else if ((0, _utils.supportsTouchEvents)()) {
    return touchEventNames[name];
  } else if ((0, _utils.supportsMouseEvents)()) {
    return mouseEventNames[name];
  }
  return name;
}
function addPointerEvent(target, eventName, handler, options) {
  return (0, _useDomEvent.addDomEvent)(target, getPointerEventName(eventName), (0, _eventInfo.wrapHandler)(handler, eventName === "pointerdown"), options);
}
function usePointerEvent(ref, eventName, handler, options) {
  return (0, _useDomEvent.useDomEvent)(ref, getPointerEventName(eventName), handler && (0, _eventInfo.wrapHandler)(handler, eventName === "pointerdown"), options);
}
},{"./use-dom-event.mjs":"QUBy","./event-info.mjs":"zZPj","./utils.mjs":"SvE7"}],"UvuD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLock = createLock;
exports.getGlobalLock = getGlobalLock;
exports.isDragActive = isDragActive;
function createLock(name) {
  var lock = null;
  return function () {
    var openLock = function () {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag) {
  var lock = false;
  if (drag === "y") {
    lock = globalVerticalLock();
  } else if (drag === "x") {
    lock = globalHorizontalLock();
  } else {
    var openHorizontal_1 = globalHorizontalLock();
    var openVertical_1 = globalVerticalLock();
    if (openHorizontal_1 && openVertical_1) {
      lock = function () {
        openHorizontal_1();
        openVertical_1();
      };
    } else {
      // Release the locks because we don't use them
      if (openHorizontal_1) openHorizontal_1();
      if (openVertical_1) openVertical_1();
    }
  }
  return lock;
}
function isDragActive() {
  // Check the gesture lock - if we get it, it means no drag gesture is active
  // and we can safely fire the tap gesture.
  var openGestureLock = getGlobalLock(true);
  if (!openGestureLock) return true;
  openGestureLock();
  return false;
}
},{}],"yZTN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useHoverGesture = useHoverGesture;
var _eventType = require("./utils/event-type.mjs");
var _types = require("../render/utils/types.mjs");
var _usePointerEvent = require("../events/use-pointer-event.mjs");
var _lock = require("./drag/utils/lock.mjs");
function createHoverEvent(visualElement, isActive, callback) {
  return function (event, info) {
    var _a;
    if (!(0, _eventType.isMouseEvent)(event) || (0, _lock.isDragActive)()) return;
    /**
     * Ensure we trigger animations before firing event callback
     */
    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(_types.AnimationType.Hover, isActive);
    callback === null || callback === void 0 ? void 0 : callback(event, info);
  };
}
function useHoverGesture(_a) {
  var onHoverStart = _a.onHoverStart,
    onHoverEnd = _a.onHoverEnd,
    whileHover = _a.whileHover,
    visualElement = _a.visualElement;
  (0, _usePointerEvent.usePointerEvent)(visualElement, "pointerenter", onHoverStart || whileHover ? createHoverEvent(visualElement, true, onHoverStart) : undefined, {
    passive: !onHoverStart
  });
  (0, _usePointerEvent.usePointerEvent)(visualElement, "pointerleave", onHoverEnd || whileHover ? createHoverEvent(visualElement, false, onHoverEnd) : undefined, {
    passive: !onHoverEnd
  });
}
},{"./utils/event-type.mjs":"xikS","../render/utils/types.mjs":"gO5D","../events/use-pointer-event.mjs":"tW3y","./drag/utils/lock.mjs":"UvuD"}],"fhsg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNodeOrChild = void 0;
/**
 * Recursively traverse up the tree to check whether the provided child node
 * is the parent or a descendant of it.
 *
 * @param parent - Element to find
 * @param child - Element to test against parent
 */
var isNodeOrChild = function (parent, child) {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
exports.isNodeOrChild = isNodeOrChild;
},{}],"Iby2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useUnmountEffect = useUnmountEffect;
var _react = require("react");
function useUnmountEffect(callback) {
  return (0, _react.useEffect)(function () {
    return function () {
      return callback();
    };
  }, []);
}
},{"react":"n8MK"}],"xkQy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clamp = void 0;
const clamp = (min, max, v) => Math.min(Math.max(v, min), max);
exports.clamp = clamp;
},{}],"MfyT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcAngularFreq = calcAngularFreq;
exports.findSpring = findSpring;
exports.minDuration = exports.minDamping = exports.maxDuration = exports.maxDamping = void 0;
var _heyListen = require("hey-listen");
var _clamp = require("../../utils/clamp.mjs");
const safeMin = 0.001;
const minDuration = 0.01;
exports.minDuration = minDuration;
const maxDuration = 10.0;
exports.maxDuration = maxDuration;
const minDamping = 0.05;
exports.minDamping = minDamping;
const maxDamping = 1;
exports.maxDamping = maxDamping;
function findSpring({
  duration = 800,
  bounce = 0.25,
  velocity = 0,
  mass = 1
}) {
  let envelope;
  let derivative;
  (0, _heyListen.warning)(duration <= maxDuration * 1000, "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = (0, _clamp.clamp)(minDamping, maxDamping, dampingRatio);
  duration = (0, _clamp.clamp)(minDuration, maxDuration, duration / 1000);
  if (dampingRatio < 1) {
    envelope = undampedFreq => {
      const exponentialDecay = undampedFreq * dampingRatio;
      const delta = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b = calcAngularFreq(undampedFreq, dampingRatio);
      const c = Math.exp(-delta);
      return safeMin - a / b * c;
    };
    derivative = undampedFreq => {
      const exponentialDecay = undampedFreq * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
      const f = Math.exp(-delta);
      const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);
      const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    };
  } else {
    envelope = undampedFreq => {
      const a = Math.exp(-undampedFreq * duration);
      const b = (undampedFreq - velocity) * duration + 1;
      return -safeMin + a * b;
    };
    derivative = undampedFreq => {
      const a = Math.exp(-undampedFreq * duration);
      const b = (velocity - undampedFreq) * (duration * duration);
      return a * b;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1000;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
},{"hey-listen":"KFGT","../../utils/clamp.mjs":"xkQy"}],"E8uF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spring = spring;
var _tslib = require("tslib");
var _findSpring = require("../utils/find-spring.mjs");
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some(key => options[key] !== undefined);
}
function getSpringOptions(options) {
  let springOptions = Object.assign({
    velocity: 0.0,
    stiffness: 100,
    damping: 10,
    mass: 1.0,
    isResolvedFromDuration: false
  }, options);
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = (0, _findSpring.findSpring)(options);
    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), {
      velocity: 0.0,
      mass: 1.0
    });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring(_a) {
  var {
      from = 0.0,
      to = 1.0,
      restSpeed = 2,
      restDelta
    } = _a,
    options = (0, _tslib.__rest)(_a, ["from", "to", "restSpeed", "restDelta"]);
  const state = {
    done: false,
    value: from
  };
  let {
    stiffness,
    damping,
    mass,
    velocity,
    duration,
    isResolvedFromDuration
  } = getSpringOptions(options);
  let resolveSpring = zero;
  let resolveVelocity = zero;
  function createSpring() {
    const initialVelocity = velocity ? -(velocity / 1000) : 0.0;
    const initialDelta = to - from;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;
    if (restDelta === undefined) {
      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);
    }
    if (dampingRatio < 1) {
      const angularFreq = (0, _findSpring.calcAngularFreq)(undampedAngularFreq, dampingRatio);
      resolveSpring = t => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
      };
      resolveVelocity = t => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = t => to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = t => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        const freqForT = Math.min(dampedAngularFreq * t, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: t => {
      const current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        const currentVelocity = resolveVelocity(t) * 1000;
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= duration;
      }
      state.value = state.done ? to : current;
      return state;
    },
    flipTarget: () => {
      velocity = -velocity;
      [from, to] = [to, from];
      createSpring();
    }
  };
}
spring.needsInterpolation = (a, b) => typeof a === "string" || typeof b === "string";
const zero = _t => 0;
},{"tslib":"vCxL","../utils/find-spring.mjs":"MfyT"}],"MEzP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.progress = void 0;
const progress = (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
exports.progress = progress;
},{}],"RcO4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mix = void 0;
const mix = (from, to, progress) => -progress * from + progress * to + from;
exports.mix = mix;
},{}],"m18T":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hslaToRgba = hslaToRgba;
function hueToRgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslaToRgba({
  hue,
  saturation,
  lightness,
  alpha
}) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q;
    red = hueToRgb(p, q, hue + 1 / 3);
    green = hueToRgb(p, q, hue);
    blue = hueToRgb(p, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha
  };
}
},{}],"aNsl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mixLinearColor = exports.mixColor = void 0;
var _mix = require("./mix.mjs");
var _styleValueTypes = require("style-value-types");
var _heyListen = require("hey-listen");
var _hslaToRgba = require("./hsla-to-rgba.mjs");
const mixLinearColor = (from, to, v) => {
  const fromExpo = from * from;
  const toExpo = to * to;
  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));
};
exports.mixLinearColor = mixLinearColor;
const colorTypes = [_styleValueTypes.hex, _styleValueTypes.rgba, _styleValueTypes.hsla];
const getColorType = v => colorTypes.find(type => type.test(v));
const notAnimatable = color => `'${color}' is not an animatable color. Use the equivalent color code instead.`;
const mixColor = (from, to) => {
  let fromColorType = getColorType(from);
  let toColorType = getColorType(to);
  (0, _heyListen.invariant)(!!fromColorType, notAnimatable(from));
  (0, _heyListen.invariant)(!!toColorType, notAnimatable(to));
  let fromColor = fromColorType.parse(from);
  let toColor = toColorType.parse(to);
  if (fromColorType === _styleValueTypes.hsla) {
    fromColor = (0, _hslaToRgba.hslaToRgba)(fromColor);
    fromColorType = _styleValueTypes.rgba;
  }
  if (toColorType === _styleValueTypes.hsla) {
    toColor = (0, _hslaToRgba.hslaToRgba)(toColor);
    toColorType = _styleValueTypes.rgba;
  }
  const blended = Object.assign({}, fromColor);
  return v => {
    for (const key in blended) {
      if (key !== "alpha") {
        blended[key] = mixLinearColor(fromColor[key], toColor[key], v);
      }
    }
    blended.alpha = (0, _mix.mix)(fromColor.alpha, toColor.alpha, v);
    return fromColorType.transform(blended);
  };
};
exports.mixColor = mixColor;
},{"./mix.mjs":"RcO4","style-value-types":"vstm","hey-listen":"KFGT","./hsla-to-rgba.mjs":"m18T"}],"WSIw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zeroPoint = exports.isNum = void 0;
const zeroPoint = {
  x: 0,
  y: 0,
  z: 0
};
exports.zeroPoint = zeroPoint;
const isNum = v => typeof v === 'number';
exports.isNum = isNum;
},{}],"OVns":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pipe = void 0;
const combineFunctions = (a, b) => v => b(a(v));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
exports.pipe = pipe;
},{}],"Fv0c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mixObject = exports.mixComplex = exports.mixArray = void 0;
var _styleValueTypes = require("style-value-types");
var _mix = require("./mix.mjs");
var _mixColor = require("./mix-color.mjs");
var _inc = require("./inc.mjs");
var _pipe = require("./pipe.mjs");
var _heyListen = require("hey-listen");
function getMixer(origin, target) {
  if ((0, _inc.isNum)(origin)) {
    return v => (0, _mix.mix)(origin, target, v);
  } else if (_styleValueTypes.color.test(origin)) {
    return (0, _mixColor.mixColor)(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
const mixArray = (from, to) => {
  const output = [...from];
  const numValues = output.length;
  const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));
  return v => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v);
    }
    return output;
  };
};
exports.mixArray = mixArray;
const mixObject = (origin, target) => {
  const output = Object.assign(Object.assign({}, origin), target);
  const blendValue = {};
  for (const key in output) {
    if (origin[key] !== undefined && target[key] !== undefined) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return v => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v);
    }
    return output;
  };
};
exports.mixObject = mixObject;
function analyse(value) {
  const parsed = _styleValueTypes.complex.parse(value);
  const numValues = parsed.length;
  let numNumbers = 0;
  let numRGB = 0;
  let numHSL = 0;
  for (let i = 0; i < numValues; i++) {
    if (numNumbers || typeof parsed[i] === "number") {
      numNumbers++;
    } else {
      if (parsed[i].hue !== undefined) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return {
    parsed,
    numNumbers,
    numRGB,
    numHSL
  };
}
const mixComplex = (origin, target) => {
  const template = _styleValueTypes.complex.createTransformer(target);
  const originStats = analyse(origin);
  const targetStats = analyse(target);
  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return (0, _pipe.pipe)(mixArray(originStats.parsed, targetStats.parsed), template);
  } else {
    (0, _heyListen.warning)(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return p => `${p > 0 ? target : origin}`;
  }
};
exports.mixComplex = mixComplex;
},{"style-value-types":"vstm","./mix.mjs":"RcO4","./mix-color.mjs":"aNsl","./inc.mjs":"WSIw","./pipe.mjs":"OVns","hey-listen":"KFGT"}],"JQaN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interpolate = interpolate;
var _progress = require("./progress.mjs");
var _mix = require("./mix.mjs");
var _mixColor = require("./mix-color.mjs");
var _mixComplex = require("./mix-complex.mjs");
var _styleValueTypes = require("style-value-types");
var _clamp = require("./clamp.mjs");
var _pipe = require("./pipe.mjs");
var _heyListen = require("hey-listen");
const mixNumber = (from, to) => p => (0, _mix.mix)(from, to, p);
function detectMixerFactory(v) {
  if (typeof v === 'number') {
    return mixNumber;
  } else if (typeof v === 'string') {
    if (_styleValueTypes.color.test(v)) {
      return _mixColor.mixColor;
    } else {
      return _mixComplex.mixComplex;
    }
  } else if (Array.isArray(v)) {
    return _mixComplex.mixArray;
  } else if (typeof v === 'object') {
    return _mixComplex.mixObject;
  }
}
function createMixers(output, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i] : ease;
      mixer = (0, _pipe.pipe)(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate([from, to], [mixer]) {
  return v => mixer((0, _progress.progress)(from, to, v));
}
function slowInterpolate(input, mixers) {
  const inputLength = input.length;
  const lastInputIndex = inputLength - 1;
  return v => {
    let mixerIndex = 0;
    let foundMixerIndex = false;
    if (v <= input[0]) {
      foundMixerIndex = true;
    } else if (v >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      let i = 1;
      for (; i < inputLength; i++) {
        if (input[i] > v || i === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i - 1;
    }
    const progressInRange = (0, _progress.progress)(input[mixerIndex], input[mixerIndex + 1], v);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output, {
  clamp: isClamp = true,
  ease,
  mixer
} = {}) {
  const inputLength = input.length;
  (0, _heyListen.invariant)(inputLength === output.length, 'Both input and output ranges must be the same length');
  (0, _heyListen.invariant)(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output = [].concat(output);
    input.reverse();
    output.reverse();
  }
  const mixers = createMixers(output, ease, mixer);
  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? v => interpolator((0, _clamp.clamp)(input[0], input[inputLength - 1], v)) : interpolator;
}
},{"./progress.mjs":"MEzP","./mix.mjs":"RcO4","./mix-color.mjs":"aNsl","./mix-complex.mjs":"Fv0c","style-value-types":"vstm","./clamp.mjs":"xkQy","./pipe.mjs":"OVns","hey-listen":"KFGT"}],"kfpK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reverseEasing = exports.mirrorEasing = exports.createExpoIn = exports.createBackIn = exports.createAnticipate = void 0;
const reverseEasing = easing => p => 1 - easing(1 - p);
exports.reverseEasing = reverseEasing;
const mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
exports.mirrorEasing = mirrorEasing;
const createExpoIn = power => p => Math.pow(p, power);
exports.createExpoIn = createExpoIn;
const createBackIn = power => p => p * p * ((power + 1) * p - power);
exports.createBackIn = createBackIn;
const createAnticipate = power => {
  const backEasing = createBackIn(power);
  return p => (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
};
exports.createAnticipate = createAnticipate;
},{}],"vHlW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linear = exports.easeOut = exports.easeInOut = exports.easeIn = exports.circOut = exports.circInOut = exports.circIn = exports.bounceOut = exports.bounceInOut = exports.bounceIn = exports.backOut = exports.backInOut = exports.backIn = exports.anticipate = void 0;
var _utils = require("./utils.mjs");
const DEFAULT_OVERSHOOT_STRENGTH = 1.525;
const BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;
const BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;
const BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;
const linear = p => p;
exports.linear = linear;
const easeIn = (0, _utils.createExpoIn)(2);
exports.easeIn = easeIn;
const easeOut = (0, _utils.reverseEasing)(easeIn);
exports.easeOut = easeOut;
const easeInOut = (0, _utils.mirrorEasing)(easeIn);
exports.easeInOut = easeInOut;
const circIn = p => 1 - Math.sin(Math.acos(p));
exports.circIn = circIn;
const circOut = (0, _utils.reverseEasing)(circIn);
exports.circOut = circOut;
const circInOut = (0, _utils.mirrorEasing)(circOut);
exports.circInOut = circInOut;
const backIn = (0, _utils.createBackIn)(DEFAULT_OVERSHOOT_STRENGTH);
exports.backIn = backIn;
const backOut = (0, _utils.reverseEasing)(backIn);
exports.backOut = backOut;
const backInOut = (0, _utils.mirrorEasing)(backIn);
exports.backInOut = backInOut;
const anticipate = (0, _utils.createAnticipate)(DEFAULT_OVERSHOOT_STRENGTH);
exports.anticipate = anticipate;
const ca = 4356.0 / 361.0;
const cb = 35442.0 / 1805.0;
const cc = 16061.0 / 1805.0;
const bounceOut = p => {
  if (p === 1 || p === 0) return p;
  const p2 = p * p;
  return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;
};
exports.bounceOut = bounceOut;
const bounceIn = (0, _utils.reverseEasing)(bounceOut);
exports.bounceIn = bounceIn;
const bounceInOut = p => p < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0)) : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;
exports.bounceInOut = bounceInOut;
},{"./utils.mjs":"kfpK"}],"nYfs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertOffsetToTimes = convertOffsetToTimes;
exports.defaultEasing = defaultEasing;
exports.defaultOffset = defaultOffset;
exports.keyframes = keyframes;
var _interpolate = require("../../utils/interpolate.mjs");
var _index = require("../../easing/index.mjs");
function defaultEasing(values, easing) {
  return values.map(() => easing || _index.easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset, duration) {
  return offset.map(o => o * duration);
}
function keyframes({
  from = 0,
  to = 1,
  ease,
  offset,
  duration = 300
}) {
  const state = {
    done: false,
    value: from
  };
  const values = Array.isArray(to) ? to : [from, to];
  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);
  function createInterpolator() {
    return (0, _interpolate.interpolate)(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: t => {
      state.value = interpolator(t);
      state.done = t >= duration;
      return state;
    },
    flipTarget: () => {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}
},{"../../utils/interpolate.mjs":"JQaN","../../easing/index.mjs":"vHlW"}],"nW9I":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decay = decay;
function decay({
  velocity = 0,
  from = 0,
  power = 0.8,
  timeConstant = 350,
  restDelta = 0.5,
  modifyTarget
}) {
  const state = {
    done: false,
    value: from
  };
  let amplitude = power * velocity;
  const ideal = from + amplitude;
  const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);
  if (target !== ideal) amplitude = target - from;
  return {
    next: t => {
      const delta = -amplitude * Math.exp(-t / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: () => {}
  };
}
},{}],"gwym":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.detectAnimationFromOptions = detectAnimationFromOptions;
var _spring = require("../generators/spring.mjs");
var _keyframes = require("../generators/keyframes.mjs");
var _decay = require("../generators/decay.mjs");
const types = {
  keyframes: _keyframes.keyframes,
  spring: _spring.spring,
  decay: _decay.decay
};
function detectAnimationFromOptions(config) {
  if (Array.isArray(config.to)) {
    return _keyframes.keyframes;
  } else if (types[config.type]) {
    return types[config.type];
  }
  const keys = new Set(Object.keys(config));
  if (keys.has("ease") || keys.has("duration") && !keys.has("dampingRatio")) {
    return _keyframes.keyframes;
  } else if (keys.has("dampingRatio") || keys.has("stiffness") || keys.has("mass") || keys.has("damping") || keys.has("restSpeed") || keys.has("restDelta")) {
    return _spring.spring;
  }
  return _keyframes.keyframes;
}
},{"../generators/spring.mjs":"E8uF","../generators/keyframes.mjs":"nYfs","../generators/decay.mjs":"nW9I"}],"cjoO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onNextFrame = exports.defaultTimestep = void 0;
const defaultTimestep = 1 / 60 * 1000;
exports.defaultTimestep = defaultTimestep;
const getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
const onNextFrame = typeof window !== "undefined" ? callback => window.requestAnimationFrame(callback) : callback => setTimeout(() => callback(getCurrentTime()), defaultTimestep);
exports.onNextFrame = onNextFrame;
},{}],"jFyu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRenderStep = createRenderStep;
function createRenderStep(runNextFrame) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive) toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing) numToRun = toRun.length;
      }
      return callback;
    },
    cancel: callback => {
      const index = toRunNextFrame.indexOf(callback);
      if (index !== -1) toRunNextFrame.splice(index, 1);
      toKeepAlive.delete(callback);
    },
    process: frameData => {
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = toRun[i];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame();
          }
        }
      }
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}
},{}],"kJ8E":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFrameData = exports.flushSync = exports.default = exports.cancelSync = void 0;
var _onNextFrame = require("./on-next-frame.mjs");
var _createRenderStep = require("./create-render-step.mjs");
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
let isProcessing = false;
const frame = {
  delta: 0,
  timestamp: 0
};
const stepsOrder = ["read", "update", "preRender", "render", "postRender"];
const steps = stepsOrder.reduce((acc, key) => {
  acc[key] = (0, _createRenderStep.createRenderStep)(() => runNextFrame = true);
  return acc;
}, {});
const sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process, keepAlive = false, immediate = false) => {
    if (!runNextFrame) startLoop();
    return step.schedule(process, keepAlive, immediate);
  };
  return acc;
}, {});
const cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
exports.cancelSync = cancelSync;
const flushSync = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
exports.flushSync = flushSync;
const processStep = stepId => steps[stepId].process(frame);
const processFrame = timestamp => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? _onNextFrame.defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    (0, _onNextFrame.onNextFrame)(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing) (0, _onNextFrame.onNextFrame)(processFrame);
};
const getFrameData = () => frame;
exports.getFrameData = getFrameData;
var _default = sync;
exports.default = _default;
},{"./on-next-frame.mjs":"cjoO","./create-render-step.mjs":"jFyu","process":"pBGv"}],"AtmX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasRepeatDelayElapsed = hasRepeatDelayElapsed;
exports.loopElapsed = loopElapsed;
exports.reverseElapsed = reverseElapsed;
function loopElapsed(elapsed, duration, delay = 0) {
  return elapsed - duration - delay;
}
function reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;
}
function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
}
},{}],"wJQQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animate = animate;
var _tslib = require("tslib");
var _detectAnimationFromOptions = require("./utils/detect-animation-from-options.mjs");
var _framesync = _interopRequireWildcard(require("framesync"));
var _interpolate = require("../utils/interpolate.mjs");
var _elapsed = require("./utils/elapsed.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const framesync = update => {
  const passTimestamp = ({
    delta
  }) => update(delta);
  return {
    start: () => _framesync.default.update(passTimestamp, true),
    stop: () => _framesync.cancelSync.update(passTimestamp)
  };
};
function animate(_a) {
  var _b, _c;
  var {
      from,
      autoplay = true,
      driver = framesync,
      elapsed = 0,
      repeat: repeatMax = 0,
      repeatType = "loop",
      repeatDelay = 0,
      onPlay,
      onStop,
      onComplete,
      onRepeat,
      onUpdate
    } = _a,
    options = (0, _tslib.__rest)(_a, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let {
    to
  } = options;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = options.duration;
  let latest;
  let isComplete = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = (0, _detectAnimationFromOptions.detectAnimationFromOptions)(options);
  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {
    interpolateFromNumber = (0, _interpolate.interpolate)([0, 100], [from, to], {
      clamp: false
    });
    from = 0;
    to = 100;
  }
  const animation = animator(Object.assign(Object.assign({}, options), {
    from,
    to
  }));
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = (0, _elapsed.reverseElapsed)(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = (0, _elapsed.loopElapsed)(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror") animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta) {
    if (!isForwardPlayback) delta = -delta;
    elapsed += delta;
    if (!isComplete) {
      const state = animation.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber) latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0) computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        (0, _elapsed.hasRepeatDelayElapsed)(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}
},{"tslib":"vCxL","./utils/detect-animation-from-options.mjs":"gwym","framesync":"kJ8E","../utils/interpolate.mjs":"JQaN","./utils/elapsed.mjs":"AtmX"}],"ulKM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.velocityPerSecond = velocityPerSecond;
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1000 / frameDuration) : 0;
}
},{}],"nepV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inertia = inertia;
var _index = require("./index.mjs");
var _velocityPerSecond = require("../utils/velocity-per-second.mjs");
var _framesync = require("framesync");
function inertia({
  from = 0,
  velocity = 0,
  min,
  max,
  power = 0.8,
  timeConstant = 750,
  bounceStiffness = 500,
  bounceDamping = 10,
  restDelta = 1,
  modifyTarget,
  driver,
  onUpdate,
  onComplete,
  onStop
}) {
  let currentAnimation;
  function isOutOfBounds(v) {
    return min !== undefined && v < min || max !== undefined && v > max;
  }
  function boundaryNearest(v) {
    if (min === undefined) return max;
    if (max === undefined) return min;
    return Math.abs(min - v) < Math.abs(max - v) ? min : max;
  }
  function startAnimation(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = (0, _index.animate)(Object.assign(Object.assign({}, options), {
      driver,
      onUpdate: v => {
        var _a;
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);
        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);
      },
      onComplete,
      onStop
    }));
  }
  function startSpring(options) {
    startAnimation(Object.assign({
      type: "spring",
      stiffness: bounceStiffness,
      damping: bounceDamping,
      restDelta
    }, options));
  }
  if (isOutOfBounds(from)) {
    startSpring({
      from,
      velocity,
      to: boundaryNearest(from)
    });
  } else {
    let target = power * velocity + from;
    if (typeof modifyTarget !== "undefined") target = modifyTarget(target);
    const boundary = boundaryNearest(target);
    const heading = boundary === min ? -1 : 1;
    let prev;
    let current;
    const checkBoundary = v => {
      prev = current;
      current = v;
      velocity = (0, _velocityPerSecond.velocityPerSecond)(v - prev, (0, _framesync.getFrameData)().delta);
      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {
        startSpring({
          from: v,
          to: boundary,
          velocity
        });
      }
    };
    startAnimation({
      type: "decay",
      from,
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : undefined
    });
  }
  return {
    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()
  };
}
},{"./index.mjs":"wJQQ","../utils/velocity-per-second.mjs":"ulKM","framesync":"kJ8E"}],"qk5m":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.radiansToDegrees = void 0;
const radiansToDegrees = radians => radians * 180 / Math.PI;
exports.radiansToDegrees = radiansToDegrees;
},{}],"RhoB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.angle = void 0;
var _radiansToDegrees = require("./radians-to-degrees.mjs");
var _inc = require("./inc.mjs");
const angle = (a, b = _inc.zeroPoint) => (0, _radiansToDegrees.radiansToDegrees)(Math.atan2(b.y - a.y, b.x - a.x));
exports.angle = angle;
},{"./radians-to-degrees.mjs":"qk5m","./inc.mjs":"WSIw"}],"NPC6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyOffset = void 0;
const applyOffset = (from, to) => {
  let hasReceivedFrom = true;
  if (to === undefined) {
    to = from;
    hasReceivedFrom = false;
  }
  return v => {
    if (hasReceivedFrom) {
      return v - from + to;
    } else {
      from = v;
      hasReceivedFrom = true;
      return to;
    }
  };
};
exports.applyOffset = applyOffset;
},{}],"jgp1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAttractor = exports.attractExpo = exports.attract = void 0;
const identity = v => v;
const createAttractor = (alterDisplacement = identity) => (constant, origin, v) => {
  const displacement = origin - v;
  const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));
  return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;
};
exports.createAttractor = createAttractor;
const attract = createAttractor();
exports.attract = attract;
const attractExpo = createAttractor(Math.sqrt);
exports.attractExpo = attractExpo;
},{}],"Wx1i":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.degreesToRadians = void 0;
const degreesToRadians = degrees => degrees * Math.PI / 180;
exports.degreesToRadians = degreesToRadians;
},{}],"eik2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPoint = void 0;
const isPoint = point => point.hasOwnProperty('x') && point.hasOwnProperty('y');
exports.isPoint = isPoint;
},{}],"d6IY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPoint3D = void 0;
var _isPoint = require("./is-point.mjs");
const isPoint3D = point => (0, _isPoint.isPoint)(point) && point.hasOwnProperty('z');
exports.isPoint3D = isPoint3D;
},{"./is-point.mjs":"eik2"}],"v8Qi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distance = distance;
var _isPoint = require("./is-point.mjs");
var _isPoint3d = require("./is-point-3d.mjs");
var _inc = require("./inc.mjs");
const distance1D = (a, b) => Math.abs(a - b);
function distance(a, b) {
  if ((0, _inc.isNum)(a) && (0, _inc.isNum)(b)) {
    return distance1D(a, b);
  } else if ((0, _isPoint.isPoint)(a) && (0, _isPoint.isPoint)(b)) {
    const xDelta = distance1D(a.x, b.x);
    const yDelta = distance1D(a.y, b.y);
    const zDelta = (0, _isPoint3d.isPoint3D)(a) && (0, _isPoint3d.isPoint3D)(b) ? distance1D(a.z, b.z) : 0;
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
}
},{"./is-point.mjs":"eik2","./is-point-3d.mjs":"d6IY","./inc.mjs":"WSIw"}],"i43y":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pointFromVector = void 0;
var _degreesToRadians = require("./degrees-to-radians.mjs");
const pointFromVector = (origin, angle, distance) => {
  angle = (0, _degreesToRadians.degreesToRadians)(angle);
  return {
    x: distance * Math.cos(angle) + origin.x,
    y: distance * Math.sin(angle) + origin.y
  };
};
exports.pointFromVector = pointFromVector;
},{"./degrees-to-radians.mjs":"Wx1i"}],"PLEY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toDecimal = void 0;
const toDecimal = (num, precision = 2) => {
  precision = Math.pow(10, precision);
  return Math.round(num * precision) / precision;
};
exports.toDecimal = toDecimal;
},{}],"KzCo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.smoothFrame = void 0;
var _toDecimal = require("./to-decimal.mjs");
const smoothFrame = (prevValue, nextValue, duration, smoothing = 0) => (0, _toDecimal.toDecimal)(prevValue + duration * (nextValue - prevValue) / Math.max(smoothing, duration));
exports.smoothFrame = smoothFrame;
},{"./to-decimal.mjs":"PLEY"}],"Smkq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.smooth = void 0;
var _smoothFrame = require("./smooth-frame.mjs");
var _framesync = require("framesync");
const smooth = (strength = 50) => {
  let previousValue = 0;
  let lastUpdated = 0;
  return v => {
    const currentFramestamp = (0, _framesync.getFrameData)().timestamp;
    const timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;
    const newValue = timeDelta ? (0, _smoothFrame.smoothFrame)(previousValue, v, timeDelta, strength) : previousValue;
    lastUpdated = currentFramestamp;
    previousValue = newValue;
    return newValue;
  };
};
exports.smooth = smooth;
},{"./smooth-frame.mjs":"KzCo","framesync":"kJ8E"}],"IBd1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.snap = void 0;
const snap = points => {
  if (typeof points === 'number') {
    return v => Math.round(v / points) * points;
  } else {
    let i = 0;
    const numPoints = points.length;
    return v => {
      let lastDistance = Math.abs(points[0] - v);
      for (i = 1; i < numPoints; i++) {
        const point = points[i];
        const distance = Math.abs(point - v);
        if (distance === 0) return point;
        if (distance > lastDistance) return points[i - 1];
        if (i === numPoints - 1) return point;
        lastDistance = distance;
      }
    };
  }
};
exports.snap = snap;
},{}],"XiAF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.velocityPerFrame = velocityPerFrame;
function velocityPerFrame(xps, frameDuration) {
  return xps / (1000 / frameDuration);
}
},{}],"QkXe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrap = void 0;
const wrap = (min, max, v) => {
  const rangeSize = max - min;
  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
};
exports.wrap = wrap;
},{}],"Qftj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cubicBezier = cubicBezier;
var _index = require("./index.mjs");
const a = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;
const b = (a1, a2) => 3.0 * a2 - 6.0 * a1;
const c = a1 => 3.0 * a1;
const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
const getSlope = (t, a1, a2) => 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);
const subdivisionPrecision = 0.0000001;
const subdivisionMaxIterations = 10;
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
const newtonIterations = 8;
const newtonMinSlope = 0.001;
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (let i = 0; i < newtonIterations; ++i) {
    const currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0.0) {
      return aGuessT;
    }
    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
const kSplineTableSize = 11;
const kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2) return _index.linear;
  const sampleValues = new Float32Array(kSplineTableSize);
  for (let i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    let intervalStart = 0.0;
    let currentSample = 1;
    const lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    const guessForT = intervalStart + dist * kSampleStepSize;
    const initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= newtonMinSlope) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}
},{"./index.mjs":"vHlW"}],"vQPB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.steps = void 0;
var _clamp = require("../utils/clamp.mjs");
const steps = (steps, direction = 'end') => progress => {
  progress = direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);
  const expanded = progress * steps;
  const rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);
  return (0, _clamp.clamp)(0, 1, rounded / steps);
};
exports.steps = steps;
},{"../utils/clamp.mjs":"xkQy"}],"KhgA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "angle", {
  enumerable: true,
  get: function () {
    return _angle.angle;
  }
});
Object.defineProperty(exports, "animate", {
  enumerable: true,
  get: function () {
    return _index.animate;
  }
});
Object.defineProperty(exports, "anticipate", {
  enumerable: true,
  get: function () {
    return _index2.anticipate;
  }
});
Object.defineProperty(exports, "applyOffset", {
  enumerable: true,
  get: function () {
    return _applyOffset.applyOffset;
  }
});
Object.defineProperty(exports, "attract", {
  enumerable: true,
  get: function () {
    return _attract.attract;
  }
});
Object.defineProperty(exports, "attractExpo", {
  enumerable: true,
  get: function () {
    return _attract.attractExpo;
  }
});
Object.defineProperty(exports, "backIn", {
  enumerable: true,
  get: function () {
    return _index2.backIn;
  }
});
Object.defineProperty(exports, "backInOut", {
  enumerable: true,
  get: function () {
    return _index2.backInOut;
  }
});
Object.defineProperty(exports, "backOut", {
  enumerable: true,
  get: function () {
    return _index2.backOut;
  }
});
Object.defineProperty(exports, "bounceIn", {
  enumerable: true,
  get: function () {
    return _index2.bounceIn;
  }
});
Object.defineProperty(exports, "bounceInOut", {
  enumerable: true,
  get: function () {
    return _index2.bounceInOut;
  }
});
Object.defineProperty(exports, "bounceOut", {
  enumerable: true,
  get: function () {
    return _index2.bounceOut;
  }
});
Object.defineProperty(exports, "circIn", {
  enumerable: true,
  get: function () {
    return _index2.circIn;
  }
});
Object.defineProperty(exports, "circInOut", {
  enumerable: true,
  get: function () {
    return _index2.circInOut;
  }
});
Object.defineProperty(exports, "circOut", {
  enumerable: true,
  get: function () {
    return _index2.circOut;
  }
});
Object.defineProperty(exports, "clamp", {
  enumerable: true,
  get: function () {
    return _clamp.clamp;
  }
});
Object.defineProperty(exports, "createAnticipate", {
  enumerable: true,
  get: function () {
    return _utils.createAnticipate;
  }
});
Object.defineProperty(exports, "createAttractor", {
  enumerable: true,
  get: function () {
    return _attract.createAttractor;
  }
});
Object.defineProperty(exports, "createBackIn", {
  enumerable: true,
  get: function () {
    return _utils.createBackIn;
  }
});
Object.defineProperty(exports, "createExpoIn", {
  enumerable: true,
  get: function () {
    return _utils.createExpoIn;
  }
});
Object.defineProperty(exports, "cubicBezier", {
  enumerable: true,
  get: function () {
    return _cubicBezier.cubicBezier;
  }
});
Object.defineProperty(exports, "decay", {
  enumerable: true,
  get: function () {
    return _decay.decay;
  }
});
Object.defineProperty(exports, "degreesToRadians", {
  enumerable: true,
  get: function () {
    return _degreesToRadians.degreesToRadians;
  }
});
Object.defineProperty(exports, "distance", {
  enumerable: true,
  get: function () {
    return _distance.distance;
  }
});
Object.defineProperty(exports, "easeIn", {
  enumerable: true,
  get: function () {
    return _index2.easeIn;
  }
});
Object.defineProperty(exports, "easeInOut", {
  enumerable: true,
  get: function () {
    return _index2.easeInOut;
  }
});
Object.defineProperty(exports, "easeOut", {
  enumerable: true,
  get: function () {
    return _index2.easeOut;
  }
});
Object.defineProperty(exports, "inertia", {
  enumerable: true,
  get: function () {
    return _inertia.inertia;
  }
});
Object.defineProperty(exports, "interpolate", {
  enumerable: true,
  get: function () {
    return _interpolate.interpolate;
  }
});
Object.defineProperty(exports, "isPoint", {
  enumerable: true,
  get: function () {
    return _isPoint.isPoint;
  }
});
Object.defineProperty(exports, "isPoint3D", {
  enumerable: true,
  get: function () {
    return _isPoint3d.isPoint3D;
  }
});
Object.defineProperty(exports, "keyframes", {
  enumerable: true,
  get: function () {
    return _keyframes.keyframes;
  }
});
Object.defineProperty(exports, "linear", {
  enumerable: true,
  get: function () {
    return _index2.linear;
  }
});
Object.defineProperty(exports, "mirrorEasing", {
  enumerable: true,
  get: function () {
    return _utils.mirrorEasing;
  }
});
Object.defineProperty(exports, "mix", {
  enumerable: true,
  get: function () {
    return _mix.mix;
  }
});
Object.defineProperty(exports, "mixColor", {
  enumerable: true,
  get: function () {
    return _mixColor.mixColor;
  }
});
Object.defineProperty(exports, "mixComplex", {
  enumerable: true,
  get: function () {
    return _mixComplex.mixComplex;
  }
});
Object.defineProperty(exports, "pipe", {
  enumerable: true,
  get: function () {
    return _pipe.pipe;
  }
});
Object.defineProperty(exports, "pointFromVector", {
  enumerable: true,
  get: function () {
    return _pointFromVector.pointFromVector;
  }
});
Object.defineProperty(exports, "progress", {
  enumerable: true,
  get: function () {
    return _progress.progress;
  }
});
Object.defineProperty(exports, "radiansToDegrees", {
  enumerable: true,
  get: function () {
    return _radiansToDegrees.radiansToDegrees;
  }
});
Object.defineProperty(exports, "reverseEasing", {
  enumerable: true,
  get: function () {
    return _utils.reverseEasing;
  }
});
Object.defineProperty(exports, "smooth", {
  enumerable: true,
  get: function () {
    return _smooth.smooth;
  }
});
Object.defineProperty(exports, "smoothFrame", {
  enumerable: true,
  get: function () {
    return _smoothFrame.smoothFrame;
  }
});
Object.defineProperty(exports, "snap", {
  enumerable: true,
  get: function () {
    return _snap.snap;
  }
});
Object.defineProperty(exports, "spring", {
  enumerable: true,
  get: function () {
    return _spring.spring;
  }
});
Object.defineProperty(exports, "steps", {
  enumerable: true,
  get: function () {
    return _steps.steps;
  }
});
Object.defineProperty(exports, "toDecimal", {
  enumerable: true,
  get: function () {
    return _toDecimal.toDecimal;
  }
});
Object.defineProperty(exports, "velocityPerFrame", {
  enumerable: true,
  get: function () {
    return _velocityPerFrame.velocityPerFrame;
  }
});
Object.defineProperty(exports, "velocityPerSecond", {
  enumerable: true,
  get: function () {
    return _velocityPerSecond.velocityPerSecond;
  }
});
Object.defineProperty(exports, "wrap", {
  enumerable: true,
  get: function () {
    return _wrap.wrap;
  }
});
var _index = require("./animations/index.mjs");
var _inertia = require("./animations/inertia.mjs");
var _decay = require("./animations/generators/decay.mjs");
var _spring = require("./animations/generators/spring.mjs");
var _keyframes = require("./animations/generators/keyframes.mjs");
var _angle = require("./utils/angle.mjs");
var _applyOffset = require("./utils/apply-offset.mjs");
var _attract = require("./utils/attract.mjs");
var _clamp = require("./utils/clamp.mjs");
var _degreesToRadians = require("./utils/degrees-to-radians.mjs");
var _distance = require("./utils/distance.mjs");
var _interpolate = require("./utils/interpolate.mjs");
var _isPoint3d = require("./utils/is-point-3d.mjs");
var _isPoint = require("./utils/is-point.mjs");
var _mixColor = require("./utils/mix-color.mjs");
var _mixComplex = require("./utils/mix-complex.mjs");
var _mix = require("./utils/mix.mjs");
var _pipe = require("./utils/pipe.mjs");
var _pointFromVector = require("./utils/point-from-vector.mjs");
var _progress = require("./utils/progress.mjs");
var _radiansToDegrees = require("./utils/radians-to-degrees.mjs");
var _smoothFrame = require("./utils/smooth-frame.mjs");
var _smooth = require("./utils/smooth.mjs");
var _snap = require("./utils/snap.mjs");
var _toDecimal = require("./utils/to-decimal.mjs");
var _velocityPerFrame = require("./utils/velocity-per-frame.mjs");
var _velocityPerSecond = require("./utils/velocity-per-second.mjs");
var _wrap = require("./utils/wrap.mjs");
var _index2 = require("./easing/index.mjs");
var _cubicBezier = require("./easing/cubic-bezier.mjs");
var _steps = require("./easing/steps.mjs");
var _utils = require("./easing/utils.mjs");
},{"./animations/index.mjs":"wJQQ","./animations/inertia.mjs":"nepV","./animations/generators/decay.mjs":"nW9I","./animations/generators/spring.mjs":"E8uF","./animations/generators/keyframes.mjs":"nYfs","./utils/angle.mjs":"RhoB","./utils/apply-offset.mjs":"NPC6","./utils/attract.mjs":"jgp1","./utils/clamp.mjs":"xkQy","./utils/degrees-to-radians.mjs":"Wx1i","./utils/distance.mjs":"v8Qi","./utils/interpolate.mjs":"JQaN","./utils/is-point-3d.mjs":"d6IY","./utils/is-point.mjs":"eik2","./utils/mix-color.mjs":"aNsl","./utils/mix-complex.mjs":"Fv0c","./utils/mix.mjs":"RcO4","./utils/pipe.mjs":"OVns","./utils/point-from-vector.mjs":"i43y","./utils/progress.mjs":"MEzP","./utils/radians-to-degrees.mjs":"qk5m","./utils/smooth-frame.mjs":"KzCo","./utils/smooth.mjs":"Smkq","./utils/snap.mjs":"IBd1","./utils/to-decimal.mjs":"PLEY","./utils/velocity-per-frame.mjs":"XiAF","./utils/velocity-per-second.mjs":"ulKM","./utils/wrap.mjs":"QkXe","./easing/index.mjs":"vHlW","./easing/cubic-bezier.mjs":"Qftj","./easing/steps.mjs":"vQPB","./easing/utils.mjs":"kfpK"}],"BPLI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTapGesture = useTapGesture;
var _react = require("react");
var _isNodeOrChild = require("./utils/is-node-or-child.mjs");
var _usePointerEvent = require("../events/use-pointer-event.mjs");
var _useUnmountEffect = require("../utils/use-unmount-effect.mjs");
var _popmotion = require("popmotion");
var _types = require("../render/utils/types.mjs");
var _lock = require("./drag/utils/lock.mjs");
/**
 * @param handlers -
 * @internal
 */
function useTapGesture(_a) {
  var onTap = _a.onTap,
    onTapStart = _a.onTapStart,
    onTapCancel = _a.onTapCancel,
    whileTap = _a.whileTap,
    visualElement = _a.visualElement;
  var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
  var isPressing = (0, _react.useRef)(false);
  var cancelPointerEndListeners = (0, _react.useRef)(null);
  /**
   * Only set listener to passive if there are no external listeners.
   */
  var eventOptions = {
    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)
  };
  function removePointerEndListener() {
    var _a;
    (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);
    cancelPointerEndListeners.current = null;
  }
  function checkPointerEnd() {
    var _a;
    removePointerEndListener();
    isPressing.current = false;
    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(_types.AnimationType.Tap, false);
    return !(0, _lock.isDragActive)();
  }
  function onPointerUp(event, info) {
    if (!checkPointerEnd()) return;
    /**
     * We only count this as a tap gesture if the event.target is the same
     * as, or a child of, this component's element
     */
    !(0, _isNodeOrChild.isNodeOrChild)(visualElement.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);
  }
  function onPointerCancel(event, info) {
    if (!checkPointerEnd()) return;
    onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);
  }
  function onPointerDown(event, info) {
    var _a;
    removePointerEndListener();
    if (isPressing.current) return;
    isPressing.current = true;
    cancelPointerEndListeners.current = (0, _popmotion.pipe)((0, _usePointerEvent.addPointerEvent)(window, "pointerup", onPointerUp, eventOptions), (0, _usePointerEvent.addPointerEvent)(window, "pointercancel", onPointerCancel, eventOptions));
    /**
     * Ensure we trigger animations before firing event callback
     */
    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(_types.AnimationType.Tap, true);
    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);
  }
  (0, _usePointerEvent.usePointerEvent)(visualElement, "pointerdown", hasPressListeners ? onPointerDown : undefined, eventOptions);
  (0, _useUnmountEffect.useUnmountEffect)(removePointerEndListener);
}
},{"react":"n8MK","./utils/is-node-or-child.mjs":"fhsg","../events/use-pointer-event.mjs":"tW3y","../utils/use-unmount-effect.mjs":"Iby2","popmotion":"KhgA","../render/utils/types.mjs":"gO5D","./drag/utils/lock.mjs":"UvuD"}],"ZTHf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warnOnce = warnOnce;
var warned = new Set();
function warnOnce(condition, message, element) {
  if (condition || warned.has(message)) return;
  console.warn(message);
  if (element) console.warn(element);
  warned.add(message);
}
},{}],"RfSX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observeIntersection = observeIntersection;
var _tslib = require("tslib");
/**
 * Map an IntersectionHandler callback to an element. We only ever make one handler for one
 * element, so even though these handlers might all be triggered by different
 * observers, we can keep them in the same map.
 */
var observerCallbacks = new WeakMap();
/**
 * Multiple observers can be created for multiple element/document roots. Each with
 * different settings. So here we store dictionaries of observers to each root,
 * using serialised settings (threshold/margin) as lookup keys.
 */
var observers = new WeakMap();
var fireObserverCallback = function (entry) {
  var _a;
  (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);
};
var fireAllObserverCallbacks = function (entries) {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver(_a) {
  var root = _a.root,
    options = (0, _tslib.__rest)(_a, ["root"]);
  var lookupRoot = root || document;
  /**
   * If we don't have an observer lookup map for this root, create one.
   */
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  var rootObservers = observers.get(lookupRoot);
  var key = JSON.stringify(options);
  /**
   * If we don't have an observer for this combination of root and settings,
   * create one.
   */
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, (0, _tslib.__assign)({
      root: root
    }, options));
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  var rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return function () {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
},{"tslib":"vCxL"}],"OaT0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useViewport = useViewport;
var _process = require("../../../utils/process.mjs");
var _react = require("react");
var _types = require("../../../render/utils/types.mjs");
var _warnOnce = require("../../../utils/warn-once.mjs");
var _observers = require("./observers.mjs");
function useViewport(_a) {
  var visualElement = _a.visualElement,
    whileInView = _a.whileInView,
    onViewportEnter = _a.onViewportEnter,
    onViewportLeave = _a.onViewportLeave,
    _b = _a.viewport,
    viewport = _b === void 0 ? {} : _b;
  var state = (0, _react.useRef)({
    hasEnteredView: false,
    isInView: false
  });
  var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);
  if (viewport.once && state.current.hasEnteredView) shouldObserve = false;
  var useObserver = typeof IntersectionObserver === "undefined" ? useMissingIntersectionObserver : useIntersectionObserver;
  useObserver(shouldObserve, state.current, visualElement, viewport);
}
var thresholdNames = {
  some: 0,
  all: 1
};
function useIntersectionObserver(shouldObserve, state, visualElement, _a) {
  var root = _a.root,
    rootMargin = _a.margin,
    _b = _a.amount,
    amount = _b === void 0 ? "some" : _b,
    once = _a.once;
  (0, _react.useEffect)(function () {
    if (!shouldObserve) return;
    var options = {
      root: root === null || root === void 0 ? void 0 : root.current,
      rootMargin: rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    var intersectionCallback = function (entry) {
      var _a;
      var isIntersecting = entry.isIntersecting;
      /**
       * If there's been no change in the viewport state, early return.
       */
      if (state.isInView === isIntersecting) return;
      state.isInView = isIntersecting;
      /**
       * Handle hasEnteredView. If this is only meant to run once, and
       * element isn't visible, early return. Otherwise set hasEnteredView to true.
       */
      if (once && !isIntersecting && state.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        state.hasEnteredView = true;
      }
      (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(_types.AnimationType.InView, isIntersecting);
      /**
       * Use the latest committed props rather than the ones in scope
       * when this observer is created
       */
      var props = visualElement.getProps();
      var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;
      callback === null || callback === void 0 ? void 0 : callback(entry);
    };
    return (0, _observers.observeIntersection)(visualElement.getInstance(), options, intersectionCallback);
  }, [shouldObserve, root, rootMargin, amount]);
}
/**
 * If IntersectionObserver is missing, we activate inView and fire onViewportEnter
 * on mount. This way, the page will be in the state the author expects users
 * to see it in for everyone.
 */
function useMissingIntersectionObserver(shouldObserve, state, visualElement, _a) {
  var _b = _a.fallback,
    fallback = _b === void 0 ? true : _b;
  (0, _react.useEffect)(function () {
    if (!shouldObserve || !fallback) return;
    if (_process.env !== "production") {
      (0, _warnOnce.warnOnce)(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount.");
    }
    /**
     * Fire this in an rAF because, at this point, the animation state
     * won't have flushed for the first time and there's certain logic in
     * there that behaves differently on the initial animation.
     *
     * This hook should be quite rarely called so setting this in an rAF
     * is preferred to changing the behaviour of the animation state.
     */
    requestAnimationFrame(function () {
      var _a;
      state.hasEnteredView = true;
      var onViewportEnter = visualElement.getProps().onViewportEnter;
      onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);
      (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(_types.AnimationType.InView, true);
    });
  }, [shouldObserve]);
}
},{"../../../utils/process.mjs":"A4AW","react":"n8MK","../../../render/utils/types.mjs":"gO5D","../../../utils/warn-once.mjs":"ZTHf","./observers.mjs":"RfSX"}],"Usef":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeRenderlessComponent = void 0;
var makeRenderlessComponent = function (hook) {
  return function (props) {
    hook(props);
    return null;
  };
};
exports.makeRenderlessComponent = makeRenderlessComponent;
},{}],"MzEU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gestureAnimations = void 0;
var _useFocusGesture = require("../../gestures/use-focus-gesture.mjs");
var _useHoverGesture = require("../../gestures/use-hover-gesture.mjs");
var _useTapGesture = require("../../gestures/use-tap-gesture.mjs");
var _useViewport = require("./viewport/use-viewport.mjs");
var _makeRenderlessComponent = require("../utils/make-renderless-component.mjs");
var gestureAnimations = {
  inView: (0, _makeRenderlessComponent.makeRenderlessComponent)(_useViewport.useViewport),
  tap: (0, _makeRenderlessComponent.makeRenderlessComponent)(_useTapGesture.useTapGesture),
  focus: (0, _makeRenderlessComponent.makeRenderlessComponent)(_useFocusGesture.useFocusGesture),
  hover: (0, _makeRenderlessComponent.makeRenderlessComponent)(_useHoverGesture.useHoverGesture)
};
exports.gestureAnimations = gestureAnimations;
},{"../../gestures/use-focus-gesture.mjs":"gdMN","../../gestures/use-hover-gesture.mjs":"yZTN","../../gestures/use-tap-gesture.mjs":"BPLI","./viewport/use-viewport.mjs":"OaT0","../utils/make-renderless-component.mjs":"Usef"}],"IO6W":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useId = void 0;
var _useConstant = require("./use-constant.mjs");
var counter = 0;
var incrementId = function () {
  return counter++;
};
var useId = function () {
  return (0, _useConstant.useConstant)(incrementId);
};
/**
 * Ideally we'd use the following code to support React 18 optionally.
 * But this fairly fails in Webpack (otherwise treeshaking wouldn't work at all).
 * Need to come up with a different way of figuring this out.
 */
// export const useId = (React as any).useId
//     ? (React as any).useId
//     : () => useConstant(incrementId)
exports.useId = useId;
},{"./use-constant.mjs":"XPaj"}],"oIU2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPresent = isPresent;
exports.useIsPresent = useIsPresent;
exports.usePresence = usePresence;
var _react = require("react");
var _PresenceContext = require("../../context/PresenceContext.mjs");
var _useId = require("../../utils/use-id.mjs");
/**
 * When a component is the child of `AnimatePresence`, it can use `usePresence`
 * to access information about whether it's still present in the React tree.
 *
 * ```jsx
 * import { usePresence } from "framer-motion"
 *
 * export const Component = () => {
 *   const [isPresent, safeToRemove] = usePresence()
 *
 *   useEffect(() => {
 *     !isPresent && setTimeout(safeToRemove, 1000)
 *   }, [isPresent])
 *
 *   return <div />
 * }
 * ```
 *
 * If `isPresent` is `false`, it means that a component has been removed the tree, but
 * `AnimatePresence` won't really remove it until `safeToRemove` has been called.
 *
 * @public
 */
function usePresence() {
  var context = (0, _react.useContext)(_PresenceContext.PresenceContext);
  if (context === null) return [true, null];
  var isPresent = context.isPresent,
    onExitComplete = context.onExitComplete,
    register = context.register;
  // It's safe to call the following hooks conditionally (after an early return) because the context will always
  // either be null or non-null for the lifespan of the component.
  // Replace with useId when released in React
  var id = (0, _useId.useId)();
  (0, _react.useEffect)(function () {
    return register(id);
  }, []);
  var safeToRemove = function () {
    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);
  };
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
/**
 * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.
 * There is no `safeToRemove` function.
 *
 * ```jsx
 * import { useIsPresent } from "framer-motion"
 *
 * export const Component = () => {
 *   const isPresent = useIsPresent()
 *
 *   useEffect(() => {
 *     !isPresent && console.log("I've been removed!")
 *   }, [isPresent])
 *
 *   return <div />
 * }
 * ```
 *
 * @public
 */
function useIsPresent() {
  return isPresent((0, _react.useContext)(_PresenceContext.PresenceContext));
}
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
},{"react":"n8MK","../../context/PresenceContext.mjs":"eYxR","../../utils/use-id.mjs":"IO6W"}],"nBzG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shallowCompare = shallowCompare;
function shallowCompare(next, prev) {
  if (!Array.isArray(prev)) return false;
  var prevLength = prev.length;
  if (prevLength !== next.length) return false;
  for (var i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i]) return false;
  }
  return true;
}
},{}],"tXn1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.secondsToMilliseconds = void 0;
/**
 * Converts seconds to milliseconds
 *
 * @param seconds - Time in seconds.
 * @return milliseconds - Converted time in milliseconds.
 */
var secondsToMilliseconds = function (seconds) {
  return seconds * 1000;
};
exports.secondsToMilliseconds = secondsToMilliseconds;
},{}],"vlKP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEasingArray = exports.easingDefinitionToFunction = void 0;
var _tslib = require("tslib");
var _heyListen = require("hey-listen");
var _popmotion = require("popmotion");
var easingLookup = {
  linear: _popmotion.linear,
  easeIn: _popmotion.easeIn,
  easeInOut: _popmotion.easeInOut,
  easeOut: _popmotion.easeOut,
  circIn: _popmotion.circIn,
  circInOut: _popmotion.circInOut,
  circOut: _popmotion.circOut,
  backIn: _popmotion.backIn,
  backInOut: _popmotion.backInOut,
  backOut: _popmotion.backOut,
  anticipate: _popmotion.anticipate,
  bounceIn: _popmotion.bounceIn,
  bounceInOut: _popmotion.bounceInOut,
  bounceOut: _popmotion.bounceOut
};
var easingDefinitionToFunction = function (definition) {
  if (Array.isArray(definition)) {
    // If cubic bezier definition, create bezier curve
    (0, _heyListen.invariant)(definition.length === 4, "Cubic bezier arrays must contain four numerical values.");
    var _a = (0, _tslib.__read)(definition, 4),
      x1 = _a[0],
      y1 = _a[1],
      x2 = _a[2],
      y2 = _a[3];
    return (0, _popmotion.cubicBezier)(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    // Else lookup from table
    (0, _heyListen.invariant)(easingLookup[definition] !== undefined, "Invalid easing type '".concat(definition, "'"));
    return easingLookup[definition];
  }
  return definition;
};
exports.easingDefinitionToFunction = easingDefinitionToFunction;
var isEasingArray = function (ease) {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};
exports.isEasingArray = isEasingArray;
},{"tslib":"vCxL","hey-listen":"KFGT","popmotion":"KhgA"}],"D182":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAnimatable = void 0;
var _styleValueTypes = require("style-value-types");
/**
 * Check if a value is animatable. Examples:
 *
 * ✅: 100, "100px", "#fff"
 * ❌: "block", "url(2.jpg)"
 * @param value
 *
 * @internal
 */
var isAnimatable = function (key, value) {
  // If the list of keys tat might be non-animatable grows, replace with Set
  if (key === "zIndex") return false;
  // If it's a number or a keyframes array, we can animate it. We might at some point
  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,
  // but for now lets leave it like this for performance reasons
  if (typeof value === "number" || Array.isArray(value)) return true;
  if (typeof value === "string" &&
  // It's animatable if we have a string
  _styleValueTypes.complex.test(value) &&
  // And it contains numbers and/or colors
  !value.startsWith("url(") // Unless it starts with "url("
  ) {
    return true;
  }
  return false;
};
exports.isAnimatable = isAnimatable;
},{"style-value-types":"vstm"}],"hLfG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.underDampedSpring = exports.linearTween = exports.getDefaultTransition = exports.criticallyDampedSpring = void 0;
var _tslib = require("tslib");
var _isKeyframesTarget = require("./is-keyframes-target.mjs");
var underDampedSpring = function () {
  return {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
};
exports.underDampedSpring = underDampedSpring;
var criticallyDampedSpring = function (to) {
  return {
    type: "spring",
    stiffness: 550,
    damping: to === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  };
};
exports.criticallyDampedSpring = criticallyDampedSpring;
var linearTween = function () {
  return {
    type: "keyframes",
    ease: "linear",
    duration: 0.3
  };
};
exports.linearTween = linearTween;
var keyframes = function (values) {
  return {
    type: "keyframes",
    duration: 0.8,
    values: values
  };
};
var defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
var getDefaultTransition = function (valueKey, to) {
  var transitionFactory;
  if ((0, _isKeyframesTarget.isKeyframesTarget)(to)) {
    transitionFactory = keyframes;
  } else {
    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
  }
  return (0, _tslib.__assign)({
    to: to
  }, transitionFactory(to));
};
exports.getDefaultTransition = getDefaultTransition;
},{"tslib":"vCxL","./is-keyframes-target.mjs":"lbx8"}],"CLPu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultValueType = exports.defaultValueTypes = void 0;
var _tslib = require("tslib");
var _styleValueTypes = require("style-value-types");
var _number = require("./number.mjs");
/**
 * A map of default value types for common values
 */
var defaultValueTypes = (0, _tslib.__assign)((0, _tslib.__assign)({}, _number.numberValueTypes), {
  // Color props
  color: _styleValueTypes.color,
  backgroundColor: _styleValueTypes.color,
  outlineColor: _styleValueTypes.color,
  fill: _styleValueTypes.color,
  stroke: _styleValueTypes.color,
  // Border props
  borderColor: _styleValueTypes.color,
  borderTopColor: _styleValueTypes.color,
  borderRightColor: _styleValueTypes.color,
  borderBottomColor: _styleValueTypes.color,
  borderLeftColor: _styleValueTypes.color,
  filter: _styleValueTypes.filter,
  WebkitFilter: _styleValueTypes.filter
});
/**
 * Gets the default ValueType for the provided value key
 */
exports.defaultValueTypes = defaultValueTypes;
var getDefaultValueType = function (key) {
  return defaultValueTypes[key];
};
exports.getDefaultValueType = getDefaultValueType;
},{"tslib":"vCxL","style-value-types":"vstm","./number.mjs":"hAFG"}],"sYhL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAnimatableNone = getAnimatableNone;
var _styleValueTypes = require("style-value-types");
var _defaults = require("./defaults.mjs");
function getAnimatableNone(key, value) {
  var _a;
  var defaultValueType = (0, _defaults.getDefaultValueType)(key);
  if (defaultValueType !== _styleValueTypes.filter) defaultValueType = _styleValueTypes.complex;
  // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target
  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);
}
},{"style-value-types":"vstm","./defaults.mjs":"CLPu"}],"JWTJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.instantAnimationState = void 0;
var instantAnimationState = {
  current: false
};
exports.instantAnimationState = instantAnimationState;
},{}],"K5UX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertTransitionToAnimationOptions = convertTransitionToAnimationOptions;
exports.getDelayFromTransition = getDelayFromTransition;
exports.getPopmotionAnimationOptions = getPopmotionAnimationOptions;
exports.getValueTransition = getValueTransition;
exports.getZeroUnit = getZeroUnit;
exports.hydrateKeyframes = hydrateKeyframes;
exports.isTransitionDefined = isTransitionDefined;
exports.isZero = isZero;
exports.startAnimation = startAnimation;
var _tslib = require("tslib");
var _popmotion = require("popmotion");
var _timeConversion = require("../../utils/time-conversion.mjs");
var _easing = require("./easing.mjs");
var _isAnimatable = require("./is-animatable.mjs");
var _defaultTransitions = require("./default-transitions.mjs");
var _heyListen = require("hey-listen");
var _animatableNone = require("../../render/dom/value-types/animatable-none.mjs");
var _useInstantTransitionState = require("../../utils/use-instant-transition-state.mjs");
var _resolveValue = require("../../utils/resolve-value.mjs");
/**
 * Decide whether a transition is defined on a given Transition.
 * This filters out orchestration options and returns true
 * if any options are left.
 */
function isTransitionDefined(_a) {
  _a.when;
  _a.delay;
  _a.delayChildren;
  _a.staggerChildren;
  _a.staggerDirection;
  _a.repeat;
  _a.repeatType;
  _a.repeatDelay;
  _a.from;
  var transition = (0, _tslib.__rest)(_a, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);
  return !!Object.keys(transition).length;
}
var legacyRepeatWarning = false;
/**
 * Convert Framer Motion's Transition type into Popmotion-compatible options.
 */
function convertTransitionToAnimationOptions(_a) {
  var ease = _a.ease,
    times = _a.times,
    yoyo = _a.yoyo,
    flip = _a.flip,
    loop = _a.loop,
    transition = (0, _tslib.__rest)(_a, ["ease", "times", "yoyo", "flip", "loop"]);
  var options = (0, _tslib.__assign)({}, transition);
  if (times) options["offset"] = times;
  /**
   * Convert any existing durations from seconds to milliseconds
   */
  if (transition.duration) options["duration"] = (0, _timeConversion.secondsToMilliseconds)(transition.duration);
  if (transition.repeatDelay) options.repeatDelay = (0, _timeConversion.secondsToMilliseconds)(transition.repeatDelay);
  /**
   * Map easing names to Popmotion's easing functions
   */
  if (ease) {
    options["ease"] = (0, _easing.isEasingArray)(ease) ? ease.map(_easing.easingDefinitionToFunction) : (0, _easing.easingDefinitionToFunction)(ease);
  }
  /**
   * Support legacy transition API
   */
  if (transition.type === "tween") options.type = "keyframes";
  /**
   * TODO: These options are officially removed from the API.
   */
  if (yoyo || loop || flip) {
    (0, _heyListen.warning)(!legacyRepeatWarning, "yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.");
    legacyRepeatWarning = true;
    if (yoyo) {
      options.repeatType = "reverse";
    } else if (loop) {
      options.repeatType = "loop";
    } else if (flip) {
      options.repeatType = "mirror";
    }
    options.repeat = loop || yoyo || flip || transition.repeat;
  }
  /**
   * TODO: Popmotion 9 has the ability to automatically detect whether to use
   * a keyframes or spring animation, but does so by detecting velocity and other spring options.
   * It'd be good to introduce a similar thing here.
   */
  if (transition.type !== "spring") options.type = "keyframes";
  return options;
}
/**
 * Get the delay for a value by checking Transition with decreasing specificity.
 */
function getDelayFromTransition(transition, key) {
  var _a, _b;
  var valueTransition = getValueTransition(transition, key) || {};
  return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;
}
function hydrateKeyframes(options) {
  if (Array.isArray(options.to) && options.to[0] === null) {
    options.to = (0, _tslib.__spreadArray)([], (0, _tslib.__read)(options.to), false);
    options.to[0] = options.from;
  }
  return options;
}
function getPopmotionAnimationOptions(transition, options, key) {
  var _a;
  if (Array.isArray(options.to)) {
    (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;
  }
  hydrateKeyframes(options);
  /**
   * Get a default transition if none is determined to be defined.
   */
  if (!isTransitionDefined(transition)) {
    transition = (0, _tslib.__assign)((0, _tslib.__assign)({}, transition), (0, _defaultTransitions.getDefaultTransition)(key, options.to));
  }
  return (0, _tslib.__assign)((0, _tslib.__assign)({}, options), convertTransitionToAnimationOptions(transition));
}
/**
 *
 */
function getAnimation(key, value, target, transition, onComplete) {
  var _a;
  var valueTransition = getValueTransition(transition, key);
  var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();
  var isTargetAnimatable = (0, _isAnimatable.isAnimatable)(key, target);
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    /**
     * If we're trying to animate from "none", try and get an animatable version
     * of the target. This could be improved to work both ways.
     */
    origin = (0, _animatableNone.getAnimatableNone)(key, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  var isOriginAnimatable = (0, _isAnimatable.isAnimatable)(key, origin);
  (0, _heyListen.warning)(isOriginAnimatable === isTargetAnimatable, "You are trying to animate ".concat(key, " from \"").concat(origin, "\" to \"").concat(target, "\". ").concat(origin, " is not an animatable value - to enable this animation set ").concat(origin, " to a value animatable to ").concat(target, " via the `style` property."));
  function start() {
    var options = {
      from: origin,
      to: target,
      velocity: value.getVelocity(),
      onComplete: onComplete,
      onUpdate: function (v) {
        return value.set(v);
      }
    };
    return valueTransition.type === "inertia" || valueTransition.type === "decay" ? (0, _popmotion.inertia)((0, _tslib.__assign)((0, _tslib.__assign)({}, options), valueTransition)) : (0, _popmotion.animate)((0, _tslib.__assign)((0, _tslib.__assign)({}, getPopmotionAnimationOptions(valueTransition, options, key)), {
      onUpdate: function (v) {
        var _a;
        options.onUpdate(v);
        (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);
      },
      onComplete: function () {
        var _a;
        options.onComplete();
        (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);
      }
    }));
  }
  function set() {
    var _a, _b;
    var finalTarget = (0, _resolveValue.resolveFinalValueInKeyframes)(target);
    value.set(finalTarget);
    onComplete();
    (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, finalTarget);
    (_b = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _b === void 0 ? void 0 : _b.call(valueTransition);
    return {
      stop: function () {}
    };
  }
  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : (0, _animatableNone.getAnimatableNone)("", potentialUnitType);
}
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}
/**
 * Start animation on a MotionValue. This function is an interface between
 * Framer Motion and Popmotion
 */
function startAnimation(key, value, target, transition) {
  if (transition === void 0) {
    transition = {};
  }
  if (_useInstantTransitionState.instantAnimationState.current) {
    transition = {
      type: false
    };
  }
  return value.start(function (onComplete) {
    var delayTimer;
    var controls;
    var animation = getAnimation(key, value, target, transition, onComplete);
    var delay = getDelayFromTransition(transition, key);
    var start = function () {
      return controls = animation();
    };
    if (delay) {
      delayTimer = window.setTimeout(start, (0, _timeConversion.secondsToMilliseconds)(delay));
    } else {
      start();
    }
    return function () {
      clearTimeout(delayTimer);
      controls === null || controls === void 0 ? void 0 : controls.stop();
    };
  });
}
},{"tslib":"vCxL","popmotion":"KhgA","../../utils/time-conversion.mjs":"tXn1","./easing.mjs":"vlKP","./is-animatable.mjs":"D182","./default-transitions.mjs":"hLfG","hey-listen":"KFGT","../../render/dom/value-types/animatable-none.mjs":"sYhL","../../utils/use-instant-transition-state.mjs":"JWTJ","../../utils/resolve-value.mjs":"NhIh"}],"LnSY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNumericalString = void 0;
/**
 * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
 */
var isNumericalString = function (v) {
  return /^\-?\d*\.?\d+$/.test(v);
};
exports.isNumericalString = isNumericalString;
},{}],"cc84":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isZeroValueString = void 0;
/**
 * Check if the value is a zero value string like "0px" or "0%"
 */
var isZeroValueString = function (v) {
  return /^0[^.\s]+$/.test(v);
};
exports.isZeroValueString = isZeroValueString;
},{}],"KvxD":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFrameData = exports.flushSync = exports.default = exports.cancelSync = void 0;
var _onNextFrame = require("./on-next-frame.mjs");
var _createRenderStep = require("./create-render-step.mjs");
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
let isProcessing = false;
const frame = {
  delta: 0,
  timestamp: 0
};
const stepsOrder = ["read", "update", "preRender", "render", "postRender"];
const steps = stepsOrder.reduce((acc, key) => {
  acc[key] = (0, _createRenderStep.createRenderStep)(() => runNextFrame = true);
  return acc;
}, {});
const sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process, keepAlive = false, immediate = false) => {
    if (!runNextFrame) startLoop();
    return step.schedule(process, keepAlive, immediate);
  };
  return acc;
}, {});
const cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
exports.cancelSync = cancelSync;
const flushSync = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
exports.flushSync = flushSync;
const processStep = stepId => steps[stepId].process(frame);
const processFrame = timestamp => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? _onNextFrame.defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    (0, _onNextFrame.onNextFrame)(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing) (0, _onNextFrame.onNextFrame)(processFrame);
};
const getFrameData = () => frame;
exports.getFrameData = getFrameData;
var _default = sync;
exports.default = _default;
},{"./on-next-frame.mjs":"cjoO","./create-render-step.mjs":"jFyu","process":"pBGv"}],"la1d":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addUniqueItem = addUniqueItem;
exports.moveItem = moveItem;
exports.removeItem = removeItem;
var _tslib = require("tslib");
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  var index = arr.indexOf(item);
  index > -1 && arr.splice(index, 1);
}
// Adapted from array-move
function moveItem(_a, fromIndex, toIndex) {
  var _b = (0, _tslib.__read)(_a),
    arr = _b.slice(0);
  var startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
  if (startIndex >= 0 && startIndex < arr.length) {
    var endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
    var _c = (0, _tslib.__read)(arr.splice(fromIndex, 1), 1),
      item = _c[0];
    arr.splice(endIndex, 0, item);
  }
  return arr;
}
},{"tslib":"vCxL"}],"eMeP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubscriptionManager = void 0;
var _array = require("./array.mjs");
var SubscriptionManager = /** @class */function () {
  function SubscriptionManager() {
    this.subscriptions = [];
  }
  SubscriptionManager.prototype.add = function (handler) {
    var _this = this;
    (0, _array.addUniqueItem)(this.subscriptions, handler);
    return function () {
      return (0, _array.removeItem)(_this.subscriptions, handler);
    };
  };
  SubscriptionManager.prototype.notify = function (a, b, c) {
    var numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions) return;
    if (numSubscriptions === 1) {
      /**
       * If there's only a single handler we can just call it without invoking a loop.
       */
      this.subscriptions[0](a, b, c);
    } else {
      for (var i = 0; i < numSubscriptions; i++) {
        /**
         * Check whether the handler exists before firing as it's possible
         * the subscriptions were modified during this loop running.
         */
        var handler = this.subscriptions[i];
        handler && handler(a, b, c);
      }
    }
  };
  SubscriptionManager.prototype.getSize = function () {
    return this.subscriptions.length;
  };
  SubscriptionManager.prototype.clear = function () {
    this.subscriptions.length = 0;
  };
  return SubscriptionManager;
}();
exports.SubscriptionManager = SubscriptionManager;
},{"./array.mjs":"la1d"}],"PQTd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MotionValue = void 0;
exports.motionValue = motionValue;
var _framesync = _interopRequireWildcard(require("framesync"));
var _popmotion = require("popmotion");
var _subscriptionManager = require("../utils/subscription-manager.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var isFloat = function (value) {
  return !isNaN(parseFloat(value));
};
/**
 * `MotionValue` is used to track the state and velocity of motion values.
 *
 * @public
 */
var MotionValue = /** @class */function () {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  function MotionValue(init) {
    var _this = this;
    /**
     * This will be replaced by the build step with the latest version number.
     * When MotionValues are provided to motion components, warn if versions are mixed.
     */
    this.version = "6.5.1";
    /**
     * Duration, in milliseconds, since last updating frame.
     *
     * @internal
     */
    this.timeDelta = 0;
    /**
     * Timestamp of the last time this `MotionValue` was updated.
     *
     * @internal
     */
    this.lastUpdated = 0;
    /**
     * Functions to notify when the `MotionValue` updates.
     *
     * @internal
     */
    this.updateSubscribers = new _subscriptionManager.SubscriptionManager();
    /**
     * Functions to notify when the velocity updates.
     *
     * @internal
     */
    this.velocityUpdateSubscribers = new _subscriptionManager.SubscriptionManager();
    /**
     * Functions to notify when the `MotionValue` updates and `render` is set to `true`.
     *
     * @internal
     */
    this.renderSubscribers = new _subscriptionManager.SubscriptionManager();
    /**
     * Tracks whether this value can output a velocity. Currently this is only true
     * if the value is numerical, but we might be able to widen the scope here and support
     * other value types.
     *
     * @internal
     */
    this.canTrackVelocity = false;
    this.updateAndNotify = function (v, render) {
      if (render === void 0) {
        render = true;
      }
      _this.prev = _this.current;
      _this.current = v;
      // Update timestamp
      var _a = (0, _framesync.getFrameData)(),
        delta = _a.delta,
        timestamp = _a.timestamp;
      if (_this.lastUpdated !== timestamp) {
        _this.timeDelta = delta;
        _this.lastUpdated = timestamp;
        _framesync.default.postRender(_this.scheduleVelocityCheck);
      }
      // Update update subscribers
      if (_this.prev !== _this.current) {
        _this.updateSubscribers.notify(_this.current);
      }
      // Update velocity subscribers
      if (_this.velocityUpdateSubscribers.getSize()) {
        _this.velocityUpdateSubscribers.notify(_this.getVelocity());
      }
      // Update render subscribers
      if (render) {
        _this.renderSubscribers.notify(_this.current);
      }
    };
    /**
     * Schedule a velocity check for the next frame.
     *
     * This is an instanced and bound function to prevent generating a new
     * function once per frame.
     *
     * @internal
     */
    this.scheduleVelocityCheck = function () {
      return _framesync.default.postRender(_this.velocityCheck);
    };
    /**
     * Updates `prev` with `current` if the value hasn't been updated this frame.
     * This ensures velocity calculations return `0`.
     *
     * This is an instanced and bound function to prevent generating a new
     * function once per frame.
     *
     * @internal
     */
    this.velocityCheck = function (_a) {
      var timestamp = _a.timestamp;
      if (timestamp !== _this.lastUpdated) {
        _this.prev = _this.current;
        _this.velocityUpdateSubscribers.notify(_this.getVelocity());
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init;
    this.canTrackVelocity = isFloat(this.current);
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.onChange(updateOpacity)
   *     const unsubscribeY = y.onChange(updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @privateRemarks
   *
   * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.
   *
   * ```jsx
   * useOnChange(x, () => {})
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @public
   */
  MotionValue.prototype.onChange = function (subscription) {
    return this.updateSubscribers.add(subscription);
  };
  MotionValue.prototype.clearListeners = function () {
    this.updateSubscribers.clear();
  };
  /**
   * Adds a function that will be notified when the `MotionValue` requests a render.
   *
   * @param subscriber - A function that's provided the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @internal
   */
  MotionValue.prototype.onRenderRequest = function (subscription) {
    // Render immediately
    subscription(this.get());
    return this.renderSubscribers.add(subscription);
  };
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  MotionValue.prototype.attach = function (passiveEffect) {
    this.passiveEffect = passiveEffect;
  };
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  MotionValue.prototype.set = function (v, render) {
    if (render === void 0) {
      render = true;
    }
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v, render);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  };
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  MotionValue.prototype.get = function () {
    return this.current;
  };
  /**
   * @public
   */
  MotionValue.prototype.getPrevious = function () {
    return this.prev;
  };
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  MotionValue.prototype.getVelocity = function () {
    // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful
    return this.canTrackVelocity ?
    // These casts could be avoided if parseFloat would be typed better
    (0, _popmotion.velocityPerSecond)(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
  };
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  MotionValue.prototype.start = function (animation) {
    var _this = this;
    this.stop();
    return new Promise(function (resolve) {
      _this.hasAnimated = true;
      _this.stopAnimation = animation(resolve);
    }).then(function () {
      return _this.clearAnimation();
    });
  };
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  MotionValue.prototype.stop = function () {
    if (this.stopAnimation) this.stopAnimation();
    this.clearAnimation();
  };
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  MotionValue.prototype.isAnimating = function () {
    return !!this.stopAnimation;
  };
  MotionValue.prototype.clearAnimation = function () {
    this.stopAnimation = null;
  };
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  MotionValue.prototype.destroy = function () {
    this.updateSubscribers.clear();
    this.renderSubscribers.clear();
    this.stop();
  };
  return MotionValue;
}();
exports.MotionValue = MotionValue;
function motionValue(init) {
  return new MotionValue(init);
}
},{"framesync":"KvxD","popmotion":"KhgA","../utils/subscription-manager.mjs":"eMeP"}],"D7b7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testValueType = void 0;
/**
 * Tests a provided value against a ValueType
 */
var testValueType = function (v) {
  return function (type) {
    return type.test(v);
  };
};
exports.testValueType = testValueType;
},{}],"Gwcl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.auto = void 0;
/**
 * ValueType for "auto"
 */
var auto = {
  test: function (v) {
    return v === "auto";
  },
  parse: function (v) {
    return v;
  }
};
exports.auto = auto;
},{}],"uOQL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findDimensionValueType = exports.dimensionValueTypes = void 0;
var _styleValueTypes = require("style-value-types");
var _test = require("./test.mjs");
var _typeAuto = require("./type-auto.mjs");
/**
 * A list of value types commonly used for dimensions
 */
var dimensionValueTypes = [_styleValueTypes.number, _styleValueTypes.px, _styleValueTypes.percent, _styleValueTypes.degrees, _styleValueTypes.vw, _styleValueTypes.vh, _typeAuto.auto];
/**
 * Tests a dimensional value against the list of dimension ValueTypes
 */
exports.dimensionValueTypes = dimensionValueTypes;
var findDimensionValueType = function (v) {
  return dimensionValueTypes.find((0, _test.testValueType)(v));
};
exports.findDimensionValueType = findDimensionValueType;
},{"style-value-types":"vstm","./test.mjs":"D7b7","./type-auto.mjs":"Gwcl"}],"AT73":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findValueType = void 0;
var _tslib = require("tslib");
var _styleValueTypes = require("style-value-types");
var _dimensions = require("./dimensions.mjs");
var _test = require("./test.mjs");
/**
 * A list of all ValueTypes
 */
var valueTypes = (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], (0, _tslib.__read)(_dimensions.dimensionValueTypes), false), [_styleValueTypes.color, _styleValueTypes.complex], false);
/**
 * Tests a value against the list of ValueTypes
 */
var findValueType = function (v) {
  return valueTypes.find((0, _test.testValueType)(v));
};
exports.findValueType = findValueType;
},{"tslib":"vCxL","style-value-types":"vstm","./dimensions.mjs":"uOQL","./test.mjs":"D7b7"}],"QDUS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkTargetForNewValues = checkTargetForNewValues;
exports.getOrigin = getOrigin;
exports.getOriginFromTransition = getOriginFromTransition;
exports.setTarget = setTarget;
exports.setValues = setValues;
var _tslib = require("tslib");
var _styleValueTypes = require("style-value-types");
var _isNumericalString = require("../../utils/is-numerical-string.mjs");
var _isZeroValueString = require("../../utils/is-zero-value-string.mjs");
var _resolveValue = require("../../utils/resolve-value.mjs");
var _index = require("../../value/index.mjs");
var _animatableNone = require("../dom/value-types/animatable-none.mjs");
var _find = require("../dom/value-types/find.mjs");
var _variants = require("./variants.mjs");
/**
 * Set VisualElement's MotionValue, creating a new MotionValue for it if
 * it doesn't exist.
 */
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, (0, _index.motionValue)(value));
  }
}
function setTarget(visualElement, definition) {
  var resolved = (0, _variants.resolveVariant)(visualElement, definition);
  var _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {},
    _b = _a.transitionEnd,
    transitionEnd = _b === void 0 ? {} : _b;
  _a.transition;
  var target = (0, _tslib.__rest)(_a, ["transitionEnd", "transition"]);
  target = (0, _tslib.__assign)((0, _tslib.__assign)({}, target), transitionEnd);
  for (var key in target) {
    var value = (0, _resolveValue.resolveFinalValueInKeyframes)(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
function setVariants(visualElement, variantLabels) {
  var reversedLabels = (0, _tslib.__spreadArray)([], (0, _tslib.__read)(variantLabels), false).reverse();
  reversedLabels.forEach(function (key) {
    var _a;
    var variant = visualElement.getVariant(key);
    variant && setTarget(visualElement, variant);
    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {
      setVariants(child, variantLabels);
    });
  });
}
function setValues(visualElement, definition) {
  if (Array.isArray(definition)) {
    return setVariants(visualElement, definition);
  } else if (typeof definition === "string") {
    return setVariants(visualElement, [definition]);
  } else {
    setTarget(visualElement, definition);
  }
}
function checkTargetForNewValues(visualElement, target, origin) {
  var _a, _b, _c;
  var _d;
  var newValueKeys = Object.keys(target).filter(function (key) {
    return !visualElement.hasValue(key);
  });
  var numNewValues = newValueKeys.length;
  if (!numNewValues) return;
  for (var i = 0; i < numNewValues; i++) {
    var key = newValueKeys[i];
    var targetValue = target[key];
    var value = null;
    /**
     * If the target is a series of keyframes, we can use the first value
     * in the array. If this first value is null, we'll still need to read from the DOM.
     */
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    /**
     * If the target isn't keyframes, or the first keyframe was null, we need to
     * first check if an origin value was explicitly defined in the transition as "from",
     * if not read the value from the DOM. As an absolute fallback, take the defined target value.
     */
    if (value === null) {
      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    /**
     * If value is still undefined or null, ignore it. Preferably this would throw,
     * but this was causing issues in Framer.
     */
    if (value === undefined || value === null) continue;
    if (typeof value === "string" && ((0, _isNumericalString.isNumericalString)(value) || (0, _isZeroValueString.isZeroValueString)(value))) {
      // If this is a number read as a string, ie "0" or "200", convert it to a number
      value = parseFloat(value);
    } else if (!(0, _find.findValueType)(value) && _styleValueTypes.complex.test(targetValue)) {
      value = (0, _animatableNone.getAnimatableNone)(key, targetValue);
    }
    visualElement.addValue(key, (0, _index.motionValue)(value));
    (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;
    visualElement.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition) {
  if (!transition) return;
  var valueTransition = transition[key] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement) {
  var _a, _b;
  var origin = {};
  for (var key in target) {
    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();
  }
  return origin;
}
},{"tslib":"vCxL","style-value-types":"vstm","../../utils/is-numerical-string.mjs":"LnSY","../../utils/is-zero-value-string.mjs":"cc84","../../utils/resolve-value.mjs":"NhIh","../../value/index.mjs":"PQTd","../dom/value-types/animatable-none.mjs":"sYhL","../dom/value-types/find.mjs":"AT73","./variants.mjs":"B4V7"}],"rHY3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animateVisualElement = animateVisualElement;
exports.sortByTreeOrder = sortByTreeOrder;
exports.stopAnimation = stopAnimation;
var _tslib = require("tslib");
var _transitions = require("../../animation/utils/transitions.mjs");
var _setters = require("./setters.mjs");
var _variants = require("./variants.mjs");
var _transform = require("../html/utils/transform.mjs");
function animateVisualElement(visualElement, definition, options) {
  if (options === void 0) {
    options = {};
  }
  visualElement.notifyAnimationStart(definition);
  var animation;
  if (Array.isArray(definition)) {
    var animations = definition.map(function (variant) {
      return animateVariant(visualElement, variant, options);
    });
    animation = Promise.all(animations);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    var resolvedDefinition = typeof definition === "function" ? (0, _variants.resolveVariant)(visualElement, definition, options.custom) : definition;
    animation = animateTarget(visualElement, resolvedDefinition, options);
  }
  return animation.then(function () {
    return visualElement.notifyAnimationComplete(definition);
  });
}
function animateVariant(visualElement, variant, options) {
  var _a;
  if (options === void 0) {
    options = {};
  }
  var resolved = (0, _variants.resolveVariant)(visualElement, variant, options.custom);
  var _b = (resolved || {}).transition,
    transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  /**
   * If we have a variant, create a callback that runs it as an animation.
   * Otherwise, we resolve a Promise immediately for a composable no-op.
   */
  var getAnimation = resolved ? function () {
    return animateTarget(visualElement, resolved, options);
  } : function () {
    return Promise.resolve();
  };
  /**
   * If we have children, create a callback that runs all their animations.
   * Otherwise, we resolve a Promise immediately for a composable no-op.
   */
  var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function (forwardDelay) {
    if (forwardDelay === void 0) {
      forwardDelay = 0;
    }
    var _a = transition.delayChildren,
      delayChildren = _a === void 0 ? 0 : _a,
      staggerChildren = transition.staggerChildren,
      staggerDirection = transition.staggerDirection;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : function () {
    return Promise.resolve();
  };
  /**
   * If the transition explicitly defines a "when" option, we need to resolve either
   * this animation or all children animations before playing the other.
   */
  var when = transition.when;
  if (when) {
    var _c = (0, _tslib.__read)(when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation], 2),
      first = _c[0],
      last = _c[1];
    return first().then(last);
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
/**
 * @internal
 */
function animateTarget(visualElement, definition, _a) {
  var _b;
  var _c = _a === void 0 ? {} : _a,
    _d = _c.delay,
    delay = _d === void 0 ? 0 : _d,
    transitionOverride = _c.transitionOverride,
    type = _c.type;
  var _e = visualElement.makeTargetAnimatable(definition),
    _f = _e.transition,
    transition = _f === void 0 ? visualElement.getDefaultTransition() : _f,
    transitionEnd = _e.transitionEnd,
    target = (0, _tslib.__rest)(_e, ["transition", "transitionEnd"]);
  if (transitionOverride) transition = transitionOverride;
  var animations = [];
  var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);
  for (var key in target) {
    var value = visualElement.getValue(key);
    var valueTarget = target[key];
    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    var valueTransition = (0, _tslib.__assign)({
      delay: delay
    }, transition);
    /**
     * Make animation instant if this is a transform prop and we should reduce motion.
     */
    if (visualElement.shouldReduceMotion && (0, _transform.isTransformProp)(key)) {
      valueTransition = (0, _tslib.__assign)((0, _tslib.__assign)({}, valueTransition), {
        type: false,
        delay: 0
      });
    }
    var animation = (0, _transitions.startAnimation)(key, value, valueTarget, valueTransition);
    animations.push(animation);
  }
  return Promise.all(animations).then(function () {
    transitionEnd && (0, _setters.setTarget)(visualElement, transitionEnd);
  });
}
function animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {
  if (delayChildren === void 0) {
    delayChildren = 0;
  }
  if (staggerChildren === void 0) {
    staggerChildren = 0;
  }
  if (staggerDirection === void 0) {
    staggerDirection = 1;
  }
  var animations = [];
  var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  var generateStaggerDuration = staggerDirection === 1 ? function (i) {
    if (i === void 0) {
      i = 0;
    }
    return i * staggerChildren;
  } : function (i) {
    if (i === void 0) {
      i = 0;
    }
    return maxStaggerDuration - i * staggerChildren;
  };
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {
    animations.push(animateVariant(child, variant, (0, _tslib.__assign)((0, _tslib.__assign)({}, options), {
      delay: delayChildren + generateStaggerDuration(i)
    })).then(function () {
      return child.notifyAnimationComplete(variant);
    }));
  });
  return Promise.all(animations);
}
function stopAnimation(visualElement) {
  visualElement.forEachValue(function (value) {
    return value.stop();
  });
}
function sortByTreeOrder(a, b) {
  return a.sortNodePosition(b);
}
/**
 * Decide whether we should block this animation. Previously, we achieved this
 * just by checking whether the key was listed in protectedKeys, but this
 * posed problems if an animation was triggered by afterChildren and protectedKeys
 * had been set to true in the meantime.
 */
function shouldBlockAnimation(_a, key) {
  var protectedKeys = _a.protectedKeys,
    needsAnimating = _a.needsAnimating;
  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
},{"tslib":"vCxL","../../animation/utils/transitions.mjs":"K5UX","./setters.mjs":"QDUS","./variants.mjs":"B4V7","../html/utils/transform.mjs":"qPCc"}],"ci7C":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkVariantsDidChange = checkVariantsDidChange;
exports.createAnimationState = createAnimationState;
exports.variantPriorityOrder = void 0;
var _tslib = require("tslib");
var _isAnimationControls = require("../../animation/utils/is-animation-controls.mjs");
var _isKeyframesTarget = require("../../animation/utils/is-keyframes-target.mjs");
var _shallowCompare = require("../../utils/shallow-compare.mjs");
var _animation = require("./animation.mjs");
var _types = require("./types.mjs");
var _variants = require("./variants.mjs");
var variantPriorityOrder = [_types.AnimationType.Animate, _types.AnimationType.InView, _types.AnimationType.Focus, _types.AnimationType.Hover, _types.AnimationType.Tap, _types.AnimationType.Drag, _types.AnimationType.Exit];
exports.variantPriorityOrder = variantPriorityOrder;
var reversePriorityOrder = (0, _tslib.__spreadArray)([], (0, _tslib.__read)(variantPriorityOrder), false).reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return function (animations) {
    return Promise.all(animations.map(function (_a) {
      var animation = _a.animation,
        options = _a.options;
      return (0, _animation.animateVisualElement)(visualElement, animation, options);
    }));
  };
}
function createAnimationState(visualElement) {
  var animate = animateList(visualElement);
  var state = createState();
  var allAnimatedKeys = {};
  var isInitialRender = true;
  /**
   * This function will be used to reduce the animation definitions for
   * each active animation type into an object of resolved values for it.
   */
  var buildResolvedTypeValues = function (acc, definition) {
    var resolved = (0, _variants.resolveVariant)(visualElement, definition);
    if (resolved) {
      resolved.transition;
      var transitionEnd = resolved.transitionEnd,
        target = (0, _tslib.__rest)(resolved, ["transition", "transitionEnd"]);
      acc = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, acc), target), transitionEnd);
    }
    return acc;
  };
  function isAnimated(key) {
    return allAnimatedKeys[key] !== undefined;
  }
  /**
   * This just allows us to inject mocked animation functions
   * @internal
   */
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  /**
   * When we receive new props, we need to:
   * 1. Create a list of protected keys for each type. This is a directory of
   *    value keys that are currently being "handled" by types of a higher priority
   *    so that whenever an animation is played of a given type, these values are
   *    protected from being animated.
   * 2. Determine if an animation type needs animating.
   * 3. Determine if any values have been removed from a type and figure out
   *    what to animate those to.
   */
  function animateChanges(options, changedActiveType) {
    var _a;
    var props = visualElement.getProps();
    var context = visualElement.getVariantContext(true) || {};
    /**
     * A list of animations that we'll build into as we iterate through the animation
     * types. This will get executed at the end of the function.
     */
    var animations = [];
    /**
     * Keep track of which values have been removed. Then, as we hit lower priority
     * animation types, we can check if they contain removed values and animate to that.
     */
    var removedKeys = new Set();
    /**
     * A dictionary of all encountered keys. This is an object to let us build into and
     * copy it without iteration. Each time we hit an animation type we set its protected
     * keys - the keys its not allowed to animate - to the latest version of this object.
     */
    var encounteredKeys = {};
    /**
     * If a variant has been removed at a given index, and this component is controlling
     * variant animations, we want to ensure lower-priority variants are forced to animate.
     */
    var removedVariantIndex = Infinity;
    var _loop_1 = function (i) {
      var type = reversePriorityOrder[i];
      var typeState = state[type];
      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];
      var propIsVariant = (0, _variants.isVariantLabel)(prop);
      /**
       * If this type has *just* changed isActive status, set activeDelta
       * to that status. Otherwise set to null.
       */
      var activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false) removedVariantIndex = i;
      /**
       * If this prop is an inherited variant, rather than been set directly on the
       * component itself, we want to make sure we allow the parent to trigger animations.
       *
       * TODO: Can probably change this to a !isControllingVariants check
       */
      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      /**
       *
       */
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      /**
       * Set all encountered keys so far as the protected keys for this type. This will
       * be any key that has been animated or otherwise handled by active, higher-priortiy types.
       */
      typeState.protectedKeys = (0, _tslib.__assign)({}, encounteredKeys);
      // Check if we can skip analysing this prop early
      if (
      // If it isn't active and hasn't *just* been set as inactive
      !typeState.isActive && activeDelta === null ||
      // If we didn't and don't have any defined prop for this animation type
      !prop && !typeState.prevProp ||
      // Or if the prop doesn't define an animation
      (0, _isAnimationControls.isAnimationControls)(prop) || typeof prop === "boolean") {
        return "continue";
      }
      /**
       * As we go look through the values defined on this type, if we detect
       * a changed value or a value that was removed in a higher priority, we set
       * this to true and add this prop to the animation list.
       */
      var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      var shouldAnimateType = variantDidChange ||
      // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant ||
      // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      /**
       * As animations can be set as variant lists, variants or target objects, we
       * coerce everything to an array if it isn't one already
       */
      var definitionList = Array.isArray(prop) ? prop : [prop];
      /**
       * Build an object of all the resolved values. We'll use this in the subsequent
       * animateChanges calls to determine whether a value has changed.
       */
      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false) resolvedValues = {};
      /**
       * Now we need to loop through all the keys in the prev prop and this prop,
       * and decide:
       * 1. If the value has changed, and needs animating
       * 2. If it has been removed, and needs adding to the removedKeys set
       * 3. If it has been removed in a higher priority type and needs animating
       * 4. If it hasn't been removed in a higher priority but hasn't changed, and
       *    needs adding to the type's protectedKeys list.
       */
      var _b = typeState.prevResolvedValues,
        prevResolvedValues = _b === void 0 ? {} : _b;
      var allKeys = (0, _tslib.__assign)((0, _tslib.__assign)({}, prevResolvedValues), resolvedValues);
      var markToAnimate = function (key) {
        shouldAnimateType = true;
        removedKeys.delete(key);
        typeState.needsAnimating[key] = true;
      };
      for (var key in allKeys) {
        var next = resolvedValues[key];
        var prev = prevResolvedValues[key];
        // If we've already handled this we can just skip ahead
        if (encounteredKeys.hasOwnProperty(key)) continue;
        /**
         * If the value has changed, we probably want to animate it.
         */
        if (next !== prev) {
          /**
           * If both values are keyframes, we need to shallow compare them to
           * detect whether any value has changed. If it has, we animate it.
           */
          if ((0, _isKeyframesTarget.isKeyframesTarget)(next) && (0, _isKeyframesTarget.isKeyframesTarget)(prev)) {
            if (!(0, _shallowCompare.shallowCompare)(next, prev) || variantDidChange) {
              markToAnimate(key);
            } else {
              /**
               * If it hasn't changed, we want to ensure it doesn't animate by
               * adding it to the list of protected keys.
               */
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== undefined) {
            // If next is defined and doesn't equal prev, it needs animating
            markToAnimate(key);
          } else {
            // If it's undefined, it's been removed.
            removedKeys.add(key);
          }
        } else if (next !== undefined && removedKeys.has(key)) {
          /**
           * If next hasn't changed and it isn't undefined, we want to check if it's
           * been removed by a higher priority
           */
          markToAnimate(key);
        } else {
          /**
           * If it hasn't changed, we add it to the list of protected values
           * to ensure it doesn't get animated.
           */
          typeState.protectedKeys[key] = true;
        }
      }
      /**
       * Update the typeState so next time animateChanges is called we can compare the
       * latest prop and resolvedValues to these.
       */
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      /**
       *
       */
      if (typeState.isActive) {
        encounteredKeys = (0, _tslib.__assign)((0, _tslib.__assign)({}, encounteredKeys), resolvedValues);
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      /**
       * If this is an inherited prop we want to hard-block animations
       * TODO: Test as this should probably still handle animations triggered
       * by removed values?
       */
      if (shouldAnimateType && !isInherited) {
        animations.push.apply(animations, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(definitionList.map(function (animation) {
          return {
            animation: animation,
            options: (0, _tslib.__assign)({
              type: type
            }, options)
          };
        })), false));
      }
    };
    /**
     * Iterate through all animation types in reverse priority order. For each, we want to
     * detect which values it's handling and whether or not they've changed (and therefore
     * need to be animated). If any values have been removed, we want to detect those in
     * lower priority props and flag for animation.
     */
    for (var i = 0; i < numAnimationTypes; i++) {
      _loop_1(i);
    }
    allAnimatedKeys = (0, _tslib.__assign)({}, encounteredKeys);
    /**
     * If there are some removed value that haven't been dealt with,
     * we need to create a new animation that falls back either to the value
     * defined in the style prop, or the last read value.
     */
    if (removedKeys.size) {
      var fallbackAnimation_1 = {};
      removedKeys.forEach(function (key) {
        var fallbackTarget = visualElement.getBaseTarget(key);
        if (fallbackTarget !== undefined) {
          fallbackAnimation_1[key] = fallbackTarget;
        }
      });
      animations.push({
        animation: fallbackAnimation_1
      });
    }
    var shouldAnimate = Boolean(animations.length);
    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations) : Promise.resolve();
  }
  /**
   * Change whether a certain animation type is active.
   */
  function setActive(type, isActive, options) {
    var _a;
    // If the active state hasn't changed, we can safely do nothing here
    if (state[type].isActive === isActive) return Promise.resolve();
    // Propagate active change to children
    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {
      var _a;
      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    var animations = animateChanges(options, type);
    for (var key in state) {
      state[key].protectedKeys = {};
    }
    return animations;
  }
  return {
    isAnimated: isAnimated,
    animateChanges: animateChanges,
    setActive: setActive,
    setAnimateFunction: setAnimateFunction,
    getState: function () {
      return state;
    }
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if ((0, _variants.isVariantLabels)(next)) {
    return !(0, _shallowCompare.shallowCompare)(next, prev);
  }
  return false;
}
function createTypeState(isActive) {
  if (isActive === void 0) {
    isActive = false;
  }
  return {
    isActive: isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  var _a;
  return _a = {}, _a[_types.AnimationType.Animate] = createTypeState(true), _a[_types.AnimationType.InView] = createTypeState(), _a[_types.AnimationType.Hover] = createTypeState(), _a[_types.AnimationType.Tap] = createTypeState(), _a[_types.AnimationType.Drag] = createTypeState(), _a[_types.AnimationType.Focus] = createTypeState(), _a[_types.AnimationType.Exit] = createTypeState(), _a;
}
},{"tslib":"vCxL","../../animation/utils/is-animation-controls.mjs":"bI9v","../../animation/utils/is-keyframes-target.mjs":"lbx8","../../utils/shallow-compare.mjs":"nBzG","./animation.mjs":"rHY3","./types.mjs":"gO5D","./variants.mjs":"B4V7"}],"V8nK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animations = void 0;
var _tslib = require("tslib");
var _react = require("react");
var _isAnimationControls = require("../../animation/utils/is-animation-controls.mjs");
var _usePresence = require("../../components/AnimatePresence/use-presence.mjs");
var _PresenceContext = require("../../context/PresenceContext.mjs");
var _animationState = require("../../render/utils/animation-state.mjs");
var _types = require("../../render/utils/types.mjs");
var _makeRenderlessComponent = require("../utils/make-renderless-component.mjs");
var animations = {
  animation: (0, _makeRenderlessComponent.makeRenderlessComponent)(function (_a) {
    var visualElement = _a.visualElement,
      animate = _a.animate;
    /**
     * We dynamically generate the AnimationState manager as it contains a reference
     * to the underlying animation library. We only want to load that if we load this,
     * so people can optionally code split it out using the `m` component.
     */
    visualElement.animationState || (visualElement.animationState = (0, _animationState.createAnimationState)(visualElement));
    /**
     * Subscribe any provided AnimationControls to the component's VisualElement
     */
    if ((0, _isAnimationControls.isAnimationControls)(animate)) {
      (0, _react.useEffect)(function () {
        return animate.subscribe(visualElement);
      }, [animate]);
    }
  }),
  exit: (0, _makeRenderlessComponent.makeRenderlessComponent)(function (props) {
    var custom = props.custom,
      visualElement = props.visualElement;
    var _a = (0, _tslib.__read)((0, _usePresence.usePresence)(), 2),
      isPresent = _a[0],
      safeToRemove = _a[1];
    var presenceContext = (0, _react.useContext)(_PresenceContext.PresenceContext);
    (0, _react.useEffect)(function () {
      var _a, _b;
      visualElement.isPresent = isPresent;
      var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(_types.AnimationType.Exit, !isPresent, {
        custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom
      });
      !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(safeToRemove));
    }, [isPresent]);
  })
};
exports.animations = animations;
},{"tslib":"vCxL","react":"n8MK","../../animation/utils/is-animation-controls.mjs":"bI9v","../../components/AnimatePresence/use-presence.mjs":"oIU2","../../context/PresenceContext.mjs":"eYxR","../../render/utils/animation-state.mjs":"ci7C","../../render/utils/types.mjs":"gO5D","../utils/make-renderless-component.mjs":"Usef"}],"VdEX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PanSession = void 0;
var _tslib = require("tslib");
var _eventType = require("./utils/event-type.mjs");
var _eventInfo = require("../events/event-info.mjs");
var _framesync = _interopRequireWildcard(require("framesync"));
var _timeConversion = require("../utils/time-conversion.mjs");
var _usePointerEvent = require("../events/use-pointer-event.mjs");
var _popmotion = require("popmotion");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @internal
 */
var PanSession = /** @class */function () {
  function PanSession(event, handlers, _a) {
    var _this = this;
    var _b = _a === void 0 ? {} : _a,
      transformPagePoint = _b.transformPagePoint;
    /**
     * @internal
     */
    this.startEvent = null;
    /**
     * @internal
     */
    this.lastMoveEvent = null;
    /**
     * @internal
     */
    this.lastMoveEventInfo = null;
    /**
     * @internal
     */
    this.handlers = {};
    this.updatePoint = function () {
      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;
      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);
      var isPanStarted = _this.startEvent !== null;
      // Only start panning if the offset is larger than 3 pixels. If we make it
      // any larger than this we'll want to reset the pointer history
      // on the first update to avoid visual snapping to the cursoe.
      var isDistancePastThreshold = (0, _popmotion.distance)(info.offset, {
        x: 0,
        y: 0
      }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold) return;
      var point = info.point;
      var timestamp = (0, _framesync.getFrameData)().timestamp;
      _this.history.push((0, _tslib.__assign)((0, _tslib.__assign)({}, point), {
        timestamp: timestamp
      }));
      var _a = _this.handlers,
        onStart = _a.onStart,
        onMove = _a.onMove;
      if (!isPanStarted) {
        onStart && onStart(_this.lastMoveEvent, info);
        _this.startEvent = _this.lastMoveEvent;
      }
      onMove && onMove(_this.lastMoveEvent, info);
    };
    this.handlePointerMove = function (event, info) {
      _this.lastMoveEvent = event;
      _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);
      // Because Safari doesn't trigger mouseup events when it's above a `<select>`
      if ((0, _eventType.isMouseEvent)(event) && event.buttons === 0) {
        _this.handlePointerUp(event, info);
        return;
      }
      // Throttle mouse move event to once per frame
      _framesync.default.update(_this.updatePoint, true);
    };
    this.handlePointerUp = function (event, info) {
      _this.end();
      var _a = _this.handlers,
        onEnd = _a.onEnd,
        onSessionEnd = _a.onSessionEnd;
      var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);
      if (_this.startEvent && onEnd) {
        onEnd(event, panInfo);
      }
      onSessionEnd && onSessionEnd(event, panInfo);
    };
    // If we have more than one touch, don't start detecting this gesture
    if ((0, _eventType.isTouchEvent)(event) && event.touches.length > 1) return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    var info = (0, _eventInfo.extractEventInfo)(event);
    var initialInfo = transformPoint(info, this.transformPagePoint);
    var point = initialInfo.point;
    var timestamp = (0, _framesync.getFrameData)().timestamp;
    this.history = [(0, _tslib.__assign)((0, _tslib.__assign)({}, point), {
      timestamp: timestamp
    })];
    var onSessionStart = handlers.onSessionStart;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = (0, _popmotion.pipe)((0, _usePointerEvent.addPointerEvent)(window, "pointermove", this.handlePointerMove), (0, _usePointerEvent.addPointerEvent)(window, "pointerup", this.handlePointerUp), (0, _usePointerEvent.addPointerEvent)(window, "pointercancel", this.handlePointerUp));
  }
  PanSession.prototype.updateHandlers = function (handlers) {
    this.handlers = handlers;
  };
  PanSession.prototype.end = function () {
    this.removeListeners && this.removeListeners();
    _framesync.cancelSync.update(this.updatePoint);
  };
  return PanSession;
}();
exports.PanSession = PanSession;
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? {
    point: transformPagePoint(info.point)
  } : info;
}
function subtractPoint(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}
function getPanInfo(_a, history) {
  var point = _a.point;
  return {
    point: point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return {
      x: 0,
      y: 0
    };
  }
  var i = history.length - 1;
  var timestampedPoint = null;
  var lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > (0, _timeConversion.secondsToMilliseconds)(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return {
      x: 0,
      y: 0
    };
  }
  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;
  if (time === 0) {
    return {
      x: 0,
      y: 0
    };
  }
  var currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
},{"tslib":"vCxL","./utils/event-type.mjs":"xikS","../events/event-info.mjs":"zZPj","framesync":"KvxD","../utils/time-conversion.mjs":"tXn1","../events/use-pointer-event.mjs":"tW3y","popmotion":"KhgA"}],"FBmE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcAxisDelta = calcAxisDelta;
exports.calcBoxDelta = calcBoxDelta;
exports.calcLength = calcLength;
exports.calcRelativeAxis = calcRelativeAxis;
exports.calcRelativeAxisPosition = calcRelativeAxisPosition;
exports.calcRelativeBox = calcRelativeBox;
exports.calcRelativePosition = calcRelativePosition;
exports.isNear = isNear;
var _popmotion = require("popmotion");
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  if (target === void 0) {
    target = 0;
  }
  if (maxDistance === void 0) {
    maxDistance = 0.01;
  }
  return (0, _popmotion.distance)(value, target) < maxDistance;
}
function calcAxisDelta(delta, source, target, origin) {
  if (origin === void 0) {
    origin = 0.5;
  }
  delta.origin = origin;
  delta.originPoint = (0, _popmotion.mix)(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 0.0001) || isNaN(delta.scale)) delta.scale = 1;
  delta.translate = (0, _popmotion.mix)(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate)) delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);
  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout, parent) {
  target.min = layout.min - parent.min;
  target.max = target.min + calcLength(layout);
}
function calcRelativePosition(target, layout, parent) {
  calcRelativeAxisPosition(target.x, layout.x, parent.x);
  calcRelativeAxisPosition(target.y, layout.y, parent.y);
}
},{"popmotion":"KhgA"}],"lu0p":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyConstraints = applyConstraints;
exports.calcOrigin = calcOrigin;
exports.calcRelativeAxisConstraints = calcRelativeAxisConstraints;
exports.calcRelativeConstraints = calcRelativeConstraints;
exports.calcViewportAxisConstraints = calcViewportAxisConstraints;
exports.calcViewportConstraints = calcViewportConstraints;
exports.defaultElastic = void 0;
exports.rebaseAxisConstraints = rebaseAxisConstraints;
exports.resolveAxisElastic = resolveAxisElastic;
exports.resolveDragElastic = resolveDragElastic;
exports.resolvePointElastic = resolvePointElastic;
var _tslib = require("tslib");
var _popmotion = require("popmotion");
var _deltaCalc = require("../../../projection/geometry/delta-calc.mjs");
/**
 * Apply constraints to a point. These constraints are both physical along an
 * axis, and an elastic factor that determines how much to constrain the point
 * by if it does lie outside the defined parameters.
 */
function applyConstraints(point, _a, elastic) {
  var min = _a.min,
    max = _a.max;
  if (min !== undefined && point < min) {
    // If we have a min point defined, and this is outside of that, constrain
    point = elastic ? (0, _popmotion.mix)(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== undefined && point > max) {
    // If we have a max point defined, and this is outside of that, constrain
    point = elastic ? (0, _popmotion.mix)(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
/**
 * Calculate constraints in terms of the viewport when defined relatively to the
 * measured axis. This is measured from the nearest edge, so a max constraint of 200
 * on an axis with a max value of 300 would return a constraint of 500 - axis length
 */
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== undefined ? axis.min + min : undefined,
    max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined
  };
}
/**
 * Calculate constraints in terms of the viewport when
 * defined relatively to the measured bounding box.
 */
function calcRelativeConstraints(layoutBox, _a) {
  var top = _a.top,
    left = _a.left,
    bottom = _a.bottom,
    right = _a.right;
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
/**
 * Calculate viewport constraints when defined as another viewport-relative axis
 */
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  var _a;
  var min = constraintsAxis.min - layoutAxis.min;
  var max = constraintsAxis.max - layoutAxis.max;
  // If the constraints axis is actually smaller than the layout axis then we can
  // flip the constraints
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    _a = (0, _tslib.__read)([max, min], 2), min = _a[0], max = _a[1];
  }
  return {
    min: min,
    max: max
  };
}
/**
 * Calculate viewport constraints when defined as another viewport-relative box
 */
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
/**
 * Calculate a transform origin relative to the source axis, between 0-1, that results
 * in an asthetically pleasing scale/transform needed to project from source to target.
 */
function calcOrigin(source, target) {
  var origin = 0.5;
  var sourceLength = (0, _deltaCalc.calcLength)(source);
  var targetLength = (0, _deltaCalc.calcLength)(target);
  if (targetLength > sourceLength) {
    origin = (0, _popmotion.progress)(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = (0, _popmotion.progress)(source.min, source.max - targetLength, target.min);
  }
  return (0, _popmotion.clamp)(0, 1, origin);
}
/**
 * Rebase the calculated viewport constraints relative to the layout.min point.
 */
function rebaseAxisConstraints(layout, constraints) {
  var relativeConstraints = {};
  if (constraints.min !== undefined) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== undefined) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
/**
 * Accepts a dragElastic prop and returns resolved elastic values for each axis.
 */
exports.defaultElastic = defaultElastic;
function resolveDragElastic(dragElastic) {
  if (dragElastic === void 0) {
    dragElastic = defaultElastic;
  }
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  var _a;
  return typeof dragElastic === "number" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;
}
},{"tslib":"vCxL","popmotion":"KhgA","../../../projection/geometry/delta-calc.mjs":"FBmE"}],"BuZ6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDelta = exports.createBox = exports.createAxisDelta = exports.createAxis = void 0;
var createAxisDelta = function () {
  return {
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  };
};
exports.createAxisDelta = createAxisDelta;
var createDelta = function () {
  return {
    x: createAxisDelta(),
    y: createAxisDelta()
  };
};
exports.createDelta = createDelta;
var createAxis = function () {
  return {
    min: 0,
    max: 0
  };
};
exports.createAxis = createAxis;
var createBox = function () {
  return {
    x: createAxis(),
    y: createAxis()
  };
};
exports.createBox = createBox;
},{}],"ZW58":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.eachAxis = eachAxis;
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
},{}],"GoD3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertBoundingBoxToBox = convertBoundingBoxToBox;
exports.convertBoxToBoundingBox = convertBoxToBoundingBox;
exports.transformBoxPoints = transformBoxPoints;
/**
 * Bounding boxes tend to be defined as top, left, right, bottom. For various operations
 * it's easier to consider each axis individually. This function returns a bounding box
 * as a map of single-axis min/max values.
 */
function convertBoundingBoxToBox(_a) {
  var top = _a.top,
    left = _a.left,
    right = _a.right,
    bottom = _a.bottom;
  return {
    x: {
      min: left,
      max: right
    },
    y: {
      min: top,
      max: bottom
    }
  };
}
function convertBoxToBoundingBox(_a) {
  var x = _a.x,
    y = _a.y;
  return {
    top: y.min,
    right: x.max,
    bottom: y.max,
    left: x.min
  };
}
/**
 * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function
 * provided by Framer to allow measured points to be corrected for device scaling. This is used
 * when measuring DOM elements and DOM event points.
 */
function transformBoxPoints(point, transformPoint) {
  if (!transformPoint) return point;
  var topLeft = transformPoint({
    x: point.left,
    y: point.top
  });
  var bottomRight = transformPoint({
    x: point.right,
    y: point.bottom
  });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
},{}],"V38s":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasScale = hasScale;
exports.hasTransform = hasTransform;
function isIdentityScale(scale) {
  return scale === undefined || scale === 1;
}
function hasScale(_a) {
  var scale = _a.scale,
    scaleX = _a.scaleX,
    scaleY = _a.scaleY;
  return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || hasTranslate(values.x) || hasTranslate(values.y) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function hasTranslate(value) {
  return value && value !== "0%";
}
},{}],"XGk1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyAxisDelta = applyAxisDelta;
exports.applyBoxDelta = applyBoxDelta;
exports.applyPointDelta = applyPointDelta;
exports.applyTreeDeltas = applyTreeDeltas;
exports.scalePoint = scalePoint;
exports.transformAxis = transformAxis;
exports.transformBox = transformBox;
exports.translateAxis = translateAxis;
var _tslib = require("tslib");
var _popmotion = require("popmotion");
var _hasTransform = require("../utils/has-transform.mjs");
/**
 * Scales a point based on a factor and an originPoint
 */
function scalePoint(point, scale, originPoint) {
  var distanceFromOrigin = point - originPoint;
  var scaled = scale * distanceFromOrigin;
  return originPoint + scaled;
}
/**
 * Applies a translate/scale delta to a point
 */
function applyPointDelta(point, translate, scale, originPoint, boxScale) {
  if (boxScale !== undefined) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale, originPoint) + translate;
}
/**
 * Applies a translate/scale delta to an axis
 */
function applyAxisDelta(axis, translate, scale, originPoint, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale === void 0) {
    scale = 1;
  }
  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);
}
/**
 * Applies a translate/scale delta to a box
 */
function applyBoxDelta(box, _a) {
  var x = _a.x,
    y = _a.y;
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
/**
 * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms
 * in a tree upon our box before then calculating how to project it into our desired viewport-relative box
 *
 * This is the final nested loop within updateLayoutDelta for future refactoring
 */
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {
  var _a, _b;
  if (isSharedTransition === void 0) {
    isSharedTransition = false;
  }
  var treeLength = treePath.length;
  if (!treeLength) return;
  // Reset the treeScale
  treeScale.x = treeScale.y = 1;
  var node;
  var delta;
  for (var i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === "contents") continue;
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.x,
        y: -node.scroll.y
      });
    }
    if (delta) {
      // Incoporate each ancestor's scale into a culmulative treeScale for this component
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      // Apply each ancestor's calculated delta into this component's recorded layout box
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && (0, _hasTransform.hasTransform)(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
}
function translateAxis(axis, distance) {
  axis.min = axis.min + distance;
  axis.max = axis.max + distance;
}
/**
 * Apply a transform to an axis from the latest resolved motion values.
 * This function basically acts as a bridge between a flat motion value map
 * and applyAxisDelta
 */
function transformAxis(axis, transforms, _a) {
  var _b = (0, _tslib.__read)(_a, 3),
    key = _b[0],
    scaleKey = _b[1],
    originKey = _b[2];
  var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;
  var originPoint = (0, _popmotion.mix)(axis.min, axis.max, axisOrigin);
  // Apply the axis delta to the final axis
  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
}
/**
 * The names of the motion values we want to apply as translation, scale and origin.
 */
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
/**
 * Apply a transform to a box from the latest resolved motion values.
 */
function transformBox(box, transform) {
  transformAxis(box.x, transform, xKeys);
  transformAxis(box.y, transform, yKeys);
}
},{"tslib":"vCxL","popmotion":"KhgA","../utils/has-transform.mjs":"V38s"}],"X9MM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.measurePageBox = measurePageBox;
exports.measureViewportBox = measureViewportBox;
var _conversion = require("../geometry/conversion.mjs");
var _deltaApply = require("../geometry/delta-apply.mjs");
function measureViewportBox(instance, transformPoint) {
  return (0, _conversion.convertBoundingBoxToBox)((0, _conversion.transformBoxPoints)(instance.getBoundingClientRect(), transformPoint));
}
function measurePageBox(element, rootProjectionNode, transformPagePoint) {
  var viewportBox = measureViewportBox(element, transformPagePoint);
  var scroll = rootProjectionNode.scroll;
  if (scroll) {
    (0, _deltaApply.translateAxis)(viewportBox.x, scroll.x);
    (0, _deltaApply.translateAxis)(viewportBox.y, scroll.y);
  }
  return viewportBox;
}
},{"../geometry/conversion.mjs":"GoD3","../geometry/delta-apply.mjs":"XGk1"}],"nXbD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.elementDragControls = exports.VisualElementDragControls = void 0;
var _tslib = require("tslib");
var _heyListen = require("hey-listen");
var _PanSession = require("../PanSession.mjs");
var _lock = require("./utils/lock.mjs");
var _isRefObject = require("../../utils/is-ref-object.mjs");
var _usePointerEvent = require("../../events/use-pointer-event.mjs");
var _constraints = require("./utils/constraints.mjs");
var _types = require("../../render/utils/types.mjs");
var _models = require("../../projection/geometry/models.mjs");
var _eachAxis = require("../../projection/utils/each-axis.mjs");
var _measure = require("../../projection/utils/measure.mjs");
var _eventInfo = require("../../events/event-info.mjs");
var _transitions = require("../../animation/utils/transitions.mjs");
var _conversion = require("../../projection/geometry/conversion.mjs");
var _useDomEvent = require("../../events/use-dom-event.mjs");
var _popmotion = require("popmotion");
var _styleValueTypes = require("style-value-types");
var _deltaCalc = require("../../projection/geometry/delta-calc.mjs");
var elementDragControls = new WeakMap();
/**
 *
 */
// let latestPointerEvent: AnyPointerEvent
exports.elementDragControls = elementDragControls;
var VisualElementDragControls = /** @class */function () {
  function VisualElementDragControls(visualElement) {
    // This is a reference to the global drag gesture lock, ensuring only one component
    // can "capture" the drag of one or both axes.
    // TODO: Look into moving this into pansession?
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = {
      x: 0,
      y: 0
    };
    /**
     * The permitted boundaries of travel, in pixels.
     */
    this.constraints = false;
    this.hasMutatedConstraints = false;
    /**
     * The per-axis resolved elastic values.
     */
    this.elastic = (0, _models.createBox)();
    this.visualElement = visualElement;
  }
  VisualElementDragControls.prototype.start = function (originEvent, _a) {
    var _this = this;
    var _b = _a === void 0 ? {} : _a,
      _c = _b.snapToCursor,
      snapToCursor = _c === void 0 ? false : _c;
    /**
     * Don't start dragging if this component is exiting
     */
    if (this.visualElement.isPresent === false) return;
    var onSessionStart = function (event) {
      // Stop any animations on both axis values immediately. This allows the user to throw and catch
      // the component.
      _this.stopAnimation();
      if (snapToCursor) {
        _this.snapToCursor((0, _eventInfo.extractEventInfo)(event, "page").point);
      }
    };
    var onStart = function (event, info) {
      var _a;
      // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
      var _b = _this.getProps(),
        drag = _b.drag,
        dragPropagation = _b.dragPropagation,
        onDragStart = _b.onDragStart;
      if (drag && !dragPropagation) {
        if (_this.openGlobalLock) _this.openGlobalLock();
        _this.openGlobalLock = (0, _lock.getGlobalLock)(drag);
        // If we don 't have the lock, don't start dragging
        if (!_this.openGlobalLock) return;
      }
      _this.isDragging = true;
      _this.currentDirection = null;
      _this.resolveConstraints();
      if (_this.visualElement.projection) {
        _this.visualElement.projection.isAnimationBlocked = true;
        _this.visualElement.projection.target = undefined;
      }
      /**
       * Record gesture origin
       */
      (0, _eachAxis.eachAxis)(function (axis) {
        var _a, _b;
        var current = _this.getAxisMotionValue(axis).get() || 0;
        /**
         * If the MotionValue is a percentage value convert to px
         */
        if (_styleValueTypes.percent.test(current)) {
          var measuredAxis = (_b = (_a = _this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.actual[axis];
          if (measuredAxis) {
            var length_1 = (0, _deltaCalc.calcLength)(measuredAxis);
            current = length_1 * (parseFloat(current) / 100);
          }
        }
        _this.originPoint[axis] = current;
      });
      // Fire onDragStart event
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);
      (_a = _this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(_types.AnimationType.Drag, true);
    };
    var onMove = function (event, info) {
      // latestPointerEvent = event
      var _a = _this.getProps(),
        dragPropagation = _a.dragPropagation,
        dragDirectionLock = _a.dragDirectionLock,
        onDirectionLock = _a.onDirectionLock,
        onDrag = _a.onDrag;
      // If we didn't successfully receive the gesture lock, early return.
      if (!dragPropagation && !_this.openGlobalLock) return;
      var offset = info.offset;
      // Attempt to detect drag direction if directionLock is true
      if (dragDirectionLock && _this.currentDirection === null) {
        _this.currentDirection = getCurrentDirection(offset);
        // If we've successfully set a direction, notify listener
        if (_this.currentDirection !== null) {
          onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(_this.currentDirection);
        }
        return;
      }
      // Update each point with the latest position
      _this.updateAxis("x", info.point, offset);
      _this.updateAxis("y", info.point, offset);
      /**
       * Ideally we would leave the renderer to fire naturally at the end of
       * this frame but if the element is about to change layout as the result
       * of a re-render we want to ensure the browser can read the latest
       * bounding box to ensure the pointer and element don't fall out of sync.
       */
      _this.visualElement.syncRender();
      /**
       * This must fire after the syncRender call as it might trigger a state
       * change which itself might trigger a layout update.
       */
      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);
    };
    var onSessionEnd = function (event, info) {
      return _this.stop(event, info);
    };
    this.panSession = new _PanSession.PanSession(originEvent, {
      onSessionStart: onSessionStart,
      onStart: onStart,
      onMove: onMove,
      onSessionEnd: onSessionEnd
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint()
    });
  };
  VisualElementDragControls.prototype.stop = function (event, info) {
    var isDragging = this.isDragging;
    this.cancel();
    if (!isDragging) return;
    var velocity = info.velocity;
    this.startAnimation(velocity);
    var onDragEnd = this.getProps().onDragEnd;
    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
  };
  VisualElementDragControls.prototype.cancel = function () {
    var _a, _b;
    this.isDragging = false;
    if (this.visualElement.projection) {
      this.visualElement.projection.isAnimationBlocked = false;
    }
    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();
    this.panSession = undefined;
    var dragPropagation = this.getProps().dragPropagation;
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(_types.AnimationType.Drag, false);
  };
  VisualElementDragControls.prototype.updateAxis = function (axis, _point, offset) {
    var drag = this.getProps().drag;
    // If we're not dragging this axis, do an early return.
    if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return;
    var axisValue = this.getAxisMotionValue(axis);
    var next = this.originPoint[axis] + offset[axis];
    // Apply constraints
    if (this.constraints && this.constraints[axis]) {
      next = (0, _constraints.applyConstraints)(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  };
  VisualElementDragControls.prototype.resolveConstraints = function () {
    var _this = this;
    var _a = this.getProps(),
      dragConstraints = _a.dragConstraints,
      dragElastic = _a.dragElastic;
    var layout = (this.visualElement.projection || {}).layout;
    var prevConstraints = this.constraints;
    if (dragConstraints && (0, _isRefObject.isRefObject)(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout) {
        this.constraints = (0, _constraints.calcRelativeConstraints)(layout.actual, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = (0, _constraints.resolveDragElastic)(dragElastic);
    /**
     * If we're outputting to external MotionValues, we want to rebase the measured constraints
     * from viewport-relative to component-relative.
     */
    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
      (0, _eachAxis.eachAxis)(function (axis) {
        if (_this.getAxisMotionValue(axis)) {
          _this.constraints[axis] = (0, _constraints.rebaseAxisConstraints)(layout.actual[axis], _this.constraints[axis]);
        }
      });
    }
  };
  VisualElementDragControls.prototype.resolveRefConstraints = function () {
    var _a = this.getProps(),
      constraints = _a.dragConstraints,
      onMeasureDragConstraints = _a.onMeasureDragConstraints;
    if (!constraints || !(0, _isRefObject.isRefObject)(constraints)) return false;
    var constraintsElement = constraints.current;
    (0, _heyListen.invariant)(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    var projection = this.visualElement.projection;
    // TODO
    if (!projection || !projection.layout) return false;
    var constraintsBox = (0, _measure.measurePageBox)(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    var measuredConstraints = (0, _constraints.calcViewportConstraints)(projection.layout.actual, constraintsBox);
    /**
     * If there's an onMeasureDragConstraints listener we call it and
     * if different constraints are returned, set constraints to that
     */
    if (onMeasureDragConstraints) {
      var userConstraints = onMeasureDragConstraints((0, _conversion.convertBoxToBoundingBox)(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = (0, _conversion.convertBoundingBoxToBox)(userConstraints);
      }
    }
    return measuredConstraints;
  };
  VisualElementDragControls.prototype.startAnimation = function (velocity) {
    var _this = this;
    var _a = this.getProps(),
      drag = _a.drag,
      dragMomentum = _a.dragMomentum,
      dragElastic = _a.dragElastic,
      dragTransition = _a.dragTransition,
      dragSnapToOrigin = _a.dragSnapToOrigin,
      onDragTransitionEnd = _a.onDragTransitionEnd;
    var constraints = this.constraints || {};
    var momentumAnimations = (0, _eachAxis.eachAxis)(function (axis) {
      var _a;
      if (!shouldDrag(axis, drag, _this.currentDirection)) {
        return;
      }
      var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};
      if (dragSnapToOrigin) transition = {
        min: 0,
        max: 0
      };
      /**
       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame
       * of spring animations so we should look into adding a disable spring option to `inertia`.
       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`
       * using the value of `dragElastic`.
       */
      var bounceStiffness = dragElastic ? 200 : 1000000;
      var bounceDamping = dragElastic ? 40 : 10000000;
      var inertia = (0, _tslib.__assign)((0, _tslib.__assign)({
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness: bounceStiffness,
        bounceDamping: bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10
      }, dragTransition), transition);
      // If we're not animating on an externally-provided `MotionValue` we can use the
      // component's animation controls which will handle interactions with whileHover (etc),
      // otherwise we just have to animate the `MotionValue` itself.
      return _this.startAxisValueAnimation(axis, inertia);
    });
    // Run all animations and then resolve the new drag constraints.
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  };
  VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {
    var axisValue = this.getAxisMotionValue(axis);
    return (0, _transitions.startAnimation)(axis, axisValue, 0, transition);
  };
  VisualElementDragControls.prototype.stopAnimation = function () {
    var _this = this;
    (0, _eachAxis.eachAxis)(function (axis) {
      return _this.getAxisMotionValue(axis).stop();
    });
  };
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {
    var _a, _b;
    var dragKey = "_drag" + axis.toUpperCase();
    var externalMotionValue = this.visualElement.getProps()[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);
  };
  VisualElementDragControls.prototype.snapToCursor = function (point) {
    var _this = this;
    (0, _eachAxis.eachAxis)(function (axis) {
      var drag = _this.getProps().drag;
      // If we're not dragging this axis, do an early return.
      if (!shouldDrag(axis, drag, _this.currentDirection)) return;
      var projection = _this.visualElement.projection;
      var axisValue = _this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        var _a = projection.layout.actual[axis],
          min = _a.min,
          max = _a.max;
        axisValue.set(point[axis] - (0, _popmotion.mix)(min, max, 0.5));
      }
    });
  };
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  VisualElementDragControls.prototype.scalePositionWithinConstraints = function () {
    var _this = this;
    var _a;
    var _b = this.getProps(),
      drag = _b.drag,
      dragConstraints = _b.dragConstraints;
    var projection = this.visualElement.projection;
    if (!(0, _isRefObject.isRefObject)(dragConstraints) || !projection || !this.constraints) return;
    /**
     * Stop current animations as there can be visual glitching if we try to do
     * this mid-animation
     */
    this.stopAnimation();
    /**
     * Record the relative position of the dragged element relative to the
     * constraints box and save as a progress value.
     */
    var boxProgress = {
      x: 0,
      y: 0
    };
    (0, _eachAxis.eachAxis)(function (axis) {
      var axisValue = _this.getAxisMotionValue(axis);
      if (axisValue) {
        var latest = axisValue.get();
        boxProgress[axis] = (0, _constraints.calcOrigin)({
          min: latest,
          max: latest
        }, _this.constraints[axis]);
      }
    });
    /**
     * Update the layout of this element and resolve the latest drag constraints
     */
    var transformTemplate = this.visualElement.getProps().transformTemplate;
    this.visualElement.getInstance().style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    /**
     * For each axis, calculate the current progress of the layout axis
     * within the new constraints.
     */
    (0, _eachAxis.eachAxis)(function (axis) {
      if (!shouldDrag(axis, drag, null)) return;
      /**
       * Calculate a new transform based on the previous box progress
       */
      var axisValue = _this.getAxisMotionValue(axis);
      var _a = _this.constraints[axis],
        min = _a.min,
        max = _a.max;
      axisValue.set((0, _popmotion.mix)(min, max, boxProgress[axis]));
    });
  };
  VisualElementDragControls.prototype.addListeners = function () {
    var _this = this;
    var _a;
    elementDragControls.set(this.visualElement, this);
    var element = this.visualElement.getInstance();
    /**
     * Attach a pointerdown event listener on this DOM element to initiate drag tracking.
     */
    var stopPointerListener = (0, _usePointerEvent.addPointerEvent)(element, "pointerdown", function (event) {
      var _a = _this.getProps(),
        drag = _a.drag,
        _b = _a.dragListener,
        dragListener = _b === void 0 ? true : _b;
      drag && dragListener && _this.start(event);
    });
    var measureDragConstraints = function () {
      var dragConstraints = _this.getProps().dragConstraints;
      if ((0, _isRefObject.isRefObject)(dragConstraints)) {
        _this.constraints = _this.resolveRefConstraints();
      }
    };
    var projection = this.visualElement.projection;
    var stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    /**
     * Attach a window resize listener to scale the draggable target within its defined
     * constraints as the window resizes.
     */
    var stopResizeListener = (0, _useDomEvent.addDomEvent)(window, "resize", function () {
      return _this.scalePositionWithinConstraints();
    });
    /**
     * If the element's layout changes, calculate the delta and apply that to
     * the drag gesture's origin point.
     */
    projection.addEventListener("didUpdate", function (_a) {
      var delta = _a.delta,
        hasLayoutChanged = _a.hasLayoutChanged;
      if (_this.isDragging && hasLayoutChanged) {
        (0, _eachAxis.eachAxis)(function (axis) {
          var motionValue = _this.getAxisMotionValue(axis);
          if (!motionValue) return;
          _this.originPoint[axis] += delta[axis].translate;
          motionValue.set(motionValue.get() + delta[axis].translate);
        });
        _this.visualElement.syncRender();
      }
    });
    return function () {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
    };
  };
  VisualElementDragControls.prototype.getProps = function () {
    var props = this.visualElement.getProps();
    var _a = props.drag,
      drag = _a === void 0 ? false : _a,
      _b = props.dragDirectionLock,
      dragDirectionLock = _b === void 0 ? false : _b,
      _c = props.dragPropagation,
      dragPropagation = _c === void 0 ? false : _c,
      _d = props.dragConstraints,
      dragConstraints = _d === void 0 ? false : _d,
      _e = props.dragElastic,
      dragElastic = _e === void 0 ? _constraints.defaultElastic : _e,
      _f = props.dragMomentum,
      dragMomentum = _f === void 0 ? true : _f;
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, props), {
      drag: drag,
      dragDirectionLock: dragDirectionLock,
      dragPropagation: dragPropagation,
      dragConstraints: dragConstraints,
      dragElastic: dragElastic,
      dragMomentum: dragMomentum
    });
  };
  return VisualElementDragControls;
}();
exports.VisualElementDragControls = VisualElementDragControls;
function shouldDrag(direction, drag, currentDirection) {
  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);
}
/**
 * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower
 * than the provided threshold, return `null`.
 *
 * @param offset - The x/y offset from origin.
 * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.
 */
function getCurrentDirection(offset, lockThreshold) {
  if (lockThreshold === void 0) {
    lockThreshold = 10;
  }
  var direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
},{"tslib":"vCxL","hey-listen":"KFGT","../PanSession.mjs":"VdEX","./utils/lock.mjs":"UvuD","../../utils/is-ref-object.mjs":"JqDl","../../events/use-pointer-event.mjs":"tW3y","./utils/constraints.mjs":"lu0p","../../render/utils/types.mjs":"gO5D","../../projection/geometry/models.mjs":"BuZ6","../../projection/utils/each-axis.mjs":"ZW58","../../projection/utils/measure.mjs":"X9MM","../../events/event-info.mjs":"zZPj","../../animation/utils/transitions.mjs":"K5UX","../../projection/geometry/conversion.mjs":"GoD3","../../events/use-dom-event.mjs":"QUBy","popmotion":"KhgA","style-value-types":"vstm","../../projection/geometry/delta-calc.mjs":"FBmE"}],"uODr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDrag = useDrag;
var _react = require("react");
var _VisualElementDragControls = require("./VisualElementDragControls.mjs");
var _useConstant = require("../../utils/use-constant.mjs");
/**
 * A hook that allows an element to be dragged.
 *
 * @internal
 */
function useDrag(props) {
  var groupDragControls = props.dragControls,
    visualElement = props.visualElement;
  var dragControls = (0, _useConstant.useConstant)(function () {
    return new _VisualElementDragControls.VisualElementDragControls(visualElement);
  });
  // If we've been provided a DragControls for manual control over the drag gesture,
  // subscribe this component to it on mount.
  (0, _react.useEffect)(function () {
    return groupDragControls && groupDragControls.subscribe(dragControls);
  }, [dragControls, groupDragControls]);
  // Apply the event listeners to the element
  (0, _react.useEffect)(function () {
    return dragControls.addListeners();
  }, [dragControls]);
}
},{"react":"n8MK","./VisualElementDragControls.mjs":"nXbD","../../utils/use-constant.mjs":"XPaj"}],"SICb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePanGesture = usePanGesture;
var _react = require("react");
var _MotionConfigContext = require("../context/MotionConfigContext.mjs");
var _useUnmountEffect = require("../utils/use-unmount-effect.mjs");
var _usePointerEvent = require("../events/use-pointer-event.mjs");
var _PanSession = require("./PanSession.mjs");
/**
 *
 * @param handlers -
 * @param ref -
 *
 * @privateRemarks
 * Currently this sets new pan gesture functions every render. The memo route has been explored
 * in the past but ultimately we're still creating new functions every render. An optimisation
 * to explore is creating the pan gestures and loading them into a `ref`.
 *
 * @internal
 */
function usePanGesture(_a) {
  var onPan = _a.onPan,
    onPanStart = _a.onPanStart,
    onPanEnd = _a.onPanEnd,
    onPanSessionStart = _a.onPanSessionStart,
    visualElement = _a.visualElement;
  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  var panSession = (0, _react.useRef)(null);
  var transformPagePoint = (0, _react.useContext)(_MotionConfigContext.MotionConfigContext).transformPagePoint;
  var handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: function (event, info) {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  (0, _react.useEffect)(function () {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new _PanSession.PanSession(event, handlers, {
      transformPagePoint: transformPagePoint
    });
  }
  (0, _usePointerEvent.usePointerEvent)(visualElement, "pointerdown", hasPanEvents && onPointerDown);
  (0, _useUnmountEffect.useUnmountEffect)(function () {
    return panSession.current && panSession.current.end();
  });
}
},{"react":"n8MK","../context/MotionConfigContext.mjs":"dtoU","../utils/use-unmount-effect.mjs":"Iby2","../events/use-pointer-event.mjs":"tW3y","./PanSession.mjs":"VdEX"}],"Q4DW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drag = void 0;
var _useDrag = require("../../gestures/drag/use-drag.mjs");
var _usePanGesture = require("../../gestures/use-pan-gesture.mjs");
var _makeRenderlessComponent = require("../utils/make-renderless-component.mjs");
var drag = {
  pan: (0, _makeRenderlessComponent.makeRenderlessComponent)(_usePanGesture.usePanGesture),
  drag: (0, _makeRenderlessComponent.makeRenderlessComponent)(_useDrag.useDrag)
};
exports.drag = drag;
},{"../../gestures/drag/use-drag.mjs":"uODr","../../gestures/use-pan-gesture.mjs":"SICb","../utils/make-renderless-component.mjs":"Usef"}],"xjhQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLifecycles = createLifecycles;
var _tslib = require("tslib");
var _subscriptionManager = require("../../utils/subscription-manager.mjs");
var names = ["LayoutMeasure", "BeforeLayoutMeasure", "LayoutUpdate", "ViewportBoxUpdate", "Update", "Render", "AnimationComplete", "LayoutAnimationComplete", "AnimationStart", "LayoutAnimationStart", "SetAxisTarget", "Unmount"];
function createLifecycles() {
  var managers = names.map(function () {
    return new _subscriptionManager.SubscriptionManager();
  });
  var propSubscriptions = {};
  var lifecycles = {
    clearAllListeners: function () {
      return managers.forEach(function (manager) {
        return manager.clear();
      });
    },
    updatePropListeners: function (props) {
      names.forEach(function (name) {
        var _a;
        var on = "on" + name;
        var propListener = props[on];
        // Unsubscribe existing subscription
        (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);
        // Add new subscription
        if (propListener) {
          propSubscriptions[name] = lifecycles[on](propListener);
        }
      });
    }
  };
  managers.forEach(function (manager, i) {
    lifecycles["on" + names[i]] = function (handler) {
      return manager.add(handler);
    };
    lifecycles["notify" + names[i]] = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return manager.notify.apply(manager, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(args), false));
    };
  });
  return lifecycles;
}
},{"tslib":"vCxL","../../utils/subscription-manager.mjs":"eMeP"}],"V7ld":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateMotionValuesFromProps = updateMotionValuesFromProps;
var _warnOnce = require("../../utils/warn-once.mjs");
var _index = require("../../value/index.mjs");
var _isMotionValue = require("../../value/utils/is-motion-value.mjs");
function updateMotionValuesFromProps(element, next, prev) {
  var _a;
  for (var key in next) {
    var nextValue = next[key];
    var prevValue = prev[key];
    if ((0, _isMotionValue.isMotionValue)(nextValue)) {
      /**
       * If this is a motion value found in props or style, we want to add it
       * to our visual element's motion value map.
       */
      element.addValue(key, nextValue);
      /**
       * Check the version of the incoming motion value with this version
       * and warn against mismatches.
       */
      if ("production" === "development") {
        (0, _warnOnce.warnOnce)(nextValue.version === "6.5.1", "Attempting to mix Framer Motion versions ".concat(nextValue.version, " with 6.5.1 may not work as expected."));
      }
    } else if ((0, _isMotionValue.isMotionValue)(prevValue)) {
      /**
       * If we're swapping to a new motion value, create a new motion value
       * from that
       */
      element.addValue(key, (0, _index.motionValue)(nextValue));
    } else if (prevValue !== nextValue) {
      /**
       * If this is a flat value that has changed, update the motion value
       * or create one if it doesn't exist. We only want to do this if we're
       * not handling the value with our animation state.
       */
      if (element.hasValue(key)) {
        var existingValue = element.getValue(key);
        // TODO: Only update values that aren't being animated or even looked at
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        element.addValue(key, (0, _index.motionValue)((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));
      }
    }
  }
  // Handle removed values
  for (var key in prev) {
    if (next[key] === undefined) element.removeValue(key);
  }
  return next;
}
},{"../../utils/warn-once.mjs":"ZTHf","../../value/index.mjs":"PQTd","../../value/utils/is-motion-value.mjs":"XNB1"}],"BwAh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visualElement = void 0;
var _tslib = require("tslib");
var _framesync = _interopRequireWildcard(require("framesync"));
var _index = require("../value/index.mjs");
var _isMotionValue = require("../value/utils/is-motion-value.mjs");
var _animationState = require("./utils/animation-state.mjs");
var _lifecycles = require("./utils/lifecycles.mjs");
var _motionValues = require("./utils/motion-values.mjs");
var _variants = require("./utils/variants.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var visualElement = function (_a) {
  var _b = _a.treeType,
    treeType = _b === void 0 ? "" : _b,
    build = _a.build,
    getBaseTarget = _a.getBaseTarget,
    makeTargetAnimatable = _a.makeTargetAnimatable,
    measureViewportBox = _a.measureViewportBox,
    renderInstance = _a.render,
    readValueFromInstance = _a.readValueFromInstance,
    removeValueFromRenderState = _a.removeValueFromRenderState,
    sortNodePosition = _a.sortNodePosition,
    scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;
  return function (_a, options) {
    var parent = _a.parent,
      props = _a.props,
      presenceId = _a.presenceId,
      blockInitialAnimation = _a.blockInitialAnimation,
      visualState = _a.visualState,
      shouldReduceMotion = _a.shouldReduceMotion;
    if (options === void 0) {
      options = {};
    }
    var isMounted = false;
    var latestValues = visualState.latestValues,
      renderState = visualState.renderState;
    /**
     * The instance of the render-specific node that will be hydrated by the
     * exposed React ref. So for example, this visual element can host a
     * HTMLElement, plain object, or Three.js object. The functions provided
     * in VisualElementConfig allow us to interface with this instance.
     */
    var instance;
    /**
     * Manages the subscriptions for a visual element's lifecycle, for instance
     * onRender
     */
    var lifecycles = (0, _lifecycles.createLifecycles)();
    /**
     * A map of all motion values attached to this visual element. Motion
     * values are source of truth for any given animated value. A motion
     * value might be provided externally by the component via props.
     */
    var values = new Map();
    /**
     * A map of every subscription that binds the provided or generated
     * motion values onChange listeners to this visual element.
     */
    var valueSubscriptions = new Map();
    /**
     * A reference to the previously-provided motion values as returned
     * from scrapeMotionValuesFromProps. We use the keys in here to determine
     * if any motion values need to be removed after props are updated.
     */
    var prevMotionValues = {};
    /**
     * When values are removed from all animation props we need to search
     * for a fallback value to animate to. These values are tracked in baseTarget.
     */
    var baseTarget = (0, _tslib.__assign)({}, latestValues);
    // Internal methods ========================
    /**
     * On mount, this will be hydrated with a callback to disconnect
     * this visual element from its parent on unmount.
     */
    var removeFromVariantTree;
    /**
     * Render the element with the latest styles outside of the React
     * render lifecycle
     */
    function render() {
      if (!instance || !isMounted) return;
      triggerBuild();
      renderInstance(instance, renderState, props.style, element.projection);
    }
    function triggerBuild() {
      build(element, renderState, latestValues, options, props);
    }
    function update() {
      lifecycles.notifyUpdate(latestValues);
    }
    /**
     *
     */
    function bindToMotionValue(key, value) {
      var removeOnChange = value.onChange(function (latestValue) {
        latestValues[key] = latestValue;
        props.onUpdate && _framesync.default.update(update, false, true);
      });
      var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);
      valueSubscriptions.set(key, function () {
        removeOnChange();
        removeOnRenderRequest();
      });
    }
    /**
     * Any motion values that are provided to the element when created
     * aren't yet bound to the element, as this would technically be impure.
     * However, we iterate through the motion values and set them to the
     * initial values for this component.
     *
     * TODO: This is impure and we should look at changing this to run on mount.
     * Doing so will break some tests but this isn't neccessarily a breaking change,
     * more a reflection of the test.
     */
    var initialMotionValues = scrapeMotionValuesFromProps(props);
    for (var key in initialMotionValues) {
      var value = initialMotionValues[key];
      if (latestValues[key] !== undefined && (0, _isMotionValue.isMotionValue)(value)) {
        value.set(latestValues[key], false);
      }
    }
    /**
     * Determine what role this visual element should take in the variant tree.
     */
    var isControllingVariants = (0, _variants.checkIfControllingVariants)(props);
    var isVariantNode = (0, _variants.checkIfVariantNode)(props);
    var element = (0, _tslib.__assign)((0, _tslib.__assign)({
      treeType: treeType,
      /**
       * This is a mirror of the internal instance prop, which keeps
       * VisualElement type-compatible with React's RefObject.
       */
      current: null,
      /**
       * The depth of this visual element within the visual element tree.
       */
      depth: parent ? parent.depth + 1 : 0,
      parent: parent,
      children: new Set(),
      /**
       *
       */
      presenceId: presenceId,
      shouldReduceMotion: shouldReduceMotion,
      /**
       * If this component is part of the variant tree, it should track
       * any children that are also part of the tree. This is essentially
       * a shadow tree to simplify logic around how to stagger over children.
       */
      variantChildren: isVariantNode ? new Set() : undefined,
      /**
       * Whether this instance is visible. This can be changed imperatively
       * by the projection tree, is analogous to CSS's visibility in that
       * hidden elements should take up layout, and needs enacting by the configured
       * render function.
       */
      isVisible: undefined,
      /**
       * Normally, if a component is controlled by a parent's variants, it can
       * rely on that ancestor to trigger animations further down the tree.
       * However, if a component is created after its parent is mounted, the parent
       * won't trigger that mount animation so the child needs to.
       *
       * TODO: This might be better replaced with a method isParentMounted
       */
      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
      /**
       * This can be set by AnimatePresence to force components that mount
       * at the same time as it to mount as if they have initial={false} set.
       */
      blockInitialAnimation: blockInitialAnimation,
      /**
       * Determine whether this component has mounted yet. This is mostly used
       * by variant children to determine whether they need to trigger their
       * own animations on mount.
       */
      isMounted: function () {
        return Boolean(instance);
      },
      mount: function (newInstance) {
        isMounted = true;
        instance = element.current = newInstance;
        if (element.projection) {
          element.projection.mount(newInstance);
        }
        if (isVariantNode && parent && !isControllingVariants) {
          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);
        }
        values.forEach(function (value, key) {
          return bindToMotionValue(key, value);
        });
        parent === null || parent === void 0 ? void 0 : parent.children.add(element);
        element.setProps(props);
      },
      /**
       *
       */
      unmount: function () {
        var _a;
        (_a = element.projection) === null || _a === void 0 ? void 0 : _a.unmount();
        _framesync.cancelSync.update(update);
        _framesync.cancelSync.render(render);
        valueSubscriptions.forEach(function (remove) {
          return remove();
        });
        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);
        lifecycles.clearAllListeners();
        instance = undefined;
        isMounted = false;
      },
      /**
       * Add a child visual element to our set of children.
       */
      addVariantChild: function (child) {
        var _a;
        var closestVariantNode = element.getClosestVariantNode();
        if (closestVariantNode) {
          (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);
          return function () {
            return closestVariantNode.variantChildren.delete(child);
          };
        }
      },
      sortNodePosition: function (other) {
        /**
         * If these nodes aren't even of the same type we can't compare their depth.
         */
        if (!sortNodePosition || treeType !== other.treeType) return 0;
        return sortNodePosition(element.getInstance(), other.getInstance());
      },
      /**
       * Returns the closest variant node in the tree starting from
       * this visual element.
       */
      getClosestVariantNode: function () {
        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();
      },
      /**
       * Expose the latest layoutId prop.
       */
      getLayoutId: function () {
        return props.layoutId;
      },
      /**
       * Returns the current instance.
       */
      getInstance: function () {
        return instance;
      },
      /**
       * Get/set the latest static values.
       */
      getStaticValue: function (key) {
        return latestValues[key];
      },
      setStaticValue: function (key, value) {
        return latestValues[key] = value;
      },
      /**
       * Returns the latest motion value state. Currently only used to take
       * a snapshot of the visual element - perhaps this can return the whole
       * visual state
       */
      getLatestValues: function () {
        return latestValues;
      },
      /**
       * Set the visiblity of the visual element. If it's changed, schedule
       * a render to reflect these changes.
       */
      setVisibility: function (visibility) {
        if (element.isVisible === visibility) return;
        element.isVisible = visibility;
        element.scheduleRender();
      },
      /**
       * Make a target animatable by Popmotion. For instance, if we're
       * trying to animate width from 100px to 100vw we need to measure 100vw
       * in pixels to determine what we really need to animate to. This is also
       * pluggable to support Framer's custom value types like Color,
       * and CSS variables.
       */
      makeTargetAnimatable: function (target, canMutate) {
        if (canMutate === void 0) {
          canMutate = true;
        }
        return makeTargetAnimatable(element, target, props, canMutate);
      },
      /**
       * Measure the current viewport box with or without transforms.
       * Only measures axis-aligned boxes, rotate and skew must be manually
       * removed with a re-render to work.
       */
      measureViewportBox: function () {
        return measureViewportBox(instance, props);
      },
      // Motion values ========================
      /**
       * Add a motion value and bind it to this visual element.
       */
      addValue: function (key, value) {
        // Remove existing value if it exists
        if (element.hasValue(key)) element.removeValue(key);
        values.set(key, value);
        latestValues[key] = value.get();
        bindToMotionValue(key, value);
      },
      /**
       * Remove a motion value and unbind any active subscriptions.
       */
      removeValue: function (key) {
        var _a;
        values.delete(key);
        (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();
        valueSubscriptions.delete(key);
        delete latestValues[key];
        removeValueFromRenderState(key, renderState);
      },
      /**
       * Check whether we have a motion value for this key
       */
      hasValue: function (key) {
        return values.has(key);
      },
      /**
       * Get a motion value for this key. If called with a default
       * value, we'll create one if none exists.
       */
      getValue: function (key, defaultValue) {
        var value = values.get(key);
        if (value === undefined && defaultValue !== undefined) {
          value = (0, _index.motionValue)(defaultValue);
          element.addValue(key, value);
        }
        return value;
      },
      /**
       * Iterate over our motion values.
       */
      forEachValue: function (callback) {
        return values.forEach(callback);
      },
      /**
       * If we're trying to animate to a previously unencountered value,
       * we need to check for it in our state and as a last resort read it
       * directly from the instance (which might have performance implications).
       */
      readValue: function (key) {
        var _a;
        return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);
      },
      /**
       * Set the base target to later animate back to. This is currently
       * only hydrated on creation and when we first read a value.
       */
      setBaseTarget: function (key, value) {
        baseTarget[key] = value;
      },
      /**
       * Find the base target for a value thats been removed from all animation
       * props.
       */
      getBaseTarget: function (key) {
        if (getBaseTarget) {
          var target = getBaseTarget(props, key);
          if (target !== undefined && !(0, _isMotionValue.isMotionValue)(target)) return target;
        }
        return baseTarget[key];
      }
    }, lifecycles), {
      /**
       * Build the renderer state based on the latest visual state.
       */
      build: function () {
        triggerBuild();
        return renderState;
      },
      /**
       * Schedule a render on the next animation frame.
       */
      scheduleRender: function () {
        _framesync.default.render(render, false, true);
      },
      /**
       * Synchronously fire render. It's prefered that we batch renders but
       * in many circumstances, like layout measurement, we need to run this
       * synchronously. However in those instances other measures should be taken
       * to batch reads/writes.
       */
      syncRender: render,
      /**
       * Update the provided props. Ensure any newly-added motion values are
       * added to our map, old ones removed, and listeners updated.
       */
      setProps: function (newProps) {
        if (newProps.transformTemplate || props.transformTemplate) {
          element.scheduleRender();
        }
        props = newProps;
        lifecycles.updatePropListeners(newProps);
        prevMotionValues = (0, _motionValues.updateMotionValuesFromProps)(element, scrapeMotionValuesFromProps(props), prevMotionValues);
      },
      getProps: function () {
        return props;
      },
      // Variants ==============================
      /**
       * Returns the variant definition with a given name.
       */
      getVariant: function (name) {
        var _a;
        return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];
      },
      /**
       * Returns the defined default transition on this component.
       */
      getDefaultTransition: function () {
        return props.transition;
      },
      getTransformPagePoint: function () {
        return props.transformPagePoint;
      },
      /**
       * Used by child variant nodes to get the closest ancestor variant props.
       */
      getVariantContext: function (startAtParent) {
        if (startAtParent === void 0) {
          startAtParent = false;
        }
        if (startAtParent) return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
        if (!isControllingVariants) {
          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
          if (props.initial !== undefined) {
            context_1.initial = props.initial;
          }
          return context_1;
        }
        var context = {};
        for (var i = 0; i < numVariantProps; i++) {
          var name_1 = variantProps[i];
          var prop = props[name_1];
          if ((0, _variants.isVariantLabel)(prop) || prop === false) {
            context[name_1] = prop;
          }
        }
        return context;
      }
    });
    return element;
  };
};
exports.visualElement = visualElement;
var variantProps = (0, _tslib.__spreadArray)(["initial"], (0, _tslib.__read)(_animationState.variantPriorityOrder), false);
var numVariantProps = variantProps.length;
},{"tslib":"vCxL","framesync":"KvxD","../value/index.mjs":"PQTd","../value/utils/is-motion-value.mjs":"XNB1","./utils/animation-state.mjs":"ci7C","./utils/lifecycles.mjs":"xjhQ","./utils/motion-values.mjs":"V7ld","./utils/variants.mjs":"B4V7"}],"fIyW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cssVariableRegex = void 0;
exports.parseCSSVariable = parseCSSVariable;
exports.resolveCSSVariables = resolveCSSVariables;
var _tslib = require("tslib");
var _heyListen = require("hey-listen");
function isCSSVariable(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
/**
 * Parse Framer's special CSS variable format into a CSS token and a fallback.
 *
 * ```
 * `var(--foo, #fff)` => [`--foo`, '#fff']
 * ```
 *
 * @param current
 */
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
exports.cssVariableRegex = cssVariableRegex;
function parseCSSVariable(current) {
  var match = cssVariableRegex.exec(current);
  if (!match) return [,];
  var _a = (0, _tslib.__read)(match, 3),
    token = _a[1],
    fallback = _a[2];
  return [token, fallback];
}
var maxDepth = 4;
function getVariableValue(current, element, depth) {
  if (depth === void 0) {
    depth = 1;
  }
  (0, _heyListen.invariant)(depth <= maxDepth, "Max CSS variable fallback depth detected in property \"".concat(current, "\". This may indicate a circular fallback dependency."));
  var _a = (0, _tslib.__read)(parseCSSVariable(current), 2),
    token = _a[0],
    fallback = _a[1];
  // No CSS variable detected
  if (!token) return;
  // Attempt to read this CSS variable off the element
  var resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable(fallback)) {
    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
/**
 * Resolve CSS variables from
 *
 * @internal
 */
function resolveCSSVariables(visualElement, _a, transitionEnd) {
  var _b;
  var target = (0, _tslib.__rest)(_a, []);
  var element = visualElement.getInstance();
  if (!(element instanceof Element)) return {
    target: target,
    transitionEnd: transitionEnd
  };
  // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`
  // only if they change but I think this reads clearer and this isn't a performance-critical path.
  if (transitionEnd) {
    transitionEnd = (0, _tslib.__assign)({}, transitionEnd);
  }
  // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved
  visualElement.forEachValue(function (value) {
    var current = value.get();
    if (!isCSSVariable(current)) return;
    var resolved = getVariableValue(current, element);
    if (resolved) value.set(resolved);
  });
  // Cycle through every target property and resolve CSS variables. Currently
  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`
  for (var key in target) {
    var current = target[key];
    if (!isCSSVariable(current)) continue;
    var resolved = getVariableValue(current, element);
    if (!resolved) continue;
    // Clone target if it hasn't already been
    target[key] = resolved;
    // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved
    // CSS variable. This will ensure that after the animation the component will reflect
    // changes in the value of the CSS variable.
    if (transitionEnd) (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;
  }
  return {
    target: target,
    transitionEnd: transitionEnd
  };
}
},{"tslib":"vCxL","hey-listen":"KFGT"}],"keCS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.positionalValues = exports.BoundingBoxDimension = void 0;
exports.unitConversion = unitConversion;
var _tslib = require("tslib");
var _styleValueTypes = require("style-value-types");
var _isKeyframesTarget = require("../../../animation/utils/is-keyframes-target.mjs");
var _heyListen = require("hey-listen");
var _transform = require("../../html/utils/transform.mjs");
var _dimensions = require("../value-types/dimensions.mjs");
var positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y"]);
var isPositionalKey = function (key) {
  return positionalKeys.has(key);
};
var hasPositionalKey = function (target) {
  return Object.keys(target).some(isPositionalKey);
};
var setAndResetVelocity = function (value, to) {
  // Looks odd but setting it twice doesn't render, it'll just
  // set both prev and current to the latest value
  value.set(to, false);
  value.set(to);
};
var isNumOrPxType = function (v) {
  return v === _styleValueTypes.number || v === _styleValueTypes.px;
};
var BoundingBoxDimension;
exports.BoundingBoxDimension = BoundingBoxDimension;
(function (BoundingBoxDimension) {
  BoundingBoxDimension["width"] = "width";
  BoundingBoxDimension["height"] = "height";
  BoundingBoxDimension["left"] = "left";
  BoundingBoxDimension["right"] = "right";
  BoundingBoxDimension["top"] = "top";
  BoundingBoxDimension["bottom"] = "bottom";
})(BoundingBoxDimension || (exports.BoundingBoxDimension = BoundingBoxDimension = {}));
var getPosFromMatrix = function (matrix, pos) {
  return parseFloat(matrix.split(", ")[pos]);
};
var getTranslateFromMatrix = function (pos2, pos3) {
  return function (_bbox, _a) {
    var transform = _a.transform;
    if (transform === "none" || !transform) return 0;
    var matrix3d = transform.match(/^matrix3d\((.+)\)$/);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      var matrix = transform.match(/^matrix\((.+)\)$/);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
};
var transformKeys = new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = _transform.transformProps.filter(function (key) {
  return !transformKeys.has(key);
});
function removeNonTranslationalTransform(visualElement) {
  var removedTransforms = [];
  nonTranslationalTransformKeys.forEach(function (key) {
    var value = visualElement.getValue(key);
    if (value !== undefined) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  // Apply changes to element before measurement
  if (removedTransforms.length) visualElement.syncRender();
  return removedTransforms;
}
var positionalValues = {
  // Dimensions
  width: function (_a, _b) {
    var x = _a.x;
    var _c = _b.paddingLeft,
      paddingLeft = _c === void 0 ? "0" : _c,
      _d = _b.paddingRight,
      paddingRight = _d === void 0 ? "0" : _d;
    return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);
  },
  height: function (_a, _b) {
    var y = _a.y;
    var _c = _b.paddingTop,
      paddingTop = _c === void 0 ? "0" : _c,
      _d = _b.paddingBottom,
      paddingBottom = _d === void 0 ? "0" : _d;
    return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);
  },
  top: function (_bbox, _a) {
    var top = _a.top;
    return parseFloat(top);
  },
  left: function (_bbox, _a) {
    var left = _a.left;
    return parseFloat(left);
  },
  bottom: function (_a, _b) {
    var y = _a.y;
    var top = _b.top;
    return parseFloat(top) + (y.max - y.min);
  },
  right: function (_a, _b) {
    var x = _a.x;
    var left = _b.left;
    return parseFloat(left) + (x.max - x.min);
  },
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
exports.positionalValues = positionalValues;
var convertChangedValueTypes = function (target, visualElement, changedKeys) {
  var originBbox = visualElement.measureViewportBox();
  var element = visualElement.getInstance();
  var elementComputedStyle = getComputedStyle(element);
  var display = elementComputedStyle.display;
  var origin = {};
  // If the element is currently set to display: "none", make it visible before
  // measuring the target bounding box
  if (display === "none") {
    visualElement.setStaticValue("display", target.display || "block");
  }
  /**
   * Record origins before we render and update styles
   */
  changedKeys.forEach(function (key) {
    origin[key] = positionalValues[key](originBbox, elementComputedStyle);
  });
  // Apply the latest values (as set in checkAndConvertChangedValueTypes)
  visualElement.syncRender();
  var targetBbox = visualElement.measureViewportBox();
  changedKeys.forEach(function (key) {
    // Restore styles to their **calculated computed style**, not their actual
    // originally set style. This allows us to animate between equivalent pixel units.
    var value = visualElement.getValue(key);
    setAndResetVelocity(value, origin[key]);
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
var checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {
  if (origin === void 0) {
    origin = {};
  }
  if (transitionEnd === void 0) {
    transitionEnd = {};
  }
  target = (0, _tslib.__assign)({}, target);
  transitionEnd = (0, _tslib.__assign)({}, transitionEnd);
  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  // We want to remove any transform values that could affect the element's bounding box before
  // it's measured. We'll reapply these later.
  var removedTransformValues = [];
  var hasAttemptedToRemoveTransformValues = false;
  var changedValueTypeKeys = [];
  targetPositionalKeys.forEach(function (key) {
    var value = visualElement.getValue(key);
    if (!visualElement.hasValue(key)) return;
    var from = origin[key];
    var fromType = (0, _dimensions.findDimensionValueType)(from);
    var to = target[key];
    var toType;
    // TODO: The current implementation of this basically throws an error
    // if you try and do value conversion via keyframes. There's probably
    // a way of doing this but the performance implications would need greater scrutiny,
    // as it'd be doing multiple resize-remeasure operations.
    if ((0, _isKeyframesTarget.isKeyframesTarget)(to)) {
      var numKeyframes = to.length;
      var fromIndex = to[0] === null ? 1 : 0;
      from = to[fromIndex];
      fromType = (0, _dimensions.findDimensionValueType)(from);
      for (var i = fromIndex; i < numKeyframes; i++) {
        if (!toType) {
          toType = (0, _dimensions.findDimensionValueType)(to[i]);
          (0, _heyListen.invariant)(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
        } else {
          (0, _heyListen.invariant)((0, _dimensions.findDimensionValueType)(to[i]) === toType, "All keyframes must be of the same type");
        }
      }
    } else {
      toType = (0, _dimensions.findDimensionValueType)(to);
    }
    if (fromType !== toType) {
      // If they're both just number or px, convert them both to numbers rather than
      // relying on resize/remeasure to convert (which is wasteful in this situation)
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        var current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === _styleValueTypes.px) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        // If one or the other value is 0, it's safe to coerce it to the
        // type of the other without measurement
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        // If we're going to do value conversion via DOM measurements, we first
        // need to remove non-positional transform values that could affect the bbox measurements.
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];
        setAndResetVelocity(value, to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    var scrollY_1 = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
    // If we removed transform values, reapply them before the next render
    if (removedTransformValues.length) {
      removedTransformValues.forEach(function (_a) {
        var _b = (0, _tslib.__read)(_a, 2),
          key = _b[0],
          value = _b[1];
        visualElement.getValue(key).set(value);
      });
    }
    // Reapply original values
    visualElement.syncRender();
    // Restore scroll position
    if (scrollY_1 !== null) window.scrollTo({
      top: scrollY_1
    });
    return {
      target: convertedTarget,
      transitionEnd: transitionEnd
    };
  } else {
    return {
      target: target,
      transitionEnd: transitionEnd
    };
  }
};
/**
 * Convert value types for x/y/width/height/top/left/bottom/right
 *
 * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`
 *
 * @internal
 */
function unitConversion(visualElement, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {
    target: target,
    transitionEnd: transitionEnd
  };
}
},{"tslib":"vCxL","style-value-types":"vstm","../../../animation/utils/is-keyframes-target.mjs":"lbx8","hey-listen":"KFGT","../../html/utils/transform.mjs":"qPCc","../value-types/dimensions.mjs":"uOQL"}],"OlKe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseDomVariant = void 0;
var _cssVariablesConversion = require("./css-variables-conversion.mjs");
var _unitConversion = require("./unit-conversion.mjs");
/**
 * Parse a DOM variant to make it animatable. This involves resolving CSS variables
 * and ensuring animations like "20%" => "calc(50vw)" are performed in pixels.
 */
var parseDomVariant = function (visualElement, target, origin, transitionEnd) {
  var resolved = (0, _cssVariablesConversion.resolveCSSVariables)(visualElement, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return (0, _unitConversion.unitConversion)(visualElement, target, origin, transitionEnd);
};
exports.parseDomVariant = parseDomVariant;
},{"./css-variables-conversion.mjs":"fIyW","./unit-conversion.mjs":"keCS"}],"KoWt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getComputedStyle = getComputedStyle;
exports.htmlVisualElement = exports.htmlConfig = void 0;
var _tslib = require("tslib");
var _index = require("../index.mjs");
var _setters = require("../utils/setters.mjs");
var _buildStyles = require("./utils/build-styles.mjs");
var _isCssVariable = require("../dom/utils/is-css-variable.mjs");
var _parseDomVariant = require("../dom/utils/parse-dom-variant.mjs");
var _transform = require("./utils/transform.mjs");
var _scrapeMotionValues = require("./utils/scrape-motion-values.mjs");
var _render = require("./utils/render.mjs");
var _defaults = require("../dom/value-types/defaults.mjs");
var _measure = require("../../projection/utils/measure.mjs");
function getComputedStyle(element) {
  return window.getComputedStyle(element);
}
var htmlConfig = {
  treeType: "dom",
  readValueFromInstance: function (domElement, key) {
    if ((0, _transform.isTransformProp)(key)) {
      var defaultType = (0, _defaults.getDefaultValueType)(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      var computedStyle = getComputedStyle(domElement);
      return ((0, _isCssVariable.isCSSVariable)(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
    }
  },
  sortNodePosition: function (a, b) {
    /**
     * compareDocumentPosition returns a bitmask, by using the bitwise &
     * we're returning true if 2 in that bitmask is set to true. 2 is set
     * to true if b preceeds a.
     */
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  },
  getBaseTarget: function (props, key) {
    var _a;
    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];
  },
  measureViewportBox: function (element, _a) {
    var transformPagePoint = _a.transformPagePoint;
    return (0, _measure.measureViewportBox)(element, transformPagePoint);
  },
  /**
   * Reset the transform on the current Element. This is called as part
   * of a batched process across the entire layout tree. To remove this write
   * cycle it'd be interesting to see if it's possible to "undo" all the current
   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms
   * works
   */
  resetTransform: function (element, domElement, props) {
    var transformTemplate = props.transformTemplate;
    domElement.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    // Ensure that whatever happens next, we restore our transform on the next frame
    element.scheduleRender();
  },
  restoreTransform: function (instance, mutableState) {
    instance.style.transform = mutableState.style.transform;
  },
  removeValueFromRenderState: function (key, _a) {
    var vars = _a.vars,
      style = _a.style;
    delete vars[key];
    delete style[key];
  },
  /**
   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`
   * can be animated by Motion.
   */
  makeTargetAnimatable: function (element, _a, _b, isMounted) {
    var transformValues = _b.transformValues;
    if (isMounted === void 0) {
      isMounted = true;
    }
    var transition = _a.transition,
      transitionEnd = _a.transitionEnd,
      target = (0, _tslib.__rest)(_a, ["transition", "transitionEnd"]);
    var origin = (0, _setters.getOrigin)(target, transition || {}, element);
    /**
     * If Framer has provided a function to convert `Color` etc value types, convert them
     */
    if (transformValues) {
      if (transitionEnd) transitionEnd = transformValues(transitionEnd);
      if (target) target = transformValues(target);
      if (origin) origin = transformValues(origin);
    }
    if (isMounted) {
      (0, _setters.checkTargetForNewValues)(element, target, origin);
      var parsed = (0, _parseDomVariant.parseDomVariant)(element, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return (0, _tslib.__assign)({
      transition: transition,
      transitionEnd: transitionEnd
    }, target);
  },
  scrapeMotionValuesFromProps: _scrapeMotionValues.scrapeMotionValuesFromProps,
  build: function (element, renderState, latestValues, options, props) {
    if (element.isVisible !== undefined) {
      renderState.style.visibility = element.isVisible ? "visible" : "hidden";
    }
    (0, _buildStyles.buildHTMLStyles)(renderState, latestValues, options, props.transformTemplate);
  },
  render: _render.renderHTML
};
exports.htmlConfig = htmlConfig;
var htmlVisualElement = (0, _index.visualElement)(htmlConfig);
exports.htmlVisualElement = htmlVisualElement;
},{"tslib":"vCxL","../index.mjs":"BwAh","../utils/setters.mjs":"QDUS","./utils/build-styles.mjs":"ZW60","../dom/utils/is-css-variable.mjs":"sTTH","../dom/utils/parse-dom-variant.mjs":"OlKe","./utils/transform.mjs":"qPCc","./utils/scrape-motion-values.mjs":"cLQp","./utils/render.mjs":"RWVZ","../dom/value-types/defaults.mjs":"CLPu","../../projection/utils/measure.mjs":"X9MM"}],"ylds":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.svgVisualElement = void 0;
var _tslib = require("tslib");
var _index = require("../index.mjs");
var _scrapeMotionValues = require("./utils/scrape-motion-values.mjs");
var _visualElement = require("../html/visual-element.mjs");
var _buildAttrs = require("./utils/build-attrs.mjs");
var _camelToDash = require("../dom/utils/camel-to-dash.mjs");
var _camelCaseAttrs = require("./utils/camel-case-attrs.mjs");
var _transform = require("../html/utils/transform.mjs");
var _render = require("./utils/render.mjs");
var _defaults = require("../dom/value-types/defaults.mjs");
var svgVisualElement = (0, _index.visualElement)((0, _tslib.__assign)((0, _tslib.__assign)({}, _visualElement.htmlConfig), {
  getBaseTarget: function (props, key) {
    return props[key];
  },
  readValueFromInstance: function (domElement, key) {
    var _a;
    if ((0, _transform.isTransformProp)(key)) {
      return ((_a = (0, _defaults.getDefaultValueType)(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;
    }
    key = !_camelCaseAttrs.camelCaseAttributes.has(key) ? (0, _camelToDash.camelToDash)(key) : key;
    return domElement.getAttribute(key);
  },
  scrapeMotionValuesFromProps: _scrapeMotionValues.scrapeMotionValuesFromProps,
  build: function (_element, renderState, latestValues, options, props) {
    (0, _buildAttrs.buildSVGAttrs)(renderState, latestValues, options, props.transformTemplate);
  },
  render: _render.renderSVG
}));
exports.svgVisualElement = svgVisualElement;
},{"tslib":"vCxL","../index.mjs":"BwAh","./utils/scrape-motion-values.mjs":"ZKWc","../html/visual-element.mjs":"KoWt","./utils/build-attrs.mjs":"vHbP","../dom/utils/camel-to-dash.mjs":"KZHC","./utils/camel-case-attrs.mjs":"Gyex","../html/utils/transform.mjs":"qPCc","./utils/render.mjs":"UZy9","../dom/value-types/defaults.mjs":"CLPu"}],"b462":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDomVisualElement = void 0;
var _visualElement = require("../html/visual-element.mjs");
var _visualElement2 = require("../svg/visual-element.mjs");
var _isSvgComponent = require("./utils/is-svg-component.mjs");
var createDomVisualElement = function (Component, options) {
  return (0, _isSvgComponent.isSVGComponent)(Component) ? (0, _visualElement2.svgVisualElement)(options, {
    enableHardwareAcceleration: false
  }) : (0, _visualElement.htmlVisualElement)(options, {
    enableHardwareAcceleration: true
  });
};
exports.createDomVisualElement = createDomVisualElement;
},{"../html/visual-element.mjs":"KoWt","../svg/visual-element.mjs":"ylds","./utils/is-svg-component.mjs":"hj4I"}],"qawa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.correctBorderRadius = void 0;
exports.pixelsToPercent = pixelsToPercent;
var _styleValueTypes = require("style-value-types");
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min) return 0;
  return pixels / (axis.max - axis.min) * 100;
}
/**
 * We always correct borderRadius as a percentage rather than pixels to reduce paints.
 * For example, if you are projecting a box that is 100px wide with a 10px borderRadius
 * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%
 * borderRadius in both states. If we animate between the two in pixels that will trigger
 * a paint each time. If we animate between the two in percentage we'll avoid a paint.
 */
var correctBorderRadius = {
  correct: function (latest, node) {
    if (!node.target) return latest;
    /**
     * If latest is a string, if it's a percentage we can return immediately as it's
     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.
     */
    if (typeof latest === "string") {
      if (_styleValueTypes.px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    /**
     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that
     * pixel value as a percentage of each axis
     */
    var x = pixelsToPercent(latest, node.target.x);
    var y = pixelsToPercent(latest, node.target.y);
    return "".concat(x, "% ").concat(y, "%");
  }
};
exports.correctBorderRadius = correctBorderRadius;
},{"style-value-types":"vstm"}],"zRZ1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.correctBoxShadow = void 0;
var _popmotion = require("popmotion");
var _styleValueTypes = require("style-value-types");
var _cssVariablesConversion = require("../../render/dom/utils/css-variables-conversion.mjs");
var varToken = "_$css";
var correctBoxShadow = {
  correct: function (latest, _a) {
    var treeScale = _a.treeScale,
      projectionDelta = _a.projectionDelta;
    var original = latest;
    /**
     * We need to first strip and store CSS variables from the string.
     */
    var containsCSSVariables = latest.includes("var(");
    var cssVariables = [];
    if (containsCSSVariables) {
      latest = latest.replace(_cssVariablesConversion.cssVariableRegex, function (match) {
        cssVariables.push(match);
        return varToken;
      });
    }
    var shadow = _styleValueTypes.complex.parse(latest);
    // TODO: Doesn't support multiple shadows
    if (shadow.length > 5) return original;
    var template = _styleValueTypes.complex.createTransformer(latest);
    var offset = typeof shadow[0] !== "number" ? 1 : 0;
    // Calculate the overall context scale
    var xScale = projectionDelta.x.scale * treeScale.x;
    var yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    /**
     * Ideally we'd correct x and y scales individually, but because blur and
     * spread apply to both we have to take a scale average and apply that instead.
     * We could potentially improve the outcome of this by incorporating the ratio between
     * the two scales.
     */
    var averageScale = (0, _popmotion.mix)(xScale, yScale, 0.5);
    // Blur
    if (typeof shadow[2 + offset] === "number") shadow[2 + offset] /= averageScale;
    // Spread
    if (typeof shadow[3 + offset] === "number") shadow[3 + offset] /= averageScale;
    var output = template(shadow);
    if (containsCSSVariables) {
      var i_1 = 0;
      output = output.replace(varToken, function () {
        var cssVariable = cssVariables[i_1];
        i_1++;
        return cssVariable;
      });
    }
    return output;
  }
};
exports.correctBoxShadow = correctBoxShadow;
},{"popmotion":"KhgA","style-value-types":"vstm","../../render/dom/utils/css-variables-conversion.mjs":"fIyW"}],"HK8W":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureLayout = MeasureLayout;
var _tslib = require("tslib");
var _framesync = _interopRequireDefault(require("framesync"));
var _react = _interopRequireWildcard(require("react"));
var _usePresence = require("../../../components/AnimatePresence/use-presence.mjs");
var _LayoutGroupContext = require("../../../context/LayoutGroupContext.mjs");
var _SwitchLayoutGroupContext = require("../../../context/SwitchLayoutGroupContext.mjs");
var _state = require("../../../projection/node/state.mjs");
var _scaleBorderRadius = require("../../../projection/styles/scale-border-radius.mjs");
var _scaleBoxShadow = require("../../../projection/styles/scale-box-shadow.mjs");
var _scaleCorrection = require("../../../projection/styles/scale-correction.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var MeasureLayoutWithContext = /** @class */function (_super) {
  (0, _tslib.__extends)(MeasureLayoutWithContext, _super);
  function MeasureLayoutWithContext() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  MeasureLayoutWithContext.prototype.componentDidMount = function () {
    var _this = this;
    var _a = this.props,
      visualElement = _a.visualElement,
      layoutGroup = _a.layoutGroup,
      switchLayoutGroup = _a.switchLayoutGroup,
      layoutId = _a.layoutId;
    var projection = visualElement.projection;
    (0, _scaleCorrection.addScaleCorrector)(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.add(projection);
      if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", function () {
        _this.safeToRemove();
      });
      projection.setOptions((0, _tslib.__assign)((0, _tslib.__assign)({}, projection.options), {
        onExitComplete: function () {
          return _this.safeToRemove();
        }
      }));
    }
    _state.globalProjectionState.hasEverUpdated = true;
  };
  MeasureLayoutWithContext.prototype.getSnapshotBeforeUpdate = function (prevProps) {
    var _this = this;
    var _a = this.props,
      layoutDependency = _a.layoutDependency,
      visualElement = _a.visualElement,
      drag = _a.drag,
      isPresent = _a.isPresent;
    var projection = visualElement.projection;
    if (!projection) return null;
    /**
     * TODO: We use this data in relegate to determine whether to
     * promote a previous element. There's no guarantee its presence data
     * will have updated by this point - if a bug like this arises it will
     * have to be that we markForRelegation and then find a new lead some other way,
     * perhaps in didUpdate
     */
    projection.isPresent = isPresent;
    if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        /**
         * If there's another stack member taking over from this one,
         * it's in charge of the exit animation and therefore should
         * be in charge of the safe to remove. Otherwise we call it here.
         */
        _framesync.default.postRender(function () {
          var _a;
          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {
            _this.safeToRemove();
          }
        });
      }
    }
    return null;
  };
  MeasureLayoutWithContext.prototype.componentDidUpdate = function () {
    var projection = this.props.visualElement.projection;
    if (projection) {
      projection.root.didUpdate();
      if (!projection.currentAnimation && projection.isLead()) {
        this.safeToRemove();
      }
    }
  };
  MeasureLayoutWithContext.prototype.componentWillUnmount = function () {
    var _a = this.props,
      visualElement = _a.visualElement,
      layoutGroup = _a.layoutGroup,
      promoteContext = _a.switchLayoutGroup;
    var projection = visualElement.projection;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.remove(projection);
      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister) promoteContext.deregister(projection);
    }
  };
  MeasureLayoutWithContext.prototype.safeToRemove = function () {
    var safeToRemove = this.props.safeToRemove;
    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();
  };
  MeasureLayoutWithContext.prototype.render = function () {
    return null;
  };
  return MeasureLayoutWithContext;
}(_react.default.Component);
function MeasureLayout(props) {
  var _a = (0, _tslib.__read)((0, _usePresence.usePresence)(), 2),
    isPresent = _a[0],
    safeToRemove = _a[1];
  var layoutGroup = (0, _react.useContext)(_LayoutGroupContext.LayoutGroupContext);
  return _react.default.createElement(MeasureLayoutWithContext, (0, _tslib.__assign)({}, props, {
    layoutGroup: layoutGroup,
    switchLayoutGroup: (0, _react.useContext)(_SwitchLayoutGroupContext.SwitchLayoutGroupContext),
    isPresent: isPresent,
    safeToRemove: safeToRemove
  }));
}
var defaultScaleCorrectors = {
  borderRadius: (0, _tslib.__assign)((0, _tslib.__assign)({}, _scaleBorderRadius.correctBorderRadius), {
    applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
  }),
  borderTopLeftRadius: _scaleBorderRadius.correctBorderRadius,
  borderTopRightRadius: _scaleBorderRadius.correctBorderRadius,
  borderBottomLeftRadius: _scaleBorderRadius.correctBorderRadius,
  borderBottomRightRadius: _scaleBorderRadius.correctBorderRadius,
  boxShadow: _scaleBoxShadow.correctBoxShadow
};
},{"tslib":"vCxL","framesync":"KvxD","react":"n8MK","../../../components/AnimatePresence/use-presence.mjs":"oIU2","../../../context/LayoutGroupContext.mjs":"dh8B","../../../context/SwitchLayoutGroupContext.mjs":"iF60","../../../projection/node/state.mjs":"h6Mt","../../../projection/styles/scale-border-radius.mjs":"qawa","../../../projection/styles/scale-box-shadow.mjs":"zRZ1","../../../projection/styles/scale-correction.mjs":"PNTQ"}],"gk0r":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.layoutFeatures = void 0;
var _MeasureLayout = require("./MeasureLayout.mjs");
var layoutFeatures = {
  measureLayout: _MeasureLayout.MeasureLayout
};
exports.layoutFeatures = layoutFeatures;
},{"./MeasureLayout.mjs":"HK8W"}],"a6aH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animate = animate;
var _index = require("../value/index.mjs");
var _isMotionValue = require("../value/utils/is-motion-value.mjs");
var _transitions = require("./utils/transitions.mjs");
/**
 * Animate a single value or a `MotionValue`.
 *
 * The first argument is either a `MotionValue` to animate, or an initial animation value.
 *
 * The second is either a value to animate to, or an array of keyframes to animate through.
 *
 * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.
 *
 * Returns `AnimationPlaybackControls`, currently just a `stop` method.
 *
 * ```javascript
 * const x = useMotionValue(0)
 *
 * useEffect(() => {
 *   const controls = animate(x, 100, {
 *     type: "spring",
 *     stiffness: 2000,
 *     onComplete: v => {}
 *   })
 *
 *   return controls.stop
 * })
 * ```
 *
 * @public
 */
function animate(from, to, transition) {
  if (transition === void 0) {
    transition = {};
  }
  var value = (0, _isMotionValue.isMotionValue)(from) ? from : (0, _index.motionValue)(from);
  (0, _transitions.startAnimation)("", value, to, transition);
  return {
    stop: function () {
      return value.stop();
    },
    isAnimating: function () {
      return value.isAnimating();
    }
  };
}
},{"../value/index.mjs":"PQTd","../value/utils/is-motion-value.mjs":"XNB1","./utils/transitions.mjs":"K5UX"}],"aKhv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mixValues = mixValues;
var _popmotion = require("popmotion");
var _styleValueTypes = require("style-value-types");
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
var asNumber = function (value) {
  return typeof value === "string" ? parseFloat(value) : value;
};
var isPx = function (value) {
  return typeof value === "number" || _styleValueTypes.px.test(value);
};
function mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {
  var _a, _b, _c, _d;
  if (shouldCrossfadeOpacity) {
    target.opacity = (0, _popmotion.mix)(0,
    // (follow?.opacity as number) ?? 0,
    // TODO Reinstate this if only child
    (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress));
    target.opacityExit = (0, _popmotion.mix)((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress));
  } else if (isOnlyMember) {
    target.opacity = (0, _popmotion.mix)((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress);
  }
  /**
   * Mix border radius
   */
  for (var i = 0; i < numBorders; i++) {
    var borderLabel = "border".concat(borders[i], "Radius");
    var followRadius = getRadius(follow, borderLabel);
    var leadRadius = getRadius(lead, borderLabel);
    if (followRadius === undefined && leadRadius === undefined) continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    var canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max((0, _popmotion.mix)(asNumber(followRadius), asNumber(leadRadius), progress), 0);
      if (_styleValueTypes.percent.test(leadRadius) || _styleValueTypes.percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  /**
   * Mix rotation
   */
  if (follow.rotate || lead.rotate) {
    target.rotate = (0, _popmotion.mix)(follow.rotate || 0, lead.rotate || 0, progress);
  }
}
function getRadius(values, radiusName) {
  var _a;
  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;
}
// /**
//  * We only want to mix the background color if there's a follow element
//  * that we're not crossfading opacity between. For instance with switch
//  * AnimateSharedLayout animations, this helps the illusion of a continuous
//  * element being animated but also cuts down on the number of paints triggered
//  * for elements where opacity is doing that work for us.
//  */
// if (
//     !hasFollowElement &&
//     latestLeadValues.backgroundColor &&
//     latestFollowValues.backgroundColor
// ) {
//     /**
//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.
//      * We could probably create a mixer that runs at the start of the animation but
//      * the idea behind the crossfader is that it runs dynamically between two potentially
//      * changing targets (ie opacity or borderRadius may be animating independently via variants)
//      */
//     leadState.backgroundColor = followState.backgroundColor = mixColor(
//         latestFollowValues.backgroundColor as string,
//         latestLeadValues.backgroundColor as string
//     )(p)
// }
var easeCrossfadeIn = compress(0, 0.5, _popmotion.circOut);
var easeCrossfadeOut = compress(0.5, 0.95, _popmotion.linear);
function compress(min, max, easing) {
  return function (p) {
    // Could replace ifs with clamp
    if (p < min) return 0;
    if (p > max) return 1;
    return easing((0, _popmotion.progress)(min, max, p));
  };
}
},{"popmotion":"KhgA","style-value-types":"vstm"}],"SpXk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyAxisInto = copyAxisInto;
exports.copyBoxInto = copyBoxInto;
/**
 * Reset an axis to the provided origin box.
 *
 * This is a mutative operation.
 */
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
/**
 * Reset a box to the provided origin box.
 *
 * This is a mutative operation.
 */
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
},{}],"w2WK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeAxisDelta = removeAxisDelta;
exports.removeAxisTransforms = removeAxisTransforms;
exports.removeBoxTransforms = removeBoxTransforms;
exports.removePointDelta = removePointDelta;
var _tslib = require("tslib");
var _popmotion = require("popmotion");
var _styleValueTypes = require("style-value-types");
var _deltaApply = require("./delta-apply.mjs");
/**
 * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse
 */
function removePointDelta(point, translate, scale, originPoint, boxScale) {
  point -= translate;
  point = (0, _deltaApply.scalePoint)(point, 1 / scale, originPoint);
  if (boxScale !== undefined) {
    point = (0, _deltaApply.scalePoint)(point, 1 / boxScale, originPoint);
  }
  return point;
}
/**
 * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse
 */
function removeAxisDelta(axis, translate, scale, origin, boxScale, originAxis, sourceAxis) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale === void 0) {
    scale = 1;
  }
  if (origin === void 0) {
    origin = 0.5;
  }
  if (originAxis === void 0) {
    originAxis = axis;
  }
  if (sourceAxis === void 0) {
    sourceAxis = axis;
  }
  if (_styleValueTypes.percent.test(translate)) {
    translate = parseFloat(translate);
    var relativeProgress = (0, _popmotion.mix)(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number") return;
  var originPoint = (0, _popmotion.mix)(originAxis.min, originAxis.max, origin);
  if (axis === originAxis) originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);
}
/**
 * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse
 * and acts as a bridge between motion values and removeAxisDelta
 */
function removeAxisTransforms(axis, transforms, _a, origin, sourceAxis) {
  var _b = (0, _tslib.__read)(_a, 3),
    key = _b[0],
    scaleKey = _b[1],
    originKey = _b[2];
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
/**
 * The names of the motion values we want to apply as translation, scale and origin.
 */
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
/**
 * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse
 * and acts as a bridge between motion values and removeAxisDelta
 */
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);
  removeAxisTransforms(box.y, transforms, yKeys, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);
}
},{"tslib":"vCxL","popmotion":"KhgA","style-value-types":"vstm","./delta-apply.mjs":"XGk1"}],"l2k5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.boxEquals = boxEquals;
exports.isDeltaZero = isDeltaZero;
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a, b) {
  return a.x.min === b.x.min && a.x.max === b.x.max && a.y.min === b.y.min && a.y.max === b.y.max;
}
},{}],"B0vZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NodeStack = void 0;
var _array = require("../../utils/array.mjs");
var NodeStack = /** @class */function () {
  function NodeStack() {
    this.members = [];
  }
  NodeStack.prototype.add = function (node) {
    (0, _array.addUniqueItem)(this.members, node);
    node.scheduleRender();
  };
  NodeStack.prototype.remove = function (node) {
    (0, _array.removeItem)(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = undefined;
    }
    if (node === this.lead) {
      var prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  };
  NodeStack.prototype.relegate = function (node) {
    var indexOfNode = this.members.findIndex(function (member) {
      return node === member;
    });
    if (indexOfNode === 0) return false;
    /**
     * Find the next projection node that is present
     */
    var prevLead;
    for (var i = indexOfNode; i >= 0; i--) {
      var member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  };
  NodeStack.prototype.promote = function (node, preserveFollowOpacity) {
    var _a;
    var prevLead = this.lead;
    if (node === prevLead) return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        node.snapshot.isShared = true;
      }
      if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {
        node.isLayoutDirty = true;
      }
      var crossfade = node.options.crossfade;
      if (crossfade === false) {
        prevLead.hide();
      }
      /**
       * TODO:
       *   - Test border radius when previous node was deleted
       *   - boxShadow mixing
       *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)
       *   - Shared between element A in transformed container and element B (transform stays the same or changes)
       *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)
       * ---
       *   - Crossfade opacity of root nodes
       *   - layoutId changes after animation
       *   - layoutId changes mid animation
       */
    }
  };

  NodeStack.prototype.exitAnimationComplete = function () {
    this.members.forEach(function (node) {
      var _a, _b, _c, _d, _e;
      (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);
      (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);
    });
  };
  NodeStack.prototype.scheduleRender = function () {
    this.members.forEach(function (node) {
      node.instance && node.scheduleRender(false);
    });
  };
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  NodeStack.prototype.removeLeadSnapshot = function () {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = undefined;
    }
  };
  return NodeStack;
}();
exports.NodeStack = NodeStack;
},{"../../utils/array.mjs":"la1d"}],"d6Uc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildProjectionTransform = buildProjectionTransform;
exports.identityProjection = void 0;
var identityProjection = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";
exports.identityProjection = identityProjection;
function buildProjectionTransform(delta, treeScale, latestTransform) {
  /**
   * The translations we use to calculate are always relative to the viewport coordinate space.
   * But when we apply scales, we also scale the coordinate space of an element and its children.
   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need
   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.
   */
  var xTranslate = delta.x.translate / treeScale.x;
  var yTranslate = delta.y.translate / treeScale.y;
  var transform = "translate3d(".concat(xTranslate, "px, ").concat(yTranslate, "px, 0) ");
  /**
   * Apply scale correction for the tree transform.
   * This will apply scale to the screen-orientated axes.
   */
  transform += "scale(".concat(1 / treeScale.x, ", ").concat(1 / treeScale.y, ") ");
  if (latestTransform) {
    var rotate = latestTransform.rotate,
      rotateX = latestTransform.rotateX,
      rotateY = latestTransform.rotateY;
    if (rotate) transform += "rotate(".concat(rotate, "deg) ");
    if (rotateX) transform += "rotateX(".concat(rotateX, "deg) ");
    if (rotateY) transform += "rotateY(".concat(rotateY, "deg) ");
  }
  /**
   * Apply scale to match the size of the element to the size we want it.
   * This will apply scale to the element-orientated axes.
   */
  var elementScaleX = delta.x.scale * treeScale.x;
  var elementScaleY = delta.y.scale * treeScale.y;
  transform += "scale(".concat(elementScaleX, ", ").concat(elementScaleY, ")");
  return transform === identityProjection ? "none" : transform;
}
},{}],"ETtW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareByDepth = void 0;
var compareByDepth = function (a, b) {
  return a.depth - b.depth;
};
exports.compareByDepth = compareByDepth;
},{}],"dNhg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlatTree = void 0;
var _array = require("../../utils/array.mjs");
var _compareByDepth = require("./compare-by-depth.mjs");
var FlatTree = /** @class */function () {
  function FlatTree() {
    this.children = [];
    this.isDirty = false;
  }
  FlatTree.prototype.add = function (child) {
    (0, _array.addUniqueItem)(this.children, child);
    this.isDirty = true;
  };
  FlatTree.prototype.remove = function (child) {
    (0, _array.removeItem)(this.children, child);
    this.isDirty = true;
  };
  FlatTree.prototype.forEach = function (callback) {
    this.isDirty && this.children.sort(_compareByDepth.compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  };
  return FlatTree;
}();
exports.FlatTree = FlatTree;
},{"../../utils/array.mjs":"la1d","./compare-by-depth.mjs":"ETtW"}],"BXY3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProjectionNode = createProjectionNode;
exports.mixAxis = mixAxis;
exports.mixAxisDelta = mixAxisDelta;
exports.mixBox = mixBox;
var _tslib = require("tslib");
var _framesync = _interopRequireWildcard(require("framesync"));
var _popmotion = require("popmotion");
var _animate = require("../../animation/animate.mjs");
var _subscriptionManager = require("../../utils/subscription-manager.mjs");
var _mixValues = require("../animation/mix-values.mjs");
var _copy = require("../geometry/copy.mjs");
var _deltaApply = require("../geometry/delta-apply.mjs");
var _deltaCalc = require("../geometry/delta-calc.mjs");
var _deltaRemove = require("../geometry/delta-remove.mjs");
var _models = require("../geometry/models.mjs");
var _transitions = require("../../animation/utils/transitions.mjs");
var _utils = require("../geometry/utils.mjs");
var _stack = require("../shared/stack.mjs");
var _scaleCorrection = require("../styles/scale-correction.mjs");
var _transform = require("../styles/transform.mjs");
var _eachAxis = require("../utils/each-axis.mjs");
var _hasTransform = require("../utils/has-transform.mjs");
var _transform2 = require("../../render/html/utils/transform.mjs");
var _flatTree = require("../../render/utils/flat-tree.mjs");
var _resolveMotionValue = require("../../value/utils/resolve-motion-value.mjs");
var _state = require("./state.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1
 * which has a noticeable difference in spring animations
 */
var animationTarget = 1000;
function createProjectionNode(_a) {
  var attachResizeListener = _a.attachResizeListener,
    defaultParent = _a.defaultParent,
    measureScroll = _a.measureScroll,
    checkIsScrollRoot = _a.checkIsScrollRoot,
    resetTransform = _a.resetTransform;
  return (/** @class */function () {
      function ProjectionNode(id, latestValues, parent) {
        var _this = this;
        if (latestValues === void 0) {
          latestValues = {};
        }
        if (parent === void 0) {
          parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent();
        }
        /**
         * A Set containing all this component's children. This is used to iterate
         * through the children.
         *
         * TODO: This could be faster to iterate as a flat array stored on the root node.
         */
        this.children = new Set();
        /**
         * Options for the node. We use this to configure what kind of layout animations
         * we should perform (if any).
         */
        this.options = {};
        /**
         * We use this to detect when its safe to shut down part of a projection tree.
         * We have to keep projecting children for scale correction and relative projection
         * until all their parents stop performing layout animations.
         */
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        /**
         * Flag to true if we think this layout has been changed. We can't always know this,
         * currently we set it to true every time a component renders, or if it has a layoutDependency
         * if that has changed between renders. Additionally, components can be grouped by LayoutGroup
         * and if one node is dirtied, they all are.
         */
        this.isLayoutDirty = false;
        /**
         * Block layout updates for instant layout transitions throughout the tree.
         */
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        /**
         * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`
         * call.
         */
        this.isUpdating = false;
        /**
         * If this is an SVG element we currently disable projection transforms
         */
        this.isSVG = false;
        /**
         * Flag to true (during promotion) if a node doing an instant layout transition needs to reset
         * its projection styles.
         */
        this.needsReset = false;
        /**
         * Flags whether this node should have its transform reset prior to measuring.
         */
        this.shouldResetTransform = false;
        /**
         * An object representing the calculated contextual/accumulated/tree scale.
         * This will be used to scale calculcated projection transforms, as these are
         * calculated in screen-space but need to be scaled for elements to actually
         * make it to their calculated destinations.
         *
         * TODO: Lazy-init
         */
        this.treeScale = {
          x: 1,
          y: 1
        };
        /**
         *
         */
        this.eventHandlers = new Map();
        // Note: Currently only running on root node
        this.potentialNodes = new Map();
        this.checkUpdateFailed = function () {
          if (_this.isUpdating) {
            _this.isUpdating = false;
            _this.clearAllSnapshots();
          }
        };
        this.updateProjection = function () {
          _this.nodes.forEach(resolveTargetDelta);
          _this.nodes.forEach(calcProjection);
        };
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        /**
         * Shared layout
         */
        // TODO Only running on root node
        this.sharedNodes = new Map();
        this.id = id;
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], (0, _tslib.__read)(parent.path), false), [parent], false) : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        id && this.root.registerPotentialNode(id, this);
        for (var i = 0; i < this.path.length; i++) {
          this.path[i].shouldResetTransform = true;
        }
        if (this.root === this) this.nodes = new _flatTree.FlatTree();
      }
      ProjectionNode.prototype.addEventListener = function (name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new _subscriptionManager.SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      };
      ProjectionNode.prototype.notifyListeners = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify.apply(subscriptionManager, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(args), false));
      };
      ProjectionNode.prototype.hasListeners = function (name) {
        return this.eventHandlers.has(name);
      };
      ProjectionNode.prototype.registerPotentialNode = function (id, node) {
        this.potentialNodes.set(id, node);
      };
      /**
       * Lifecycles
       */
      ProjectionNode.prototype.mount = function (instance, isLayoutDirty) {
        var _this = this;
        var _a;
        if (isLayoutDirty === void 0) {
          isLayoutDirty = false;
        }
        if (this.instance) return;
        this.isSVG = instance instanceof SVGElement && instance.tagName !== "svg";
        this.instance = instance;
        var _b = this.options,
          layoutId = _b.layoutId,
          layout = _b.layout,
          visualElement = _b.visualElement;
        if (visualElement && !visualElement.getInstance()) {
          visualElement.mount(instance);
        }
        this.root.nodes.add(this);
        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);
        this.id && this.root.potentialNodes.delete(this.id);
        if (isLayoutDirty && (layout || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          var unblockTimeout_1;
          var resizeUnblockUpdate_1 = function () {
            return _this.root.updateBlockedByResize = false;
          };
          attachResizeListener(instance, function () {
            _this.root.updateBlockedByResize = true;
            clearTimeout(unblockTimeout_1);
            unblockTimeout_1 = window.setTimeout(resizeUnblockUpdate_1, 250);
            if (_state.globalProjectionState.hasAnimatedSinceResize) {
              _state.globalProjectionState.hasAnimatedSinceResize = false;
              _this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        // Only register the handler if it requires layout animation
        if (this.options.animate !== false && visualElement && (layoutId || layout)) {
          this.addEventListener("didUpdate", function (_a) {
            var _b, _c, _d, _e, _f;
            var delta = _a.delta,
              hasLayoutChanged = _a.hasLayoutChanged,
              hasRelativeTargetChanged = _a.hasRelativeTargetChanged,
              newLayout = _a.layout;
            if (_this.isTreeAnimationBlocked()) {
              _this.target = undefined;
              _this.relativeTarget = undefined;
              return;
            }
            // TODO: Check here if an animation exists
            var layoutTransition = (_c = (_b = _this.options.transition) !== null && _b !== void 0 ? _b : visualElement.getDefaultTransition()) !== null && _c !== void 0 ? _c : defaultLayoutTransition;
            var _g = visualElement.getProps(),
              onLayoutAnimationStart = _g.onLayoutAnimationStart,
              onLayoutAnimationComplete = _g.onLayoutAnimationComplete;
            /**
             * The target layout of the element might stay the same,
             * but its position relative to its parent has changed.
             */
            var targetChanged = !_this.targetLayout || !(0, _utils.boxEquals)(_this.targetLayout, newLayout) || hasRelativeTargetChanged;
            /**
             * If the layout hasn't seemed to have changed, it might be that the
             * element is visually in the same place in the document but its position
             * relative to its parent has indeed changed. So here we check for that.
             */
            var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
            if (((_d = _this.resumeFrom) === null || _d === void 0 ? void 0 : _d.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !_this.currentAnimation)) {
              if (_this.resumeFrom) {
                _this.resumingFrom = _this.resumeFrom;
                _this.resumingFrom.resumingFrom = undefined;
              }
              _this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
              var animationOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _transitions.getValueTransition)(layoutTransition, "layout")), {
                onPlay: onLayoutAnimationStart,
                onComplete: onLayoutAnimationComplete
              });
              if (visualElement.shouldReduceMotion) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              _this.startAnimation(animationOptions);
            } else {
              /**
               * If the layout hasn't changed and we have an animation that hasn't started yet,
               * finish it immediately. Otherwise it will be animating from a location
               * that was probably never commited to screen and look like a jumpy box.
               */
              if (!hasLayoutChanged && _this.animationProgress === 0) {
                _this.finishAnimation();
              }
              _this.isLead() && ((_f = (_e = _this.options).onExitComplete) === null || _f === void 0 ? void 0 : _f.call(_e));
            }
            _this.targetLayout = newLayout;
          });
        }
      };
      ProjectionNode.prototype.unmount = function () {
        var _a, _b;
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);
        (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);
        this.instance = undefined;
        _framesync.cancelSync.preRender(this.updateProjection);
      };
      // only on the root
      ProjectionNode.prototype.blockUpdate = function () {
        this.updateManuallyBlocked = true;
      };
      ProjectionNode.prototype.unblockUpdate = function () {
        this.updateManuallyBlocked = false;
      };
      ProjectionNode.prototype.isUpdateBlocked = function () {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      };
      ProjectionNode.prototype.isTreeAnimationBlocked = function () {
        var _a;
        return this.isAnimationBlocked || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) || false;
      };
      // Note: currently only running on root node
      ProjectionNode.prototype.startUpdate = function () {
        var _a;
        if (this.isUpdateBlocked()) return;
        this.isUpdating = true;
        (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);
      };
      ProjectionNode.prototype.willUpdate = function (shouldNotifyListeners) {
        var _a, _b, _c;
        if (shouldNotifyListeners === void 0) {
          shouldNotifyListeners = true;
        }
        if (this.root.isUpdateBlocked()) {
          (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);
          return;
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty) return;
        this.isLayoutDirty = true;
        for (var i = 0; i < this.path.length; i++) {
          var node = this.path[i];
          node.shouldResetTransform = true;
          /**
           * TODO: Check we haven't updated the scroll
           * since the last didUpdate
           */
          node.updateScroll();
        }
        var _d = this.options,
          layoutId = _d.layoutId,
          layout = _d.layout;
        if (layoutId === undefined && !layout) return;
        var transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;
        this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      };
      // Note: Currently only running on root node
      ProjectionNode.prototype.didUpdate = function () {
        var updateWasBlocked = this.isUpdateBlocked();
        // When doing an instant transition, we skip the layout update,
        // but should still clean up the measurements so that the next
        // snapshot could be taken correctly.
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (!this.isUpdating) return;
        this.isUpdating = false;
        /**
         * Search for and mount newly-added projection elements.
         *
         * TODO: Every time a new component is rendered we could search up the tree for
         * the closest mounted node and query from there rather than document.
         */
        if (this.potentialNodes.size) {
          this.potentialNodes.forEach(mountNodeEarly);
          this.potentialNodes.clear();
        }
        /**
         * Write
         */
        this.nodes.forEach(resetTransformStyle);
        /**
         * Read ==================
         */
        // Update layout measurements of updated children
        this.nodes.forEach(updateLayout);
        /**
         * Write
         */
        // Notify listeners that the layout is updated
        this.nodes.forEach(notifyLayoutUpdate);
        this.clearAllSnapshots();
        // Flush any scheduled updates
        _framesync.flushSync.update();
        _framesync.flushSync.preRender();
        _framesync.flushSync.render();
      };
      ProjectionNode.prototype.clearAllSnapshots = function () {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      };
      ProjectionNode.prototype.scheduleUpdateProjection = function () {
        _framesync.default.preRender(this.updateProjection, false, true);
      };
      ProjectionNode.prototype.scheduleCheckAfterUnmount = function () {
        var _this = this;
        /**
         * If the unmounting node is in a layoutGroup and did trigger a willUpdate,
         * we manually call didUpdate to give a chance to the siblings to animate.
         * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.
         */
        _framesync.default.postRender(function () {
          if (_this.isLayoutDirty) {
            _this.root.didUpdate();
          } else {
            _this.root.checkUpdateFailed();
          }
        });
      };
      /**
       * Update measurements
       */
      ProjectionNode.prototype.updateSnapshot = function () {
        if (this.snapshot || !this.instance) return;
        var measured = this.measure();
        var layout = this.removeTransform(this.removeElementScroll(measured));
        roundBox(layout);
        this.snapshot = {
          measured: measured,
          layout: layout,
          latestValues: {}
        };
      };
      ProjectionNode.prototype.updateLayout = function () {
        var _a;
        if (!this.instance) return;
        // TODO: Incorporate into a forwarded scroll offset
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        /**
         * When a node is mounted, it simply resumes from the prevLead's
         * snapshot instead of taking a new one, but the ancestors scroll
         * might have updated while the prevLead is unmounted. We need to
         * update the scroll again to make sure the layout we measure is
         * up to date.
         */
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (var i = 0; i < this.path.length; i++) {
            var node = this.path[i];
            node.updateScroll();
          }
        }
        var measured = this.measure();
        roundBox(measured);
        var prevLayout = this.layout;
        this.layout = {
          measured: measured,
          actual: this.removeElementScroll(measured)
        };
        this.layoutCorrected = (0, _models.createBox)();
        this.isLayoutDirty = false;
        this.projectionDelta = undefined;
        this.notifyListeners("measure", this.layout.actual);
        (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);
      };
      ProjectionNode.prototype.updateScroll = function () {
        if (this.options.layoutScroll && this.instance) {
          this.isScrollRoot = checkIsScrollRoot(this.instance);
          this.scroll = measureScroll(this.instance);
        }
      };
      ProjectionNode.prototype.resetTransform = function () {
        var _a;
        if (!resetTransform) return;
        var isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
        var hasProjection = this.projectionDelta && !(0, _utils.isDeltaZero)(this.projectionDelta);
        var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;
        var transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
        var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && (hasProjection || (0, _hasTransform.hasTransform)(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      };
      ProjectionNode.prototype.measure = function () {
        var visualElement = this.options.visualElement;
        if (!visualElement) return (0, _models.createBox)();
        var box = visualElement.measureViewportBox();
        // Remove viewport scroll to give page-relative coordinates
        var scroll = this.root.scroll;
        if (scroll) {
          (0, _deltaApply.translateAxis)(box.x, scroll.x);
          (0, _deltaApply.translateAxis)(box.y, scroll.y);
        }
        return box;
      };
      ProjectionNode.prototype.removeElementScroll = function (box) {
        var boxWithoutScroll = (0, _models.createBox)();
        (0, _copy.copyBoxInto)(boxWithoutScroll, box);
        /**
         * Performance TODO: Keep a cumulative scroll offset down the tree
         * rather than loop back up the path.
         */
        for (var i = 0; i < this.path.length; i++) {
          var node = this.path[i];
          var scroll_1 = node.scroll,
            options = node.options,
            isScrollRoot = node.isScrollRoot;
          if (node !== this.root && scroll_1 && options.layoutScroll) {
            /**
             * If this is a new scroll root, we want to remove all previous scrolls
             * from the viewport box.
             */
            if (isScrollRoot) {
              (0, _copy.copyBoxInto)(boxWithoutScroll, box);
              var rootScroll = this.root.scroll;
              /**
               * Undo the application of page scroll that was originally added
               * to the measured bounding box.
               */
              if (rootScroll) {
                (0, _deltaApply.translateAxis)(boxWithoutScroll.x, -rootScroll.x);
                (0, _deltaApply.translateAxis)(boxWithoutScroll.y, -rootScroll.y);
              }
            }
            (0, _deltaApply.translateAxis)(boxWithoutScroll.x, scroll_1.x);
            (0, _deltaApply.translateAxis)(boxWithoutScroll.y, scroll_1.y);
          }
        }
        return boxWithoutScroll;
      };
      ProjectionNode.prototype.applyTransform = function (box, transformOnly) {
        if (transformOnly === void 0) {
          transformOnly = false;
        }
        var withTransforms = (0, _models.createBox)();
        (0, _copy.copyBoxInto)(withTransforms, box);
        for (var i = 0; i < this.path.length; i++) {
          var node = this.path[i];
          if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
            (0, _deltaApply.transformBox)(withTransforms, {
              x: -node.scroll.x,
              y: -node.scroll.y
            });
          }
          if (!(0, _hasTransform.hasTransform)(node.latestValues)) continue;
          (0, _deltaApply.transformBox)(withTransforms, node.latestValues);
        }
        if ((0, _hasTransform.hasTransform)(this.latestValues)) {
          (0, _deltaApply.transformBox)(withTransforms, this.latestValues);
        }
        return withTransforms;
      };
      ProjectionNode.prototype.removeTransform = function (box) {
        var _a;
        var boxWithoutTransform = (0, _models.createBox)();
        (0, _copy.copyBoxInto)(boxWithoutTransform, box);
        for (var i = 0; i < this.path.length; i++) {
          var node = this.path[i];
          if (!node.instance) continue;
          if (!(0, _hasTransform.hasTransform)(node.latestValues)) continue;
          (0, _hasTransform.hasScale)(node.latestValues) && node.updateSnapshot();
          var sourceBox = (0, _models.createBox)();
          var nodeBox = node.measure();
          (0, _copy.copyBoxInto)(sourceBox, nodeBox);
          (0, _deltaRemove.removeBoxTransforms)(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layout, sourceBox);
        }
        if ((0, _hasTransform.hasTransform)(this.latestValues)) {
          (0, _deltaRemove.removeBoxTransforms)(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      };
      /**
       *
       */
      ProjectionNode.prototype.setTargetDelta = function (delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
      };
      ProjectionNode.prototype.setOptions = function (options) {
        var _a;
        this.options = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, this.options), options), {
          crossfade: (_a = options.crossfade) !== null && _a !== void 0 ? _a : true
        });
      };
      ProjectionNode.prototype.clearMeasurements = function () {
        this.scroll = undefined;
        this.layout = undefined;
        this.snapshot = undefined;
        this.prevTransformTemplateValue = undefined;
        this.targetDelta = undefined;
        this.target = undefined;
        this.isLayoutDirty = false;
      };
      /**
       * Frame calculations
       */
      ProjectionNode.prototype.resolveTargetDelta = function () {
        var _a;
        var _b = this.options,
          layout = _b.layout,
          layoutId = _b.layoutId;
        /**
         * If we have no layout, we can't perform projection, so early return
         */
        if (!this.layout || !(layout || layoutId)) return;
        /**
         * If we don't have a targetDelta but do have a layout, we can attempt to resolve
         * a relativeParent. This will allow a component to perform scale correction
         * even if no animation has started.
         */
        // TODO If this is unsuccessful this currently happens every frame
        if (!this.targetDelta && !this.relativeTarget) {
          // TODO: This is a semi-repetition of further down this function, make DRY
          this.relativeParent = this.getClosestProjectingParent();
          if (this.relativeParent && this.relativeParent.layout) {
            this.relativeTarget = (0, _models.createBox)();
            this.relativeTargetOrigin = (0, _models.createBox)();
            (0, _deltaCalc.calcRelativePosition)(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);
            (0, _copy.copyBoxInto)(this.relativeTarget, this.relativeTargetOrigin);
          }
        }
        /**
         * If we have no relative target or no target delta our target isn't valid
         * for this frame.
         */
        if (!this.relativeTarget && !this.targetDelta) return;
        /**
         * Lazy-init target data structure
         */
        if (!this.target) {
          this.target = (0, _models.createBox)();
          this.targetWithTransforms = (0, _models.createBox)();
        }
        /**
         * If we've got a relative box for this component, resolve it into a target relative to the parent.
         */
        if (this.relativeTarget && this.relativeTargetOrigin && ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {
          (0, _deltaCalc.calcRelativeBox)(this.target, this.relativeTarget, this.relativeParent.target);
          /**
           * If we've only got a targetDelta, resolve it into a target
           */
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            // TODO: This is creating a new object every frame
            this.target = this.applyTransform(this.layout.actual);
          } else {
            (0, _copy.copyBoxInto)(this.target, this.layout.actual);
          }
          (0, _deltaApply.applyBoxDelta)(this.target, this.targetDelta);
        } else {
          /**
           * If no target, use own layout as target
           */
          (0, _copy.copyBoxInto)(this.target, this.layout.actual);
        }
        /**
         * If we've been told to attempt to resolve a relative target, do so.
         */
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          this.relativeParent = this.getClosestProjectingParent();
          if (this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target) {
            this.relativeTarget = (0, _models.createBox)();
            this.relativeTargetOrigin = (0, _models.createBox)();
            (0, _deltaCalc.calcRelativePosition)(this.relativeTargetOrigin, this.target, this.relativeParent.target);
            (0, _copy.copyBoxInto)(this.relativeTarget, this.relativeTargetOrigin);
          }
        }
      };
      ProjectionNode.prototype.getClosestProjectingParent = function () {
        if (!this.parent || (0, _hasTransform.hasTransform)(this.parent.latestValues)) return undefined;
        if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      };
      ProjectionNode.prototype.calcProjection = function () {
        var _a;
        var _b = this.options,
          layout = _b.layout,
          layoutId = _b.layoutId;
        /**
         * If this section of the tree isn't animating we can
         * delete our target sources for the following frame.
         */
        this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = undefined;
        }
        if (!this.layout || !(layout || layoutId)) return;
        var lead = this.getLead();
        /**
         * Reset the corrected box with the latest values from box, as we're then going
         * to perform mutative operations on it.
         */
        (0, _copy.copyBoxInto)(this.layoutCorrected, this.layout.actual);
        /**
         * Apply all the parent deltas to this box to produce the corrected box. This
         * is the layout box, as it will appear on screen as a result of the transforms of its parents.
         */
        (0, _deltaApply.applyTreeDeltas)(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);
        var target = lead.target;
        if (!target) return;
        if (!this.projectionDelta) {
          this.projectionDelta = (0, _models.createDelta)();
          this.projectionDeltaWithTransform = (0, _models.createDelta)();
        }
        var prevTreeScaleX = this.treeScale.x;
        var prevTreeScaleY = this.treeScale.y;
        var prevProjectionTransform = this.projectionTransform;
        /**
         * Update the delta between the corrected box and the target box before user-set transforms were applied.
         * This will allow us to calculate the corrected borderRadius and boxShadow to compensate
         * for our layout reprojection, but still allow them to be scaled correctly by the user.
         * It might be that to simplify this we may want to accept that user-set scale is also corrected
         * and we wouldn't have to keep and calc both deltas, OR we could support a user setting
         * to allow people to choose whether these styles are corrected based on just the
         * layout reprojection or the final bounding box.
         */
        (0, _deltaCalc.calcBoxDelta)(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        this.projectionTransform = (0, _transform.buildProjectionTransform)(this.projectionDelta, this.treeScale);
        if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
      };
      ProjectionNode.prototype.hide = function () {
        this.isVisible = false;
        // TODO: Schedule render
      };

      ProjectionNode.prototype.show = function () {
        this.isVisible = true;
        // TODO: Schedule render
      };

      ProjectionNode.prototype.scheduleRender = function (notifyAll) {
        var _a, _b, _c;
        if (notifyAll === void 0) {
          notifyAll = true;
        }
        (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);
        notifyAll && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = undefined;
        }
      };
      ProjectionNode.prototype.setAnimationOrigin = function (delta, hasOnlyRelativeTargetChanged) {
        var _this = this;
        var _a;
        if (hasOnlyRelativeTargetChanged === void 0) {
          hasOnlyRelativeTargetChanged = false;
        }
        var snapshot = this.snapshot;
        var snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};
        var mixedValues = (0, _tslib.__assign)({}, this.latestValues);
        var targetDelta = (0, _models.createDelta)();
        this.relativeTarget = this.relativeTargetOrigin = undefined;
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        var relativeLayout = (0, _models.createBox)();
        var isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;
        var isOnlyMember = (((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.members.length) || 0) <= 1;
        var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        this.mixTargetDelta = function (latest) {
          var _a;
          var progress = latest / 1000;
          mixAxisDelta(targetDelta.x, delta.x, progress);
          mixAxisDelta(targetDelta.y, delta.y, progress);
          _this.setTargetDelta(targetDelta);
          if (_this.relativeTarget && _this.relativeTargetOrigin && _this.layout && ((_a = _this.relativeParent) === null || _a === void 0 ? void 0 : _a.layout)) {
            (0, _deltaCalc.calcRelativePosition)(relativeLayout, _this.layout.actual, _this.relativeParent.layout.actual);
            mixBox(_this.relativeTarget, _this.relativeTargetOrigin, relativeLayout, progress);
          }
          if (isSharedLayoutAnimation) {
            _this.animationValues = mixedValues;
            (0, _mixValues.mixValues)(mixedValues, snapshotLatestValues, _this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);
          }
          _this.root.scheduleUpdateProjection();
          _this.scheduleRender();
          _this.animationProgress = progress;
        };
        this.mixTargetDelta(0);
      };
      ProjectionNode.prototype.startAnimation = function (options) {
        var _this = this;
        var _a, _b;
        this.notifyListeners("animationStart");
        (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
        if (this.resumingFrom) {
          (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();
        }
        if (this.pendingAnimation) {
          _framesync.cancelSync.update(this.pendingAnimation);
          this.pendingAnimation = undefined;
        }
        /**
         * Start the animation in the next frame to have a frame with progress 0,
         * where the target is the same as when the animation started, so we can
         * calculate the relative positions correctly for instant transitions.
         */
        this.pendingAnimation = _framesync.default.update(function () {
          _state.globalProjectionState.hasAnimatedSinceResize = true;
          _this.currentAnimation = (0, _animate.animate)(0, animationTarget, (0, _tslib.__assign)((0, _tslib.__assign)({}, options), {
            onUpdate: function (latest) {
              var _a;
              _this.mixTargetDelta(latest);
              (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, latest);
            },
            onComplete: function () {
              var _a;
              (_a = options.onComplete) === null || _a === void 0 ? void 0 : _a.call(options);
              _this.completeAnimation();
            }
          }));
          if (_this.resumingFrom) {
            _this.resumingFrom.currentAnimation = _this.currentAnimation;
          }
          _this.pendingAnimation = undefined;
        });
      };
      ProjectionNode.prototype.completeAnimation = function () {
        var _a;
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = undefined;
          this.resumingFrom.preserveOpacity = undefined;
        }
        (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = undefined;
        this.notifyListeners("animationComplete");
      };
      ProjectionNode.prototype.finishAnimation = function () {
        var _a;
        if (this.currentAnimation) {
          (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      };
      ProjectionNode.prototype.applyTransformsToTarget = function () {
        var _a = this.getLead(),
          targetWithTransforms = _a.targetWithTransforms,
          target = _a.target,
          layout = _a.layout,
          latestValues = _a.latestValues;
        if (!targetWithTransforms || !target || !layout) return;
        (0, _copy.copyBoxInto)(targetWithTransforms, target);
        /**
         * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.
         * This is the final box that we will then project into by calculating a transform delta and
         * applying it to the corrected box.
         */
        (0, _deltaApply.transformBox)(targetWithTransforms, latestValues);
        /**
         * Update the delta between the corrected box and the final target box, after
         * user-set transforms are applied to it. This will be used by the renderer to
         * create a transform style that will reproject the element from its actual layout
         * into the desired bounding box.
         */
        (0, _deltaCalc.calcBoxDelta)(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      };
      ProjectionNode.prototype.registerSharedNode = function (layoutId, node) {
        var _a, _b, _c;
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new _stack.NodeStack());
        }
        var stack = this.sharedNodes.get(layoutId);
        stack.add(node);
        node.promote({
          transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,
          preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)
        });
      };
      ProjectionNode.prototype.isLead = function () {
        var stack = this.getStack();
        return stack ? stack.lead === this : true;
      };
      ProjectionNode.prototype.getLead = function () {
        var _a;
        var layoutId = this.options.layoutId;
        return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
      };
      ProjectionNode.prototype.getPrevLead = function () {
        var _a;
        var layoutId = this.options.layoutId;
        return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;
      };
      ProjectionNode.prototype.getStack = function () {
        var layoutId = this.options.layoutId;
        if (layoutId) return this.root.sharedNodes.get(layoutId);
      };
      ProjectionNode.prototype.promote = function (_a) {
        var _b = _a === void 0 ? {} : _a,
          needsReset = _b.needsReset,
          transition = _b.transition,
          preserveFollowOpacity = _b.preserveFollowOpacity;
        var stack = this.getStack();
        if (stack) stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = undefined;
          this.needsReset = true;
        }
        if (transition) this.setOptions({
          transition: transition
        });
      };
      ProjectionNode.prototype.relegate = function () {
        var stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      };
      ProjectionNode.prototype.resetRotation = function () {
        var visualElement = this.options.visualElement;
        if (!visualElement) return;
        // If there's no detected rotation values, we can early return without a forced render.
        var hasRotate = false;
        // Keep a record of all the values we've reset
        var resetValues = {};
        // Check the rotate value of all axes and reset to 0
        for (var i = 0; i < _transform2.transformAxes.length; i++) {
          var axis = _transform2.transformAxes[i];
          var key = "rotate" + axis;
          // If this rotation doesn't exist as a motion value, then we don't
          // need to reset it
          if (!visualElement.getStaticValue(key)) {
            continue;
          }
          hasRotate = true;
          // Record the rotation and then temporarily set it to 0
          resetValues[key] = visualElement.getStaticValue(key);
          visualElement.setStaticValue(key, 0);
        }
        // If there's no rotation values, we don't need to do any more.
        if (!hasRotate) return;
        // Force a render of this element to apply the transform with all rotations
        // set to 0.
        visualElement === null || visualElement === void 0 ? void 0 : visualElement.syncRender();
        // Put back all the values we reset
        for (var key in resetValues) {
          visualElement.setStaticValue(key, resetValues[key]);
        }
        // Schedule a render for the next frame. This ensures we won't visually
        // see the element with the reset rotate value applied.
        visualElement.scheduleRender();
      };
      ProjectionNode.prototype.getProjectionStyles = function (styleProp) {
        var _a, _b, _c, _d, _e, _f;
        if (styleProp === void 0) {
          styleProp = {};
        }
        // TODO: Return lifecycle-persistent object
        var styles = {};
        if (!this.instance || this.isSVG) return styles;
        if (!this.isVisible) {
          return {
            visibility: "hidden"
          };
        } else {
          styles.visibility = "";
        }
        var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;
        if (this.needsReset) {
          this.needsReset = false;
          styles.opacity = "";
          styles.pointerEvents = (0, _resolveMotionValue.resolveMotionValue)(styleProp.pointerEvents) || "";
          styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return styles;
        }
        var lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          var emptyStyles = {};
          if (this.options.layoutId) {
            emptyStyles.opacity = (_b = this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1;
            emptyStyles.pointerEvents = (0, _resolveMotionValue.resolveMotionValue)(styleProp.pointerEvents) || "";
          }
          if (this.hasProjected && !(0, _hasTransform.hasTransform)(this.latestValues)) {
            emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return emptyStyles;
        }
        var valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        styles.transform = (0, _transform.buildProjectionTransform)(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          styles.transform = transformTemplate(valuesToRender, styles.transform);
        }
        var _g = this.projectionDelta,
          x = _g.x,
          y = _g.y;
        styles.transformOrigin = "".concat(x.origin * 100, "% ").concat(y.origin * 100, "% 0");
        if (lead.animationValues) {
          /**
           * If the lead component is animating, assign this either the entering/leaving
           * opacity
           */
          styles.opacity = lead === this ? (_d = (_c = valuesToRender.opacity) !== null && _c !== void 0 ? _c : this.latestValues.opacity) !== null && _d !== void 0 ? _d : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          /**
           * Or we're not animating at all, set the lead component to its actual
           * opacity and other components to hidden.
           */
          styles.opacity = lead === this ? (_e = valuesToRender.opacity) !== null && _e !== void 0 ? _e : "" : (_f = valuesToRender.opacityExit) !== null && _f !== void 0 ? _f : 0;
        }
        /**
         * Apply scale correction
         */
        for (var key in _scaleCorrection.scaleCorrectors) {
          if (valuesToRender[key] === undefined) continue;
          var _h = _scaleCorrection.scaleCorrectors[key],
            correct = _h.correct,
            applyTo = _h.applyTo;
          var corrected = correct(valuesToRender[key], lead);
          if (applyTo) {
            var num = applyTo.length;
            for (var i = 0; i < num; i++) {
              styles[applyTo[i]] = corrected;
            }
          } else {
            styles[key] = corrected;
          }
        }
        /**
         * Disable pointer events on follow components. This is to ensure
         * that if a follow component covers a lead component it doesn't block
         * pointer events on the lead.
         */
        if (this.options.layoutId) {
          styles.pointerEvents = lead === this ? (0, _resolveMotionValue.resolveMotionValue)(styleProp.pointerEvents) || "" : "none";
        }
        return styles;
      };
      ProjectionNode.prototype.clearSnapshot = function () {
        this.resumeFrom = this.snapshot = undefined;
      };
      // Only run on root
      ProjectionNode.prototype.resetTree = function () {
        this.root.nodes.forEach(function (node) {
          var _a;
          return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
        });
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      };
      return ProjectionNode;
    }()
  );
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a, _b, _c, _d;
  var snapshot = (_b = (_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) !== null && _b !== void 0 ? _b : node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    var _e = node.layout,
      layout_1 = _e.actual,
      measuredLayout = _e.measured;
    // TODO Maybe we want to also resize the layout snapshot so we don't trigger
    // animations for instance if layout="size" and an element has only changed position
    if (node.options.animationType === "size") {
      (0, _eachAxis.eachAxis)(function (axis) {
        var axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];
        var length = (0, _deltaCalc.calcLength)(axisSnapshot);
        axisSnapshot.min = layout_1[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (node.options.animationType === "position") {
      (0, _eachAxis.eachAxis)(function (axis) {
        var axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];
        var length = (0, _deltaCalc.calcLength)(layout_1[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
      });
    }
    var layoutDelta = (0, _models.createDelta)();
    (0, _deltaCalc.calcBoxDelta)(layoutDelta, layout_1, snapshot.layout);
    var visualDelta = (0, _models.createDelta)();
    if (snapshot.isShared) {
      (0, _deltaCalc.calcBoxDelta)(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measured);
    } else {
      (0, _deltaCalc.calcBoxDelta)(visualDelta, layout_1, snapshot.layout);
    }
    var hasLayoutChanged = !(0, _utils.isDeltaZero)(layoutDelta);
    var hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      node.relativeParent = node.getClosestProjectingParent();
      /**
       * If the relativeParent is itself resuming from a different element then
       * the relative snapshot is not relavent
       */
      if (node.relativeParent && !node.relativeParent.resumeFrom) {
        var _f = node.relativeParent,
          parentSnapshot = _f.snapshot,
          parentLayout = _f.layout;
        if (parentSnapshot && parentLayout) {
          var relativeSnapshot = (0, _models.createBox)();
          (0, _deltaCalc.calcRelativePosition)(relativeSnapshot, snapshot.layout, parentSnapshot.layout);
          var relativeLayout = (0, _models.createBox)();
          (0, _deltaCalc.calcRelativePosition)(relativeLayout, layout_1, parentLayout.actual);
          if (!(0, _utils.boxEquals)(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout_1,
      snapshot: snapshot,
      delta: visualDelta,
      layoutDelta: layoutDelta,
      hasLayoutChanged: hasLayoutChanged,
      hasRelativeTargetChanged: hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    (_d = (_c = node.options).onExitComplete) === null || _d === void 0 ? void 0 : _d.call(_c);
  }
  /**
   * Clearing transition
   * TODO: Investigate why this transition is being passed in as {type: false } from Framer
   * and why we need it at all
   */
  node.options.transition = undefined;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function resetTransformStyle(node) {
  var visualElement = node.options.visualElement;
  if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notifyBeforeLayoutMeasure();
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = undefined;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetRotation(node) {
  node.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
  output.translate = (0, _popmotion.mix)(delta.translate, 0, p);
  output.scale = (0, _popmotion.mix)(delta.scale, 1, p);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p) {
  output.min = (0, _popmotion.mix)(from.min, to.min, p);
  output.max = (0, _popmotion.mix)(from.max, to.max, p);
}
function mixBox(output, from, to, p) {
  mixAxis(output.x, from.x, to.x, p);
  mixAxis(output.y, from.y, to.y, p);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== undefined;
}
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function mountNodeEarly(node, id) {
  /**
   * Rather than searching the DOM from document we can search the
   * path for the deepest mounted ancestor and search from there
   */
  var searchNode = node.root;
  for (var i = node.path.length - 1; i >= 0; i--) {
    if (Boolean(node.path[i].instance)) {
      searchNode = node.path[i];
      break;
    }
  }
  var searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;
  var element = searchElement.querySelector("[data-projection-id=\"".concat(id, "\"]"));
  if (element) node.mount(element, true);
}
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
},{"tslib":"vCxL","framesync":"KvxD","popmotion":"KhgA","../../animation/animate.mjs":"a6aH","../../utils/subscription-manager.mjs":"eMeP","../animation/mix-values.mjs":"aKhv","../geometry/copy.mjs":"SpXk","../geometry/delta-apply.mjs":"XGk1","../geometry/delta-calc.mjs":"FBmE","../geometry/delta-remove.mjs":"w2WK","../geometry/models.mjs":"BuZ6","../../animation/utils/transitions.mjs":"K5UX","../geometry/utils.mjs":"l2k5","../shared/stack.mjs":"B0vZ","../styles/scale-correction.mjs":"PNTQ","../styles/transform.mjs":"d6Uc","../utils/each-axis.mjs":"ZW58","../utils/has-transform.mjs":"V38s","../../render/html/utils/transform.mjs":"qPCc","../../render/utils/flat-tree.mjs":"dNhg","../../value/utils/resolve-motion-value.mjs":"MEus","./state.mjs":"h6Mt"}],"GIiC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocumentProjectionNode = void 0;
var _createProjectionNode = require("./create-projection-node.mjs");
var _useDomEvent = require("../../events/use-dom-event.mjs");
var DocumentProjectionNode = (0, _createProjectionNode.createProjectionNode)({
  attachResizeListener: function (ref, notify) {
    return (0, _useDomEvent.addDomEvent)(ref, "resize", notify);
  },
  measureScroll: function () {
    return {
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    };
  },
  checkIsScrollRoot: function () {
    return true;
  }
});
exports.DocumentProjectionNode = DocumentProjectionNode;
},{"./create-projection-node.mjs":"BXY3","../../events/use-dom-event.mjs":"QUBy"}],"w8YZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rootProjectionNode = exports.HTMLProjectionNode = void 0;
var _createProjectionNode = require("./create-projection-node.mjs");
var _DocumentProjectionNode = require("./DocumentProjectionNode.mjs");
var rootProjectionNode = {
  current: undefined
};
exports.rootProjectionNode = rootProjectionNode;
var HTMLProjectionNode = (0, _createProjectionNode.createProjectionNode)({
  measureScroll: function (instance) {
    return {
      x: instance.scrollLeft,
      y: instance.scrollTop
    };
  },
  defaultParent: function () {
    if (!rootProjectionNode.current) {
      var documentNode = new _DocumentProjectionNode.DocumentProjectionNode(0, {});
      documentNode.mount(window);
      documentNode.setOptions({
        layoutScroll: true
      });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: function (instance, value) {
    instance.style.transform = value !== null && value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: function (instance) {
    return Boolean(window.getComputedStyle(instance).position === "fixed");
  }
});
exports.HTMLProjectionNode = HTMLProjectionNode;
},{"./create-projection-node.mjs":"BXY3","./DocumentProjectionNode.mjs":"GIiC"}],"g8vb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDomMotionComponent = createDomMotionComponent;
exports.motion = void 0;
var _tslib = require("tslib");
var _index = require("../../motion/index.mjs");
var _motionProxy = require("./motion-proxy.mjs");
var _createConfig = require("./utils/create-config.mjs");
var _gestures = require("../../motion/features/gestures.mjs");
var _animations = require("../../motion/features/animations.mjs");
var _drag = require("../../motion/features/drag.mjs");
var _createVisualElement = require("./create-visual-element.mjs");
var _index2 = require("../../motion/features/layout/index.mjs");
var _HTMLProjectionNode = require("../../projection/node/HTMLProjectionNode.mjs");
var featureBundle = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, _animations.animations), _gestures.gestureAnimations), _drag.drag), _index2.layoutFeatures);
/**
 * HTML & SVG components, optimised for use with gestures and animation. These can be used as
 * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.
 *
 * @public
 */
var motion = /*@__PURE__*/(0, _motionProxy.createMotionProxy)(function (Component, config) {
  return (0, _createConfig.createDomMotionConfig)(Component, config, featureBundle, _createVisualElement.createDomVisualElement, _HTMLProjectionNode.HTMLProjectionNode);
});
/**
 * Create a DOM `motion` component with the provided string. This is primarily intended
 * as a full alternative to `motion` for consumers who have to support environments that don't
 * support `Proxy`.
 *
 * ```javascript
 * import { createDomMotionComponent } from "framer-motion"
 *
 * const motion = {
 *   div: createDomMotionComponent('div')
 * }
 * ```
 *
 * @public
 */
exports.motion = motion;
function createDomMotionComponent(key) {
  return (0, _index.createMotionComponent)((0, _createConfig.createDomMotionConfig)(key, {
    forwardMotionProps: false
  }, featureBundle, _createVisualElement.createDomVisualElement, _HTMLProjectionNode.HTMLProjectionNode));
}
},{"tslib":"vCxL","../../motion/index.mjs":"zTNr","./motion-proxy.mjs":"dmfT","./utils/create-config.mjs":"Tc5g","../../motion/features/gestures.mjs":"MzEU","../../motion/features/animations.mjs":"V8nK","../../motion/features/drag.mjs":"Q4DW","./create-visual-element.mjs":"b462","../../motion/features/layout/index.mjs":"gk0r","../../projection/node/HTMLProjectionNode.mjs":"w8YZ"}],"DqZ3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.m = void 0;
var _motionProxy = require("./motion-proxy.mjs");
var _createConfig = require("./utils/create-config.mjs");
/**
 * @public
 */
var m = (0, _motionProxy.createMotionProxy)(_createConfig.createDomMotionConfig);
exports.m = m;
},{"./motion-proxy.mjs":"dmfT","./utils/create-config.mjs":"Tc5g"}],"i3lR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useIsMounted = useIsMounted;
var _react = require("react");
var _useIsomorphicEffect = require("./use-isomorphic-effect.mjs");
function useIsMounted() {
  var isMounted = (0, _react.useRef)(false);
  (0, _useIsomorphicEffect.useIsomorphicLayoutEffect)(function () {
    isMounted.current = true;
    return function () {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
},{"react":"n8MK","./use-isomorphic-effect.mjs":"tqWN"}],"lEeZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useForceUpdate = useForceUpdate;
var _tslib = require("tslib");
var _framesync = _interopRequireDefault(require("framesync"));
var _react = require("react");
var _useIsMounted = require("./use-is-mounted.mjs");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function useForceUpdate() {
  var isMounted = (0, _useIsMounted.useIsMounted)();
  var _a = (0, _tslib.__read)((0, _react.useState)(0), 2),
    forcedRenderCount = _a[0],
    setForcedRenderCount = _a[1];
  var forceRender = (0, _react.useCallback)(function () {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  /**
   * Defer this to the end of the next animation frame in case there are multiple
   * synchronous calls.
   */
  var deferredForceRender = (0, _react.useCallback)(function () {
    return _framesync.default.postRender(forceRender);
  }, [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
},{"tslib":"vCxL","framesync":"KvxD","react":"n8MK","./use-is-mounted.mjs":"i3lR"}],"SMBJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PresenceChild = void 0;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
var _PresenceContext = require("../../context/PresenceContext.mjs");
var _useConstant = require("../../utils/use-constant.mjs");
var _useId = require("../../utils/use-id.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var PresenceChild = function (_a) {
  var children = _a.children,
    initial = _a.initial,
    isPresent = _a.isPresent,
    onExitComplete = _a.onExitComplete,
    custom = _a.custom,
    presenceAffectsLayout = _a.presenceAffectsLayout;
  var presenceChildren = (0, _useConstant.useConstant)(newChildrenMap);
  var id = (0, _useId.useId)();
  var context = (0, React.useMemo)(function () {
    return {
      id: id,
      initial: initial,
      isPresent: isPresent,
      custom: custom,
      onExitComplete: function (childId) {
        var e_1, _a;
        presenceChildren.set(childId, true);
        try {
          for (var _b = (0, _tslib.__values)(presenceChildren.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var isComplete = _c.value;
            if (!isComplete) return; // can stop searching when any is incomplete
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete();
      },
      register: function (childId) {
        presenceChildren.set(childId, false);
        return function () {
          return presenceChildren.delete(childId);
        };
      }
    };
  },
  /**
   * If the presence of a child affects the layout of the components around it,
   * we want to make a new context value to ensure they get re-rendered
   * so they can detect that layout change.
   */
  presenceAffectsLayout ? undefined : [isPresent]);
  (0, React.useMemo)(function () {
    presenceChildren.forEach(function (_, key) {
      return presenceChildren.set(key, false);
    });
  }, [isPresent]);
  /**
   * If there's no `motion` components to fire exit animations, we want to remove this
   * component immediately.
   */
  React.useEffect(function () {
    !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());
  }, [isPresent]);
  return React.createElement(_PresenceContext.PresenceContext.Provider, {
    value: context
  }, children);
};
exports.PresenceChild = PresenceChild;
function newChildrenMap() {
  return new Map();
}
},{"tslib":"vCxL","react":"n8MK","../../context/PresenceContext.mjs":"eYxR","../../utils/use-constant.mjs":"XPaj","../../utils/use-id.mjs":"IO6W"}],"iuND":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimatePresence = void 0;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
var _process = require("../../utils/process.mjs");
var _useForceUpdate = require("../../utils/use-force-update.mjs");
var _useIsMounted = require("../../utils/use-is-mounted.mjs");
var _PresenceChild = require("./PresenceChild.mjs");
var _LayoutGroupContext = require("../../context/LayoutGroupContext.mjs");
var _useIsomorphicEffect = require("../../utils/use-isomorphic-effect.mjs");
var _useUnmountEffect = require("../../utils/use-unmount-effect.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var getChildKey = function (child) {
  return child.key || "";
};
function updateChildLookup(children, allChildren) {
  children.forEach(function (child) {
    var key = getChildKey(child);
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  var filtered = [];
  // We use forEach here instead of map as map mutates the component key by preprending `.$`
  React.Children.forEach(children, function (child) {
    if ((0, React.isValidElement)(child)) filtered.push(child);
  });
  return filtered;
}
/**
 * `AnimatePresence` enables the animation of components that have been removed from the tree.
 *
 * When adding/removing more than a single child, every child **must** be given a unique `key` prop.
 *
 * Any `motion` components that have an `exit` property defined will animate out when removed from
 * the tree.
 *
 * ```jsx
 * import { motion, AnimatePresence } from 'framer-motion'
 *
 * export const Items = ({ items }) => (
 *   <AnimatePresence>
 *     {items.map(item => (
 *       <motion.div
 *         key={item.id}
 *         initial={{ opacity: 0 }}
 *         animate={{ opacity: 1 }}
 *         exit={{ opacity: 0 }}
 *       />
 *     ))}
 *   </AnimatePresence>
 * )
 * ```
 *
 * You can sequence exit animations throughout a tree using variants.
 *
 * If a child contains multiple `motion` components with `exit` props, it will only unmount the child
 * once all `motion` components have finished animating out. Likewise, any components using
 * `usePresence` all need to call `safeToRemove`.
 *
 * @public
 */
var AnimatePresence = function (_a) {
  var children = _a.children,
    custom = _a.custom,
    _b = _a.initial,
    initial = _b === void 0 ? true : _b,
    onExitComplete = _a.onExitComplete,
    exitBeforeEnter = _a.exitBeforeEnter,
    _c = _a.presenceAffectsLayout,
    presenceAffectsLayout = _c === void 0 ? true : _c;
  // We want to force a re-render once all exiting animations have finished. We
  // either use a local forceRender function, or one from a parent context if it exists.
  var _d = (0, _tslib.__read)((0, _useForceUpdate.useForceUpdate)(), 1),
    forceRender = _d[0];
  var forceRenderLayoutGroup = (0, React.useContext)(_LayoutGroupContext.LayoutGroupContext).forceRender;
  if (forceRenderLayoutGroup) forceRender = forceRenderLayoutGroup;
  var isMounted = (0, _useIsMounted.useIsMounted)();
  // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key
  var filteredChildren = onlyElements(children);
  var childrenToRender = filteredChildren;
  var exiting = new Set();
  // Keep a living record of the children we're actually rendering so we
  // can diff to figure out which are entering and exiting
  var presentChildren = (0, React.useRef)(childrenToRender);
  // A lookup table to quickly reference components by key
  var allChildren = (0, React.useRef)(new Map()).current;
  // If this is the initial component render, just deal with logic surrounding whether
  // we play onMount animations or not.
  var isInitialRender = (0, React.useRef)(true);
  (0, _useIsomorphicEffect.useIsomorphicLayoutEffect)(function () {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  (0, _useUnmountEffect.useUnmountEffect)(function () {
    isInitialRender.current = true;
    allChildren.clear();
    exiting.clear();
  });
  if (isInitialRender.current) {
    return React.createElement(React.Fragment, null, childrenToRender.map(function (child) {
      return React.createElement(_PresenceChild.PresenceChild, {
        key: getChildKey(child),
        isPresent: true,
        initial: initial ? undefined : false,
        presenceAffectsLayout: presenceAffectsLayout
      }, child);
    }));
  }
  // If this is a subsequent render, deal with entering and exiting children
  childrenToRender = (0, _tslib.__spreadArray)([], (0, _tslib.__read)(childrenToRender), false);
  // Diff the keys of the currently-present and target children to update our
  // exiting list.
  var presentKeys = presentChildren.current.map(getChildKey);
  var targetKeys = filteredChildren.map(getChildKey);
  // Diff the present children with our target children and mark those that are exiting
  var numPresent = presentKeys.length;
  for (var i = 0; i < numPresent; i++) {
    var key = presentKeys[i];
    if (targetKeys.indexOf(key) === -1) {
      exiting.add(key);
    }
  }
  // If we currently have exiting children, and we're deferring rendering incoming children
  // until after all current children have exiting, empty the childrenToRender array
  if (exitBeforeEnter && exiting.size) {
    childrenToRender = [];
  }
  // Loop through all currently exiting components and clone them to overwrite `animate`
  // with any `exit` prop they might have defined.
  exiting.forEach(function (key) {
    // If this component is actually entering again, early return
    if (targetKeys.indexOf(key) !== -1) return;
    var child = allChildren.get(key);
    if (!child) return;
    var insertionIndex = presentKeys.indexOf(key);
    var onExit = function () {
      allChildren.delete(key);
      exiting.delete(key);
      // Remove this child from the present children
      var removeIndex = presentChildren.current.findIndex(function (presentChild) {
        return presentChild.key === key;
      });
      presentChildren.current.splice(removeIndex, 1);
      // Defer re-rendering until all exiting children have indeed left
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        if (isMounted.current === false) return;
        forceRender();
        onExitComplete && onExitComplete();
      }
    };
    childrenToRender.splice(insertionIndex, 0, React.createElement(_PresenceChild.PresenceChild, {
      key: getChildKey(child),
      isPresent: false,
      onExitComplete: onExit,
      custom: custom,
      presenceAffectsLayout: presenceAffectsLayout
    }, child));
  });
  // Add `MotionContext` even to children that don't need it to ensure we're rendering
  // the same tree between renders
  childrenToRender = childrenToRender.map(function (child) {
    var key = child.key;
    return exiting.has(key) ? child : React.createElement(_PresenceChild.PresenceChild, {
      key: getChildKey(child),
      isPresent: true,
      presenceAffectsLayout: presenceAffectsLayout
    }, child);
  });
  if (_process.env !== "production" && exitBeforeEnter && childrenToRender.length > 1) {
    console.warn("You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.");
  }
  return React.createElement(React.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {
    return (0, React.cloneElement)(child);
  }));
};
exports.AnimatePresence = AnimatePresence;
},{"tslib":"vCxL","react":"n8MK","../../utils/process.mjs":"A4AW","../../utils/use-force-update.mjs":"lEeZ","../../utils/use-is-mounted.mjs":"i3lR","./PresenceChild.mjs":"SMBJ","../../context/LayoutGroupContext.mjs":"dh8B","../../utils/use-isomorphic-effect.mjs":"tqWN","../../utils/use-unmount-effect.mjs":"Iby2"}],"pJ5w":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DeprecatedLayoutGroupContext = void 0;
var _react = require("react");
/**
 * @deprecated
 */
var DeprecatedLayoutGroupContext = (0, _react.createContext)(null);
exports.DeprecatedLayoutGroupContext = DeprecatedLayoutGroupContext;
},{"react":"n8MK"}],"qwpB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeGroup = nodeGroup;
var notify = function (node) {
  return !node.isLayoutDirty && node.willUpdate(false);
};
function nodeGroup() {
  var nodes = new Set();
  var subscriptions = new WeakMap();
  var dirtyAll = function () {
    return nodes.forEach(notify);
  };
  return {
    add: function (node) {
      nodes.add(node);
      subscriptions.set(node, node.addEventListener("willUpdate", dirtyAll));
    },
    remove: function (node) {
      var _a;
      nodes.delete(node);
      (_a = subscriptions.get(node)) === null || _a === void 0 ? void 0 : _a();
      subscriptions.delete(node);
      dirtyAll();
    },
    dirty: dirtyAll
  };
}
},{}],"lIE0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LayoutGroup = void 0;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
var _LayoutGroupContext = require("../../context/LayoutGroupContext.mjs");
var _DeprecatedLayoutGroupContext = require("../../context/DeprecatedLayoutGroupContext.mjs");
var _useForceUpdate = require("../../utils/use-force-update.mjs");
var _group = require("../../projection/node/group.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var shouldInheritGroup = function (inherit) {
  return inherit === true;
};
var shouldInheritId = function (inherit) {
  return shouldInheritGroup(inherit === true) || inherit === "id";
};
var LayoutGroup = function (_a) {
  var _b, _c;
  var children = _a.children,
    id = _a.id,
    inheritId = _a.inheritId,
    _d = _a.inherit,
    inherit = _d === void 0 ? true : _d;
  // Maintain backwards-compatibility with inheritId until 7.0
  if (inheritId !== undefined) inherit = inheritId;
  var layoutGroupContext = (0, React.useContext)(_LayoutGroupContext.LayoutGroupContext);
  var deprecatedLayoutGroupContext = (0, React.useContext)(_DeprecatedLayoutGroupContext.DeprecatedLayoutGroupContext);
  var _e = (0, _tslib.__read)((0, _useForceUpdate.useForceUpdate)(), 2),
    forceRender = _e[0],
    key = _e[1];
  var context = (0, React.useRef)(null);
  var upstreamId = (_b = layoutGroupContext.id) !== null && _b !== void 0 ? _b : deprecatedLayoutGroupContext;
  if (context.current === null) {
    if (shouldInheritId(inherit) && upstreamId) {
      id = id ? upstreamId + "-" + id : upstreamId;
    }
    context.current = {
      id: id,
      group: shouldInheritGroup(inherit) ? (_c = layoutGroupContext === null || layoutGroupContext === void 0 ? void 0 : layoutGroupContext.group) !== null && _c !== void 0 ? _c : (0, _group.nodeGroup)() : (0, _group.nodeGroup)()
    };
  }
  var memoizedContext = (0, React.useMemo)(function () {
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, context.current), {
      forceRender: forceRender
    });
  }, [key]);
  return React.createElement(_LayoutGroupContext.LayoutGroupContext.Provider, {
    value: memoizedContext
  }, children);
};
exports.LayoutGroup = LayoutGroup;
},{"tslib":"vCxL","react":"n8MK","../../context/LayoutGroupContext.mjs":"dh8B","../../context/DeprecatedLayoutGroupContext.mjs":"pJ5w","../../utils/use-force-update.mjs":"lEeZ","../../projection/node/group.mjs":"qwpB"}],"O5hi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimateSharedLayout = void 0;
var _heyListen = require("hey-listen");
var React = _interopRequireWildcard(require("react"));
var _useConstant = require("../utils/use-constant.mjs");
var _index = require("./LayoutGroup/index.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var id = 0;
var AnimateSharedLayout = function (_a) {
  var children = _a.children;
  React.useEffect(function () {
    (0, _heyListen.warning)(false, "AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations");
  }, []);
  return React.createElement(_index.LayoutGroup, {
    id: (0, _useConstant.useConstant)(function () {
      return "asl-".concat(id++);
    })
  }, children);
};
exports.AnimateSharedLayout = AnimateSharedLayout;
},{"hey-listen":"KFGT","react":"n8MK","../utils/use-constant.mjs":"XPaj","./LayoutGroup/index.mjs":"lIE0"}],"vn6c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MotionConfig = MotionConfig;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
var _MotionConfigContext = require("../../context/MotionConfigContext.mjs");
var _filterProps = require("../../render/dom/utils/filter-props.mjs");
var _useConstant = require("../../utils/use-constant.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * `MotionConfig` is used to set configuration options for all children `motion` components.
 *
 * ```jsx
 * import { motion, MotionConfig } from "framer-motion"
 *
 * export function App() {
 *   return (
 *     <MotionConfig transition={{ type: "spring" }}>
 *       <motion.div animate={{ x: 100 }} />
 *     </MotionConfig>
 *   )
 * }
 * ```
 *
 * @public
 */
function MotionConfig(_a) {
  var children = _a.children,
    isValidProp = _a.isValidProp,
    config = (0, _tslib.__rest)(_a, ["children", "isValidProp"]);
  isValidProp && (0, _filterProps.loadExternalIsValidProp)(isValidProp);
  /**
   * Inherit props from any parent MotionConfig components
   */
  config = (0, _tslib.__assign)((0, _tslib.__assign)({}, (0, React.useContext)(_MotionConfigContext.MotionConfigContext)), config);
  /**
   * Don't allow isStatic to change between renders as it affects how many hooks
   * motion components fire.
   */
  config.isStatic = (0, _useConstant.useConstant)(function () {
    return config.isStatic;
  });
  /**
   * Creating a new config context object will re-render every `motion` component
   * every time it renders. So we only want to create a new one sparingly.
   */
  var context = (0, React.useMemo)(function () {
    return config;
  }, [JSON.stringify(config.transition), config.transformPagePoint, config.reducedMotion]);
  return React.createElement(_MotionConfigContext.MotionConfigContext.Provider, {
    value: context
  }, children);
}
},{"tslib":"vCxL","react":"n8MK","../../context/MotionConfigContext.mjs":"dtoU","../../render/dom/utils/filter-props.mjs":"Rt1I","../../utils/use-constant.mjs":"XPaj"}],"i2Ei":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LazyMotion = LazyMotion;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
var _LazyContext = require("../../context/LazyContext.mjs");
var _definitions = require("../../motion/features/definitions.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Used in conjunction with the `m` component to reduce bundle size.
 *
 * `m` is a version of the `motion` component that only loads functionality
 * critical for the initial render.
 *
 * `LazyMotion` can then be used to either synchronously or asynchronously
 * load animation and gesture support.
 *
 * ```jsx
 * // Synchronous loading
 * import { LazyMotion, m, domAnimations } from "framer-motion"
 *
 * function App() {
 *   return (
 *     <LazyMotion features={domAnimations}>
 *       <m.div animate={{ scale: 2 }} />
 *     </LazyMotion>
 *   )
 * }
 *
 * // Asynchronous loading
 * import { LazyMotion, m } from "framer-motion"
 *
 * function App() {
 *   return (
 *     <LazyMotion features={() => import('./path/to/domAnimations')}>
 *       <m.div animate={{ scale: 2 }} />
 *     </LazyMotion>
 *   )
 * }
 * ```
 *
 * @public
 */
function LazyMotion(_a) {
  var children = _a.children,
    features = _a.features,
    _b = _a.strict,
    strict = _b === void 0 ? false : _b;
  var _c = (0, _tslib.__read)((0, React.useState)(!isLazyBundle(features)), 2),
    setIsLoaded = _c[1];
  var loadedRenderer = (0, React.useRef)(undefined);
  /**
   * If this is a synchronous load, load features immediately
   */
  if (!isLazyBundle(features)) {
    var renderer = features.renderer,
      loadedFeatures = (0, _tslib.__rest)(features, ["renderer"]);
    loadedRenderer.current = renderer;
    (0, _definitions.loadFeatures)(loadedFeatures);
  }
  (0, React.useEffect)(function () {
    if (isLazyBundle(features)) {
      features().then(function (_a) {
        var renderer = _a.renderer,
          loadedFeatures = (0, _tslib.__rest)(_a, ["renderer"]);
        (0, _definitions.loadFeatures)(loadedFeatures);
        loadedRenderer.current = renderer;
        setIsLoaded(true);
      });
    }
  }, []);
  return React.createElement(_LazyContext.LazyContext.Provider, {
    value: {
      renderer: loadedRenderer.current,
      strict: strict
    }
  }, children);
}
function isLazyBundle(features) {
  return typeof features === "function";
}
},{"tslib":"vCxL","react":"n8MK","../../context/LazyContext.mjs":"Y8MD","../../motion/features/definitions.mjs":"tAsV"}],"RnnB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReorderContext = void 0;
var _react = require("react");
var ReorderContext = (0, _react.createContext)(null);
exports.ReorderContext = ReorderContext;
},{"react":"n8MK"}],"gQVR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkReorder = checkReorder;
var _popmotion = require("popmotion");
var _array = require("../../../utils/array.mjs");
function checkReorder(order, value, offset, velocity) {
  if (!velocity) return order;
  var index = order.findIndex(function (item) {
    return item.value === value;
  });
  if (index === -1) return order;
  var nextOffset = velocity > 0 ? 1 : -1;
  var nextItem = order[index + nextOffset];
  if (!nextItem) return order;
  var item = order[index];
  var nextLayout = nextItem.layout;
  var nextItemCenter = (0, _popmotion.mix)(nextLayout.min, nextLayout.max, 0.5);
  if (nextOffset === 1 && item.layout.max + offset > nextItemCenter || nextOffset === -1 && item.layout.min + offset < nextItemCenter) {
    return (0, _array.moveItem)(order, index, index + nextOffset);
  }
  return order;
}
},{"popmotion":"KhgA","../../../utils/array.mjs":"la1d"}],"PA7c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Group = void 0;
exports.ReorderGroup = ReorderGroup;
var _tslib = require("tslib");
var _heyListen = require("hey-listen");
var React = _interopRequireWildcard(require("react"));
var _ReorderContext = require("../../context/ReorderContext.mjs");
var _motion = require("../../render/dom/motion.mjs");
var _useConstant = require("../../utils/use-constant.mjs");
var _checkReorder = require("./utils/check-reorder.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ReorderGroup(_a, externalRef) {
  var children = _a.children,
    _b = _a.as,
    as = _b === void 0 ? "ul" : _b,
    _c = _a.axis,
    axis = _c === void 0 ? "y" : _c,
    onReorder = _a.onReorder,
    values = _a.values,
    props = (0, _tslib.__rest)(_a, ["children", "as", "axis", "onReorder", "values"]);
  var Component = (0, _useConstant.useConstant)(function () {
    return (0, _motion.motion)(as);
  });
  var order = [];
  var isReordering = (0, React.useRef)(false);
  (0, _heyListen.invariant)(Boolean(values), "Reorder.Group must be provided a values prop");
  var context = {
    axis: axis,
    registerItem: function (value, layout) {
      /**
       * Ensure entries can't add themselves more than once
       */
      if (layout && order.findIndex(function (entry) {
        return value === entry.value;
      }) === -1) {
        order.push({
          value: value,
          layout: layout[axis]
        });
        order.sort(compareMin);
      }
    },
    updateOrder: function (id, offset, velocity) {
      if (isReordering.current) return;
      var newOrder = (0, _checkReorder.checkReorder)(order, id, offset, velocity);
      if (order !== newOrder) {
        isReordering.current = true;
        onReorder(newOrder.map(getValue).filter(function (value) {
          return values.indexOf(value) !== -1;
        }));
      }
    }
  };
  (0, React.useEffect)(function () {
    isReordering.current = false;
  });
  return React.createElement(Component, (0, _tslib.__assign)({}, props, {
    ref: externalRef
  }), React.createElement(_ReorderContext.ReorderContext.Provider, {
    value: context
  }, children));
}
var Group = (0, React.forwardRef)(ReorderGroup);
exports.Group = Group;
function getValue(item) {
  return item.value;
}
function compareMin(a, b) {
  return a.layout.min - b.layout.min;
}
},{"tslib":"vCxL","hey-listen":"KFGT","react":"n8MK","../../context/ReorderContext.mjs":"RnnB","../../render/dom/motion.mjs":"g8vb","../../utils/use-constant.mjs":"XPaj","./utils/check-reorder.mjs":"gQVR"}],"g4mR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMotionValue = useMotionValue;
var _tslib = require("tslib");
var _react = require("react");
var _index = require("./index.mjs");
var _MotionConfigContext = require("../context/MotionConfigContext.mjs");
var _useConstant = require("../utils/use-constant.mjs");
/**
 * Creates a `MotionValue` to track the state and velocity of a value.
 *
 * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.
 *
 * ```jsx
 * export const MyComponent = () => {
 *   const scale = useMotionValue(1)
 *
 *   return <motion.div style={{ scale }} />
 * }
 * ```
 *
 * @param initial - The initial state.
 *
 * @public
 */
function useMotionValue(initial) {
  var value = (0, _useConstant.useConstant)(function () {
    return (0, _index.motionValue)(initial);
  });
  /**
   * If this motion value is being used in static mode, like on
   * the Framer canvas, force components to rerender when the motion
   * value is updated.
   */
  var isStatic = (0, _react.useContext)(_MotionConfigContext.MotionConfigContext).isStatic;
  if (isStatic) {
    var _a = (0, _tslib.__read)((0, _react.useState)(initial), 2),
      setLatest_1 = _a[1];
    (0, _react.useEffect)(function () {
      return value.onChange(setLatest_1);
    }, []);
  }
  return value;
}
},{"tslib":"vCxL","react":"n8MK","./index.mjs":"PQTd","../context/MotionConfigContext.mjs":"dtoU","../utils/use-constant.mjs":"XPaj"}],"by1U":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform = transform;
var _tslib = require("tslib");
var _popmotion = require("popmotion");
var isCustomValueType = function (v) {
  return typeof v === "object" && v.mix;
};
var getMixer = function (v) {
  return isCustomValueType(v) ? v.mix : undefined;
};
function transform() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var useImmediate = !Array.isArray(args[0]);
  var argOffset = useImmediate ? 0 : -1;
  var inputValue = args[0 + argOffset];
  var inputRange = args[1 + argOffset];
  var outputRange = args[2 + argOffset];
  var options = args[3 + argOffset];
  var interpolator = (0, _popmotion.interpolate)(inputRange, outputRange, (0, _tslib.__assign)({
    mixer: getMixer(outputRange[0])
  }, options));
  return useImmediate ? interpolator(inputValue) : interpolator;
}
},{"tslib":"vCxL","popmotion":"KhgA"}],"mmTv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMultiOnChange = useMultiOnChange;
exports.useOnChange = useOnChange;
var _isMotionValue = require("./utils/is-motion-value.mjs");
var _useIsomorphicEffect = require("../utils/use-isomorphic-effect.mjs");
function useOnChange(value, callback) {
  (0, _useIsomorphicEffect.useIsomorphicLayoutEffect)(function () {
    if ((0, _isMotionValue.isMotionValue)(value)) return value.onChange(callback);
  }, [callback]);
}
function useMultiOnChange(values, handler) {
  (0, _useIsomorphicEffect.useIsomorphicLayoutEffect)(function () {
    var subscriptions = values.map(function (value) {
      return value.onChange(handler);
    });
    return function () {
      return subscriptions.forEach(function (unsubscribe) {
        return unsubscribe();
      });
    };
  });
}
},{"./utils/is-motion-value.mjs":"XNB1","../utils/use-isomorphic-effect.mjs":"tqWN"}],"iyMT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCombineMotionValues = useCombineMotionValues;
var _useMotionValue = require("./use-motion-value.mjs");
var _useOnChange = require("./use-on-change.mjs");
var _framesync = _interopRequireDefault(require("framesync"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function useCombineMotionValues(values, combineValues) {
  /**
   * Initialise the returned motion value. This remains the same between renders.
   */
  var value = (0, _useMotionValue.useMotionValue)(combineValues());
  /**
   * Create a function that will update the template motion value with the latest values.
   * This is pre-bound so whenever a motion value updates it can schedule its
   * execution in Framesync. If it's already been scheduled it won't be fired twice
   * in a single frame.
   */
  var updateValue = function () {
    return value.set(combineValues());
  };
  /**
   * Synchronously update the motion value with the latest values during the render.
   * This ensures that within a React render, the styles applied to the DOM are up-to-date.
   */
  updateValue();
  /**
   * Subscribe to all motion values found within the template. Whenever any of them change,
   * schedule an update.
   */
  (0, _useOnChange.useMultiOnChange)(values, function () {
    return _framesync.default.update(updateValue, false, true);
  });
  return value;
}
},{"./use-motion-value.mjs":"g4mR","./use-on-change.mjs":"mmTv","framesync":"KvxD"}],"uy6A":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTransform = useTransform;
var _tslib = require("tslib");
var _transform = require("../utils/transform.mjs");
var _useCombineValues = require("./use-combine-values.mjs");
var _useConstant = require("../utils/use-constant.mjs");
function useTransform(input, inputRangeOrTransformer, outputRange, options) {
  var transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : (0, _transform.transform)(inputRangeOrTransformer, outputRange, options);
  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], function (_a) {
    var _b = (0, _tslib.__read)(_a, 1),
      latest = _b[0];
    return transformer(latest);
  });
}
function useListTransform(values, transformer) {
  var latest = (0, _useConstant.useConstant)(function () {
    return [];
  });
  return (0, _useCombineValues.useCombineMotionValues)(values, function () {
    latest.length = 0;
    var numValues = values.length;
    for (var i = 0; i < numValues; i++) {
      latest[i] = values[i].get();
    }
    return transformer(latest);
  });
}
},{"tslib":"vCxL","../utils/transform.mjs":"by1U","./use-combine-values.mjs":"iyMT","../utils/use-constant.mjs":"XPaj"}],"MnNf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Item = void 0;
exports.ReorderItem = ReorderItem;
var _tslib = require("tslib");
var _heyListen = require("hey-listen");
var React = _interopRequireWildcard(require("react"));
var _ReorderContext = require("../../context/ReorderContext.mjs");
var _motion = require("../../render/dom/motion.mjs");
var _useConstant = require("../../utils/use-constant.mjs");
var _useMotionValue = require("../../value/use-motion-value.mjs");
var _useTransform = require("../../value/use-transform.mjs");
var _isMotionValue = require("../../value/utils/is-motion-value.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useDefaultMotionValue(value, defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = 0;
  }
  return (0, _isMotionValue.isMotionValue)(value) ? value : (0, _useMotionValue.useMotionValue)(defaultValue);
}
function ReorderItem(_a, externalRef) {
  var children = _a.children,
    style = _a.style,
    value = _a.value,
    _b = _a.as,
    as = _b === void 0 ? "li" : _b,
    onDrag = _a.onDrag,
    _c = _a.layout,
    layout = _c === void 0 ? true : _c,
    props = (0, _tslib.__rest)(_a, ["children", "style", "value", "as", "onDrag", "layout"]);
  var Component = (0, _useConstant.useConstant)(function () {
    return (0, _motion.motion)(as);
  });
  var context = (0, React.useContext)(_ReorderContext.ReorderContext);
  var point = {
    x: useDefaultMotionValue(style === null || style === void 0 ? void 0 : style.x),
    y: useDefaultMotionValue(style === null || style === void 0 ? void 0 : style.y)
  };
  var zIndex = (0, _useTransform.useTransform)([point.x, point.y], function (_a) {
    var _b = (0, _tslib.__read)(_a, 2),
      latestX = _b[0],
      latestY = _b[1];
    return latestX || latestY ? 1 : "unset";
  });
  var measuredLayout = (0, React.useRef)(null);
  (0, _heyListen.invariant)(Boolean(context), "Reorder.Item must be a child of Reorder.Group");
  var _d = context,
    axis = _d.axis,
    registerItem = _d.registerItem,
    updateOrder = _d.updateOrder;
  (0, React.useEffect)(function () {
    registerItem(value, measuredLayout.current);
  }, [context]);
  return React.createElement(Component, (0, _tslib.__assign)({
    drag: axis
  }, props, {
    dragSnapToOrigin: true,
    style: (0, _tslib.__assign)((0, _tslib.__assign)({}, style), {
      x: point.x,
      y: point.y,
      zIndex: zIndex
    }),
    layout: layout,
    onDrag: function (event, gesturePoint) {
      var velocity = gesturePoint.velocity;
      velocity[axis] && updateOrder(value, point[axis].get(), velocity[axis]);
      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, gesturePoint);
    },
    onLayoutMeasure: function (measured) {
      measuredLayout.current = measured;
    },
    ref: externalRef
  }), children);
}
var Item = (0, React.forwardRef)(ReorderItem);
exports.Item = Item;
},{"tslib":"vCxL","hey-listen":"KFGT","react":"n8MK","../../context/ReorderContext.mjs":"RnnB","../../render/dom/motion.mjs":"g8vb","../../utils/use-constant.mjs":"XPaj","../../value/use-motion-value.mjs":"g4mR","../../value/use-transform.mjs":"uy6A","../../value/utils/is-motion-value.mjs":"XNB1"}],"Ow6O":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Reorder = void 0;
var _Group = require("./Group.mjs");
var _Item = require("./Item.mjs");
var Reorder = {
  Group: _Group.Group,
  Item: _Item.Item
};
exports.Reorder = Reorder;
},{"./Group.mjs":"PA7c","./Item.mjs":"MnNf"}],"EKP7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.domAnimation = void 0;
var _tslib = require("tslib");
var _animations = require("../../motion/features/animations.mjs");
var _gestures = require("../../motion/features/gestures.mjs");
var _createVisualElement = require("./create-visual-element.mjs");
/**
 * @public
 */
var domAnimation = (0, _tslib.__assign)((0, _tslib.__assign)({
  renderer: _createVisualElement.createDomVisualElement
}, _animations.animations), _gestures.gestureAnimations);
exports.domAnimation = domAnimation;
},{"tslib":"vCxL","../../motion/features/animations.mjs":"V8nK","../../motion/features/gestures.mjs":"MzEU","./create-visual-element.mjs":"b462"}],"kXnc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.domMax = void 0;
var _tslib = require("tslib");
var _drag = require("../../motion/features/drag.mjs");
var _index = require("../../motion/features/layout/index.mjs");
var _featuresAnimation = require("./features-animation.mjs");
var _HTMLProjectionNode = require("../../projection/node/HTMLProjectionNode.mjs");
/**
 * @public
 */
var domMax = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, _featuresAnimation.domAnimation), _drag.drag), _index.layoutFeatures), {
  projectionNodeConstructor: _HTMLProjectionNode.HTMLProjectionNode
});
exports.domMax = domMax;
},{"tslib":"vCxL","../../motion/features/drag.mjs":"Q4DW","../../motion/features/layout/index.mjs":"gk0r","./features-animation.mjs":"EKP7","../../projection/node/HTMLProjectionNode.mjs":"w8YZ"}],"jGDL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMotionTemplate = useMotionTemplate;
var _useCombineValues = require("./use-combine-values.mjs");
/**
 * Combine multiple motion values into a new one using a string template literal.
 *
 * ```jsx
 * import {
 *   motion,
 *   useSpring,
 *   useMotionValue,
 *   useMotionTemplate
 * } from "framer-motion"
 *
 * function Component() {
 *   const shadowX = useSpring(0)
 *   const shadowY = useMotionValue(0)
 *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`
 *
 *   return <motion.div style={{ filter: shadow }} />
 * }
 * ```
 *
 * @public
 */
function useMotionTemplate(fragments) {
  var values = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }
  /**
   * Create a function that will build a string from the latest motion values.
   */
  var numFragments = fragments.length;
  function buildValue() {
    var output = "";
    for (var i = 0; i < numFragments; i++) {
      output += fragments[i];
      var value = values[i];
      if (value) output += values[i].get();
    }
    return output;
  }
  return (0, _useCombineValues.useCombineMotionValues)(values, buildValue);
}
},{"./use-combine-values.mjs":"iyMT"}],"FQQL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSpring = useSpring;
var _tslib = require("tslib");
var _react = require("react");
var _popmotion = require("popmotion");
var _isMotionValue = require("./utils/is-motion-value.mjs");
var _useMotionValue = require("./use-motion-value.mjs");
var _useOnChange = require("./use-on-change.mjs");
var _MotionConfigContext = require("../context/MotionConfigContext.mjs");
/**
 * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.
 *
 * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber
 * to another `MotionValue`.
 *
 * @remarks
 *
 * ```jsx
 * const x = useSpring(0, { stiffness: 300 })
 * const y = useSpring(x, { damping: 10 })
 * ```
 *
 * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.
 * @param springConfig - Configuration options for the spring.
 * @returns `MotionValue`
 *
 * @public
 */
function useSpring(source, config) {
  if (config === void 0) {
    config = {};
  }
  var isStatic = (0, _react.useContext)(_MotionConfigContext.MotionConfigContext).isStatic;
  var activeSpringAnimation = (0, _react.useRef)(null);
  var value = (0, _useMotionValue.useMotionValue)((0, _isMotionValue.isMotionValue)(source) ? source.get() : source);
  (0, _react.useMemo)(function () {
    return value.attach(function (v, set) {
      /**
       * A more hollistic approach to this might be to use isStatic to fix VisualElement animations
       * at that level, but this will work for now
       */
      if (isStatic) return set(v);
      if (activeSpringAnimation.current) {
        activeSpringAnimation.current.stop();
      }
      activeSpringAnimation.current = (0, _popmotion.animate)((0, _tslib.__assign)((0, _tslib.__assign)({
        from: value.get(),
        to: v,
        velocity: value.getVelocity()
      }, config), {
        onUpdate: set
      }));
      return value.get();
    });
  }, [JSON.stringify(config)]);
  (0, _useOnChange.useOnChange)(source, function (v) {
    return value.set(parseFloat(v));
  });
  return value;
}
},{"tslib":"vCxL","react":"n8MK","popmotion":"KhgA","./utils/is-motion-value.mjs":"XNB1","./use-motion-value.mjs":"g4mR","./use-on-change.mjs":"mmTv","../context/MotionConfigContext.mjs":"dtoU"}],"Co8D":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useVelocity = useVelocity;
var _react = require("react");
var _useMotionValue = require("./use-motion-value.mjs");
/**
 * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.
 *
 * ```javascript
 * const x = useMotionValue(0)
 * const xVelocity = useVelocity(x)
 * const xAcceleration = useVelocity(xVelocity)
 * ```
 *
 * @public
 */
function useVelocity(value) {
  var velocity = (0, _useMotionValue.useMotionValue)(value.getVelocity());
  (0, _react.useEffect)(function () {
    return value.velocityUpdateSubscribers.add(function (newVelocity) {
      velocity.set(newVelocity);
    });
  }, [value]);
  return velocity;
}
},{"react":"n8MK","./use-motion-value.mjs":"g4mR"}],"OKzR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MotionValue = void 0;
/**
 * The MotionValue tracks the state of a single animatable
 * value. Currently, updatedAt and current are unused. The
 * long term idea is to use this to minimise the number
 * of DOM reads, and to abstract the DOM interactions here.
 */
class MotionValue {
  setAnimation(animation) {
    this.animation = animation;
    animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => {});
  }
  clearAnimation() {
    this.animation = this.generator = undefined;
  }
}
exports.MotionValue = MotionValue;
},{}],"qkev":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "MotionValue", {
  enumerable: true,
  get: function () {
    return _MotionValueEs.MotionValue;
  }
});
var _MotionValueEs = require("./MotionValue.es.js");
},{"./MotionValue.es.js":"OKzR"}],"gR3x":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAnimationData = getAnimationData;
exports.getMotionValue = getMotionValue;
var _types = require("@motionone/types");
const data = new WeakMap();
function getAnimationData(element) {
  if (!data.has(element)) {
    data.set(element, {
      transforms: [],
      values: new Map()
    });
  }
  return data.get(element);
}
function getMotionValue(motionValues, name) {
  if (!motionValues.has(name)) {
    motionValues.set(name, new _types.MotionValue());
  }
  return motionValues.get(name);
}
},{"@motionone/types":"qkev"}],"VSjm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addUniqueItem = addUniqueItem;
exports.removeItem = removeItem;
function addUniqueItem(array, item) {
  array.indexOf(item) === -1 && array.push(item);
}
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  index > -1 && arr.splice(index, 1);
}
},{}],"gG0b":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaults = void 0;
const defaults = {
  duration: 0.3,
  delay: 0,
  endDelay: 0,
  repeat: 0,
  easing: "ease"
};
exports.defaults = defaults;
},{}],"HPp1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNumber = void 0;
const isNumber = value => typeof value === "number";
exports.isNumber = isNumber;
},{}],"SXko":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEasingList = void 0;
var _isNumberEs = require("./is-number.es.js");
const isEasingList = easing => Array.isArray(easing) && !(0, _isNumberEs.isNumber)(easing[0]);
exports.isEasingList = isEasingList;
},{"./is-number.es.js":"HPp1"}],"Ckz0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEasingForSegment = getEasingForSegment;
var _isEasingListEs = require("./is-easing-list.es.js");
var _wrapEs = require("./wrap.es.js");
function getEasingForSegment(easing, i) {
  return (0, _isEasingListEs.isEasingList)(easing) ? easing[(0, _wrapEs.wrap)(0, easing.length, i)] : easing;
}
},{"./is-easing-list.es.js":"SXko","./wrap.es.js":"QkXe"}],"HAzk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mix = void 0;
const mix = (min, max, progress) => -progress * min + progress * max + min;
exports.mix = mix;
},{}],"WvGz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noopReturn = exports.noop = void 0;
const noop = () => {};
exports.noop = noop;
const noopReturn = v => v;
exports.noopReturn = noopReturn;
},{}],"xXqd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.progress = void 0;
const progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);
exports.progress = progress;
},{}],"BqMH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultOffset = defaultOffset;
exports.fillOffset = fillOffset;
var _mixEs = require("./mix.es.js");
var _progressEs = require("./progress.es.js");
function fillOffset(offset, remaining) {
  const min = offset[offset.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = (0, _progressEs.progress)(0, remaining, i);
    offset.push((0, _mixEs.mix)(min, 1, offsetProgress));
  }
}
function defaultOffset(length) {
  const offset = [0];
  fillOffset(offset, length - 1);
  return offset;
}
},{"./mix.es.js":"HAzk","./progress.es.js":"xXqd"}],"CpgM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interpolate = interpolate;
var _mixEs = require("./mix.es.js");
var _noopEs = require("./noop.es.js");
var _offsetEs = require("./offset.es.js");
var _progressEs = require("./progress.es.js");
var _easingEs = require("./easing.es.js");
var _clampEs = require("./clamp.es.js");
function interpolate(output, input = (0, _offsetEs.defaultOffset)(output.length), easing = _noopEs.noopReturn) {
  const length = output.length;
  /**
   * If the input length is lower than the output we
   * fill the input to match. This currently assumes the input
   * is an animation progress value so is a good candidate for
   * moving outside the function.
   */
  const remainder = length - input.length;
  remainder > 0 && (0, _offsetEs.fillOffset)(input, remainder);
  return t => {
    let i = 0;
    for (; i < length - 2; i++) {
      if (t < input[i + 1]) break;
    }
    let progressInRange = (0, _clampEs.clamp)(0, 1, (0, _progressEs.progress)(input[i], input[i + 1], t));
    const segmentEasing = (0, _easingEs.getEasingForSegment)(easing, i);
    progressInRange = segmentEasing(progressInRange);
    return (0, _mixEs.mix)(output[i], output[i + 1], progressInRange);
  };
}
},{"./mix.es.js":"HAzk","./noop.es.js":"WvGz","./offset.es.js":"BqMH","./progress.es.js":"xXqd","./easing.es.js":"Ckz0","./clamp.es.js":"xkQy"}],"K0Dc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCubicBezier = void 0;
var _isNumberEs = require("./is-number.es.js");
const isCubicBezier = easing => Array.isArray(easing) && (0, _isNumberEs.isNumber)(easing[0]);
exports.isCubicBezier = isCubicBezier;
},{"./is-number.es.js":"HPp1"}],"tDjW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEasingGenerator = void 0;
const isEasingGenerator = easing => typeof easing === "object" && Boolean(easing.createAnimation);
exports.isEasingGenerator = isEasingGenerator;
},{}],"sjVb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunction = void 0;
const isFunction = value => typeof value === "function";
exports.isFunction = isFunction;
},{}],"Solh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isString = void 0;
const isString = value => typeof value === "string";
exports.isString = isString;
},{}],"tOc7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.time = void 0;
const time = {
  ms: seconds => seconds * 1000,
  s: milliseconds => milliseconds / 1000
};
exports.time = time;
},{}],"jedc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.velocityPerSecond = velocityPerSecond;
/*
  Convert velocity into velocity per second

  @param [number]: Unit per frame
  @param [number]: Frame duration in ms
*/
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1000 / frameDuration) : 0;
}
},{}],"tYSI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "addUniqueItem", {
  enumerable: true,
  get: function () {
    return _arrayEs.addUniqueItem;
  }
});
Object.defineProperty(exports, "clamp", {
  enumerable: true,
  get: function () {
    return _clampEs.clamp;
  }
});
Object.defineProperty(exports, "defaultOffset", {
  enumerable: true,
  get: function () {
    return _offsetEs.defaultOffset;
  }
});
Object.defineProperty(exports, "defaults", {
  enumerable: true,
  get: function () {
    return _defaultsEs.defaults;
  }
});
Object.defineProperty(exports, "fillOffset", {
  enumerable: true,
  get: function () {
    return _offsetEs.fillOffset;
  }
});
Object.defineProperty(exports, "getEasingForSegment", {
  enumerable: true,
  get: function () {
    return _easingEs.getEasingForSegment;
  }
});
Object.defineProperty(exports, "interpolate", {
  enumerable: true,
  get: function () {
    return _interpolateEs.interpolate;
  }
});
Object.defineProperty(exports, "isCubicBezier", {
  enumerable: true,
  get: function () {
    return _isCubicBezierEs.isCubicBezier;
  }
});
Object.defineProperty(exports, "isEasingGenerator", {
  enumerable: true,
  get: function () {
    return _isEasingGeneratorEs.isEasingGenerator;
  }
});
Object.defineProperty(exports, "isEasingList", {
  enumerable: true,
  get: function () {
    return _isEasingListEs.isEasingList;
  }
});
Object.defineProperty(exports, "isFunction", {
  enumerable: true,
  get: function () {
    return _isFunctionEs.isFunction;
  }
});
Object.defineProperty(exports, "isNumber", {
  enumerable: true,
  get: function () {
    return _isNumberEs.isNumber;
  }
});
Object.defineProperty(exports, "isString", {
  enumerable: true,
  get: function () {
    return _isStringEs.isString;
  }
});
Object.defineProperty(exports, "mix", {
  enumerable: true,
  get: function () {
    return _mixEs.mix;
  }
});
Object.defineProperty(exports, "noop", {
  enumerable: true,
  get: function () {
    return _noopEs.noop;
  }
});
Object.defineProperty(exports, "noopReturn", {
  enumerable: true,
  get: function () {
    return _noopEs.noopReturn;
  }
});
Object.defineProperty(exports, "progress", {
  enumerable: true,
  get: function () {
    return _progressEs.progress;
  }
});
Object.defineProperty(exports, "removeItem", {
  enumerable: true,
  get: function () {
    return _arrayEs.removeItem;
  }
});
Object.defineProperty(exports, "time", {
  enumerable: true,
  get: function () {
    return _timeEs.time;
  }
});
Object.defineProperty(exports, "velocityPerSecond", {
  enumerable: true,
  get: function () {
    return _velocityEs.velocityPerSecond;
  }
});
Object.defineProperty(exports, "wrap", {
  enumerable: true,
  get: function () {
    return _wrapEs.wrap;
  }
});
var _arrayEs = require("./array.es.js");
var _clampEs = require("./clamp.es.js");
var _defaultsEs = require("./defaults.es.js");
var _easingEs = require("./easing.es.js");
var _interpolateEs = require("./interpolate.es.js");
var _isCubicBezierEs = require("./is-cubic-bezier.es.js");
var _isEasingGeneratorEs = require("./is-easing-generator.es.js");
var _isEasingListEs = require("./is-easing-list.es.js");
var _isFunctionEs = require("./is-function.es.js");
var _isNumberEs = require("./is-number.es.js");
var _isStringEs = require("./is-string.es.js");
var _mixEs = require("./mix.es.js");
var _noopEs = require("./noop.es.js");
var _offsetEs = require("./offset.es.js");
var _progressEs = require("./progress.es.js");
var _timeEs = require("./time.es.js");
var _velocityEs = require("./velocity.es.js");
var _wrapEs = require("./wrap.es.js");
},{"./array.es.js":"VSjm","./clamp.es.js":"xkQy","./defaults.es.js":"gG0b","./easing.es.js":"Ckz0","./interpolate.es.js":"CpgM","./is-cubic-bezier.es.js":"K0Dc","./is-easing-generator.es.js":"tDjW","./is-easing-list.es.js":"SXko","./is-function.es.js":"sjVb","./is-number.es.js":"HPp1","./is-string.es.js":"Solh","./mix.es.js":"HAzk","./noop.es.js":"WvGz","./offset.es.js":"BqMH","./progress.es.js":"xXqd","./time.es.js":"tOc7","./velocity.es.js":"jedc","./wrap.es.js":"QkXe"}],"KAJF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformDefinitions = exports.transformAlias = exports.isTransform = exports.compareTransformOrder = exports.buildTransformTemplate = exports.axes = exports.asTransformCssVar = exports.addTransformToElement = void 0;
var _utils = require("@motionone/utils");
var _dataEs = require("../data.es.js");
/**
 * A list of all transformable axes. We'll use this list to generated a version
 * of each axes for each transform.
 */
const axes = ["", "X", "Y", "Z"];
/**
 * An ordered array of each transformable value. By default, transform values
 * will be sorted to this order.
 */
exports.axes = axes;
const order = ["translate", "scale", "rotate", "skew"];
const transformAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ"
};
exports.transformAlias = transformAlias;
const rotation = {
  syntax: "<angle>",
  initialValue: "0deg",
  toDefaultUnit: v => v + "deg"
};
const baseTransformProperties = {
  translate: {
    syntax: "<length-percentage>",
    initialValue: "0px",
    toDefaultUnit: v => v + "px"
  },
  rotate: rotation,
  scale: {
    syntax: "<number>",
    initialValue: 1,
    toDefaultUnit: _utils.noopReturn
  },
  skew: rotation
};
const transformDefinitions = new Map();
exports.transformDefinitions = transformDefinitions;
const asTransformCssVar = name => `--motion-${name}`;
/**
 * Generate a list of every possible transform key
 */
exports.asTransformCssVar = asTransformCssVar;
const transforms = ["x", "y", "z"];
order.forEach(name => {
  axes.forEach(axis => {
    transforms.push(name + axis);
    transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);
  });
});
/**
 * A function to use with Array.sort to sort transform keys by their default order.
 */
const compareTransformOrder = (a, b) => transforms.indexOf(a) - transforms.indexOf(b);
/**
 * Provide a quick way to check if a string is the name of a transform
 */
exports.compareTransformOrder = compareTransformOrder;
const transformLookup = new Set(transforms);
const isTransform = name => transformLookup.has(name);
exports.isTransform = isTransform;
const addTransformToElement = (element, name) => {
  // Map x to translateX etc
  if (transformAlias[name]) name = transformAlias[name];
  const {
    transforms
  } = (0, _dataEs.getAnimationData)(element);
  (0, _utils.addUniqueItem)(transforms, name);
  /**
   * TODO: An optimisation here could be to cache the transform in element data
   * and only update if this has changed.
   */
  element.style.transform = buildTransformTemplate(transforms);
};
exports.addTransformToElement = addTransformToElement;
const buildTransformTemplate = transforms => transforms.sort(compareTransformOrder).reduce(transformListToString, "").trim();
exports.buildTransformTemplate = buildTransformTemplate;
const transformListToString = (template, name) => `${template} ${name}(var(${asTransformCssVar(name)}))`;
},{"@motionone/utils":"tYSI","../data.es.js":"gR3x"}],"fHRu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCssVar = void 0;
exports.registerCssVariable = registerCssVariable;
exports.registeredProperties = void 0;
var _transformsEs = require("./transforms.es.js");
const isCssVar = name => name.startsWith("--");
exports.isCssVar = isCssVar;
const registeredProperties = new Set();
exports.registeredProperties = registeredProperties;
function registerCssVariable(name) {
  if (registeredProperties.has(name)) return;
  registeredProperties.add(name);
  try {
    const {
      syntax,
      initialValue
    } = _transformsEs.transformDefinitions.has(name) ? _transformsEs.transformDefinitions.get(name) : {};
    CSS.registerProperty({
      name,
      inherits: false,
      syntax,
      initialValue
    });
  } catch (e) {}
}
},{"./transforms.es.js":"KAJF"}],"e85p":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cubicBezier = cubicBezier;
var _utils = require("@motionone/utils");
/*
  Bezier function generator

  This has been modified from Gaëtan Renaudeau's BezierEasing
  https://github.com/gre/bezier-easing/blob/master/src/index.js
  https://github.com/gre/bezier-easing/blob/master/LICENSE
  
  I've removed the newtonRaphsonIterate algo because in benchmarking it
  wasn't noticiably faster than binarySubdivision, indeed removing it
  usually improved times, depending on the curve.

  I also removed the lookup table, as for the added bundle size and loop we're
  only cutting ~4 or so subdivision iterations. I bumped the max iterations up
  to 12 to compensate and this still tended to be faster for no perceivable
  loss in accuracy.

  Usage
    const easeOut = cubicBezier(.17,.67,.83,.67);
    const x = easeOut(0.5); // returns 0.627...
*/
// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
const calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;
const subdivisionPrecision = 0.0000001;
const subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - x;
    if (currentX > 0.0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  // If this is a linear gradient, return linear easing
  if (mX1 === mY1 && mX2 === mY2) return _utils.noopReturn;
  const getTForX = aX => binarySubdivide(aX, 0, 1, mX1, mX2);
  // If animation is at start/end, return t without easing
  return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}
},{"@motionone/utils":"tYSI"}],"ah2D":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.steps = void 0;
var _utils = require("@motionone/utils");
const steps = (steps, direction = "end") => progress => {
  progress = direction === "end" ? Math.min(progress, 0.999) : Math.max(progress, 0.001);
  const expanded = progress * steps;
  const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
  return (0, _utils.clamp)(0, 1, rounded / steps);
};
exports.steps = steps;
},{"@motionone/utils":"tYSI"}],"XYBE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "cubicBezier", {
  enumerable: true,
  get: function () {
    return _cubicBezierEs.cubicBezier;
  }
});
Object.defineProperty(exports, "steps", {
  enumerable: true,
  get: function () {
    return _stepsEs.steps;
  }
});
var _cubicBezierEs = require("./cubic-bezier.es.js");
var _stepsEs = require("./steps.es.js");
},{"./cubic-bezier.es.js":"e85p","./steps.es.js":"ah2D"}],"H5Xc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEasingFunction = getEasingFunction;
var _easing = require("@motionone/easing");
var _utils = require("@motionone/utils");
const namedEasings = {
  ease: (0, _easing.cubicBezier)(0.25, 0.1, 0.25, 1.0),
  "ease-in": (0, _easing.cubicBezier)(0.42, 0.0, 1.0, 1.0),
  "ease-in-out": (0, _easing.cubicBezier)(0.42, 0.0, 0.58, 1.0),
  "ease-out": (0, _easing.cubicBezier)(0.0, 0.0, 0.58, 1.0)
};
const functionArgsRegex = /\((.*?)\)/;
function getEasingFunction(definition) {
  // If already an easing function, return
  if ((0, _utils.isFunction)(definition)) return definition;
  // If an easing curve definition, return bezier function
  if ((0, _utils.isCubicBezier)(definition)) return (0, _easing.cubicBezier)(...definition);
  // If we have a predefined easing function, return
  if (namedEasings[definition]) return namedEasings[definition];
  // If this is a steps function, attempt to create easing curve
  if (definition.startsWith("steps")) {
    const args = functionArgsRegex.exec(definition);
    if (args) {
      const argsArray = args[1].split(",");
      return (0, _easing.steps)(parseFloat(argsArray[0]), argsArray[1].trim());
    }
  }
  return _utils.noopReturn;
}
},{"@motionone/easing":"XYBE","@motionone/utils":"tYSI"}],"EGYz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Animation = void 0;
var _utils = require("@motionone/utils");
var _easingEs = require("./utils/easing.es.js");
class Animation {
  constructor(output, keyframes = [0, 1], {
    easing,
    duration: initialDuration = _utils.defaults.duration,
    delay = _utils.defaults.delay,
    endDelay = _utils.defaults.endDelay,
    repeat = _utils.defaults.repeat,
    offset,
    direction = "normal"
  } = {}) {
    this.startTime = null;
    this.rate = 1;
    this.t = 0;
    this.cancelTimestamp = null;
    this.easing = _utils.noopReturn;
    this.duration = 0;
    this.totalDuration = 0;
    this.repeat = 0;
    this.playState = "idle";
    this.finished = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
    easing = easing || _utils.defaults.easing;
    if ((0, _utils.isEasingGenerator)(easing)) {
      const custom = easing.createAnimation(keyframes);
      easing = custom.easing;
      keyframes = custom.keyframes || keyframes;
      initialDuration = custom.duration || initialDuration;
    }
    this.repeat = repeat;
    this.easing = (0, _utils.isEasingList)(easing) ? _utils.noopReturn : (0, _easingEs.getEasingFunction)(easing);
    this.updateDuration(initialDuration);
    const interpolate$1 = (0, _utils.interpolate)(keyframes, offset, (0, _utils.isEasingList)(easing) ? easing.map(_easingEs.getEasingFunction) : _utils.noopReturn);
    this.tick = timestamp => {
      var _a;
      // TODO: Temporary fix for OptionsResolver typing
      delay = delay;
      let t = 0;
      if (this.pauseTime !== undefined) {
        t = this.pauseTime;
      } else {
        t = (timestamp - this.startTime) * this.rate;
      }
      this.t = t;
      // Convert to seconds
      t /= 1000;
      // Rebase on delay
      t = Math.max(t - delay, 0);
      /**
       * If this animation has finished, set the current time
       * to the total duration.
       */
      if (this.playState === "finished" && this.pauseTime === undefined) {
        t = this.totalDuration;
      }
      /**
       * Get the current progress (0-1) of the animation. If t is >
       * than duration we'll get values like 2.5 (midway through the
       * third iteration)
       */
      const progress = t / this.duration;
      // TODO progress += iterationStart
      /**
       * Get the current iteration (0 indexed). For instance the floor of
       * 2.5 is 2.
       */
      let currentIteration = Math.floor(progress);
      /**
       * Get the current progress of the iteration by taking the remainder
       * so 2.5 is 0.5 through iteration 2
       */
      let iterationProgress = progress % 1.0;
      if (!iterationProgress && progress >= 1) {
        iterationProgress = 1;
      }
      /**
       * If iteration progress is 1 we count that as the end
       * of the previous iteration.
       */
      iterationProgress === 1 && currentIteration--;
      /**
       * Reverse progress if we're not running in "normal" direction
       */
      const iterationIsOdd = currentIteration % 2;
      if (direction === "reverse" || direction === "alternate" && iterationIsOdd || direction === "alternate-reverse" && !iterationIsOdd) {
        iterationProgress = 1 - iterationProgress;
      }
      const p = t >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);
      const latest = interpolate$1(this.easing(p));
      output(latest);
      const isAnimationFinished = this.pauseTime === undefined && (this.playState === "finished" || t >= this.totalDuration + endDelay);
      if (isAnimationFinished) {
        this.playState = "finished";
        (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);
      } else if (this.playState !== "idle") {
        this.frameRequestId = requestAnimationFrame(this.tick);
      }
    };
    this.play();
  }
  play() {
    const now = performance.now();
    this.playState = "running";
    if (this.pauseTime !== undefined) {
      this.startTime = now - this.pauseTime;
    } else if (!this.startTime) {
      this.startTime = now;
    }
    this.cancelTimestamp = this.startTime;
    this.pauseTime = undefined;
    this.frameRequestId = requestAnimationFrame(this.tick);
  }
  pause() {
    this.playState = "paused";
    this.pauseTime = this.t;
  }
  finish() {
    this.playState = "finished";
    this.tick(0);
  }
  stop() {
    var _a;
    this.playState = "idle";
    if (this.frameRequestId !== undefined) {
      cancelAnimationFrame(this.frameRequestId);
    }
    (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);
  }
  cancel() {
    this.stop();
    this.tick(this.cancelTimestamp);
  }
  reverse() {
    this.rate *= -1;
  }
  commitStyles() {}
  updateDuration(duration) {
    this.duration = duration;
    this.totalDuration = duration * (this.repeat + 1);
  }
  get currentTime() {
    return this.t;
  }
  set currentTime(t) {
    if (this.pauseTime !== undefined || this.rate === 0) {
      this.pauseTime = t;
    } else {
      this.startTime = performance.now() - t / this.rate;
    }
  }
  get playbackRate() {
    return this.rate;
  }
  set playbackRate(rate) {
    this.rate = rate;
  }
}
exports.Animation = Animation;
},{"@motionone/utils":"tYSI","./utils/easing.es.js":"H5Xc"}],"tBXo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Animation", {
  enumerable: true,
  get: function () {
    return _AnimationEs.Animation;
  }
});
Object.defineProperty(exports, "getEasingFunction", {
  enumerable: true,
  get: function () {
    return _easingEs.getEasingFunction;
  }
});
var _AnimationEs = require("./Animation.es.js");
var _easingEs = require("./utils/easing.es.js");
},{"./Animation.es.js":"EGYz","./utils/easing.es.js":"H5Xc"}],"NSRt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cubicBezierAsString = exports.convertEasing = void 0;
var _utils = require("@motionone/utils");
const convertEasing = easing => (0, _utils.isCubicBezier)(easing) ? cubicBezierAsString(easing) : easing;
exports.convertEasing = convertEasing;
const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
exports.cubicBezierAsString = cubicBezierAsString;
},{"@motionone/utils":"tYSI"}],"M1rd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.supports = void 0;
const testAnimation = keyframes => document.createElement("div").animate(keyframes, {
  duration: 0.001
});
const featureTests = {
  cssRegisterProperty: () => typeof CSS !== "undefined" && Object.hasOwnProperty.call(CSS, "registerProperty"),
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
  partialKeyframes: () => {
    try {
      testAnimation({
        opacity: [1]
      });
    } catch (e) {
      return false;
    }
    return true;
  },
  finished: () => Boolean(testAnimation({
    opacity: [0, 1]
  }).finished)
};
const results = {};
const supports = {};
exports.supports = supports;
for (const key in featureTests) {
  supports[key] = () => {
    if (results[key] === undefined) results[key] = featureTests[key]();
    return results[key];
  };
}
},{}],"KE62":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hydrateKeyframes = hydrateKeyframes;
exports.keyframesList = void 0;
function hydrateKeyframes(keyframes, readInitialValue) {
  for (let i = 0; i < keyframes.length; i++) {
    if (keyframes[i] === null) {
      keyframes[i] = i ? keyframes[i - 1] : readInitialValue();
    }
  }
  return keyframes;
}
const keyframesList = keyframes => Array.isArray(keyframes) ? keyframes : [keyframes];
exports.keyframesList = keyframesList;
},{}],"utUU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStyleName = getStyleName;
var _transformsEs = require("./transforms.es.js");
function getStyleName(key) {
  if (_transformsEs.transformAlias[key]) key = _transformsEs.transformAlias[key];
  return (0, _transformsEs.isTransform)(key) ? (0, _transformsEs.asTransformCssVar)(key) : key;
}
},{"./transforms.es.js":"KAJF"}],"gKTj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style = void 0;
var _cssVarEs = require("./utils/css-var.es.js");
var _getStyleNameEs = require("./utils/get-style-name.es.js");
var _transformsEs = require("./utils/transforms.es.js");
const style = {
  get: (element, name) => {
    name = (0, _getStyleNameEs.getStyleName)(name);
    let value = (0, _cssVarEs.isCssVar)(name) ? element.style.getPropertyValue(name) : getComputedStyle(element)[name];
    if (!value && value !== 0) {
      const definition = _transformsEs.transformDefinitions.get(name);
      if (definition) value = definition.initialValue;
    }
    return value;
  },
  set: (element, name, value) => {
    name = (0, _getStyleNameEs.getStyleName)(name);
    if ((0, _cssVarEs.isCssVar)(name)) {
      element.style.setProperty(name, value);
    } else {
      element.style[name] = value;
    }
  }
};
exports.style = style;
},{"./utils/css-var.es.js":"fHRu","./utils/get-style-name.es.js":"utUU","./utils/transforms.es.js":"KAJF"}],"M5JE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stopAnimation = stopAnimation;
function stopAnimation(animation, needsCommit = true) {
  if (!animation || animation.playState === "finished") return;
  // Suppress error thrown by WAAPI
  try {
    if (animation.stop) {
      animation.stop();
    } else {
      needsCommit && animation.commitStyles();
      animation.cancel();
    }
  } catch (e) {}
}
},{}],"N0EX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animateStyle = animateStyle;
var _dataEs = require("./data.es.js");
var _cssVarEs = require("./utils/css-var.es.js");
var _animation = require("@motionone/animation");
var _utils = require("@motionone/utils");
var _transformsEs = require("./utils/transforms.es.js");
var _easingEs = require("./utils/easing.es.js");
var _featureDetectionEs = require("./utils/feature-detection.es.js");
var _keyframesEs = require("./utils/keyframes.es.js");
var _styleEs = require("./style.es.js");
var _getStyleNameEs = require("./utils/get-style-name.es.js");
var _stopAnimationEs = require("./utils/stop-animation.es.js");
function getDevToolsRecord() {
  return window.__MOTION_DEV_TOOLS_RECORD;
}
function animateStyle(element, key, keyframesDefinition, options = {}) {
  const record = getDevToolsRecord();
  const isRecording = options.record !== false && record;
  let animation;
  let {
    duration = _utils.defaults.duration,
    delay = _utils.defaults.delay,
    endDelay = _utils.defaults.endDelay,
    repeat = _utils.defaults.repeat,
    easing = _utils.defaults.easing,
    direction,
    offset,
    allowWebkitAcceleration = false
  } = options;
  const data = (0, _dataEs.getAnimationData)(element);
  let canAnimateNatively = _featureDetectionEs.supports.waapi();
  const valueIsTransform = (0, _transformsEs.isTransform)(key);
  /**
   * If this is an individual transform, we need to map its
   * key to a CSS variable and update the element's transform style
   */
  valueIsTransform && (0, _transformsEs.addTransformToElement)(element, key);
  const name = (0, _getStyleNameEs.getStyleName)(key);
  const motionValue = (0, _dataEs.getMotionValue)(data.values, name);
  /**
   * Get definition of value, this will be used to convert numerical
   * keyframes into the default value type.
   */
  const definition = _transformsEs.transformDefinitions.get(name);
  /**
   * Stop the current animation, if any. Because this will trigger
   * commitStyles (DOM writes) and we might later trigger DOM reads,
   * this is fired now and we return a factory function to create
   * the actual animation that can get called in batch,
   */
  (0, _stopAnimationEs.stopAnimation)(motionValue.animation, !((0, _utils.isEasingGenerator)(easing) && motionValue.generator) && options.record !== false);
  /**
   * Batchable factory function containing all DOM reads.
   */
  return () => {
    const readInitialValue = () => {
      var _a, _b;
      return (_b = (_a = _styleEs.style.get(element, name)) !== null && _a !== void 0 ? _a : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0;
    };
    /**
     * Replace null values with the previous keyframe value, or read
     * it from the DOM if it's the first keyframe.
     */
    let keyframes = (0, _keyframesEs.hydrateKeyframes)((0, _keyframesEs.keyframesList)(keyframesDefinition), readInitialValue);
    if ((0, _utils.isEasingGenerator)(easing)) {
      const custom = easing.createAnimation(keyframes, readInitialValue, valueIsTransform, name, motionValue);
      easing = custom.easing;
      if (custom.keyframes !== undefined) keyframes = custom.keyframes;
      if (custom.duration !== undefined) duration = custom.duration;
    }
    /**
     * If this is a CSS variable we need to register it with the browser
     * before it can be animated natively. We also set it with setProperty
     * rather than directly onto the element.style object.
     */
    if ((0, _cssVarEs.isCssVar)(name)) {
      if (_featureDetectionEs.supports.cssRegisterProperty()) {
        (0, _cssVarEs.registerCssVariable)(name);
      } else {
        canAnimateNatively = false;
      }
    }
    /**
     * If we can animate this value with WAAPI, do so. Currently this only
     * feature detects CSS.registerProperty but could check WAAPI too.
     */
    if (canAnimateNatively) {
      /**
       * Convert numbers to default value types. Currently this only supports
       * transforms but it could also support other value types.
       */
      if (definition) {
        keyframes = keyframes.map(value => (0, _utils.isNumber)(value) ? definition.toDefaultUnit(value) : value);
      }
      /**
       * If this browser doesn't support partial/implicit keyframes we need to
       * explicitly provide one.
       */
      if (keyframes.length === 1 && (!_featureDetectionEs.supports.partialKeyframes() || isRecording)) {
        keyframes.unshift(readInitialValue());
      }
      const animationOptions = {
        delay: _utils.time.ms(delay),
        duration: _utils.time.ms(duration),
        endDelay: _utils.time.ms(endDelay),
        easing: !(0, _utils.isEasingList)(easing) ? (0, _easingEs.convertEasing)(easing) : undefined,
        direction,
        iterations: repeat + 1,
        fill: "both"
      };
      animation = element.animate({
        [name]: keyframes,
        offset,
        easing: (0, _utils.isEasingList)(easing) ? easing.map(_easingEs.convertEasing) : undefined
      }, animationOptions);
      /**
       * Polyfill finished Promise in browsers that don't support it
       */
      if (!animation.finished) {
        animation.finished = new Promise((resolve, reject) => {
          animation.onfinish = resolve;
          animation.oncancel = reject;
        });
      }
      const target = keyframes[keyframes.length - 1];
      animation.finished.then(() => {
        // Apply styles to target
        _styleEs.style.set(element, name, target);
        // Ensure fill modes don't persist
        animation.cancel();
      }).catch(_utils.noop);
      /**
       * This forces Webkit to run animations on the main thread by exploiting
       * this condition:
       * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics/ca/GraphicsLayerCA.cpp?rev=281238#L1099
       *
       * This fixes Webkit's timing bugs, like accelerated animations falling
       * out of sync with main thread animations and massive delays in starting
       * accelerated animations in WKWebView.
       */
      if (!allowWebkitAcceleration) animation.playbackRate = 1.000001;
      /**
       * If we can't animate the value natively then we can fallback to the numbers-only
       * polyfill for transforms.
       */
    } else if (valueIsTransform) {
      /**
       * If any keyframe is a string (because we measured it from the DOM), we need to convert
       * it into a number before passing to the Animation polyfill.
       */
      keyframes = keyframes.map(value => typeof value === "string" ? parseFloat(value) : value);
      /**
       * If we only have a single keyframe, we need to create an initial keyframe by reading
       * the current value from the DOM.
       */
      if (keyframes.length === 1) {
        keyframes.unshift(parseFloat(readInitialValue()));
      }
      const render = latest => {
        if (definition) latest = definition.toDefaultUnit(latest);
        _styleEs.style.set(element, name, latest);
      };
      animation = new _animation.Animation(render, keyframes, Object.assign(Object.assign({}, options), {
        duration,
        easing
      }));
    } else {
      const target = keyframes[keyframes.length - 1];
      _styleEs.style.set(element, name, definition && (0, _utils.isNumber)(target) ? definition.toDefaultUnit(target) : target);
    }
    if (isRecording) {
      record(element, key, keyframes, {
        duration,
        delay: delay,
        easing,
        repeat,
        offset
      }, "motion-one");
    }
    motionValue.setAnimation(animation);
    return animation;
  };
}
},{"./data.es.js":"gR3x","./utils/css-var.es.js":"fHRu","@motionone/animation":"tBXo","@motionone/utils":"tYSI","./utils/transforms.es.js":"KAJF","./utils/easing.es.js":"NSRt","./utils/feature-detection.es.js":"M1rd","./utils/keyframes.es.js":"KE62","./style.es.js":"gKTj","./utils/get-style-name.es.js":"utUU","./utils/stop-animation.es.js":"M5JE"}],"ED5R":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOptions = void 0;
const getOptions = (options, key) =>
/**
 * TODO: Make test for this
 * Always return a new object otherwise delay is overwritten by results of stagger
 * and this results in no stagger
 */
options[key] ? Object.assign(Object.assign({}, options), options[key]) : Object.assign({}, options);
exports.getOptions = getOptions;
},{}],"M9wN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveElements = resolveElements;
function resolveElements(elements, selectorCache) {
  var _a;
  if (typeof elements === "string") {
    if (selectorCache) {
      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = document.querySelectorAll(elements);
      elements = selectorCache[elements];
    } else {
      elements = document.querySelectorAll(elements);
    }
  } else if (elements instanceof Element) {
    elements = [elements];
  }
  /**
   * Return an empty array
   */
  return Array.from(elements || []);
}
},{}],"lUCL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withControls = exports.controls = void 0;
var _utils = require("@motionone/utils");
var _stopAnimationEs = require("./stop-animation.es.js");
const createAnimation = factory => factory();
const withControls = (animationFactory, options, duration = _utils.defaults.duration) => {
  return new Proxy({
    animations: animationFactory.map(createAnimation).filter(Boolean),
    duration,
    options
  }, controls);
};
/**
 * TODO:
 * Currently this returns the first animation, ideally it would return
 * the first active animation.
 */
exports.withControls = withControls;
const getActiveAnimation = state => state.animations[0];
const controls = {
  get: (target, key) => {
    const activeAnimation = getActiveAnimation(target);
    switch (key) {
      case "duration":
        return target.duration;
      case "currentTime":
        return _utils.time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) || 0);
      case "playbackRate":
      case "playState":
        return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key];
      case "finished":
        if (!target.finished) {
          target.finished = Promise.all(target.animations.map(selectFinished)).catch(_utils.noop);
        }
        return target.finished;
      case "stop":
        return () => {
          target.animations.forEach(animation => (0, _stopAnimationEs.stopAnimation)(animation));
        };
      case "forEachNative":
        /**
         * This is for internal use only, fire a callback for each
         * underlying animation.
         */
        return callback => {
          target.animations.forEach(animation => callback(animation, target));
        };
      default:
        return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) === "undefined" ? undefined : () => target.animations.forEach(animation => animation[key]());
    }
  },
  set: (target, key, value) => {
    switch (key) {
      case "currentTime":
        value = _utils.time.ms(value);
      case "currentTime":
      case "playbackRate":
        for (let i = 0; i < target.animations.length; i++) {
          target.animations[i][key] = value;
        }
        return true;
    }
    return false;
  }
};
exports.controls = controls;
const selectFinished = animation => animation.finished;
},{"@motionone/utils":"tYSI","./stop-animation.es.js":"M5JE"}],"vTH9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFromIndex = getFromIndex;
exports.resolveOption = resolveOption;
exports.stagger = stagger;
var _utils = require("@motionone/utils");
var _animation = require("@motionone/animation");
function stagger(duration = 0.1, {
  start = 0,
  from = 0,
  easing
} = {}) {
  return (i, total) => {
    const fromIndex = (0, _utils.isNumber)(from) ? from : getFromIndex(from, total);
    const distance = Math.abs(fromIndex - i);
    let delay = duration * distance;
    if (easing) {
      const maxDelay = total * duration;
      const easingFunction = (0, _animation.getEasingFunction)(easing);
      delay = easingFunction(delay / maxDelay) * maxDelay;
    }
    return start + delay;
  };
}
function getFromIndex(from, total) {
  if (from === "first") {
    return 0;
  } else {
    const lastIndex = total - 1;
    return from === "last" ? lastIndex : lastIndex / 2;
  }
}
function resolveOption(option, i, total) {
  return typeof option === "function" ? option(i, total) : option;
}
},{"@motionone/utils":"tYSI","@motionone/animation":"tBXo"}],"NUfT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animate = animate;
var _animateStyleEs = require("./animate-style.es.js");
var _optionsEs = require("./utils/options.es.js");
var _resolveElementsEs = require("../utils/resolve-elements.es.js");
var _controlsEs = require("./utils/controls.es.js");
var _staggerEs = require("../utils/stagger.es.js");
function animate(elements, keyframes, options = {}) {
  elements = (0, _resolveElementsEs.resolveElements)(elements);
  const numElements = elements.length;
  /**
   * Create and start new animations
   */
  const animationFactories = [];
  for (let i = 0; i < numElements; i++) {
    const element = elements[i];
    for (const key in keyframes) {
      const valueOptions = (0, _optionsEs.getOptions)(options, key);
      valueOptions.delay = (0, _staggerEs.resolveOption)(valueOptions.delay, i, numElements);
      const animation = (0, _animateStyleEs.animateStyle)(element, key, keyframes[key], valueOptions);
      animationFactories.push(animation);
    }
  }
  return (0, _controlsEs.withControls)(animationFactories, options,
  /**
   * TODO:
   * If easing is set to spring or glide, duration will be dynamically
   * generated. Ideally we would dynamically generate this from
   * animation.effect.getComputedTiming().duration but this isn't
   * supported in iOS13 or our number polyfill. Perhaps it's possible
   * to Proxy animations returned from animateStyle that has duration
   * as a getter.
   */
  options.duration);
}
},{"./animate-style.es.js":"N0EX","./utils/options.es.js":"ED5R","../utils/resolve-elements.es.js":"M9wN","./utils/controls.es.js":"lUCL","../utils/stagger.es.js":"vTH9"}],"CQe6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcNextTime = calcNextTime;
var _utils = require("@motionone/utils");
function calcNextTime(current, next, prev, labels) {
  var _a;
  if ((0, _utils.isNumber)(next)) {
    return next;
  } else if (next.startsWith("-") || next.startsWith("+")) {
    return Math.max(0, current + parseFloat(next));
  } else if (next === "<") {
    return prev;
  } else {
    return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;
  }
}
},{"@motionone/utils":"tYSI"}],"jQWj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addKeyframes = addKeyframes;
exports.eraseKeyframes = eraseKeyframes;
var _utils = require("@motionone/utils");
function eraseKeyframes(sequence, startTime, endTime) {
  for (let i = 0; i < sequence.length; i++) {
    const keyframe = sequence[i];
    if (keyframe.at > startTime && keyframe.at < endTime) {
      (0, _utils.removeItem)(sequence, keyframe);
      // If we remove this item we have to push the pointer back one
      i--;
    }
  }
}
function addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {
  /**
   * Erase every existing value between currentTime and targetTime,
   * this will essentially splice this timeline into any currently
   * defined ones.
   */
  eraseKeyframes(sequence, startTime, endTime);
  for (let i = 0; i < keyframes.length; i++) {
    sequence.push({
      value: keyframes[i],
      at: (0, _utils.mix)(startTime, endTime, offset[i]),
      easing: (0, _utils.getEasingForSegment)(easing, i)
    });
  }
}
},{"@motionone/utils":"tYSI"}],"AVXd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareByTime = compareByTime;
function compareByTime(a, b) {
  if (a.at === b.at) {
    return a.value === null ? 1 : -1;
  } else {
    return a.at - b.at;
  }
}
},{}],"kfMi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAnimationsFromTimeline = createAnimationsFromTimeline;
exports.timeline = timeline;
var _tslib = require("tslib");
var _heyListen = require("hey-listen");
var _utils = require("@motionone/utils");
var _staggerEs = require("../utils/stagger.es.js");
var _animateStyleEs = require("../animate/animate-style.es.js");
var _controlsEs = require("../animate/utils/controls.es.js");
var _keyframesEs = require("../animate/utils/keyframes.es.js");
var _optionsEs = require("../animate/utils/options.es.js");
var _resolveElementsEs = require("../utils/resolve-elements.es.js");
var _transformsEs = require("../animate/utils/transforms.es.js");
var _calcTimeEs = require("./utils/calc-time.es.js");
var _editEs = require("./utils/edit.es.js");
var _sortEs = require("./utils/sort.es.js");
function timeline(definition, options = {}) {
  var _a;
  const animationDefinitions = createAnimationsFromTimeline(definition, options);
  /**
   * Create and start animations
   */
  const animationFactories = animationDefinitions.map(definition => (0, _animateStyleEs.animateStyle)(...definition)).filter(Boolean);
  return (0, _controlsEs.withControls)(animationFactories, options,
  // Get the duration from the first animation definition
  (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);
}
function createAnimationsFromTimeline(definition, _a = {}) {
  var {
      defaultOptions = {}
    } = _a,
    timelineOptions = (0, _tslib.__rest)(_a, ["defaultOptions"]);
  const animationDefinitions = [];
  const elementSequences = new Map();
  const elementCache = {};
  const timeLabels = new Map();
  let prevTime = 0;
  let currentTime = 0;
  let totalDuration = 0;
  /**
   * Build the timeline by mapping over the definition array and converting
   * the definitions into keyframes and offsets with absolute time values.
   * These will later get converted into relative offsets in a second pass.
   */
  for (let i = 0; i < definition.length; i++) {
    const segment = definition[i];
    /**
     * If this is a timeline label, mark it and skip the rest of this iteration.
     */
    if ((0, _utils.isString)(segment)) {
      timeLabels.set(segment, currentTime);
      continue;
    } else if (!Array.isArray(segment)) {
      timeLabels.set(segment.name, (0, _calcTimeEs.calcNextTime)(currentTime, segment.at, prevTime, timeLabels));
      continue;
    }
    const [elementDefinition, keyframes, options = {}] = segment;
    /**
     * If a relative or absolute time value has been specified we need to resolve
     * it in relation to the currentTime.
     */
    if (options.at !== undefined) {
      currentTime = (0, _calcTimeEs.calcNextTime)(currentTime, options.at, prevTime, timeLabels);
    }
    /**
     * Keep track of the maximum duration in this definition. This will be
     * applied to currentTime once the definition has been parsed.
     */
    let maxDuration = 0;
    /**
     * Find all the elements specified in the definition and parse value
     * keyframes from their timeline definitions.
     */
    const elements = (0, _resolveElementsEs.resolveElements)(elementDefinition, elementCache);
    const numElements = elements.length;
    for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {
      const element = elements[elementIndex];
      const elementSequence = getElementSequence(element, elementSequences);
      for (const key in keyframes) {
        const valueSequence = getValueSequence(key, elementSequence);
        let valueKeyframes = (0, _keyframesEs.keyframesList)(keyframes[key]);
        const valueOptions = (0, _optionsEs.getOptions)(options, key);
        let {
          duration = defaultOptions.duration || _utils.defaults.duration,
          easing = defaultOptions.easing || _utils.defaults.easing
        } = valueOptions;
        if ((0, _utils.isEasingGenerator)(easing)) {
          const valueIsTransform = (0, _transformsEs.isTransform)(key);
          (0, _heyListen.invariant)(valueKeyframes.length === 2 || !valueIsTransform, "spring must be provided 2 keyframes within timeline");
          const custom = easing.createAnimation(valueKeyframes,
          // TODO We currently only support explicit keyframes
          // so this doesn't currently read from the DOM
          () => "0", valueIsTransform);
          easing = custom.easing;
          if (custom.keyframes !== undefined) valueKeyframes = custom.keyframes;
          if (custom.duration !== undefined) duration = custom.duration;
        }
        const delay = (0, _staggerEs.resolveOption)(options.delay, elementIndex, numElements) || 0;
        const startTime = currentTime + delay;
        const targetTime = startTime + duration;
        /**
         *
         */
        let {
          offset = (0, _utils.defaultOffset)(valueKeyframes.length)
        } = valueOptions;
        /**
         * If there's only one offset of 0, fill in a second with length 1
         *
         * TODO: Ensure there's a test that covers this removal
         */
        if (offset.length === 1 && offset[0] === 0) {
          offset[1] = 1;
        }
        /**
         * Fill out if offset if fewer offsets than keyframes
         */
        const remainder = length - valueKeyframes.length;
        remainder > 0 && (0, _utils.fillOffset)(offset, remainder);
        /**
         * If only one value has been set, ie [1], push a null to the start of
         * the keyframe array. This will let us mark a keyframe at this point
         * that will later be hydrated with the previous value.
         */
        valueKeyframes.length === 1 && valueKeyframes.unshift(null);
        /**
         * Add keyframes, mapping offsets to absolute time.
         */
        (0, _editEs.addKeyframes)(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);
        maxDuration = Math.max(delay + duration, maxDuration);
        totalDuration = Math.max(targetTime, totalDuration);
      }
    }
    prevTime = currentTime;
    currentTime += maxDuration;
  }
  /**
   * For every element and value combination create a new animation.
   */
  elementSequences.forEach((valueSequences, element) => {
    for (const key in valueSequences) {
      const valueSequence = valueSequences[key];
      /**
       * Arrange all the keyframes in ascending time order.
       */
      valueSequence.sort(_sortEs.compareByTime);
      const keyframes = [];
      const valueOffset = [];
      const valueEasing = [];
      /**
       * For each keyframe, translate absolute times into
       * relative offsets based on the total duration of the timeline.
       */
      for (let i = 0; i < valueSequence.length; i++) {
        const {
          at,
          value,
          easing
        } = valueSequence[i];
        keyframes.push(value);
        valueOffset.push((0, _utils.progress)(0, totalDuration, at));
        valueEasing.push(easing || _utils.defaults.easing);
      }
      /**
       * If the first keyframe doesn't land on offset: 0
       * provide one by duplicating the initial keyframe. This ensures
       * it snaps to the first keyframe when the animation starts.
       */
      if (valueOffset[0] !== 0) {
        valueOffset.unshift(0);
        keyframes.unshift(keyframes[0]);
        valueEasing.unshift("linear");
      }
      /**
       * If the last keyframe doesn't land on offset: 1
       * provide one with a null wildcard value. This will ensure it
       * stays static until the end of the animation.
       */
      if (valueOffset[valueOffset.length - 1] !== 1) {
        valueOffset.push(1);
        keyframes.push(null);
      }
      animationDefinitions.push([element, key, keyframes, Object.assign(Object.assign(Object.assign({}, defaultOptions), {
        duration: totalDuration,
        easing: valueEasing,
        offset: valueOffset
      }), timelineOptions)]);
    }
  });
  return animationDefinitions;
}
function getElementSequence(element, sequences) {
  !sequences.has(element) && sequences.set(element, {});
  return sequences.get(element);
}
function getValueSequence(name, sequences) {
  if (!sequences[name]) sequences[name] = [];
  return sequences[name];
}
},{"tslib":"vCxL","hey-listen":"KFGT","@motionone/utils":"tYSI","../utils/stagger.es.js":"vTH9","../animate/animate-style.es.js":"N0EX","../animate/utils/controls.es.js":"lUCL","../animate/utils/keyframes.es.js":"KE62","../animate/utils/options.es.js":"ED5R","../utils/resolve-elements.es.js":"M9wN","../animate/utils/transforms.es.js":"KAJF","./utils/calc-time.es.js":"CQe6","./utils/edit.es.js":"jQWj","./utils/sort.es.js":"AVXd"}],"QU8i":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcGeneratorVelocity = calcGeneratorVelocity;
var _utils = require("@motionone/utils");
const sampleT = 5; // ms
function calcGeneratorVelocity(resolveValue, t, current) {
  const prevT = Math.max(t - sampleT, 0);
  return (0, _utils.velocityPerSecond)(current - resolveValue(prevT), t - prevT);
}
},{"@motionone/utils":"tYSI"}],"IP8p":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaults = void 0;
const defaults = {
  stiffness: 100.0,
  damping: 10.0,
  mass: 1.0
};
exports.defaults = defaults;
},{}],"cXsT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcDampingRatio = void 0;
var _defaultsEs = require("./defaults.es.js");
const calcDampingRatio = (stiffness = _defaultsEs.defaults.stiffness, damping = _defaultsEs.defaults.damping, mass = _defaultsEs.defaults.mass) => damping / (2 * Math.sqrt(stiffness * mass));
exports.calcDampingRatio = calcDampingRatio;
},{"./defaults.es.js":"IP8p"}],"RBa5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasReachedTarget = hasReachedTarget;
function hasReachedTarget(origin, target, current) {
  return origin < target && current >= target || origin > target && current <= target;
}
},{}],"K8Qr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spring = void 0;
var _utils = require("@motionone/utils");
var _defaultsEs = require("./defaults.es.js");
var _utilsEs = require("./utils.es.js");
var _hasReachedTargetEs = require("../utils/has-reached-target.es.js");
var _velocityEs = require("../utils/velocity.es.js");
const spring = ({
  stiffness = _defaultsEs.defaults.stiffness,
  damping = _defaultsEs.defaults.damping,
  mass = _defaultsEs.defaults.mass,
  from = 0,
  to = 1,
  velocity = 0.0,
  restSpeed = 2,
  restDistance = 0.5
} = {}) => {
  velocity = velocity ? _utils.time.s(velocity) : 0.0;
  const state = {
    done: false,
    hasReachedTarget: false,
    current: from,
    target: to
  };
  const initialDelta = to - from;
  const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;
  const dampingRatio = (0, _utilsEs.calcDampingRatio)(stiffness, damping, mass);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
    // Underdamped spring (bouncy)
    resolveSpring = t => to - Math.exp(-dampingRatio * undampedAngularFreq * t) * ((-velocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
  } else {
    // Critically damped spring
    resolveSpring = t => {
      return to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (-velocity + undampedAngularFreq * initialDelta) * t);
    };
  }
  return t => {
    state.current = resolveSpring(t);
    const currentVelocity = t === 0 ? velocity : (0, _velocityEs.calcGeneratorVelocity)(resolveSpring, t, state.current);
    const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
    const isBelowDisplacementThreshold = Math.abs(to - state.current) <= restDistance;
    state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
    state.hasReachedTarget = (0, _hasReachedTargetEs.hasReachedTarget)(from, to, state.current);
    return state;
  };
};
exports.spring = spring;
},{"@motionone/utils":"tYSI","./defaults.es.js":"IP8p","./utils.es.js":"cXsT","../utils/has-reached-target.es.js":"RBa5","../utils/velocity.es.js":"QU8i"}],"Xz5r":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glide = void 0;
var _utils = require("@motionone/utils");
var _velocityEs = require("../utils/velocity.es.js");
var _indexEs = require("../spring/index.es.js");
const glide = ({
  from = 0,
  velocity = 0.0,
  power = 0.8,
  decay = 0.325,
  bounceDamping,
  bounceStiffness,
  changeTarget,
  min,
  max,
  restDistance = 0.5,
  restSpeed
}) => {
  decay = _utils.time.ms(decay);
  const state = {
    hasReachedTarget: false,
    done: false,
    current: from,
    target: from
  };
  const isOutOfBounds = v => min !== undefined && v < min || max !== undefined && v > max;
  const nearestBoundary = v => {
    if (min === undefined) return max;
    if (max === undefined) return min;
    return Math.abs(min - v) < Math.abs(max - v) ? min : max;
  };
  let amplitude = power * velocity;
  const ideal = from + amplitude;
  const target = changeTarget === undefined ? ideal : changeTarget(ideal);
  state.target = target;
  /**
   * If the target has changed we need to re-calculate the amplitude, otherwise
   * the animation will start from the wrong position.
   */
  if (target !== ideal) amplitude = target - from;
  const calcDelta = t => -amplitude * Math.exp(-t / decay);
  const calcLatest = t => target + calcDelta(t);
  const applyFriction = t => {
    const delta = calcDelta(t);
    const latest = calcLatest(t);
    state.done = Math.abs(delta) <= restDistance;
    state.current = state.done ? target : latest;
  };
  /**
   * Ideally this would resolve for t in a stateless way, we could
   * do that by always precalculating the animation but as we know
   * this will be done anyway we can assume that spring will
   * be discovered during that.
   */
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = t => {
    if (!isOutOfBounds(state.current)) return;
    timeReachedBoundary = t;
    spring$1 = (0, _indexEs.spring)({
      from: state.current,
      to: nearestBoundary(state.current),
      velocity: (0, _velocityEs.calcGeneratorVelocity)(calcLatest, t, state.current),
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDistance,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return t => {
    /**
     * We need to resolve the friction to figure out if we need a
     * spring but we don't want to do this twice per frame. So here
     * we flag if we updated for this frame and later if we did
     * we can skip doing it again.
     */
    let hasUpdatedFrame = false;
    if (!spring$1 && timeReachedBoundary === undefined) {
      hasUpdatedFrame = true;
      applyFriction(t);
      checkCatchBoundary(t);
    }
    /**
     * If we have a spring and the provided t is beyond the moment the friction
     * animation crossed the min/max boundary, use the spring.
     */
    if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {
      state.hasReachedTarget = true;
      return spring$1(t - timeReachedBoundary);
    } else {
      state.hasReachedTarget = false;
      !hasUpdatedFrame && applyFriction(t);
      return state;
    }
  };
};
exports.glide = glide;
},{"@motionone/utils":"tYSI","../utils/velocity.es.js":"QU8i","../spring/index.es.js":"K8Qr"}],"VyZr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pregenerateKeyframes = pregenerateKeyframes;
var _utils = require("@motionone/utils");
const timeStep = 10;
const maxDuration = 10000;
function pregenerateKeyframes(generator, toUnit = _utils.noopReturn) {
  let overshootDuration = undefined;
  let timestamp = timeStep;
  let state = generator(0);
  const keyframes = [toUnit(state.current)];
  while (!state.done && timestamp < maxDuration) {
    state = generator(timestamp);
    keyframes.push(toUnit(state.done ? state.target : state.current));
    if (overshootDuration === undefined && state.hasReachedTarget) {
      overshootDuration = timestamp;
    }
    timestamp += timeStep;
  }
  const duration = timestamp - timeStep;
  /**
   * If generating an animation that didn't actually move,
   * generate a second keyframe so we have an origin and target.
   */
  if (keyframes.length === 1) keyframes.push(state.current);
  return {
    keyframes,
    duration: duration / 1000,
    overshootDuration: (overshootDuration !== null && overshootDuration !== void 0 ? overshootDuration : duration) / 1000
  };
}
},{"@motionone/utils":"tYSI"}],"Tr79":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "calcGeneratorVelocity", {
  enumerable: true,
  get: function () {
    return _velocityEs.calcGeneratorVelocity;
  }
});
Object.defineProperty(exports, "glide", {
  enumerable: true,
  get: function () {
    return _indexEs.glide;
  }
});
Object.defineProperty(exports, "pregenerateKeyframes", {
  enumerable: true,
  get: function () {
    return _pregenerateKeyframesEs.pregenerateKeyframes;
  }
});
Object.defineProperty(exports, "spring", {
  enumerable: true,
  get: function () {
    return _indexEs2.spring;
  }
});
var _indexEs = require("./glide/index.es.js");
var _indexEs2 = require("./spring/index.es.js");
var _pregenerateKeyframesEs = require("./utils/pregenerate-keyframes.es.js");
var _velocityEs = require("./utils/velocity.es.js");
},{"./glide/index.es.js":"Xz5r","./spring/index.es.js":"K8Qr","./utils/pregenerate-keyframes.es.js":"VyZr","./utils/velocity.es.js":"QU8i"}],"M6Gf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGeneratorEasing = createGeneratorEasing;
var _generators = require("@motionone/generators");
function createGeneratorEasing(createGenerator) {
  const keyframesCache = new WeakMap();
  return (options = {}) => {
    const generatorCache = new Map();
    const getGenerator = (from = 0, to = 100, velocity = 0, isScale = false) => {
      const key = `${from}-${to}-${velocity}-${isScale}`;
      if (!generatorCache.has(key)) {
        generatorCache.set(key, createGenerator(Object.assign({
          from,
          to,
          velocity,
          restSpeed: isScale ? 0.05 : 2,
          restDistance: isScale ? 0.01 : 0.5
        }, options)));
      }
      return generatorCache.get(key);
    };
    const getKeyframes = generator => {
      if (!keyframesCache.has(generator)) {
        keyframesCache.set(generator, (0, _generators.pregenerateKeyframes)(generator));
      }
      return keyframesCache.get(generator);
    };
    return {
      createAnimation: (keyframes, getOrigin, canUseGenerator, name, motionValue) => {
        var _a, _b;
        let settings;
        const numKeyframes = keyframes.length;
        let shouldUseGenerator = canUseGenerator && numKeyframes <= 2 && keyframes.every(isNumberOrNull);
        if (shouldUseGenerator) {
          const target = keyframes[numKeyframes - 1];
          const unresolvedOrigin = numKeyframes === 1 ? null : keyframes[0];
          let velocity = 0;
          let origin = 0;
          const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;
          if (prevGenerator) {
            /**
             * If we have a generator for this value we can use it to resolve
             * the animations's current value and velocity.
             */
            const {
              animation,
              generatorStartTime
            } = motionValue;
            const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;
            const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;
            const prevGeneratorCurrent = prevGenerator(currentTime).current;
            origin = (_a = unresolvedOrigin) !== null && _a !== void 0 ? _a : prevGeneratorCurrent;
            if (numKeyframes === 1 || numKeyframes === 2 && keyframes[0] === null) {
              velocity = (0, _generators.calcGeneratorVelocity)(t => prevGenerator(t).current, currentTime, prevGeneratorCurrent);
            }
          } else {
            origin = (_b = unresolvedOrigin) !== null && _b !== void 0 ? _b : parseFloat(getOrigin());
          }
          const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes("scale"));
          const keyframesMetadata = getKeyframes(generator);
          settings = Object.assign(Object.assign({}, keyframesMetadata), {
            easing: "linear"
          });
          // TODO Add test for this
          if (motionValue) {
            motionValue.generator = generator;
            motionValue.generatorStartTime = performance.now();
          }
        } else {
          const keyframesMetadata = getKeyframes(getGenerator(0, 100));
          settings = {
            easing: "ease",
            duration: keyframesMetadata.overshootDuration
          };
        }
        return settings;
      }
    };
  };
}
const isNumberOrNull = value => typeof value !== "string";
},{"@motionone/generators":"Tr79"}],"ckIA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spring = void 0;
var _generators = require("@motionone/generators");
var _createGeneratorEasingEs = require("../create-generator-easing.es.js");
const spring = (0, _createGeneratorEasingEs.createGeneratorEasing)(_generators.spring);
exports.spring = spring;
},{"@motionone/generators":"Tr79","../create-generator-easing.es.js":"M6Gf"}],"ceXu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glide = void 0;
var _generators = require("@motionone/generators");
var _createGeneratorEasingEs = require("../create-generator-easing.es.js");
const glide = (0, _createGeneratorEasingEs.createGeneratorEasing)(_generators.glide);
exports.glide = glide;
},{"@motionone/generators":"Tr79","../create-generator-easing.es.js":"M6Gf"}],"h8E3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inView = inView;
var _resolveElementsEs = require("../utils/resolve-elements.es.js");
const thresholds = {
  any: 0,
  all: 1
};
function inView(elementOrSelector, onStart, {
  root,
  margin: rootMargin,
  amount = "any"
} = {}) {
  /**
   * If this browser doesn't support IntersectionObserver, return a dummy stop function.
   * Default triggering of onStart is tricky - it could be used for starting/stopping
   * videos, lazy loading content etc. We could provide an option to enable a fallback, or
   * provide a fallback callback option.
   */
  if (typeof IntersectionObserver === "undefined") {
    return () => {};
  }
  const elements = (0, _resolveElementsEs.resolveElements)(elementOrSelector);
  const activeIntersections = new WeakMap();
  const onIntersectionChange = entries => {
    entries.forEach(entry => {
      const onEnd = activeIntersections.get(entry.target);
      /**
       * If there's no change to the intersection, we don't need to
       * do anything here.
       */
      if (entry.isIntersecting === Boolean(onEnd)) return;
      if (entry.isIntersecting) {
        const newOnEnd = onStart(entry);
        if (typeof newOnEnd === "function") {
          activeIntersections.set(entry.target, newOnEnd);
        } else {
          observer.unobserve(entry.target);
        }
      } else if (onEnd) {
        onEnd(entry);
        activeIntersections.delete(entry.target);
      }
    });
  };
  const observer = new IntersectionObserver(onIntersectionChange, {
    root,
    rootMargin,
    threshold: typeof amount === "number" ? amount : thresholds[amount]
  });
  elements.forEach(element => observer.observe(element));
  return () => observer.disconnect();
}
},{"../utils/resolve-elements.es.js":"M9wN"}],"raS2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resizeElement = resizeElement;
var _resolveElementsEs = require("../../utils/resolve-elements.es.js");
const resizeHandlers = new WeakMap();
let observer;
function getElementSize(target, borderBoxSize) {
  if (borderBoxSize) {
    const {
      inlineSize,
      blockSize
    } = borderBoxSize[0];
    return {
      width: inlineSize,
      height: blockSize
    };
  } else if (target instanceof SVGElement && "getBBox" in target) {
    return target.getBBox();
  } else {
    return {
      width: target.offsetWidth,
      height: target.offsetHeight
    };
  }
}
function notifyTarget({
  target,
  contentRect,
  borderBoxSize
}) {
  var _a;
  (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach(handler => {
    handler({
      target,
      contentSize: contentRect,
      get size() {
        return getElementSize(target, borderBoxSize);
      }
    });
  });
}
function notifyAll(entries) {
  entries.forEach(notifyTarget);
}
function createResizeObserver() {
  if (typeof ResizeObserver === "undefined") return;
  observer = new ResizeObserver(notifyAll);
}
function resizeElement(target, handler) {
  if (!observer) createResizeObserver();
  const elements = (0, _resolveElementsEs.resolveElements)(target);
  elements.forEach(element => {
    let elementHandlers = resizeHandlers.get(element);
    if (!elementHandlers) {
      elementHandlers = new Set();
      resizeHandlers.set(element, elementHandlers);
    }
    elementHandlers.add(handler);
    observer === null || observer === void 0 ? void 0 : observer.observe(element);
  });
  return () => {
    elements.forEach(element => {
      const elementHandlers = resizeHandlers.get(element);
      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);
      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {
        observer === null || observer === void 0 ? void 0 : observer.unobserve(element);
      }
    });
  };
}
},{"../../utils/resolve-elements.es.js":"M9wN"}],"WVs4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resizeWindow = resizeWindow;
const windowCallbacks = new Set();
let windowResizeHandler;
function createWindowResizeHandler() {
  windowResizeHandler = () => {
    const size = {
      width: window.innerWidth,
      height: window.innerHeight
    };
    const info = {
      target: window,
      size,
      contentSize: size
    };
    windowCallbacks.forEach(callback => callback(info));
  };
  window.addEventListener("resize", windowResizeHandler);
}
function resizeWindow(callback) {
  windowCallbacks.add(callback);
  if (!windowResizeHandler) createWindowResizeHandler();
  return () => {
    windowCallbacks.delete(callback);
    if (!windowCallbacks.size && windowResizeHandler) {
      windowResizeHandler = undefined;
    }
  };
}
},{}],"JpLI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resize = resize;
var _handleElementEs = require("./handle-element.es.js");
var _handleWindowEs = require("./handle-window.es.js");
function resize(a, b) {
  return typeof a === "function" ? (0, _handleWindowEs.resizeWindow)(a) : (0, _handleElementEs.resizeElement)(a, b);
}
},{"./handle-element.es.js":"raS2","./handle-window.es.js":"WVs4"}],"Td0n":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createScrollInfo = void 0;
exports.updateScrollInfo = updateScrollInfo;
var _utils = require("@motionone/utils");
/**
 * A time in milliseconds, beyond which we consider the scroll velocity to be 0.
 */
const maxElapsed = 50;
const createAxisInfo = () => ({
  current: 0,
  offset: [],
  progress: 0,
  scrollLength: 0,
  targetOffset: 0,
  targetLength: 0,
  containerLength: 0,
  velocity: 0
});
const createScrollInfo = () => ({
  time: 0,
  x: createAxisInfo(),
  y: createAxisInfo()
});
exports.createScrollInfo = createScrollInfo;
const keys = {
  x: {
    length: "Width",
    position: "Left"
  },
  y: {
    length: "Height",
    position: "Top"
  }
};
function updateAxisInfo(element, axisName, info, time) {
  const axis = info[axisName];
  const {
    length,
    position
  } = keys[axisName];
  const prev = axis.current;
  const prevTime = info.time;
  axis.current = element["scroll" + position];
  axis.scrollLength = element["scroll" + length] - element["client" + length];
  axis.offset.length = 0;
  axis.offset[0] = 0;
  axis.offset[1] = axis.scrollLength;
  axis.progress = (0, _utils.progress)(0, axis.scrollLength, axis.current);
  const elapsed = time - prevTime;
  axis.velocity = elapsed > maxElapsed ? 0 : (0, _utils.velocityPerSecond)(axis.current - prev, elapsed);
}
function updateScrollInfo(element, info, time) {
  updateAxisInfo(element, "x", info, time);
  updateAxisInfo(element, "y", info, time);
  info.time = time;
}
},{"@motionone/utils":"tYSI"}],"AlY6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcInset = calcInset;
function calcInset(element, container) {
  let inset = {
    x: 0,
    y: 0
  };
  let current = element;
  while (current && current !== container) {
    if (current instanceof HTMLElement) {
      inset.x += current.offsetLeft;
      inset.y += current.offsetTop;
      current = current.offsetParent;
    } else if (current instanceof SVGGraphicsElement && "getBBox" in current) {
      const {
        top,
        left
      } = current.getBBox();
      inset.x += left;
      inset.y += top;
      /**
       * Assign the next parent element as the <svg /> tag.
       */
      while (current && current.tagName !== "svg") {
        current = current.parentNode;
      }
    }
  }
  return inset;
}
},{}],"IgHy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScrollOffset = void 0;
const ScrollOffset = {
  Enter: [[0, 1], [1, 1]],
  Exit: [[0, 0], [1, 0]],
  Any: [[1, 0], [0, 1]],
  All: [[0, 0], [1, 1]]
};
exports.ScrollOffset = ScrollOffset;
},{}],"Xwdu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.namedEdges = void 0;
exports.resolveEdge = resolveEdge;
var _utils = require("@motionone/utils");
const namedEdges = {
  start: 0,
  center: 0.5,
  end: 1
};
exports.namedEdges = namedEdges;
function resolveEdge(edge, length, inset = 0) {
  let delta = 0;
  /**
   * If we have this edge defined as a preset, replace the definition
   * with the numerical value.
   */
  if (namedEdges[edge] !== undefined) {
    edge = namedEdges[edge];
  }
  /**
   * Handle unit values
   */
  if ((0, _utils.isString)(edge)) {
    const asNumber = parseFloat(edge);
    if (edge.endsWith("px")) {
      delta = asNumber;
    } else if (edge.endsWith("%")) {
      edge = asNumber / 100;
    } else if (edge.endsWith("vw")) {
      delta = asNumber / 100 * document.documentElement.clientWidth;
    } else if (edge.endsWith("vh")) {
      delta = asNumber / 100 * document.documentElement.clientHeight;
    } else {
      edge = asNumber;
    }
  }
  /**
   * If the edge is defined as a number, handle as a progress value.
   */
  if ((0, _utils.isNumber)(edge)) {
    delta = length * edge;
  }
  return inset + delta;
}
},{"@motionone/utils":"tYSI"}],"U31k":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveOffset = resolveOffset;
var _utils = require("@motionone/utils");
var _edgeEs = require("./edge.es.js");
const defaultOffset = [0, 0];
function resolveOffset(offset, containerLength, targetLength, targetInset) {
  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;
  let targetPoint = 0;
  let containerPoint = 0;
  if ((0, _utils.isNumber)(offset)) {
    /**
     * If we're provided offset: [0, 0.5, 1] then each number x should become
     * [x, x], so we default to the behaviour of mapping 0 => 0 of both target
     * and container etc.
     */
    offsetDefinition = [offset, offset];
  } else if ((0, _utils.isString)(offset)) {
    offset = offset.trim();
    if (offset.includes(" ")) {
      offsetDefinition = offset.split(" ");
    } else {
      /**
       * If we're provided a definition like "100px" then we want to apply
       * that only to the top of the target point, leaving the container at 0.
       * Whereas a named offset like "end" should be applied to both.
       */
      offsetDefinition = [offset, _edgeEs.namedEdges[offset] ? offset : `0`];
    }
  }
  targetPoint = (0, _edgeEs.resolveEdge)(offsetDefinition[0], targetLength, targetInset);
  containerPoint = (0, _edgeEs.resolveEdge)(offsetDefinition[1], containerLength);
  return targetPoint - containerPoint;
}
},{"@motionone/utils":"tYSI","./edge.es.js":"Xwdu"}],"uejl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveOffsets = resolveOffsets;
var _utils = require("@motionone/utils");
var _insetEs = require("./inset.es.js");
var _presetsEs = require("./presets.es.js");
var _offsetEs = require("./offset.es.js");
const point = {
  x: 0,
  y: 0
};
function resolveOffsets(container, info, options) {
  let {
    offset: offsetDefinition = _presetsEs.ScrollOffset.All
  } = options;
  const {
    target = container,
    axis = "y"
  } = options;
  const lengthLabel = axis === "y" ? "height" : "width";
  const inset = target !== container ? (0, _insetEs.calcInset)(target, container) : point;
  /**
   * Measure the target and container. If they're the same thing then we
   * use the container's scrollWidth/Height as the target, from there
   * all other calculations can remain the same.
   */
  const targetSize = target === container ? {
    width: container.scrollWidth,
    height: container.scrollHeight
  } : {
    width: target.clientWidth,
    height: target.clientHeight
  };
  const containerSize = {
    width: container.clientWidth,
    height: container.clientHeight
  };
  /**
   * Reset the length of the resolved offset array rather than creating a new one.
   * TODO: More reusable data structures for targetSize/containerSize would also be good.
   */
  info[axis].offset.length = 0;
  /**
   * Populate the offset array by resolving the user's offset definition into
   * a list of pixel scroll offets.
   */
  let hasChanged = !info[axis].interpolate;
  const numOffsets = offsetDefinition.length;
  for (let i = 0; i < numOffsets; i++) {
    const offset = (0, _offsetEs.resolveOffset)(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);
    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {
      hasChanged = true;
    }
    info[axis].offset[i] = offset;
  }
  /**
   * If the pixel scroll offsets have changed, create a new interpolator function
   * to map scroll value into a progress.
   */
  if (hasChanged) {
    info[axis].interpolate = (0, _utils.interpolate)((0, _utils.defaultOffset)(numOffsets), info[axis].offset);
    info[axis].interpolatorOffsets = [...info[axis].offset];
  }
  info[axis].progress = info[axis].interpolate(info[axis].current);
}
},{"@motionone/utils":"tYSI","./inset.es.js":"AlY6","./presets.es.js":"IgHy","./offset.es.js":"U31k"}],"XQtX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOnScrollHandler = createOnScrollHandler;
var _utils = require("@motionone/utils");
var _infoEs = require("./info.es.js");
var _indexEs = require("./offsets/index.es.js");
function measure(container, target = container, info) {
  /**
   * Find inset of target within scrollable container
   */
  info.x.targetOffset = 0;
  info.y.targetOffset = 0;
  if (target !== container) {
    let node = target;
    while (node && node != container) {
      info.x.targetOffset += node.offsetLeft;
      info.y.targetOffset += node.offsetTop;
      node = node.offsetParent;
    }
  }
  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;
  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;
  info.x.containerLength = container.clientWidth;
  info.y.containerLength = container.clientHeight;
}
function createOnScrollHandler(element, onScroll, info, options = {}) {
  const axis = options.axis || "y";
  return {
    measure: () => measure(element, options.target, info),
    update: time => {
      (0, _infoEs.updateScrollInfo)(element, info, time);
      if (options.offset || options.target) {
        (0, _indexEs.resolveOffsets)(element, info, options);
      }
    },
    notify: typeof onScroll === "function" ? () => onScroll(info) : scrubAnimation(onScroll, info[axis])
  };
}
function scrubAnimation(controls, axisInfo) {
  controls.pause();
  controls.forEachNative((animation, {
    easing
  }) => {
    var _a, _b;
    if (animation.updateDuration) {
      if (!easing) animation.easing = _utils.noopReturn;
      animation.updateDuration(1);
    } else {
      const timingOptions = {
        duration: 1000
      };
      if (!easing) timingOptions.easing = "linear";
      (_b = (_a = animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming) === null || _b === void 0 ? void 0 : _b.call(_a, timingOptions);
    }
  });
  return () => {
    controls.currentTime = axisInfo.progress;
  };
}
},{"@motionone/utils":"tYSI","./info.es.js":"Td0n","./offsets/index.es.js":"uejl"}],"eYX7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scroll = scroll;
var _tslib = require("tslib");
var _indexEs = require("../resize/index.es.js");
var _infoEs = require("./info.es.js");
var _onScrollHandlerEs = require("./on-scroll-handler.es.js");
const scrollListeners = new WeakMap();
const resizeListeners = new WeakMap();
const onScrollHandlers = new WeakMap();
const getEventTarget = element => element === document.documentElement ? window : element;
function scroll(onScroll, _a = {}) {
  var {
      container = document.documentElement
    } = _a,
    options = (0, _tslib.__rest)(_a, ["container"]);
  let containerHandlers = onScrollHandlers.get(container);
  /**
   * Get the onScroll handlers for this container.
   * If one isn't found, create a new one.
   */
  if (!containerHandlers) {
    containerHandlers = new Set();
    onScrollHandlers.set(container, containerHandlers);
  }
  /**
   * Create a new onScroll handler for the provided callback.
   */
  const info = (0, _infoEs.createScrollInfo)();
  const containerHandler = (0, _onScrollHandlerEs.createOnScrollHandler)(container, onScroll, info, options);
  containerHandlers.add(containerHandler);
  /**
   * Check if there's a scroll event listener for this container.
   * If not, create one.
   */
  if (!scrollListeners.has(container)) {
    const listener = () => {
      const time = performance.now();
      for (const handler of containerHandlers) handler.measure();
      for (const handler of containerHandlers) handler.update(time);
      for (const handler of containerHandlers) handler.notify();
    };
    scrollListeners.set(container, listener);
    const target = getEventTarget(container);
    window.addEventListener("resize", listener, {
      passive: true
    });
    if (container !== document.documentElement) {
      resizeListeners.set(container, (0, _indexEs.resize)(container, listener));
    }
    target.addEventListener("scroll", listener, {
      passive: true
    });
  }
  const listener = scrollListeners.get(container);
  const onLoadProcesss = requestAnimationFrame(listener);
  return () => {
    var _a;
    if (typeof onScroll !== "function") onScroll.stop();
    cancelAnimationFrame(onLoadProcesss);
    /**
     * Check if we even have any handlers for this container.
     */
    const containerHandlers = onScrollHandlers.get(container);
    if (!containerHandlers) return;
    containerHandlers.delete(containerHandler);
    if (containerHandlers.size) return;
    /**
     * If no more handlers, remove the scroll listener too.
     */
    const listener = scrollListeners.get(container);
    scrollListeners.delete(container);
    if (listener) {
      getEventTarget(container).removeEventListener("scroll", listener);
      (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();
      window.removeEventListener("resize", listener);
    }
  };
}
},{"tslib":"vCxL","../resize/index.es.js":"JpLI","./info.es.js":"Td0n","./on-scroll-handler.es.js":"XQtX"}],"Miq4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasChanged = hasChanged;
exports.shallowCompare = shallowCompare;
function hasChanged(a, b) {
  if (typeof a !== typeof b) return true;
  if (Array.isArray(a) && Array.isArray(b)) return !shallowCompare(a, b);
  return a !== b;
}
function shallowCompare(next, prev) {
  const prevLength = prev.length;
  if (prevLength !== next.length) return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i]) return false;
  }
  return true;
}
},{}],"CPQy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isVariant = isVariant;
function isVariant(definition) {
  return typeof definition === "object";
}
},{}],"IE2h":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveVariant = resolveVariant;
var _isVariantEs = require("./is-variant.es.js");
function resolveVariant(definition, variants) {
  if ((0, _isVariantEs.isVariant)(definition)) {
    return definition;
  } else if (definition && variants) {
    return variants[definition];
  }
}
},{"./is-variant.es.js":"CPQy"}],"fXfs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scheduleAnimation = scheduleAnimation;
exports.unscheduleAnimation = unscheduleAnimation;
var _utils = require("@motionone/utils");
let scheduled = undefined;
function processScheduledAnimations() {
  if (!scheduled) return;
  const generators = scheduled.sort(compareByDepth).map(fireAnimateUpdates);
  generators.forEach(fireNext);
  generators.forEach(fireNext);
  scheduled = undefined;
}
function scheduleAnimation(state) {
  if (!scheduled) {
    scheduled = [state];
    requestAnimationFrame(processScheduledAnimations);
  } else {
    (0, _utils.addUniqueItem)(scheduled, state);
  }
}
function unscheduleAnimation(state) {
  scheduled && (0, _utils.removeItem)(scheduled, state);
}
const compareByDepth = (a, b) => a.getDepth() - b.getDepth();
const fireAnimateUpdates = state => state.animateUpdates();
const fireNext = iterator => iterator.next();
},{"@motionone/utils":"tYSI"}],"I3Vy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatchPointerEvent = dispatchPointerEvent;
exports.dispatchViewEvent = dispatchViewEvent;
exports.motionEvent = void 0;
const motionEvent = (name, target) => new CustomEvent(name, {
  detail: {
    target
  }
});
exports.motionEvent = motionEvent;
function dispatchPointerEvent(element, name, event) {
  element.dispatchEvent(new CustomEvent(name, {
    detail: {
      originalEvent: event
    }
  }));
}
function dispatchViewEvent(element, name, entry) {
  element.dispatchEvent(new CustomEvent(name, {
    detail: {
      originalEntry: entry
    }
  }));
}
},{}],"rxbX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inView = void 0;
var _tslib = require("tslib");
var _eventsEs = require("../utils/events.es.js");
var _inViewEs = require("../../gestures/in-view.es.js");
const inView = {
  isActive: options => Boolean(options.inView),
  subscribe: (element, {
    enable,
    disable
  }, {
    inViewOptions = {}
  }) => {
    const {
        once
      } = inViewOptions,
      viewOptions = (0, _tslib.__rest)(inViewOptions, ["once"]);
    return (0, _inViewEs.inView)(element, enterEntry => {
      enable();
      (0, _eventsEs.dispatchViewEvent)(element, "viewenter", enterEntry);
      if (!once) {
        return leaveEntry => {
          disable();
          (0, _eventsEs.dispatchViewEvent)(element, "viewleave", leaveEntry);
        };
      }
    }, viewOptions);
  }
};
exports.inView = inView;
},{"tslib":"vCxL","../utils/events.es.js":"I3Vy","../../gestures/in-view.es.js":"h8E3"}],"LyOs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hover = void 0;
var _eventsEs = require("../utils/events.es.js");
const mouseEvent = (element, name, action) => event => {
  if (event.pointerType && event.pointerType !== "mouse") return;
  action();
  (0, _eventsEs.dispatchPointerEvent)(element, name, event);
};
const hover = {
  isActive: options => Boolean(options.hover),
  subscribe: (element, {
    enable,
    disable
  }) => {
    const onEnter = mouseEvent(element, "hoverstart", enable);
    const onLeave = mouseEvent(element, "hoverend", disable);
    element.addEventListener("pointerenter", onEnter);
    element.addEventListener("pointerleave", onLeave);
    return () => {
      element.removeEventListener("pointerenter", onEnter);
      element.removeEventListener("pointerleave", onLeave);
    };
  }
};
exports.hover = hover;
},{"../utils/events.es.js":"I3Vy"}],"sUqG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.press = void 0;
var _eventsEs = require("../utils/events.es.js");
const press = {
  isActive: options => Boolean(options.press),
  subscribe: (element, {
    enable,
    disable
  }) => {
    const onPointerUp = event => {
      disable();
      (0, _eventsEs.dispatchPointerEvent)(element, "pressend", event);
      window.removeEventListener("pointerup", onPointerUp);
    };
    const onPointerDown = event => {
      enable();
      (0, _eventsEs.dispatchPointerEvent)(element, "pressstart", event);
      window.addEventListener("pointerup", onPointerUp);
    };
    element.addEventListener("pointerdown", onPointerDown);
    return () => {
      element.removeEventListener("pointerdown", onPointerDown);
      window.removeEventListener("pointerup", onPointerUp);
    };
  }
};
exports.press = press;
},{"../utils/events.es.js":"I3Vy"}],"q8os":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMotionState = createMotionState;
exports.mountedStates = void 0;
var _tslib = require("tslib");
var _heyListen = require("hey-listen");
var _utils = require("@motionone/utils");
var _animateStyleEs = require("../animate/animate-style.es.js");
var _styleEs = require("../animate/style.es.js");
var _optionsEs = require("../animate/utils/options.es.js");
var _hasChangedEs = require("./utils/has-changed.es.js");
var _resolveVariantEs = require("./utils/resolve-variant.es.js");
var _scheduleEs = require("./utils/schedule.es.js");
var _inViewEs = require("./gestures/in-view.es.js");
var _hoverEs = require("./gestures/hover.es.js");
var _pressEs = require("./gestures/press.es.js");
var _eventsEs = require("./utils/events.es.js");
const gestures = {
  inView: _inViewEs.inView,
  hover: _hoverEs.hover,
  press: _pressEs.press
};
/**
 * A list of state types, in priority order. If a value is defined in
 * a righter-most type, it will override any definition in a lefter-most.
 */
const stateTypes = ["initial", "animate", ...Object.keys(gestures), "exit"];
/**
 * A global store of all generated motion states. This can be used to lookup
 * a motion state for a given Element.
 */
const mountedStates = new WeakMap();
exports.mountedStates = mountedStates;
function createMotionState(options = {}, parent) {
  /**
   * The element represented by the motion state. This is an empty reference
   * when we create the state to support SSR and allow for later mounting
   * in view libraries.
   *
   * @ts-ignore
   */
  let element;
  /**
   * Calculate a depth that we can use to order motion states by tree depth.
   */
  let depth = parent ? parent.getDepth() + 1 : 0;
  /**
   * Track which states are currently active.
   */
  const activeStates = {
    initial: true,
    animate: true
  };
  /**
   * A map of functions that, when called, will remove event listeners for
   * a given gesture.
   */
  const gestureSubscriptions = {};
  /**
   * Initialise a context to share through motion states. This
   * will be populated by variant names (if any).
   */
  const context = {};
  for (const name of stateTypes) {
    context[name] = typeof options[name] === "string" ? options[name] : parent === null || parent === void 0 ? void 0 : parent.getContext()[name];
  }
  /**
   * If initial is set to false we use the animate prop as the initial
   * animation state.
   */
  const initialVariantSource = options.initial === false ? "animate" : "initial";
  /**
   * Destructure an initial target out from the resolved initial variant.
   */
  let _a = (0, _resolveVariantEs.resolveVariant)(options[initialVariantSource] || context[initialVariantSource], options.variants) || {},
    target = (0, _tslib.__rest)(_a, ["transition"]);
  /**
   * The base target is a cached map of values that we'll use to animate
   * back to if a value is removed from all active state types. This
   * is usually the initial value as read from the DOM, for instance if
   * it hasn't been defined in initial.
   */
  const baseTarget = Object.assign({}, target);
  /**
   * A generator that will be processed by the global animation scheduler.
   * This yeilds when it switches from reading the DOM to writing to it
   * to prevent layout thrashing.
   */
  function* animateUpdates() {
    var _a, _b;
    const prevTarget = target;
    target = {};
    const animationOptions = {};
    for (const name of stateTypes) {
      if (!activeStates[name]) continue;
      const variant = (0, _resolveVariantEs.resolveVariant)(options[name]);
      if (!variant) continue;
      for (const key in variant) {
        if (key === "transition") continue;
        target[key] = variant[key];
        animationOptions[key] = (0, _optionsEs.getOptions)((_b = (_a = variant.transition) !== null && _a !== void 0 ? _a : options.transition) !== null && _b !== void 0 ? _b : {}, key);
      }
    }
    const allTargetKeys = new Set([...Object.keys(target), ...Object.keys(prevTarget)]);
    const animationFactories = [];
    allTargetKeys.forEach(key => {
      var _a;
      if (target[key] === undefined) {
        target[key] = baseTarget[key];
      }
      if ((0, _hasChangedEs.hasChanged)(prevTarget[key], target[key])) {
        (_a = baseTarget[key]) !== null && _a !== void 0 ? _a : baseTarget[key] = _styleEs.style.get(element, key);
        animationFactories.push((0, _animateStyleEs.animateStyle)(element, key, target[key], animationOptions[key]));
      }
    });
    // Wait for all animation states to read from the DOM
    yield;
    const animations = animationFactories.map(factory => factory()).filter(Boolean);
    if (!animations.length) return;
    const animationTarget = target;
    element.dispatchEvent((0, _eventsEs.motionEvent)("motionstart", animationTarget));
    Promise.all(animations.map(animation => animation.finished)).then(() => {
      element.dispatchEvent((0, _eventsEs.motionEvent)("motioncomplete", animationTarget));
    }).catch(_utils.noop);
  }
  const setGesture = (name, isActive) => () => {
    activeStates[name] = isActive;
    (0, _scheduleEs.scheduleAnimation)(state);
  };
  const updateGestureSubscriptions = () => {
    for (const name in gestures) {
      const isGestureActive = gestures[name].isActive(options);
      const remove = gestureSubscriptions[name];
      if (isGestureActive && !remove) {
        gestureSubscriptions[name] = gestures[name].subscribe(element, {
          enable: setGesture(name, true),
          disable: setGesture(name, false)
        }, options);
      } else if (!isGestureActive && remove) {
        remove();
        delete gestureSubscriptions[name];
      }
    }
  };
  const state = {
    update: newOptions => {
      if (!element) return;
      options = newOptions;
      updateGestureSubscriptions();
      (0, _scheduleEs.scheduleAnimation)(state);
    },
    setActive: (name, isActive) => {
      if (!element) return;
      activeStates[name] = isActive;
      (0, _scheduleEs.scheduleAnimation)(state);
    },
    animateUpdates,
    getDepth: () => depth,
    getTarget: () => target,
    getOptions: () => options,
    getContext: () => context,
    mount: newElement => {
      (0, _heyListen.invariant)(Boolean(newElement), "Animation state must be mounted with valid Element");
      element = newElement;
      mountedStates.set(element, state);
      updateGestureSubscriptions();
      return () => {
        mountedStates.delete(element);
        (0, _scheduleEs.unscheduleAnimation)(state);
        for (const key in gestureSubscriptions) {
          gestureSubscriptions[key]();
        }
      };
    },
    isMounted: () => Boolean(element)
  };
  return state;
}
},{"tslib":"vCxL","hey-listen":"KFGT","@motionone/utils":"tYSI","../animate/animate-style.es.js":"N0EX","../animate/style.es.js":"gKTj","../animate/utils/options.es.js":"ED5R","./utils/has-changed.es.js":"Miq4","./utils/resolve-variant.es.js":"IE2h","./utils/schedule.es.js":"fXfs","./gestures/in-view.es.js":"rxbX","./gestures/hover.es.js":"LyOs","./gestures/press.es.js":"sUqG","./utils/events.es.js":"I3Vy"}],"dvoA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStyles = createStyles;
var _utils = require("@motionone/utils");
var _transformsEs = require("./transforms.es.js");
function createStyles(keyframes) {
  const initialKeyframes = {};
  const transformKeys = [];
  for (let key in keyframes) {
    const value = keyframes[key];
    if ((0, _transformsEs.isTransform)(key)) {
      if (_transformsEs.transformAlias[key]) key = _transformsEs.transformAlias[key];
      transformKeys.push(key);
      key = (0, _transformsEs.asTransformCssVar)(key);
    }
    let initialKeyframe = Array.isArray(value) ? value[0] : value;
    /**
     * If this is a number and we have a default value type, convert the number
     * to this type.
     */
    const definition = _transformsEs.transformDefinitions.get(key);
    if (definition) {
      initialKeyframe = (0, _utils.isNumber)(value) ? definition.toDefaultUnit(value) : value;
    }
    initialKeyframes[key] = initialKeyframe;
  }
  if (transformKeys.length) {
    initialKeyframes.transform = (0, _transformsEs.buildTransformTemplate)(transformKeys);
  }
  return initialKeyframes;
}
},{"@motionone/utils":"tYSI","./transforms.es.js":"KAJF"}],"OW3t":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStyleString = createStyleString;
var _styleObjectEs = require("./style-object.es.js");
const camelLetterToPipeLetter = letter => `-${letter.toLowerCase()}`;
const camelToPipeCase = str => str.replace(/[A-Z]/g, camelLetterToPipeLetter);
function createStyleString(target = {}) {
  const styles = (0, _styleObjectEs.createStyles)(target);
  let style = "";
  for (const key in styles) {
    style += key.startsWith("--") ? key : camelToPipeCase(key);
    style += `: ${styles[key]}; `;
  }
  return style;
}
},{"./style-object.es.js":"dvoA"}],"j80A":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ScrollOffset", {
  enumerable: true,
  get: function () {
    return _presetsEs.ScrollOffset;
  }
});
Object.defineProperty(exports, "animate", {
  enumerable: true,
  get: function () {
    return _indexEs.animate;
  }
});
Object.defineProperty(exports, "animateStyle", {
  enumerable: true,
  get: function () {
    return _animateStyleEs.animateStyle;
  }
});
Object.defineProperty(exports, "createMotionState", {
  enumerable: true,
  get: function () {
    return _indexEs7.createMotionState;
  }
});
Object.defineProperty(exports, "createStyleString", {
  enumerable: true,
  get: function () {
    return _styleStringEs.createStyleString;
  }
});
Object.defineProperty(exports, "createStyles", {
  enumerable: true,
  get: function () {
    return _styleObjectEs.createStyles;
  }
});
Object.defineProperty(exports, "getAnimationData", {
  enumerable: true,
  get: function () {
    return _dataEs.getAnimationData;
  }
});
Object.defineProperty(exports, "getStyleName", {
  enumerable: true,
  get: function () {
    return _getStyleNameEs.getStyleName;
  }
});
Object.defineProperty(exports, "glide", {
  enumerable: true,
  get: function () {
    return _indexEs4.glide;
  }
});
Object.defineProperty(exports, "inView", {
  enumerable: true,
  get: function () {
    return _inViewEs.inView;
  }
});
Object.defineProperty(exports, "mountedStates", {
  enumerable: true,
  get: function () {
    return _indexEs7.mountedStates;
  }
});
Object.defineProperty(exports, "resize", {
  enumerable: true,
  get: function () {
    return _indexEs5.resize;
  }
});
Object.defineProperty(exports, "scroll", {
  enumerable: true,
  get: function () {
    return _indexEs6.scroll;
  }
});
Object.defineProperty(exports, "spring", {
  enumerable: true,
  get: function () {
    return _indexEs3.spring;
  }
});
Object.defineProperty(exports, "stagger", {
  enumerable: true,
  get: function () {
    return _staggerEs.stagger;
  }
});
Object.defineProperty(exports, "style", {
  enumerable: true,
  get: function () {
    return _styleEs.style;
  }
});
Object.defineProperty(exports, "timeline", {
  enumerable: true,
  get: function () {
    return _indexEs2.timeline;
  }
});
Object.defineProperty(exports, "withControls", {
  enumerable: true,
  get: function () {
    return _controlsEs.withControls;
  }
});
var _indexEs = require("./animate/index.es.js");
var _animateStyleEs = require("./animate/animate-style.es.js");
var _indexEs2 = require("./timeline/index.es.js");
var _staggerEs = require("./utils/stagger.es.js");
var _indexEs3 = require("./easing/spring/index.es.js");
var _indexEs4 = require("./easing/glide/index.es.js");
var _styleEs = require("./animate/style.es.js");
var _inViewEs = require("./gestures/in-view.es.js");
var _indexEs5 = require("./gestures/resize/index.es.js");
var _indexEs6 = require("./gestures/scroll/index.es.js");
var _presetsEs = require("./gestures/scroll/offsets/presets.es.js");
var _controlsEs = require("./animate/utils/controls.es.js");
var _dataEs = require("./animate/data.es.js");
var _getStyleNameEs = require("./animate/utils/get-style-name.es.js");
var _indexEs7 = require("./state/index.es.js");
var _styleObjectEs = require("./animate/utils/style-object.es.js");
var _styleStringEs = require("./animate/utils/style-string.es.js");
},{"./animate/index.es.js":"NUfT","./animate/animate-style.es.js":"N0EX","./timeline/index.es.js":"kfMi","./utils/stagger.es.js":"vTH9","./easing/spring/index.es.js":"ckIA","./easing/glide/index.es.js":"ceXu","./animate/style.es.js":"gKTj","./gestures/in-view.es.js":"h8E3","./gestures/resize/index.es.js":"JpLI","./gestures/scroll/index.es.js":"eYX7","./gestures/scroll/offsets/presets.es.js":"IgHy","./animate/utils/controls.es.js":"lUCL","./animate/data.es.js":"gR3x","./animate/utils/get-style-name.es.js":"utUU","./state/index.es.js":"q8os","./animate/utils/style-object.es.js":"dvoA","./animate/utils/style-string.es.js":"OW3t"}],"N72a":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useScroll = useScroll;
var _tslib = require("tslib");
var _dom = require("@motionone/dom");
var _index = require("./index.mjs");
var _useConstant = require("../utils/use-constant.mjs");
var _useIsomorphicEffect = require("../utils/use-isomorphic-effect.mjs");
var createScrollMotionValues = function () {
  return {
    scrollX: (0, _index.motionValue)(0),
    scrollY: (0, _index.motionValue)(0),
    scrollXProgress: (0, _index.motionValue)(0),
    scrollYProgress: (0, _index.motionValue)(0)
  };
};
function useScroll(_a) {
  if (_a === void 0) {
    _a = {};
  }
  var container = _a.container,
    target = _a.target,
    options = (0, _tslib.__rest)(_a, ["container", "target"]);
  var values = (0, _useConstant.useConstant)(createScrollMotionValues);
  (0, _useIsomorphicEffect.useIsomorphicLayoutEffect)(function () {
    return (0, _dom.scroll)(function (_a) {
      var x = _a.x,
        y = _a.y;
      values.scrollX.set(x.current);
      values.scrollXProgress.set(x.progress);
      values.scrollY.set(y.current);
      values.scrollYProgress.set(y.progress);
    }, (0, _tslib.__assign)((0, _tslib.__assign)({}, options), {
      container: (container === null || container === void 0 ? void 0 : container.current) || undefined,
      target: (target === null || target === void 0 ? void 0 : target.current) || undefined
    }));
  }, []);
  return values;
}
},{"tslib":"vCxL","@motionone/dom":"j80A","./index.mjs":"PQTd","../utils/use-constant.mjs":"XPaj","../utils/use-isomorphic-effect.mjs":"tqWN"}],"T4Ut":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useElementScroll = useElementScroll;
var _warnOnce = require("../../utils/warn-once.mjs");
var _useScroll = require("../use-scroll.mjs");
function useElementScroll(ref) {
  (0, _warnOnce.warnOnce)(false, "useElementScroll is deprecated. Convert to useScroll({ container: ref }).");
  return (0, _useScroll.useScroll)({
    container: ref
  });
}
},{"../../utils/warn-once.mjs":"ZTHf","../use-scroll.mjs":"N72a"}],"yPHL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useViewportScroll = useViewportScroll;
var _warnOnce = require("../../utils/warn-once.mjs");
var _useScroll = require("../use-scroll.mjs");
function useViewportScroll() {
  (0, _warnOnce.warnOnce)(false, "useViewportScroll is deprecated. Convert to useScroll().");
  return (0, _useScroll.useScroll)();
}
},{"../../utils/warn-once.mjs":"ZTHf","../use-scroll.mjs":"N72a"}],"DZvo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAnimationFrame = useAnimationFrame;
var _framesync = _interopRequireWildcard(require("framesync"));
var _react = require("react");
var _useConstant = require("./use-constant.mjs");
var _MotionConfigContext = require("../context/MotionConfigContext.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var getCurrentTime = typeof performance !== "undefined" ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
function useAnimationFrame(callback) {
  var initialTimestamp = (0, _useConstant.useConstant)(getCurrentTime);
  var isStatic = (0, _react.useContext)(_MotionConfigContext.MotionConfigContext).isStatic;
  (0, _react.useEffect)(function () {
    if (isStatic) return;
    var provideTimeSinceStart = function (_a) {
      var timestamp = _a.timestamp;
      callback(timestamp - initialTimestamp);
    };
    _framesync.default.update(provideTimeSinceStart, true);
    return function () {
      return _framesync.cancelSync.update(provideTimeSinceStart);
    };
  }, [callback]);
}
},{"framesync":"KvxD","react":"n8MK","./use-constant.mjs":"XPaj","../context/MotionConfigContext.mjs":"dtoU"}],"L9bs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTime = useTime;
var _useAnimationFrame = require("../utils/use-animation-frame.mjs");
var _useMotionValue = require("./use-motion-value.mjs");
function useTime() {
  var time = (0, _useMotionValue.useMotionValue)(0);
  (0, _useAnimationFrame.useAnimationFrame)(function (t) {
    return time.set(t);
  });
  return time;
}
},{"../utils/use-animation-frame.mjs":"DZvo","./use-motion-value.mjs":"g4mR"}],"DUul":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animationControls = animationControls;
var _tslib = require("tslib");
var _heyListen = require("hey-listen");
var _animation = require("../render/utils/animation.mjs");
var _setters = require("../render/utils/setters.mjs");
/**
 * @public
 */
function animationControls() {
  /**
   * Track whether the host component has mounted.
   */
  var hasMounted = false;
  /**
   * Pending animations that are started before a component is mounted.
   * TODO: Remove this as animations should only run in effects
   */
  var pendingAnimations = [];
  /**
   * A collection of linked component animation controls.
   */
  var subscribers = new Set();
  var controls = {
    subscribe: function (visualElement) {
      subscribers.add(visualElement);
      return function () {
        return void subscribers.delete(visualElement);
      };
    },
    start: function (definition, transitionOverride) {
      /**
       * TODO: We only perform this hasMounted check because in Framer we used to
       * encourage the ability to start an animation within the render phase. This
       * isn't behaviour concurrent-safe so when we make Framer concurrent-safe
       * we can ditch this.
       */
      if (hasMounted) {
        var animations_1 = [];
        subscribers.forEach(function (visualElement) {
          animations_1.push((0, _animation.animateVisualElement)(visualElement, definition, {
            transitionOverride: transitionOverride
          }));
        });
        return Promise.all(animations_1);
      } else {
        return new Promise(function (resolve) {
          pendingAnimations.push({
            animation: [definition, transitionOverride],
            resolve: resolve
          });
        });
      }
    },
    set: function (definition) {
      (0, _heyListen.invariant)(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      return subscribers.forEach(function (visualElement) {
        (0, _setters.setValues)(visualElement, definition);
      });
    },
    stop: function () {
      subscribers.forEach(function (visualElement) {
        (0, _animation.stopAnimation)(visualElement);
      });
    },
    mount: function () {
      hasMounted = true;
      pendingAnimations.forEach(function (_a) {
        var animation = _a.animation,
          resolve = _a.resolve;
        controls.start.apply(controls, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(animation), false)).then(resolve);
      });
      return function () {
        hasMounted = false;
        controls.stop();
      };
    }
  };
  return controls;
}
},{"tslib":"vCxL","hey-listen":"KFGT","../render/utils/animation.mjs":"rHY3","../render/utils/setters.mjs":"QDUS"}],"W61j":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAnimation = void 0;
exports.useAnimationControls = useAnimationControls;
var _animationControls = require("./animation-controls.mjs");
var _react = require("react");
var _useConstant = require("../utils/use-constant.mjs");
/**
 * Creates `AnimationControls`, which can be used to manually start, stop
 * and sequence animations on one or more components.
 *
 * The returned `AnimationControls` should be passed to the `animate` property
 * of the components you want to animate.
 *
 * These components can then be animated with the `start` method.
 *
 * ```jsx
 * import * as React from 'react'
 * import { motion, useAnimation } from 'framer-motion'
 *
 * export function MyComponent(props) {
 *    const controls = useAnimation()
 *
 *    controls.start({
 *        x: 100,
 *        transition: { duration: 0.5 },
 *    })
 *
 *    return <motion.div animate={controls} />
 * }
 * ```
 *
 * @returns Animation controller with `start` and `stop` methods
 *
 * @public
 */
function useAnimationControls() {
  var controls = (0, _useConstant.useConstant)(_animationControls.animationControls);
  (0, _react.useEffect)(controls.mount, []);
  return controls;
}
var useAnimation = useAnimationControls;
exports.useAnimation = useAnimation;
},{"./animation-controls.mjs":"DUul","react":"n8MK","../utils/use-constant.mjs":"XPaj"}],"rBwd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCycle = useCycle;
var _tslib = require("tslib");
var _popmotion = require("popmotion");
var _react = require("react");
/**
 * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.
 *
 * An index value can be passed to the returned `cycle` function to cycle to a specific index.
 *
 * ```jsx
 * import * as React from "react"
 * import { motion, useCycle } from "framer-motion"
 *
 * export const MyComponent = () => {
 *   const [x, cycleX] = useCycle(0, 50, 100)
 *
 *   return (
 *     <motion.div
 *       animate={{ x: x }}
 *       onTap={() => cycleX()}
 *      />
 *    )
 * }
 * ```
 *
 * @param items - items to cycle through
 * @returns [currentState, cycleState]
 *
 * @public
 */
function useCycle() {
  var items = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    items[_i] = arguments[_i];
  }
  var index = (0, _react.useRef)(0);
  var _a = (0, _tslib.__read)((0, _react.useState)(items[index.current]), 2),
    item = _a[0],
    setItem = _a[1];
  var runCycle = (0, _react.useCallback)(function (next) {
    index.current = typeof next !== "number" ? (0, _popmotion.wrap)(0, items.length, index.current + 1) : next;
    setItem(items[index.current]);
  }, (0, _tslib.__spreadArray)([items.length], (0, _tslib.__read)(items), false));
  return [item, runCycle];
}
},{"tslib":"vCxL","popmotion":"KhgA","react":"n8MK"}],"T3Kn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInView = useInView;
var _tslib = require("tslib");
var _react = require("react");
var _dom = require("@motionone/dom");
function useInView(ref, _a) {
  var _b = _a === void 0 ? {} : _a,
    root = _b.root,
    margin = _b.margin,
    amount = _b.amount,
    _c = _b.once,
    once = _c === void 0 ? false : _c;
  var _d = (0, _tslib.__read)((0, _react.useState)(false), 2),
    isInView = _d[0],
    setInView = _d[1];
  (0, _react.useEffect)(function () {
    var _a;
    if (!ref.current || once && isInView) return;
    var onEnter = function () {
      setInView(true);
      return once ? undefined : function () {
        return setInView(false);
      };
    };
    var options = {
      root: (_a = root === null || root === void 0 ? void 0 : root.current) !== null && _a !== void 0 ? _a : undefined,
      margin: margin,
      amount: amount === "some" ? "any" : amount
    };
    return (0, _dom.inView)(ref.current, onEnter, options);
  }, [root, ref, margin, once]);
  return isInView;
}
},{"tslib":"vCxL","react":"n8MK","@motionone/dom":"j80A"}],"Rzk3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DragControls = void 0;
exports.useDragControls = useDragControls;
var _useConstant = require("../../utils/use-constant.mjs");
/**
 * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.
 *
 * ```jsx
 * const dragControls = useDragControls()
 *
 * function startDrag(event) {
 *   dragControls.start(event, { snapToCursor: true })
 * }
 *
 * return (
 *   <>
 *     <div onPointerDown={startDrag} />
 *     <motion.div drag="x" dragControls={dragControls} />
 *   </>
 * )
 * ```
 *
 * @public
 */
var DragControls = /** @class */function () {
  function DragControls() {
    this.componentControls = new Set();
  }
  /**
   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
   *
   * @internal
   */
  DragControls.prototype.subscribe = function (controls) {
    var _this = this;
    this.componentControls.add(controls);
    return function () {
      return _this.componentControls.delete(controls);
    };
  };
  /**
   * Start a drag gesture on every `motion` component that has this set of drag controls
   * passed into it via the `dragControls` prop.
   *
   * ```jsx
   * dragControls.start(e, {
   *   snapToCursor: true
   * })
   * ```
   *
   * @param event - PointerEvent
   * @param options - Options
   *
   * @public
   */
  DragControls.prototype.start = function (event, options) {
    this.componentControls.forEach(function (controls) {
      controls.start(event.nativeEvent || event, options);
    });
  };
  return DragControls;
}();
exports.DragControls = DragControls;
var createDragControls = function () {
  return new DragControls();
};
/**
 * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop
 * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we
 * might want to initiate that dragging from a different component than the draggable one.
 *
 * By creating a `dragControls` using the `useDragControls` hook, we can pass this into
 * the draggable component's `dragControls` prop. It exposes a `start` method
 * that can start dragging from pointer events on other components.
 *
 * ```jsx
 * const dragControls = useDragControls()
 *
 * function startDrag(event) {
 *   dragControls.start(event, { snapToCursor: true })
 * }
 *
 * return (
 *   <>
 *     <div onPointerDown={startDrag} />
 *     <motion.div drag="x" dragControls={dragControls} />
 *   </>
 * )
 * ```
 *
 * @public
 */
function useDragControls() {
  return (0, _useConstant.useConstant)(createDragControls);
}
},{"../../utils/use-constant.mjs":"XPaj"}],"TeBw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInstantLayoutTransition = useInstantLayoutTransition;
var _HTMLProjectionNode = require("./node/HTMLProjectionNode.mjs");
function useInstantLayoutTransition() {
  return startTransition;
}
function startTransition(cb) {
  if (!_HTMLProjectionNode.rootProjectionNode.current) return;
  _HTMLProjectionNode.rootProjectionNode.current.isUpdating = false;
  _HTMLProjectionNode.rootProjectionNode.current.blockUpdate();
  cb === null || cb === void 0 ? void 0 : cb();
}
},{"./node/HTMLProjectionNode.mjs":"w8YZ"}],"b7vO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInstantTransition = useInstantTransition;
var _tslib = require("tslib");
var _framesync = _interopRequireDefault(require("framesync"));
var _react = require("react");
var _useInstantLayoutTransition = require("../projection/use-instant-layout-transition.mjs");
var _useForceUpdate = require("./use-force-update.mjs");
var _useInstantTransitionState = require("./use-instant-transition-state.mjs");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function useInstantTransition() {
  var _a = (0, _tslib.__read)((0, _useForceUpdate.useForceUpdate)(), 2),
    forceUpdate = _a[0],
    forcedRenderCount = _a[1];
  var startInstantLayoutTransition = (0, _useInstantLayoutTransition.useInstantLayoutTransition)();
  (0, _react.useEffect)(function () {
    /**
     * Unblock after two animation frames, otherwise this will unblock too soon.
     */
    _framesync.default.postRender(function () {
      return _framesync.default.postRender(function () {
        return _useInstantTransitionState.instantAnimationState.current = false;
      });
    });
  }, [forcedRenderCount]);
  return function (callback) {
    startInstantLayoutTransition(function () {
      _useInstantTransitionState.instantAnimationState.current = true;
      forceUpdate();
      callback();
    });
  };
}
},{"tslib":"vCxL","framesync":"KvxD","react":"n8MK","../projection/use-instant-layout-transition.mjs":"TeBw","./use-force-update.mjs":"lEeZ","./use-instant-transition-state.mjs":"JWTJ"}],"dlBT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useResetProjection = useResetProjection;
var React = _interopRequireWildcard(require("react"));
var _HTMLProjectionNode = require("./node/HTMLProjectionNode.mjs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useResetProjection() {
  var reset = React.useCallback(function () {
    var root = _HTMLProjectionNode.rootProjectionNode.current;
    if (!root) return;
    root.resetTree();
  }, []);
  return reset;
}
},{"react":"n8MK","./node/HTMLProjectionNode.mjs":"w8YZ"}],"EaIN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAnimatedState = useAnimatedState;
var _tslib = require("tslib");
var _react = require("react");
var _useConstant = require("../utils/use-constant.mjs");
var _setters = require("../render/utils/setters.mjs");
var _index = require("../render/index.mjs");
var _animation = require("../render/utils/animation.mjs");
var _useVisualState = require("../motion/utils/use-visual-state.mjs");
var _models = require("../projection/geometry/models.mjs");
var createObject = function () {
  return {};
};
var stateVisualElement = (0, _index.visualElement)({
  build: function () {},
  measureViewportBox: _models.createBox,
  resetTransform: function () {},
  restoreTransform: function () {},
  removeValueFromRenderState: function () {},
  render: function () {},
  scrapeMotionValuesFromProps: createObject,
  readValueFromInstance: function (_state, key, options) {
    return options.initialState[key] || 0;
  },
  makeTargetAnimatable: function (element, _a) {
    var transition = _a.transition,
      transitionEnd = _a.transitionEnd,
      target = (0, _tslib.__rest)(_a, ["transition", "transitionEnd"]);
    var origin = (0, _setters.getOrigin)(target, transition || {}, element);
    (0, _setters.checkTargetForNewValues)(element, target, origin);
    return (0, _tslib.__assign)({
      transition: transition,
      transitionEnd: transitionEnd
    }, target);
  }
});
var useVisualState = (0, _useVisualState.makeUseVisualState)({
  scrapeMotionValuesFromProps: createObject,
  createRenderState: createObject
});
/**
 * This is not an officially supported API and may be removed
 * on any version.
 */
function useAnimatedState(initialState) {
  var _a = (0, _tslib.__read)((0, _react.useState)(initialState), 2),
    animationState = _a[0],
    setAnimationState = _a[1];
  var visualState = useVisualState({}, false);
  var element = (0, _useConstant.useConstant)(function () {
    return stateVisualElement({
      props: {},
      visualState: visualState
    }, {
      initialState: initialState
    });
  });
  (0, _react.useEffect)(function () {
    element.mount({});
    return element.unmount;
  }, [element]);
  (0, _react.useEffect)(function () {
    element.setProps({
      onUpdate: function (v) {
        setAnimationState((0, _tslib.__assign)({}, v));
      }
    });
  }, [setAnimationState, element]);
  var startAnimation = (0, _useConstant.useConstant)(function () {
    return function (animationDefinition) {
      return (0, _animation.animateVisualElement)(element, animationDefinition);
    };
  });
  return [animationState, startAnimation];
}
},{"tslib":"vCxL","react":"n8MK","../utils/use-constant.mjs":"XPaj","../render/utils/setters.mjs":"QDUS","../render/index.mjs":"BwAh","../render/utils/animation.mjs":"rHY3","../motion/utils/use-visual-state.mjs":"b7cz","../projection/geometry/models.mjs":"BuZ6"}],"cNAf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invertScale = void 0;
exports.useInvertedScale = useInvertedScale;
var _useTransform = require("./use-transform.mjs");
var _heyListen = require("hey-listen");
var _useMotionValue = require("./use-motion-value.mjs");
var _index = require("../context/MotionContext/index.mjs");
// Keep things reasonable and avoid scale: Infinity. In practise we might need
// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]
// to simply hide content at unreasonable scales.
var maxScale = 100000;
var invertScale = function (scale) {
  return scale > 0.001 ? 1 / scale : maxScale;
};
exports.invertScale = invertScale;
var hasWarned = false;
/**
 * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse
 * of their respective parent scales.
 *
 * This is useful for undoing the distortion of content when scaling a parent component.
 *
 * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.
 * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output
 * of those instead.
 *
 * ```jsx
 * const MyComponent = () => {
 *   const { scaleX, scaleY } = useInvertedScale()
 *   return <motion.div style={{ scaleX, scaleY }} />
 * }
 * ```
 *
 * @deprecated
 */
function useInvertedScale(scale) {
  var parentScaleX = (0, _useMotionValue.useMotionValue)(1);
  var parentScaleY = (0, _useMotionValue.useMotionValue)(1);
  var visualElement = (0, _index.useVisualElementContext)();
  (0, _heyListen.invariant)(!!(scale || visualElement), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
  (0, _heyListen.warning)(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
  hasWarned = true;
  if (scale) {
    parentScaleX = scale.scaleX || parentScaleX;
    parentScaleY = scale.scaleY || parentScaleY;
  } else if (visualElement) {
    parentScaleX = visualElement.getValue("scaleX", 1);
    parentScaleY = visualElement.getValue("scaleY", 1);
  }
  var scaleX = (0, _useTransform.useTransform)(parentScaleX, invertScale);
  var scaleY = (0, _useTransform.useTransform)(parentScaleY, invertScale);
  return {
    scaleX: scaleX,
    scaleY: scaleY
  };
}
},{"./use-transform.mjs":"uy6A","hey-listen":"KFGT","./use-motion-value.mjs":"g4mR","../context/MotionContext/index.mjs":"rq4D"}],"gNpu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AnimatePresence", {
  enumerable: true,
  get: function () {
    return _index.AnimatePresence;
  }
});
Object.defineProperty(exports, "AnimateSharedLayout", {
  enumerable: true,
  get: function () {
    return _AnimateSharedLayout.AnimateSharedLayout;
  }
});
Object.defineProperty(exports, "AnimationType", {
  enumerable: true,
  get: function () {
    return _types.AnimationType;
  }
});
Object.defineProperty(exports, "DeprecatedLayoutGroupContext", {
  enumerable: true,
  get: function () {
    return _DeprecatedLayoutGroupContext.DeprecatedLayoutGroupContext;
  }
});
Object.defineProperty(exports, "DragControls", {
  enumerable: true,
  get: function () {
    return _useDragControls.DragControls;
  }
});
Object.defineProperty(exports, "FlatTree", {
  enumerable: true,
  get: function () {
    return _flatTree.FlatTree;
  }
});
Object.defineProperty(exports, "LayoutGroup", {
  enumerable: true,
  get: function () {
    return _index4.LayoutGroup;
  }
});
Object.defineProperty(exports, "LayoutGroupContext", {
  enumerable: true,
  get: function () {
    return _LayoutGroupContext.LayoutGroupContext;
  }
});
Object.defineProperty(exports, "LazyMotion", {
  enumerable: true,
  get: function () {
    return _index3.LazyMotion;
  }
});
Object.defineProperty(exports, "MotionConfig", {
  enumerable: true,
  get: function () {
    return _index2.MotionConfig;
  }
});
Object.defineProperty(exports, "MotionConfigContext", {
  enumerable: true,
  get: function () {
    return _MotionConfigContext.MotionConfigContext;
  }
});
Object.defineProperty(exports, "MotionContext", {
  enumerable: true,
  get: function () {
    return _index9.MotionContext;
  }
});
Object.defineProperty(exports, "MotionValue", {
  enumerable: true,
  get: function () {
    return _index6.MotionValue;
  }
});
Object.defineProperty(exports, "PresenceContext", {
  enumerable: true,
  get: function () {
    return _PresenceContext.PresenceContext;
  }
});
Object.defineProperty(exports, "Reorder", {
  enumerable: true,
  get: function () {
    return _index5.Reorder;
  }
});
Object.defineProperty(exports, "SwitchLayoutGroupContext", {
  enumerable: true,
  get: function () {
    return _SwitchLayoutGroupContext.SwitchLayoutGroupContext;
  }
});
Object.defineProperty(exports, "addPointerEvent", {
  enumerable: true,
  get: function () {
    return _usePointerEvent.addPointerEvent;
  }
});
Object.defineProperty(exports, "addScaleCorrector", {
  enumerable: true,
  get: function () {
    return _scaleCorrection.addScaleCorrector;
  }
});
Object.defineProperty(exports, "animate", {
  enumerable: true,
  get: function () {
    return _animate.animate;
  }
});
Object.defineProperty(exports, "animateVisualElement", {
  enumerable: true,
  get: function () {
    return _animation.animateVisualElement;
  }
});
Object.defineProperty(exports, "animationControls", {
  enumerable: true,
  get: function () {
    return _animationControls.animationControls;
  }
});
Object.defineProperty(exports, "animations", {
  enumerable: true,
  get: function () {
    return _animations.animations;
  }
});
Object.defineProperty(exports, "calcLength", {
  enumerable: true,
  get: function () {
    return _deltaCalc.calcLength;
  }
});
Object.defineProperty(exports, "checkTargetForNewValues", {
  enumerable: true,
  get: function () {
    return _setters.checkTargetForNewValues;
  }
});
Object.defineProperty(exports, "createBox", {
  enumerable: true,
  get: function () {
    return _models.createBox;
  }
});
Object.defineProperty(exports, "createDomMotionComponent", {
  enumerable: true,
  get: function () {
    return _motion.createDomMotionComponent;
  }
});
Object.defineProperty(exports, "createMotionComponent", {
  enumerable: true,
  get: function () {
    return _index7.createMotionComponent;
  }
});
Object.defineProperty(exports, "domAnimation", {
  enumerable: true,
  get: function () {
    return _featuresAnimation.domAnimation;
  }
});
Object.defineProperty(exports, "domMax", {
  enumerable: true,
  get: function () {
    return _featuresMax.domMax;
  }
});
Object.defineProperty(exports, "filterProps", {
  enumerable: true,
  get: function () {
    return _filterProps.filterProps;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _isBrowser.isBrowser;
  }
});
Object.defineProperty(exports, "isDragActive", {
  enumerable: true,
  get: function () {
    return _lock.isDragActive;
  }
});
Object.defineProperty(exports, "isMotionValue", {
  enumerable: true,
  get: function () {
    return _isMotionValue.isMotionValue;
  }
});
Object.defineProperty(exports, "isValidMotionProp", {
  enumerable: true,
  get: function () {
    return _validProp.isValidMotionProp;
  }
});
Object.defineProperty(exports, "m", {
  enumerable: true,
  get: function () {
    return _motionMinimal.m;
  }
});
Object.defineProperty(exports, "makeUseVisualState", {
  enumerable: true,
  get: function () {
    return _useVisualState.makeUseVisualState;
  }
});
Object.defineProperty(exports, "motion", {
  enumerable: true,
  get: function () {
    return _motion.motion;
  }
});
Object.defineProperty(exports, "motionValue", {
  enumerable: true,
  get: function () {
    return _index6.motionValue;
  }
});
Object.defineProperty(exports, "resolveMotionValue", {
  enumerable: true,
  get: function () {
    return _resolveMotionValue.resolveMotionValue;
  }
});
Object.defineProperty(exports, "transform", {
  enumerable: true,
  get: function () {
    return _transform.transform;
  }
});
Object.defineProperty(exports, "useAnimation", {
  enumerable: true,
  get: function () {
    return _useAnimation.useAnimation;
  }
});
Object.defineProperty(exports, "useAnimationControls", {
  enumerable: true,
  get: function () {
    return _useAnimation.useAnimationControls;
  }
});
Object.defineProperty(exports, "useAnimationFrame", {
  enumerable: true,
  get: function () {
    return _useAnimationFrame.useAnimationFrame;
  }
});
Object.defineProperty(exports, "useCycle", {
  enumerable: true,
  get: function () {
    return _useCycle.useCycle;
  }
});
Object.defineProperty(exports, "useDeprecatedAnimatedState", {
  enumerable: true,
  get: function () {
    return _useAnimatedState.useAnimatedState;
  }
});
Object.defineProperty(exports, "useDeprecatedInvertedScale", {
  enumerable: true,
  get: function () {
    return _useInvertedScale.useInvertedScale;
  }
});
Object.defineProperty(exports, "useDomEvent", {
  enumerable: true,
  get: function () {
    return _useDomEvent.useDomEvent;
  }
});
Object.defineProperty(exports, "useDragControls", {
  enumerable: true,
  get: function () {
    return _useDragControls.useDragControls;
  }
});
Object.defineProperty(exports, "useElementScroll", {
  enumerable: true,
  get: function () {
    return _useElementScroll.useElementScroll;
  }
});
Object.defineProperty(exports, "useForceUpdate", {
  enumerable: true,
  get: function () {
    return _useForceUpdate.useForceUpdate;
  }
});
Object.defineProperty(exports, "useInView", {
  enumerable: true,
  get: function () {
    return _useInView.useInView;
  }
});
Object.defineProperty(exports, "useInstantLayoutTransition", {
  enumerable: true,
  get: function () {
    return _useInstantLayoutTransition.useInstantLayoutTransition;
  }
});
Object.defineProperty(exports, "useInstantTransition", {
  enumerable: true,
  get: function () {
    return _useInstantTransition.useInstantTransition;
  }
});
Object.defineProperty(exports, "useIsPresent", {
  enumerable: true,
  get: function () {
    return _usePresence.useIsPresent;
  }
});
Object.defineProperty(exports, "useIsomorphicLayoutEffect", {
  enumerable: true,
  get: function () {
    return _useIsomorphicEffect.useIsomorphicLayoutEffect;
  }
});
Object.defineProperty(exports, "useMotionTemplate", {
  enumerable: true,
  get: function () {
    return _useMotionTemplate.useMotionTemplate;
  }
});
Object.defineProperty(exports, "useMotionValue", {
  enumerable: true,
  get: function () {
    return _useMotionValue.useMotionValue;
  }
});
Object.defineProperty(exports, "usePresence", {
  enumerable: true,
  get: function () {
    return _usePresence.usePresence;
  }
});
Object.defineProperty(exports, "useReducedMotion", {
  enumerable: true,
  get: function () {
    return _useReducedMotion.useReducedMotion;
  }
});
Object.defineProperty(exports, "useReducedMotionConfig", {
  enumerable: true,
  get: function () {
    return _useReducedMotion.useReducedMotionConfig;
  }
});
Object.defineProperty(exports, "useResetProjection", {
  enumerable: true,
  get: function () {
    return _useResetProjection.useResetProjection;
  }
});
Object.defineProperty(exports, "useScroll", {
  enumerable: true,
  get: function () {
    return _useScroll.useScroll;
  }
});
Object.defineProperty(exports, "useSpring", {
  enumerable: true,
  get: function () {
    return _useSpring.useSpring;
  }
});
Object.defineProperty(exports, "useTime", {
  enumerable: true,
  get: function () {
    return _useTime.useTime;
  }
});
Object.defineProperty(exports, "useTransform", {
  enumerable: true,
  get: function () {
    return _useTransform.useTransform;
  }
});
Object.defineProperty(exports, "useUnmountEffect", {
  enumerable: true,
  get: function () {
    return _useUnmountEffect.useUnmountEffect;
  }
});
Object.defineProperty(exports, "useVelocity", {
  enumerable: true,
  get: function () {
    return _useVelocity.useVelocity;
  }
});
Object.defineProperty(exports, "useViewportScroll", {
  enumerable: true,
  get: function () {
    return _useViewportScroll.useViewportScroll;
  }
});
Object.defineProperty(exports, "useVisualElementContext", {
  enumerable: true,
  get: function () {
    return _index9.useVisualElementContext;
  }
});
Object.defineProperty(exports, "visualElement", {
  enumerable: true,
  get: function () {
    return _index8.visualElement;
  }
});
Object.defineProperty(exports, "wrapHandler", {
  enumerable: true,
  get: function () {
    return _eventInfo.wrapHandler;
  }
});
var _motion = require("./render/dom/motion.mjs");
var _motionMinimal = require("./render/dom/motion-minimal.mjs");
var _index = require("./components/AnimatePresence/index.mjs");
var _AnimateSharedLayout = require("./components/AnimateSharedLayout.mjs");
var _index2 = require("./components/MotionConfig/index.mjs");
var _index3 = require("./components/LazyMotion/index.mjs");
var _index4 = require("./components/LayoutGroup/index.mjs");
var _index5 = require("./components/Reorder/index.mjs");
var _featuresAnimation = require("./render/dom/features-animation.mjs");
var _featuresMax = require("./render/dom/features-max.mjs");
var _useMotionValue = require("./value/use-motion-value.mjs");
var _useMotionTemplate = require("./value/use-motion-template.mjs");
var _index6 = require("./value/index.mjs");
var _resolveMotionValue = require("./value/utils/resolve-motion-value.mjs");
var _useTransform = require("./value/use-transform.mjs");
var _useSpring = require("./value/use-spring.mjs");
var _useVelocity = require("./value/use-velocity.mjs");
var _useScroll = require("./value/use-scroll.mjs");
var _useElementScroll = require("./value/scroll/use-element-scroll.mjs");
var _useViewportScroll = require("./value/scroll/use-viewport-scroll.mjs");
var _useTime = require("./value/use-time.mjs");
var _useReducedMotion = require("./utils/use-reduced-motion.mjs");
var _animationControls = require("./animation/animation-controls.mjs");
var _useAnimation = require("./animation/use-animation.mjs");
var _useAnimationFrame = require("./utils/use-animation-frame.mjs");
var _animate = require("./animation/animate.mjs");
var _animation = require("./render/utils/animation.mjs");
var _useCycle = require("./utils/use-cycle.mjs");
var _transform = require("./utils/transform.mjs");
var _validProp = require("./motion/utils/valid-prop.mjs");
var _usePresence = require("./components/AnimatePresence/use-presence.mjs");
var _useInView = require("./utils/use-in-view.mjs");
var _useDragControls = require("./gestures/drag/use-drag-controls.mjs");
var _useDomEvent = require("./events/use-dom-event.mjs");
var _index7 = require("./motion/index.mjs");
var _index8 = require("./render/index.mjs");
var _scaleCorrection = require("./projection/styles/scale-correction.mjs");
var _useInstantTransition = require("./utils/use-instant-transition.mjs");
var _useInstantLayoutTransition = require("./projection/use-instant-layout-transition.mjs");
var _useResetProjection = require("./projection/use-reset-projection.mjs");
var _index9 = require("./context/MotionContext/index.mjs");
var _MotionConfigContext = require("./context/MotionConfigContext.mjs");
var _PresenceContext = require("./context/PresenceContext.mjs");
var _LayoutGroupContext = require("./context/LayoutGroupContext.mjs");
var _DeprecatedLayoutGroupContext = require("./context/DeprecatedLayoutGroupContext.mjs");
var _SwitchLayoutGroupContext = require("./context/SwitchLayoutGroupContext.mjs");
var _flatTree = require("./render/utils/flat-tree.mjs");
var _useAnimatedState = require("./animation/use-animated-state.mjs");
var _useInvertedScale = require("./value/use-inverted-scale.mjs");
var _types = require("./render/utils/types.mjs");
var _animations = require("./motion/features/animations.mjs");
var _setters = require("./render/utils/setters.mjs");
var _models = require("./projection/geometry/models.mjs");
var _deltaCalc = require("./projection/geometry/delta-calc.mjs");
var _filterProps = require("./render/dom/utils/filter-props.mjs");
var _useVisualState = require("./motion/utils/use-visual-state.mjs");
var _lock = require("./gestures/drag/utils/lock.mjs");
var _usePointerEvent = require("./events/use-pointer-event.mjs");
var _eventInfo = require("./events/event-info.mjs");
var _isMotionValue = require("./value/utils/is-motion-value.mjs");
var _isBrowser = require("./utils/is-browser.mjs");
var _useUnmountEffect = require("./utils/use-unmount-effect.mjs");
var _useIsomorphicEffect = require("./utils/use-isomorphic-effect.mjs");
var _useForceUpdate = require("./utils/use-force-update.mjs");
},{"./render/dom/motion.mjs":"g8vb","./render/dom/motion-minimal.mjs":"DqZ3","./components/AnimatePresence/index.mjs":"iuND","./components/AnimateSharedLayout.mjs":"O5hi","./components/MotionConfig/index.mjs":"vn6c","./components/LazyMotion/index.mjs":"i2Ei","./components/LayoutGroup/index.mjs":"lIE0","./components/Reorder/index.mjs":"Ow6O","./render/dom/features-animation.mjs":"EKP7","./render/dom/features-max.mjs":"kXnc","./value/use-motion-value.mjs":"g4mR","./value/use-motion-template.mjs":"jGDL","./value/index.mjs":"PQTd","./value/utils/resolve-motion-value.mjs":"MEus","./value/use-transform.mjs":"uy6A","./value/use-spring.mjs":"FQQL","./value/use-velocity.mjs":"Co8D","./value/use-scroll.mjs":"N72a","./value/scroll/use-element-scroll.mjs":"T4Ut","./value/scroll/use-viewport-scroll.mjs":"yPHL","./value/use-time.mjs":"L9bs","./utils/use-reduced-motion.mjs":"Lmpf","./animation/animation-controls.mjs":"DUul","./animation/use-animation.mjs":"W61j","./utils/use-animation-frame.mjs":"DZvo","./animation/animate.mjs":"a6aH","./render/utils/animation.mjs":"rHY3","./utils/use-cycle.mjs":"rBwd","./utils/transform.mjs":"by1U","./motion/utils/valid-prop.mjs":"QzZB","./components/AnimatePresence/use-presence.mjs":"oIU2","./utils/use-in-view.mjs":"T3Kn","./gestures/drag/use-drag-controls.mjs":"Rzk3","./events/use-dom-event.mjs":"QUBy","./motion/index.mjs":"zTNr","./render/index.mjs":"BwAh","./projection/styles/scale-correction.mjs":"PNTQ","./utils/use-instant-transition.mjs":"b7vO","./projection/use-instant-layout-transition.mjs":"TeBw","./projection/use-reset-projection.mjs":"dlBT","./context/MotionContext/index.mjs":"rq4D","./context/MotionConfigContext.mjs":"dtoU","./context/PresenceContext.mjs":"eYxR","./context/LayoutGroupContext.mjs":"dh8B","./context/DeprecatedLayoutGroupContext.mjs":"pJ5w","./context/SwitchLayoutGroupContext.mjs":"iF60","./render/utils/flat-tree.mjs":"dNhg","./animation/use-animated-state.mjs":"EaIN","./value/use-inverted-scale.mjs":"cNAf","./render/utils/types.mjs":"gO5D","./motion/features/animations.mjs":"V8nK","./render/utils/setters.mjs":"QDUS","./projection/geometry/models.mjs":"BuZ6","./projection/geometry/delta-calc.mjs":"FBmE","./render/dom/utils/filter-props.mjs":"Rt1I","./motion/utils/use-visual-state.mjs":"b7cz","./gestures/drag/utils/lock.mjs":"UvuD","./events/use-pointer-event.mjs":"tW3y","./events/event-info.mjs":"zZPj","./value/utils/is-motion-value.mjs":"XNB1","./utils/is-browser.mjs":"Kkfx","./utils/use-unmount-effect.mjs":"Iby2","./utils/use-isomorphic-effect.mjs":"tqWN","./utils/use-force-update.mjs":"lEeZ"}],"rlVT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToastComponent = void 0;
var _chunk5XWPESX = require("./chunk-5XWPESX6.mjs");
var _reactUseTimeout = require("@chakra-ui/react-use-timeout");
var _reactUseUpdateEffect = require("@chakra-ui/react-use-update-effect");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _framerMotion = require("framer-motion");
var _system = require("@chakra-ui/system");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/toast.component.tsx

var toastMotionVariants = {
  initial: props => {
    const {
      position
    } = props;
    const dir = ["top", "bottom"].includes(position) ? "y" : "x";
    let factor = ["top-right", "bottom-right"].includes(position) ? 1 : -1;
    if (position === "bottom") factor = 1;
    return {
      opacity: 0,
      [dir]: factor * 24
    };
  },
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.85,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
var ToastComponent = (0, _react.memo)(props => {
  const {
    id,
    message,
    onCloseComplete,
    onRequestRemove,
    requestClose = false,
    position = "bottom",
    duration = 5e3,
    containerStyle,
    motionVariants = toastMotionVariants,
    toastSpacing = "0.5rem"
  } = props;
  const [delay, setDelay] = (0, _react.useState)(duration);
  const isPresent = (0, _framerMotion.useIsPresent)();
  (0, _reactUseUpdateEffect.useUpdateEffect)(() => {
    if (!isPresent) {
      onCloseComplete == null ? void 0 : onCloseComplete();
    }
  }, [isPresent]);
  (0, _reactUseUpdateEffect.useUpdateEffect)(() => {
    setDelay(duration);
  }, [duration]);
  const onMouseEnter = () => setDelay(null);
  const onMouseLeave = () => setDelay(duration);
  const close = () => {
    if (isPresent) onRequestRemove();
  };
  (0, _react.useEffect)(() => {
    if (isPresent && requestClose) {
      onRequestRemove();
    }
  }, [isPresent, requestClose, onRequestRemove]);
  (0, _reactUseTimeout.useTimeout)(close, delay);
  const containerStyles = (0, _react.useMemo)(() => ({
    pointerEvents: "auto",
    maxWidth: 560,
    minWidth: 300,
    margin: toastSpacing,
    ...containerStyle
  }), [containerStyle, toastSpacing]);
  const toastStyle = (0, _react.useMemo)(() => (0, _chunk5XWPESX.getToastStyle)(position), [position]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.motion.li, {
    layout: true,
    className: "chakra-toast",
    variants: motionVariants,
    initial: "initial",
    animate: "animate",
    exit: "exit",
    onHoverStart: onMouseEnter,
    onHoverEnd: onMouseLeave,
    custom: {
      position
    },
    style: toastStyle,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
      role: "status",
      "aria-atomic": "true",
      className: "chakra-toast__inner",
      __css: containerStyles,
      children: (0, _sharedUtils.runIfFn)(message, {
        id,
        onClose: close
      })
    })
  });
});
exports.ToastComponent = ToastComponent;
ToastComponent.displayName = "ToastComponent";
},{"./chunk-5XWPESX6.mjs":"jgcb","@chakra-ui/react-use-timeout":"zBjX","@chakra-ui/react-use-update-effect":"GqG2","@chakra-ui/shared-utils":"gghr","framer-motion":"gNpu","@chakra-ui/system":"ogbg","react":"n8MK","react/jsx-runtime":"plwR"}],"jrAa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToastProvider = void 0;
var _chunk7WY3NOY = require("./chunk-7WY3NOY6.mjs");
var _chunkRANSABEB = require("./chunk-RANSABEB.mjs");
var _chunk5XWPESX = require("./chunk-5XWPESX6.mjs");
var _framerMotion = require("framer-motion");
var _portal = require("@chakra-ui/portal");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/toast.provider.tsx

var ToastProvider = props => {
  const state = (0, _react.useSyncExternalStore)(_chunkRANSABEB.toastStore.subscribe, _chunkRANSABEB.toastStore.getState, _chunkRANSABEB.toastStore.getState);
  const {
    children,
    motionVariants,
    component: Component = _chunk7WY3NOY.ToastComponent,
    portalProps
  } = props;
  const stateKeys = Object.keys(state);
  const toastList = stateKeys.map(position => {
    const toasts = state[position];
    return /* @__PURE__ */(0, _jsxRuntime.jsx)("ul", {
      role: "region",
      "aria-live": "polite",
      id: `chakra-toast-manager-${position}`,
      style: (0, _chunk5XWPESX.getToastListStyle)(position),
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.AnimatePresence, {
        initial: false,
        children: toasts.map(toast => /* @__PURE__ */(0, _jsxRuntime.jsx)(Component, {
          motionVariants,
          ...toast
        }, toast.id))
      })
    }, position);
  });
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [children, /* @__PURE__ */(0, _jsxRuntime.jsx)(_portal.Portal, {
      ...portalProps,
      children: toastList
    })]
  });
};
exports.ToastProvider = ToastProvider;
},{"./chunk-7WY3NOY6.mjs":"rlVT","./chunk-RANSABEB.mjs":"YYXI","./chunk-5XWPESX6.mjs":"jgcb","framer-motion":"gNpu","@chakra-ui/portal":"HPzc","react":"n8MK","react/jsx-runtime":"plwR"}],"O9tX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStandaloneToast = createStandaloneToast;
exports.defaultStandaloneParam = void 0;
var _chunkRPIBUI = require("./chunk-RPIBUI32.mjs");
var _chunkRANSABEB = require("./chunk-RANSABEB.mjs");
var _system = require("@chakra-ui/system");
var _theme = _interopRequireDefault(require("@chakra-ui/theme"));
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// src/create-standalone-toast.tsx

var defaults = {
  duration: 5e3,
  variant: "solid"
};
var defaultStandaloneParam = {
  theme: _theme.default,
  colorMode: "light",
  toggleColorMode: () => {},
  setColorMode: () => {},
  defaultOptions: defaults,
  forced: false
};
exports.defaultStandaloneParam = defaultStandaloneParam;
function createStandaloneToast({
  theme = defaultStandaloneParam.theme,
  colorMode = defaultStandaloneParam.colorMode,
  toggleColorMode = defaultStandaloneParam.toggleColorMode,
  setColorMode = defaultStandaloneParam.setColorMode,
  defaultOptions = defaultStandaloneParam.defaultOptions,
  motionVariants,
  toastSpacing,
  component,
  forced
} = defaultStandaloneParam) {
  const colorModeContextValue = {
    colorMode,
    setColorMode,
    toggleColorMode,
    forced
  };
  const ToastContainer = () => /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.ThemeProvider, {
    theme,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.ColorModeContext.Provider, {
      value: colorModeContextValue,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkRPIBUI.ToastProvider, {
        defaultOptions,
        motionVariants,
        toastSpacing,
        component
      })
    })
  });
  return {
    ToastContainer,
    toast: (0, _chunkRANSABEB.createToastFn)(theme.direction, defaultOptions)
  };
}
},{"./chunk-RPIBUI32.mjs":"jrAa","./chunk-RANSABEB.mjs":"YYXI","@chakra-ui/system":"ogbg","@chakra-ui/theme":"MnNi","react/jsx-runtime":"plwR"}],"GTFK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Toast", {
  enumerable: true,
  get: function () {
    return _chunkRANSABEB.Toast;
  }
});
Object.defineProperty(exports, "ToastProvider", {
  enumerable: true,
  get: function () {
    return _chunkRPIBUI.ToastProvider;
  }
});
Object.defineProperty(exports, "createRenderToast", {
  enumerable: true,
  get: function () {
    return _chunkRANSABEB.createRenderToast;
  }
});
Object.defineProperty(exports, "createStandaloneToast", {
  enumerable: true,
  get: function () {
    return _chunkUJSRCXIR.createStandaloneToast;
  }
});
Object.defineProperty(exports, "createToastFn", {
  enumerable: true,
  get: function () {
    return _chunkRANSABEB.createToastFn;
  }
});
Object.defineProperty(exports, "defaultStandaloneParam", {
  enumerable: true,
  get: function () {
    return _chunkUJSRCXIR.defaultStandaloneParam;
  }
});
Object.defineProperty(exports, "getToastPlacement", {
  enumerable: true,
  get: function () {
    return _chunkF6QD4NSP.getToastPlacement;
  }
});
Object.defineProperty(exports, "useToast", {
  enumerable: true,
  get: function () {
    return _chunkBXBGUOGI.useToast;
  }
});
var _chunkBXBGUOGI = require("./chunk-BXBGUOGI.mjs");
var _chunkUJSRCXIR = require("./chunk-UJSRCXIR.mjs");
var _chunkRPIBUI = require("./chunk-RPIBUI32.mjs");
require("./chunk-7WY3NOY6.mjs");
var _chunkRANSABEB = require("./chunk-RANSABEB.mjs");
require("./chunk-5XWPESX6.mjs");
var _chunkF6QD4NSP = require("./chunk-F6QD4NSP.mjs");
require("./chunk-FWJZM4EJ.mjs");
},{"./chunk-BXBGUOGI.mjs":"tFTP","./chunk-UJSRCXIR.mjs":"O9tX","./chunk-RPIBUI32.mjs":"jrAa","./chunk-7WY3NOY6.mjs":"rlVT","./chunk-RANSABEB.mjs":"YYXI","./chunk-5XWPESX6.mjs":"jgcb","./chunk-F6QD4NSP.mjs":"Haj3","./chunk-FWJZM4EJ.mjs":"Tnu0"}],"MnNk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChakraProvider = exports.ChakraBaseProvider = void 0;
var _provider = require("@chakra-ui/provider");
var _theme = require("@chakra-ui/theme");
var _toast = require("@chakra-ui/toast");
var _jsxRuntime = require("react/jsx-runtime");
// src/chakra-provider.tsx

var createChakraProvider = providerTheme => {
  return function ChakraProvider2({
    children,
    theme = providerTheme,
    toastOptions,
    ...restProps
  }) {
    return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_provider.ChakraProvider, {
      theme,
      ...restProps,
      children: [children, /* @__PURE__ */(0, _jsxRuntime.jsx)(_toast.ToastProvider, {
        ...toastOptions
      })]
    });
  };
};
var ChakraProvider = createChakraProvider(_theme.theme);
exports.ChakraProvider = ChakraProvider;
var ChakraBaseProvider = createChakraProvider(_theme.baseTheme);
exports.ChakraBaseProvider = ChakraBaseProvider;
},{"@chakra-ui/provider":"B8pe","@chakra-ui/theme":"MnNi","@chakra-ui/toast":"GTFK","react/jsx-runtime":"plwR"}],"JMfd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cast = exports.__publicField = void 0;
exports.getNextIndex = getNextIndex;
exports.getPrevIndex = getPrevIndex;
exports.isElement = void 0;
exports.sortNodes = sortNodes;
exports.useSafeLayoutEffect = void 0;
var _react = require("react");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/utils.ts
exports.__publicField = __publicField;
function sortNodes(nodes) {
  return nodes.sort((a, b) => {
    const compare = a.compareDocumentPosition(b);
    if (compare & Node.DOCUMENT_POSITION_FOLLOWING || compare & Node.DOCUMENT_POSITION_CONTAINED_BY) {
      return -1;
    }
    if (compare & Node.DOCUMENT_POSITION_PRECEDING || compare & Node.DOCUMENT_POSITION_CONTAINS) {
      return 1;
    }
    if (compare & Node.DOCUMENT_POSITION_DISCONNECTED || compare & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) {
      throw Error("Cannot sort the given nodes.");
    } else {
      return 0;
    }
  });
}
var isElement = el => typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
exports.isElement = isElement;
function getNextIndex(current, max, loop) {
  let next = current + 1;
  if (loop && next >= max) next = 0;
  return next;
}
function getPrevIndex(current, max, loop) {
  let next = current - 1;
  if (loop && next < 0) next = max;
  return next;
}
var useSafeLayoutEffect = typeof window !== "undefined" ? _react.useLayoutEffect : _react.useEffect;
exports.useSafeLayoutEffect = useSafeLayoutEffect;
var cast = value => value;
exports.cast = cast;
},{"react":"n8MK"}],"NwpB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DescendantsManager = void 0;
var _chunkN7WDF4QK = require("./chunk-N7WDF4QK.mjs");
// src/descendant.ts
var DescendantsManager = class {
  constructor() {
    (0, _chunkN7WDF4QK.__publicField)(this, "descendants", /* @__PURE__ */new Map());
    (0, _chunkN7WDF4QK.__publicField)(this, "register", nodeOrOptions => {
      if (nodeOrOptions == null) return;
      if ((0, _chunkN7WDF4QK.isElement)(nodeOrOptions)) {
        return this.registerNode(nodeOrOptions);
      }
      return node => {
        this.registerNode(node, nodeOrOptions);
      };
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "unregister", node => {
      this.descendants.delete(node);
      const sorted = (0, _chunkN7WDF4QK.sortNodes)(Array.from(this.descendants.keys()));
      this.assignIndex(sorted);
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "destroy", () => {
      this.descendants.clear();
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "assignIndex", descendants => {
      this.descendants.forEach(descendant => {
        const index = descendants.indexOf(descendant.node);
        descendant.index = index;
        descendant.node.dataset["index"] = descendant.index.toString();
      });
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "count", () => this.descendants.size);
    (0, _chunkN7WDF4QK.__publicField)(this, "enabledCount", () => this.enabledValues().length);
    (0, _chunkN7WDF4QK.__publicField)(this, "values", () => {
      const values = Array.from(this.descendants.values());
      return values.sort((a, b) => a.index - b.index);
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "enabledValues", () => {
      return this.values().filter(descendant => !descendant.disabled);
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "item", index => {
      if (this.count() === 0) return void 0;
      return this.values()[index];
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "enabledItem", index => {
      if (this.enabledCount() === 0) return void 0;
      return this.enabledValues()[index];
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "first", () => this.item(0));
    (0, _chunkN7WDF4QK.__publicField)(this, "firstEnabled", () => this.enabledItem(0));
    (0, _chunkN7WDF4QK.__publicField)(this, "last", () => this.item(this.descendants.size - 1));
    (0, _chunkN7WDF4QK.__publicField)(this, "lastEnabled", () => {
      const lastIndex = this.enabledValues().length - 1;
      return this.enabledItem(lastIndex);
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "indexOf", node => {
      var _a, _b;
      if (!node) return -1;
      return (_b = (_a = this.descendants.get(node)) == null ? void 0 : _a.index) != null ? _b : -1;
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "enabledIndexOf", node => {
      if (node == null) return -1;
      return this.enabledValues().findIndex(i => i.node.isSameNode(node));
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "next", (index, loop = true) => {
      const next = (0, _chunkN7WDF4QK.getNextIndex)(index, this.count(), loop);
      return this.item(next);
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "nextEnabled", (index, loop = true) => {
      const item = this.item(index);
      if (!item) return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const nextEnabledIndex = (0, _chunkN7WDF4QK.getNextIndex)(enabledIndex, this.enabledCount(), loop);
      return this.enabledItem(nextEnabledIndex);
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "prev", (index, loop = true) => {
      const prev = (0, _chunkN7WDF4QK.getPrevIndex)(index, this.count() - 1, loop);
      return this.item(prev);
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "prevEnabled", (index, loop = true) => {
      const item = this.item(index);
      if (!item) return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const prevEnabledIndex = (0, _chunkN7WDF4QK.getPrevIndex)(enabledIndex, this.enabledCount() - 1, loop);
      return this.enabledItem(prevEnabledIndex);
    });
    (0, _chunkN7WDF4QK.__publicField)(this, "registerNode", (node, options) => {
      if (!node || this.descendants.has(node)) return;
      const keys = Array.from(this.descendants.keys()).concat(node);
      const sorted = (0, _chunkN7WDF4QK.sortNodes)(keys);
      if (options == null ? void 0 : options.disabled) {
        options.disabled = !!options.disabled;
      }
      const descendant = {
        node,
        index: -1,
        ...options
      };
      this.descendants.set(node, descendant);
      this.assignIndex(sorted);
    });
  }
};
exports.DescendantsManager = DescendantsManager;
},{"./chunk-N7WDF4QK.mjs":"JMfd"}],"EUzL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assignRef = assignRef;
exports.mergeRefs = mergeRefs;
exports.useMergeRefs = useMergeRefs;
var _react = require("react");
// src/index.ts

function assignRef(ref, value) {
  if (ref == null) return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function mergeRefs(...refs) {
  return node => {
    refs.forEach(ref => {
      assignRef(ref, node);
    });
  };
}
function useMergeRefs(...refs) {
  return (0, _react.useMemo)(() => mergeRefs(...refs), refs);
}
},{"react":"n8MK"}],"kRT7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDescendantContext = createDescendantContext;
var _chunkP6SLLHUK = require("./chunk-P6SLLHUK.mjs");
var _chunkN7WDF4QK = require("./chunk-N7WDF4QK.mjs");
var _reactContext = require("@chakra-ui/react-context");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _react = require("react");
// src/use-descendant.ts

function useDescendants() {
  const descendants = (0, _react.useRef)(new _chunkP6SLLHUK.DescendantsManager());
  (0, _chunkN7WDF4QK.useSafeLayoutEffect)(() => {
    return () => descendants.current.destroy();
  });
  return descendants.current;
}
var [DescendantsContextProvider, useDescendantsContext] = (0, _reactContext.createContext)({
  name: "DescendantsProvider",
  errorMessage: "useDescendantsContext must be used within DescendantsProvider"
});
function useDescendant(options) {
  const descendants = useDescendantsContext();
  const [index, setIndex] = (0, _react.useState)(-1);
  const ref = (0, _react.useRef)(null);
  (0, _chunkN7WDF4QK.useSafeLayoutEffect)(() => {
    return () => {
      if (!ref.current) return;
      descendants.unregister(ref.current);
    };
  }, []);
  (0, _chunkN7WDF4QK.useSafeLayoutEffect)(() => {
    if (!ref.current) return;
    const dataIndex = Number(ref.current.dataset["index"]);
    if (index != dataIndex && !Number.isNaN(dataIndex)) {
      setIndex(dataIndex);
    }
  });
  const refCallback = options ? (0, _chunkN7WDF4QK.cast)(descendants.register(options)) : (0, _chunkN7WDF4QK.cast)(descendants.register);
  return {
    descendants,
    index,
    enabledIndex: descendants.enabledIndexOf(ref.current),
    register: (0, _reactUseMergeRefs.mergeRefs)(refCallback, ref)
  };
}
function createDescendantContext() {
  const ContextProvider = (0, _chunkN7WDF4QK.cast)(DescendantsContextProvider);
  const _useDescendantsContext = () => (0, _chunkN7WDF4QK.cast)(useDescendantsContext());
  const _useDescendant = options => useDescendant(options);
  const _useDescendants = () => useDescendants();
  return [ContextProvider, _useDescendantsContext, _useDescendants, _useDescendant];
}
},{"./chunk-P6SLLHUK.mjs":"NwpB","./chunk-N7WDF4QK.mjs":"JMfd","@chakra-ui/react-context":"lT23","@chakra-ui/react-use-merge-refs":"EUzL","react":"n8MK"}],"HJpF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "createDescendantContext", {
  enumerable: true,
  get: function () {
    return _chunkD5UZ3RNN.createDescendantContext;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _chunkD5UZ3RNN.createDescendantContext;
  }
});
var _chunkD5UZ3RNN = require("./chunk-D5UZ3RNN.mjs");
require("./chunk-P6SLLHUK.mjs");
require("./chunk-N7WDF4QK.mjs");
},{"./chunk-D5UZ3RNN.mjs":"kRT7","./chunk-P6SLLHUK.mjs":"NwpB","./chunk-N7WDF4QK.mjs":"JMfd"}],"jEwM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAccordionStyles = exports.useAccordionItemContext = exports.useAccordionDescendantsContext = exports.useAccordionDescendants = exports.useAccordionDescendant = exports.AccordionStylesProvider = exports.AccordionItemProvider = exports.AccordionDescendantsProvider = void 0;
var _descendant = require("@chakra-ui/descendant");
var _reactContext = require("@chakra-ui/react-context");
// src/accordion-context.ts

var [AccordionStylesProvider, useAccordionStyles] = (0, _reactContext.createContext)({
  name: "AccordionStylesContext",
  hookName: "useAccordionStyles",
  providerName: "<Accordion />"
});
exports.useAccordionStyles = useAccordionStyles;
exports.AccordionStylesProvider = AccordionStylesProvider;
var [AccordionItemProvider, useAccordionItemContext] = (0, _reactContext.createContext)({
  name: "AccordionItemContext",
  hookName: "useAccordionItemContext",
  providerName: "<AccordionItem />"
});
exports.useAccordionItemContext = useAccordionItemContext;
exports.AccordionItemProvider = AccordionItemProvider;
var [AccordionDescendantsProvider, useAccordionDescendantsContext, useAccordionDescendants, useAccordionDescendant] = (0, _descendant.createDescendantContext)();
exports.useAccordionDescendant = useAccordionDescendant;
exports.useAccordionDescendants = useAccordionDescendants;
exports.useAccordionDescendantsContext = useAccordionDescendantsContext;
exports.AccordionDescendantsProvider = AccordionDescendantsProvider;
},{"@chakra-ui/descendant":"HJpF","@chakra-ui/react-context":"lT23"}],"c9A0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AccordionButton = void 0;
var _chunkJST25EWU = require("./chunk-JST25EWU.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/accordion-button.tsx

var AccordionButton = (0, _system.forwardRef)(function AccordionButton2(props, ref) {
  const {
    getButtonProps
  } = (0, _chunkJST25EWU.useAccordionItemContext)();
  const buttonProps = getButtonProps(props, ref);
  const styles = (0, _chunkJST25EWU.useAccordionStyles)();
  const buttonStyles = {
    display: "flex",
    alignItems: "center",
    width: "100%",
    outline: 0,
    ...styles.button
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.button, {
    ...buttonProps,
    className: (0, _sharedUtils.cx)("chakra-accordion__button", props.className),
    __css: buttonStyles
  });
});
exports.AccordionButton = AccordionButton;
AccordionButton.displayName = "AccordionButton";
},{"./chunk-JST25EWU.mjs":"jEwM","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"DWQz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useControllableProp = useControllableProp;
exports.useControllableState = useControllableState;
var _react = require("react");
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
// src/index.ts

function useControllableProp(prop, state) {
  const controlled = typeof prop !== "undefined";
  const value = controlled ? prop : state;
  return (0, _react.useMemo)(() => [controlled, value], [controlled, value]);
}
function useControllableState(props) {
  const {
    value: valueProp,
    defaultValue,
    onChange,
    shouldUpdate = (prev, next) => prev !== next
  } = props;
  const onChangeProp = (0, _reactUseCallbackRef.useCallbackRef)(onChange);
  const shouldUpdateProp = (0, _reactUseCallbackRef.useCallbackRef)(shouldUpdate);
  const [uncontrolledState, setUncontrolledState] = (0, _react.useState)(defaultValue);
  const controlled = valueProp !== void 0;
  const value = controlled ? valueProp : uncontrolledState;
  const setValue = (0, _reactUseCallbackRef.useCallbackRef)(next => {
    const setter = next;
    const nextValue = typeof next === "function" ? setter(value) : next;
    if (!shouldUpdateProp(value, nextValue)) {
      return;
    }
    if (!controlled) {
      setUncontrolledState(nextValue);
    }
    onChangeProp(nextValue);
  }, [controlled, onChangeProp, value, shouldUpdateProp]);
  return [value, setValue];
}
},{"react":"n8MK","@chakra-ui/react-use-callback-ref":"PPhG"}],"vMhb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AccordionProvider = void 0;
exports.useAccordion = useAccordion;
exports.useAccordionContext = void 0;
exports.useAccordionItem = useAccordionItem;
var _chunkJST25EWU = require("./chunk-JST25EWU.mjs");
var _reactContext = require("@chakra-ui/react-context");
var _reactUseControllableState = require("@chakra-ui/react-use-controllable-state");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
// src/use-accordion.ts

function useAccordion(props) {
  const {
    onChange,
    defaultIndex,
    index: indexProp,
    allowMultiple,
    allowToggle,
    ...htmlProps
  } = props;
  allowMultipleWarning(props);
  allowMultipleAndAllowToggleWarning(props);
  const descendants = (0, _chunkJST25EWU.useAccordionDescendants)();
  const [focusedIndex, setFocusedIndex] = (0, _react.useState)(-1);
  (0, _react.useEffect)(() => {
    return () => {
      setFocusedIndex(-1);
    };
  }, []);
  const [index, setIndex] = (0, _reactUseControllableState.useControllableState)({
    value: indexProp,
    defaultValue() {
      if (allowMultiple) return defaultIndex != null ? defaultIndex : [];
      return defaultIndex != null ? defaultIndex : -1;
    },
    onChange
  });
  const getAccordionItemProps = idx => {
    let isOpen = false;
    if (idx !== null) {
      isOpen = Array.isArray(index) ? index.includes(idx) : index === idx;
    }
    const onChange2 = isOpen2 => {
      if (idx === null) return;
      if (allowMultiple && Array.isArray(index)) {
        const nextState = isOpen2 ? index.concat(idx) : index.filter(i => i !== idx);
        setIndex(nextState);
      } else if (isOpen2) {
        setIndex(idx);
      } else if (allowToggle) {
        setIndex(-1);
      }
    };
    return {
      isOpen,
      onChange: onChange2
    };
  };
  return {
    index,
    setIndex,
    htmlProps,
    getAccordionItemProps,
    focusedIndex,
    setFocusedIndex,
    descendants
  };
}
var [AccordionProvider, useAccordionContext] = (0, _reactContext.createContext)({
  name: "AccordionContext",
  hookName: "useAccordionContext",
  providerName: "Accordion"
});
exports.useAccordionContext = useAccordionContext;
exports.AccordionProvider = AccordionProvider;
function useAccordionItem(props) {
  const {
    isDisabled,
    isFocusable,
    id,
    ...htmlProps
  } = props;
  const {
    getAccordionItemProps,
    setFocusedIndex
  } = useAccordionContext();
  const buttonRef = (0, _react.useRef)(null);
  const reactId = (0, _react.useId)();
  const uid = id != null ? id : reactId;
  const buttonId = `accordion-button-${uid}`;
  const panelId = `accordion-panel-${uid}`;
  focusableNotDisabledWarning(props);
  const {
    register,
    index,
    descendants
  } = (0, _chunkJST25EWU.useAccordionDescendant)({
    disabled: isDisabled && !isFocusable
  });
  const {
    isOpen,
    onChange
  } = getAccordionItemProps(index === -1 ? null : index);
  warnIfOpenAndDisabled({
    isOpen,
    isDisabled
  });
  const onOpen = () => {
    onChange == null ? void 0 : onChange(true);
  };
  const onClose = () => {
    onChange == null ? void 0 : onChange(false);
  };
  const onClick = (0, _react.useCallback)(() => {
    onChange == null ? void 0 : onChange(!isOpen);
    setFocusedIndex(index);
  }, [index, setFocusedIndex, isOpen, onChange]);
  const onKeyDown = (0, _react.useCallback)(event => {
    const keyMap = {
      ArrowDown: () => {
        const next = descendants.nextEnabled(index);
        next == null ? void 0 : next.node.focus();
      },
      ArrowUp: () => {
        const prev = descendants.prevEnabled(index);
        prev == null ? void 0 : prev.node.focus();
      },
      Home: () => {
        const first = descendants.firstEnabled();
        first == null ? void 0 : first.node.focus();
      },
      End: () => {
        const last = descendants.lastEnabled();
        last == null ? void 0 : last.node.focus();
      }
    };
    const action = keyMap[event.key];
    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [descendants, index]);
  const onFocus = (0, _react.useCallback)(() => {
    setFocusedIndex(index);
  }, [setFocusedIndex, index]);
  const getButtonProps = (0, _react.useCallback)(function getButtonProps2(props2 = {}, ref = null) {
    return {
      ...props2,
      type: "button",
      ref: (0, _reactUseMergeRefs.mergeRefs)(register, buttonRef, ref),
      id: buttonId,
      disabled: !!isDisabled,
      "aria-expanded": !!isOpen,
      "aria-controls": panelId,
      onClick: (0, _sharedUtils.callAllHandlers)(props2.onClick, onClick),
      onFocus: (0, _sharedUtils.callAllHandlers)(props2.onFocus, onFocus),
      onKeyDown: (0, _sharedUtils.callAllHandlers)(props2.onKeyDown, onKeyDown)
    };
  }, [buttonId, isDisabled, isOpen, onClick, onFocus, onKeyDown, panelId, register]);
  const getPanelProps = (0, _react.useCallback)(function getPanelProps2(props2 = {}, ref = null) {
    return {
      ...props2,
      ref,
      role: "region",
      id: panelId,
      "aria-labelledby": buttonId,
      hidden: !isOpen
    };
  }, [buttonId, isOpen, panelId]);
  return {
    isOpen,
    isDisabled,
    isFocusable,
    onOpen,
    onClose,
    getButtonProps,
    getPanelProps,
    htmlProps
  };
}
function allowMultipleWarning(props) {
  const index = props.index || props.defaultIndex;
  const condition = index != null && !Array.isArray(index) && props.allowMultiple;
  (0, _sharedUtils.warn)({
    condition: !!condition,
    message: `If 'allowMultiple' is passed, then 'index' or 'defaultIndex' must be an array. You passed: ${typeof index},`
  });
}
function allowMultipleAndAllowToggleWarning(props) {
  (0, _sharedUtils.warn)({
    condition: !!(props.allowMultiple && props.allowToggle),
    message: `If 'allowMultiple' is passed, 'allowToggle' will be ignored. Either remove 'allowToggle' or 'allowMultiple' depending on whether you want multiple accordions visible or not`
  });
}
function focusableNotDisabledWarning(props) {
  (0, _sharedUtils.warn)({
    condition: !!(props.isFocusable && !props.isDisabled),
    message: `Using only 'isFocusable', this prop is reserved for situations where you pass 'isDisabled' but you still want the element to receive focus (A11y). Either remove it or pass 'isDisabled' as well.
    `
  });
}
function warnIfOpenAndDisabled(props) {
  (0, _sharedUtils.warn)({
    condition: props.isOpen && !!props.isDisabled,
    message: "Cannot open a disabled accordion item"
  });
}
},{"./chunk-JST25EWU.mjs":"jEwM","@chakra-ui/react-context":"lT23","@chakra-ui/react-use-controllable-state":"DWQz","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/shared-utils":"gghr","react":"n8MK"}],"ToOc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AccordionIcon = AccordionIcon;
var _chunkJDQBKIKM = require("./chunk-JDQBKIKM.mjs");
var _chunkJST25EWU = require("./chunk-JST25EWU.mjs");
var _icon = require("@chakra-ui/icon");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/accordion-icon.tsx

function AccordionIcon(props) {
  const {
    isOpen,
    isDisabled
  } = (0, _chunkJST25EWU.useAccordionItemContext)();
  const {
    reduceMotion
  } = (0, _chunkJDQBKIKM.useAccordionContext)();
  const _className = (0, _sharedUtils.cx)("chakra-accordion__icon", props.className);
  const styles = (0, _chunkJST25EWU.useAccordionStyles)();
  const iconStyles = {
    opacity: isDisabled ? 0.4 : 1,
    transform: isOpen ? "rotate(-180deg)" : void 0,
    transition: reduceMotion ? void 0 : "transform 0.2s",
    transformOrigin: "center",
    ...styles.icon
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
    viewBox: "0 0 24 24",
    "aria-hidden": true,
    className: _className,
    __css: iconStyles,
    ...props,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
      fill: "currentColor",
      d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
    })
  });
}
AccordionIcon.displayName = "AccordionIcon";
},{"./chunk-JDQBKIKM.mjs":"vMhb","./chunk-JST25EWU.mjs":"jEwM","@chakra-ui/icon":"aPuf","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"eOEH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AccordionItem = void 0;
var _chunkJDQBKIKM = require("./chunk-JDQBKIKM.mjs");
var _chunkJST25EWU = require("./chunk-JST25EWU.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/accordion-item.tsx

var AccordionItem = (0, _system.forwardRef)(function AccordionItem2(props, ref) {
  const {
    children,
    className
  } = props;
  const {
    htmlProps,
    ...context
  } = (0, _chunkJDQBKIKM.useAccordionItem)(props);
  const styles = (0, _chunkJST25EWU.useAccordionStyles)();
  const containerStyles = {
    ...styles.container,
    overflowAnchor: "none"
  };
  const ctx = (0, _react.useMemo)(() => context, [context]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkJST25EWU.AccordionItemProvider, {
    value: ctx,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
      ref,
      ...htmlProps,
      className: (0, _sharedUtils.cx)("chakra-accordion__item", className),
      __css: containerStyles,
      children: typeof children === "function" ? children({
        isExpanded: !!context.isOpen,
        isDisabled: !!context.isDisabled
      }) : children
    })
  });
});
exports.AccordionItem = AccordionItem;
AccordionItem.displayName = "AccordionItem";
},{"./chunk-JDQBKIKM.mjs":"vMhb","./chunk-JST25EWU.mjs":"jEwM","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"eiU0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRANSITION_VARIANTS = exports.TRANSITION_EASINGS = exports.TRANSITION_DEFAULTS = void 0;
exports.getSlideTransition = getSlideTransition;
exports.withDelay = void 0;
// src/transition-utils.ts
var TRANSITION_EASINGS = {
  ease: [0.25, 0.1, 0.25, 1],
  easeIn: [0.4, 0, 1, 1],
  easeOut: [0, 0, 0.2, 1],
  easeInOut: [0.4, 0, 0.2, 1]
};
exports.TRANSITION_EASINGS = TRANSITION_EASINGS;
var TRANSITION_VARIANTS = {
  scale: {
    enter: {
      scale: 1
    },
    exit: {
      scale: 0.95
    }
  },
  fade: {
    enter: {
      opacity: 1
    },
    exit: {
      opacity: 0
    }
  },
  pushLeft: {
    enter: {
      x: "100%"
    },
    exit: {
      x: "-30%"
    }
  },
  pushRight: {
    enter: {
      x: "-100%"
    },
    exit: {
      x: "30%"
    }
  },
  pushUp: {
    enter: {
      y: "100%"
    },
    exit: {
      y: "-30%"
    }
  },
  pushDown: {
    enter: {
      y: "-100%"
    },
    exit: {
      y: "30%"
    }
  },
  slideLeft: {
    position: {
      left: 0,
      top: 0,
      bottom: 0,
      width: "100%"
    },
    enter: {
      x: 0,
      y: 0
    },
    exit: {
      x: "-100%",
      y: 0
    }
  },
  slideRight: {
    position: {
      right: 0,
      top: 0,
      bottom: 0,
      width: "100%"
    },
    enter: {
      x: 0,
      y: 0
    },
    exit: {
      x: "100%",
      y: 0
    }
  },
  slideUp: {
    position: {
      top: 0,
      left: 0,
      right: 0,
      maxWidth: "100vw"
    },
    enter: {
      x: 0,
      y: 0
    },
    exit: {
      x: 0,
      y: "-100%"
    }
  },
  slideDown: {
    position: {
      bottom: 0,
      left: 0,
      right: 0,
      maxWidth: "100vw"
    },
    enter: {
      x: 0,
      y: 0
    },
    exit: {
      x: 0,
      y: "100%"
    }
  }
};
exports.TRANSITION_VARIANTS = TRANSITION_VARIANTS;
function getSlideTransition(options) {
  var _a;
  const side = (_a = options == null ? void 0 : options.direction) != null ? _a : "right";
  switch (side) {
    case "right":
      return TRANSITION_VARIANTS.slideRight;
    case "left":
      return TRANSITION_VARIANTS.slideLeft;
    case "bottom":
      return TRANSITION_VARIANTS.slideDown;
    case "top":
      return TRANSITION_VARIANTS.slideUp;
    default:
      return TRANSITION_VARIANTS.slideRight;
  }
}
var TRANSITION_DEFAULTS = {
  enter: {
    duration: 0.2,
    ease: TRANSITION_EASINGS.easeOut
  },
  exit: {
    duration: 0.1,
    ease: TRANSITION_EASINGS.easeIn
  }
};
exports.TRANSITION_DEFAULTS = TRANSITION_DEFAULTS;
var withDelay = {
  enter: (transition, delay) => ({
    ...transition,
    delay: typeof delay === "number" ? delay : delay == null ? void 0 : delay["enter"]
  }),
  exit: (transition, delay) => ({
    ...transition,
    delay: typeof delay === "number" ? delay : delay == null ? void 0 : delay["exit"]
  })
};
exports.withDelay = withDelay;
},{}],"cGZx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Collapse = void 0;
var _chunkLB6CWFOC = require("./chunk-LB6CWFOC.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _framerMotion = require("framer-motion");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/collapse.tsx

var isNumeric = value => value != null && parseInt(value.toString(), 10) > 0;
var defaultTransitions = {
  exit: {
    height: {
      duration: 0.2,
      ease: _chunkLB6CWFOC.TRANSITION_EASINGS.ease
    },
    opacity: {
      duration: 0.3,
      ease: _chunkLB6CWFOC.TRANSITION_EASINGS.ease
    }
  },
  enter: {
    height: {
      duration: 0.3,
      ease: _chunkLB6CWFOC.TRANSITION_EASINGS.ease
    },
    opacity: {
      duration: 0.4,
      ease: _chunkLB6CWFOC.TRANSITION_EASINGS.ease
    }
  }
};
var variants = {
  exit: ({
    animateOpacity,
    startingHeight,
    transition,
    transitionEnd,
    delay
  }) => {
    var _a;
    return {
      ...(animateOpacity && {
        opacity: isNumeric(startingHeight) ? 1 : 0
      }),
      height: startingHeight,
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit,
      transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : _chunkLB6CWFOC.withDelay.exit(defaultTransitions.exit, delay)
    };
  },
  enter: ({
    animateOpacity,
    endingHeight,
    transition,
    transitionEnd,
    delay
  }) => {
    var _a;
    return {
      ...(animateOpacity && {
        opacity: 1
      }),
      height: endingHeight,
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter,
      transition: (_a = transition == null ? void 0 : transition.enter) != null ? _a : _chunkLB6CWFOC.withDelay.enter(defaultTransitions.enter, delay)
    };
  }
};
var Collapse = (0, _react.forwardRef)((props, ref) => {
  const {
    in: isOpen,
    unmountOnExit,
    animateOpacity = true,
    startingHeight = 0,
    endingHeight = "auto",
    style,
    className,
    transition,
    transitionEnd,
    ...rest
  } = props;
  const [mounted, setMounted] = (0, _react.useState)(false);
  (0, _react.useEffect)(() => {
    const timeout = setTimeout(() => {
      setMounted(true);
    });
    return () => clearTimeout(timeout);
  }, []);
  (0, _sharedUtils.warn)({
    condition: Boolean(startingHeight > 0 && unmountOnExit),
    message: `startingHeight and unmountOnExit are mutually exclusive. You can't use them together`
  });
  const hasStartingHeight = parseFloat(startingHeight.toString()) > 0;
  const custom = {
    startingHeight,
    endingHeight,
    animateOpacity,
    transition: !mounted ? {
      enter: {
        duration: 0
      }
    } : transition,
    transitionEnd: {
      enter: transitionEnd == null ? void 0 : transitionEnd.enter,
      exit: unmountOnExit ? transitionEnd == null ? void 0 : transitionEnd.exit : {
        ...(transitionEnd == null ? void 0 : transitionEnd.exit),
        display: hasStartingHeight ? "block" : "none"
      }
    }
  };
  const show = unmountOnExit ? isOpen : true;
  const animate = isOpen || unmountOnExit ? "enter" : "exit";
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.AnimatePresence, {
    initial: false,
    custom,
    children: show && /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.motion.div, {
      ref,
      ...rest,
      className: (0, _sharedUtils.cx)("chakra-collapse", className),
      style: {
        overflow: "hidden",
        display: "block",
        ...style
      },
      custom,
      variants,
      initial: unmountOnExit ? "exit" : false,
      animate,
      exit: "exit"
    })
  });
});
exports.Collapse = Collapse;
Collapse.displayName = "Collapse";
},{"./chunk-LB6CWFOC.mjs":"eiU0","@chakra-ui/shared-utils":"gghr","framer-motion":"gNpu","react":"n8MK","react/jsx-runtime":"plwR"}],"oldU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fadeConfig = exports.Fade = void 0;
var _chunkLB6CWFOC = require("./chunk-LB6CWFOC.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _framerMotion = require("framer-motion");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/fade.tsx

var variants = {
  enter: ({
    transition,
    transitionEnd,
    delay
  } = {}) => {
    var _a;
    return {
      opacity: 1,
      transition: (_a = transition == null ? void 0 : transition.enter) != null ? _a : _chunkLB6CWFOC.withDelay.enter(_chunkLB6CWFOC.TRANSITION_DEFAULTS.enter, delay),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
    };
  },
  exit: ({
    transition,
    transitionEnd,
    delay
  } = {}) => {
    var _a;
    return {
      opacity: 0,
      transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : _chunkLB6CWFOC.withDelay.exit(_chunkLB6CWFOC.TRANSITION_DEFAULTS.exit, delay),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
    };
  }
};
var fadeConfig = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants
};
exports.fadeConfig = fadeConfig;
var Fade = (0, _react.forwardRef)(function Fade2(props, ref) {
  const {
    unmountOnExit,
    in: isOpen,
    className,
    transition,
    transitionEnd,
    delay,
    ...rest
  } = props;
  const animate = isOpen || unmountOnExit ? "enter" : "exit";
  const show = unmountOnExit ? isOpen && unmountOnExit : true;
  const custom = {
    transition,
    transitionEnd,
    delay
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.AnimatePresence, {
    custom,
    children: show && /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.motion.div, {
      ref,
      className: (0, _sharedUtils.cx)("chakra-fade", className),
      custom,
      ...fadeConfig,
      animate,
      ...rest
    })
  });
});
exports.Fade = Fade;
Fade.displayName = "Fade";
},{"./chunk-LB6CWFOC.mjs":"eiU0","@chakra-ui/shared-utils":"gghr","framer-motion":"gNpu","react":"n8MK","react/jsx-runtime":"plwR"}],"SA8t":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scaleFadeConfig = exports.ScaleFade = void 0;
var _chunkLB6CWFOC = require("./chunk-LB6CWFOC.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _framerMotion = require("framer-motion");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/scale-fade.tsx

var variants = {
  exit: ({
    reverse,
    initialScale,
    transition,
    transitionEnd,
    delay
  }) => {
    var _a;
    return {
      opacity: 0,
      ...(reverse ? {
        scale: initialScale,
        transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
      } : {
        transitionEnd: {
          scale: initialScale,
          ...(transitionEnd == null ? void 0 : transitionEnd.exit)
        }
      }),
      transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : _chunkLB6CWFOC.withDelay.exit(_chunkLB6CWFOC.TRANSITION_DEFAULTS.exit, delay)
    };
  },
  enter: ({
    transitionEnd,
    transition,
    delay
  }) => {
    var _a;
    return {
      opacity: 1,
      scale: 1,
      transition: (_a = transition == null ? void 0 : transition.enter) != null ? _a : _chunkLB6CWFOC.withDelay.enter(_chunkLB6CWFOC.TRANSITION_DEFAULTS.enter, delay),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
    };
  }
};
var scaleFadeConfig = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants
};
exports.scaleFadeConfig = scaleFadeConfig;
var ScaleFade = (0, _react.forwardRef)(function ScaleFade2(props, ref) {
  const {
    unmountOnExit,
    in: isOpen,
    reverse = true,
    initialScale = 0.95,
    className,
    transition,
    transitionEnd,
    delay,
    ...rest
  } = props;
  const show = unmountOnExit ? isOpen && unmountOnExit : true;
  const animate = isOpen || unmountOnExit ? "enter" : "exit";
  const custom = {
    initialScale,
    reverse,
    transition,
    transitionEnd,
    delay
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.AnimatePresence, {
    custom,
    children: show && /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.motion.div, {
      ref,
      className: (0, _sharedUtils.cx)("chakra-offset-slide", className),
      ...scaleFadeConfig,
      animate,
      custom,
      ...rest
    })
  });
});
exports.ScaleFade = ScaleFade;
ScaleFade.displayName = "ScaleFade";
},{"./chunk-LB6CWFOC.mjs":"eiU0","@chakra-ui/shared-utils":"gghr","framer-motion":"gNpu","react":"n8MK","react/jsx-runtime":"plwR"}],"BhwC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.slideFadeConfig = exports.SlideFade = void 0;
var _chunkLB6CWFOC = require("./chunk-LB6CWFOC.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _framerMotion = require("framer-motion");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/slide-fade.tsx

var variants = {
  initial: ({
    offsetX,
    offsetY,
    transition,
    transitionEnd,
    delay
  }) => {
    var _a;
    return {
      opacity: 0,
      x: offsetX,
      y: offsetY,
      transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : _chunkLB6CWFOC.withDelay.exit(_chunkLB6CWFOC.TRANSITION_DEFAULTS.exit, delay),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
    };
  },
  enter: ({
    transition,
    transitionEnd,
    delay
  }) => {
    var _a;
    return {
      opacity: 1,
      x: 0,
      y: 0,
      transition: (_a = transition == null ? void 0 : transition.enter) != null ? _a : _chunkLB6CWFOC.withDelay.enter(_chunkLB6CWFOC.TRANSITION_DEFAULTS.enter, delay),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
    };
  },
  exit: ({
    offsetY,
    offsetX,
    transition,
    transitionEnd,
    reverse,
    delay
  }) => {
    var _a;
    const offset = {
      x: offsetX,
      y: offsetY
    };
    return {
      opacity: 0,
      transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : _chunkLB6CWFOC.withDelay.exit(_chunkLB6CWFOC.TRANSITION_DEFAULTS.exit, delay),
      ...(reverse ? {
        ...offset,
        transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
      } : {
        transitionEnd: {
          ...offset,
          ...(transitionEnd == null ? void 0 : transitionEnd.exit)
        }
      })
    };
  }
};
var slideFadeConfig = {
  initial: "initial",
  animate: "enter",
  exit: "exit",
  variants
};
exports.slideFadeConfig = slideFadeConfig;
var SlideFade = (0, _react.forwardRef)(function SlideFade2(props, ref) {
  const {
    unmountOnExit,
    in: isOpen,
    reverse = true,
    className,
    offsetX = 0,
    offsetY = 8,
    transition,
    transitionEnd,
    delay,
    ...rest
  } = props;
  const show = unmountOnExit ? isOpen && unmountOnExit : true;
  const animate = isOpen || unmountOnExit ? "enter" : "exit";
  const custom = {
    offsetX,
    offsetY,
    reverse,
    transition,
    transitionEnd,
    delay
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.AnimatePresence, {
    custom,
    children: show && /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.motion.div, {
      ref,
      className: (0, _sharedUtils.cx)("chakra-offset-slide", className),
      custom,
      ...slideFadeConfig,
      animate,
      ...rest
    })
  });
});
exports.SlideFade = SlideFade;
SlideFade.displayName = "SlideFade";
},{"./chunk-LB6CWFOC.mjs":"eiU0","@chakra-ui/shared-utils":"gghr","framer-motion":"gNpu","react":"n8MK","react/jsx-runtime":"plwR"}],"qPLU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Slide = void 0;
var _chunkLB6CWFOC = require("./chunk-LB6CWFOC.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _framerMotion = require("framer-motion");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/slide.tsx

var defaultTransition = {
  exit: {
    duration: 0.15,
    ease: _chunkLB6CWFOC.TRANSITION_EASINGS.easeInOut
  },
  enter: {
    type: "spring",
    damping: 25,
    stiffness: 180
  }
};
var variants = {
  exit: ({
    direction,
    transition,
    transitionEnd,
    delay
  }) => {
    var _a;
    const {
      exit: exitStyles
    } = (0, _chunkLB6CWFOC.getSlideTransition)({
      direction
    });
    return {
      ...exitStyles,
      transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : _chunkLB6CWFOC.withDelay.exit(defaultTransition.exit, delay),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
    };
  },
  enter: ({
    direction,
    transitionEnd,
    transition,
    delay
  }) => {
    var _a;
    const {
      enter: enterStyles
    } = (0, _chunkLB6CWFOC.getSlideTransition)({
      direction
    });
    return {
      ...enterStyles,
      transition: (_a = transition == null ? void 0 : transition.enter) != null ? _a : _chunkLB6CWFOC.withDelay.enter(defaultTransition.enter, delay),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
    };
  }
};
var Slide = (0, _react.forwardRef)(function Slide2(props, ref) {
  const {
    direction = "right",
    style,
    unmountOnExit,
    in: isOpen,
    className,
    transition,
    transitionEnd,
    delay,
    motionProps,
    ...rest
  } = props;
  const transitionStyles = (0, _chunkLB6CWFOC.getSlideTransition)({
    direction
  });
  const computedStyle = Object.assign({
    position: "fixed"
  }, transitionStyles.position, style);
  const show = unmountOnExit ? isOpen && unmountOnExit : true;
  const animate = isOpen || unmountOnExit ? "enter" : "exit";
  const custom = {
    transitionEnd,
    transition,
    direction,
    delay
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.AnimatePresence, {
    custom,
    children: show && /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.motion.div, {
      ...rest,
      ref,
      initial: "exit",
      className: (0, _sharedUtils.cx)("chakra-slide", className),
      animate,
      exit: "exit",
      custom,
      variants,
      style: computedStyle,
      ...motionProps
    })
  });
});
exports.Slide = Slide;
Slide.displayName = "Slide";
},{"./chunk-LB6CWFOC.mjs":"eiU0","@chakra-ui/shared-utils":"gghr","framer-motion":"gNpu","react":"n8MK","react/jsx-runtime":"plwR"}],"H7Ru":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Collapse", {
  enumerable: true,
  get: function () {
    return _chunk3TED3OTR.Collapse;
  }
});
Object.defineProperty(exports, "EASINGS", {
  enumerable: true,
  get: function () {
    return _chunkLB6CWFOC.TRANSITION_EASINGS;
  }
});
Object.defineProperty(exports, "Fade", {
  enumerable: true,
  get: function () {
    return _chunkNBEP2PWU.Fade;
  }
});
Object.defineProperty(exports, "ScaleFade", {
  enumerable: true,
  get: function () {
    return _chunk462CPKWM.ScaleFade;
  }
});
Object.defineProperty(exports, "Slide", {
  enumerable: true,
  get: function () {
    return _chunkD35G6FNO.Slide;
  }
});
Object.defineProperty(exports, "SlideFade", {
  enumerable: true,
  get: function () {
    return _chunkZ2TCYYTS.SlideFade;
  }
});
Object.defineProperty(exports, "fadeConfig", {
  enumerable: true,
  get: function () {
    return _chunkNBEP2PWU.fadeConfig;
  }
});
Object.defineProperty(exports, "getSlideTransition", {
  enumerable: true,
  get: function () {
    return _chunkLB6CWFOC.getSlideTransition;
  }
});
Object.defineProperty(exports, "scaleFadeConfig", {
  enumerable: true,
  get: function () {
    return _chunk462CPKWM.scaleFadeConfig;
  }
});
Object.defineProperty(exports, "slideFadeConfig", {
  enumerable: true,
  get: function () {
    return _chunkZ2TCYYTS.slideFadeConfig;
  }
});
Object.defineProperty(exports, "withDelay", {
  enumerable: true,
  get: function () {
    return _chunkLB6CWFOC.withDelay;
  }
});
var _chunk3TED3OTR = require("./chunk-3TED3OTR.mjs");
var _chunkNBEP2PWU = require("./chunk-NBEP2PWU.mjs");
var _chunk462CPKWM = require("./chunk-462CPKWM.mjs");
var _chunkZ2TCYYTS = require("./chunk-Z2TCYYTS.mjs");
var _chunkD35G6FNO = require("./chunk-D35G6FNO.mjs");
var _chunkLB6CWFOC = require("./chunk-LB6CWFOC.mjs");
},{"./chunk-3TED3OTR.mjs":"cGZx","./chunk-NBEP2PWU.mjs":"oldU","./chunk-462CPKWM.mjs":"SA8t","./chunk-Z2TCYYTS.mjs":"BhwC","./chunk-D35G6FNO.mjs":"qPLU","./chunk-LB6CWFOC.mjs":"eiU0"}],"sLXj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AccordionPanel = void 0;
var _chunkJDQBKIKM = require("./chunk-JDQBKIKM.mjs");
var _chunkJST25EWU = require("./chunk-JST25EWU.mjs");
var _system = require("@chakra-ui/system");
var _transition = require("@chakra-ui/transition");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/accordion-panel.tsx

var AccordionPanel = (0, _system.forwardRef)(function AccordionPanel2(props, ref) {
  const {
    className,
    motionProps,
    ...rest
  } = props;
  const {
    reduceMotion
  } = (0, _chunkJDQBKIKM.useAccordionContext)();
  const {
    getPanelProps,
    isOpen
  } = (0, _chunkJST25EWU.useAccordionItemContext)();
  const panelProps = getPanelProps(rest, ref);
  const _className = (0, _sharedUtils.cx)("chakra-accordion__panel", className);
  const styles = (0, _chunkJST25EWU.useAccordionStyles)();
  if (!reduceMotion) {
    delete panelProps.hidden;
  }
  const child = /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...panelProps,
    __css: styles.panel,
    className: _className
  });
  if (!reduceMotion) {
    return /* @__PURE__ */(0, _jsxRuntime.jsx)(_transition.Collapse, {
      in: isOpen,
      ...motionProps,
      children: child
    });
  }
  return child;
});
exports.AccordionPanel = AccordionPanel;
AccordionPanel.displayName = "AccordionPanel";
},{"./chunk-JDQBKIKM.mjs":"vMhb","./chunk-JST25EWU.mjs":"jEwM","@chakra-ui/system":"ogbg","@chakra-ui/transition":"H7Ru","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"IYkD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Accordion = void 0;
var _chunkJDQBKIKM = require("./chunk-JDQBKIKM.mjs");
var _chunkJST25EWU = require("./chunk-JST25EWU.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/accordion.tsx

var Accordion = (0, _system.forwardRef)(function Accordion2({
  children,
  reduceMotion,
  ...props
}, ref) {
  const styles = (0, _system.useMultiStyleConfig)("Accordion", props);
  const ownProps = (0, _system.omitThemingProps)(props);
  const {
    htmlProps,
    descendants,
    ...context
  } = (0, _chunkJDQBKIKM.useAccordion)(ownProps);
  const ctx = (0, _react.useMemo)(() => ({
    ...context,
    reduceMotion: !!reduceMotion
  }), [context, reduceMotion]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkJST25EWU.AccordionDescendantsProvider, {
    value: descendants,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkJDQBKIKM.AccordionProvider, {
      value: ctx,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkJST25EWU.AccordionStylesProvider, {
        value: styles,
        children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
          ref,
          ...htmlProps,
          className: (0, _sharedUtils.cx)("chakra-accordion", props.className),
          __css: styles.root,
          children
        })
      })
    })
  });
});
exports.Accordion = Accordion;
Accordion.displayName = "Accordion";
},{"./chunk-JDQBKIKM.mjs":"vMhb","./chunk-JST25EWU.mjs":"jEwM","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"sjov":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAccordionItemState = useAccordionItemState;
var _chunkJST25EWU = require("./chunk-JST25EWU.mjs");
// src/use-accordion-item-state.ts
function useAccordionItemState() {
  const {
    isOpen,
    isDisabled,
    onClose,
    onOpen
  } = (0, _chunkJST25EWU.useAccordionItemContext)();
  return {
    isOpen,
    onClose,
    isDisabled,
    onOpen
  };
}
},{"./chunk-JST25EWU.mjs":"jEwM"}],"R6Ey":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Accordion", {
  enumerable: true,
  get: function () {
    return _chunk3VH7AMBV.Accordion;
  }
});
Object.defineProperty(exports, "AccordionButton", {
  enumerable: true,
  get: function () {
    return _chunkAPVWO53B.AccordionButton;
  }
});
Object.defineProperty(exports, "AccordionIcon", {
  enumerable: true,
  get: function () {
    return _chunkIXS34X2E.AccordionIcon;
  }
});
Object.defineProperty(exports, "AccordionItem", {
  enumerable: true,
  get: function () {
    return _chunkI3JYRBXX.AccordionItem;
  }
});
Object.defineProperty(exports, "AccordionPanel", {
  enumerable: true,
  get: function () {
    return _chunkWA4Q3J7T.AccordionPanel;
  }
});
Object.defineProperty(exports, "AccordionProvider", {
  enumerable: true,
  get: function () {
    return _chunkJDQBKIKM.AccordionProvider;
  }
});
Object.defineProperty(exports, "useAccordion", {
  enumerable: true,
  get: function () {
    return _chunkJDQBKIKM.useAccordion;
  }
});
Object.defineProperty(exports, "useAccordionContext", {
  enumerable: true,
  get: function () {
    return _chunkJDQBKIKM.useAccordionContext;
  }
});
Object.defineProperty(exports, "useAccordionItem", {
  enumerable: true,
  get: function () {
    return _chunkJDQBKIKM.useAccordionItem;
  }
});
Object.defineProperty(exports, "useAccordionItemState", {
  enumerable: true,
  get: function () {
    return _chunkUN5JZMTF.useAccordionItemState;
  }
});
Object.defineProperty(exports, "useAccordionStyles", {
  enumerable: true,
  get: function () {
    return _chunkJST25EWU.useAccordionStyles;
  }
});
var _chunkAPVWO53B = require("./chunk-APVWO53B.mjs");
var _chunkIXS34X2E = require("./chunk-IXS34X2E.mjs");
var _chunkI3JYRBXX = require("./chunk-I3JYRBXX.mjs");
var _chunkWA4Q3J7T = require("./chunk-WA4Q3J7T.mjs");
var _chunk3VH7AMBV = require("./chunk-3VH7AMBV.mjs");
var _chunkJDQBKIKM = require("./chunk-JDQBKIKM.mjs");
var _chunkUN5JZMTF = require("./chunk-UN5JZMTF.mjs");
var _chunkJST25EWU = require("./chunk-JST25EWU.mjs");
},{"./chunk-APVWO53B.mjs":"c9A0","./chunk-IXS34X2E.mjs":"ToOc","./chunk-I3JYRBXX.mjs":"eOEH","./chunk-WA4Q3J7T.mjs":"sLXj","./chunk-3VH7AMBV.mjs":"IYkD","./chunk-JDQBKIKM.mjs":"vMhb","./chunk-UN5JZMTF.mjs":"sjov","./chunk-JST25EWU.mjs":"jEwM"}],"Xw8j":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAvatarStyles = exports.AvatarStylesProvider = void 0;
var _reactContext = require("@chakra-ui/react-context");
// src/avatar-context.tsx

var [AvatarStylesProvider, useAvatarStyles] = (0, _reactContext.createContext)({
  name: `AvatarStylesContext`,
  hookName: `useAvatarStyles`,
  providerName: "<Avatar/>"
});
exports.useAvatarStyles = useAvatarStyles;
exports.AvatarStylesProvider = AvatarStylesProvider;
},{"@chakra-ui/react-context":"lT23"}],"S0TY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AvatarBadge = void 0;
var _chunkQVBG3QXJ = require("./chunk-QVBG3QXJ.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/avatar-badge.tsx

var placementMap = {
  "top-start": {
    top: "0",
    insetStart: "0",
    transform: "translate(-25%, -25%)"
  },
  "top-end": {
    top: "0",
    insetEnd: "0",
    transform: "translate(25%, -25%)"
  },
  "bottom-start": {
    bottom: "0",
    insetStart: "0",
    transform: "translate(-25%, 25%)"
  },
  "bottom-end": {
    bottom: "0",
    insetEnd: "0",
    transform: "translate(25%, 25%)"
  }
};
var AvatarBadge = (0, _system.forwardRef)(function AvatarBadge2(props, ref) {
  const {
    placement = "bottom-end",
    className,
    ...rest
  } = props;
  const styles = (0, _chunkQVBG3QXJ.useAvatarStyles)();
  const placementStyles = placementMap[placement];
  const badgeStyles = {
    position: "absolute",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    ...placementStyles,
    ...styles.badge
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    ...rest,
    className: (0, _sharedUtils.cx)("chakra-avatar__badge", className),
    __css: badgeStyles
  });
});
exports.AvatarBadge = AvatarBadge;
AvatarBadge.displayName = "AvatarBadge";
},{"./chunk-QVBG3QXJ.mjs":"Xw8j","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"xK3S":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AvatarName = AvatarName;
exports.initials = initials;
var _chunkQVBG3QXJ = require("./chunk-QVBG3QXJ.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/avatar-name.tsx

function initials(name) {
  const [firstName, lastName] = name.split(" ");
  return firstName && lastName ? `${firstName.charAt(0)}${lastName.charAt(0)}` : firstName.charAt(0);
}
function AvatarName(props) {
  const {
    name,
    getInitials,
    ...rest
  } = props;
  const styles = (0, _chunkQVBG3QXJ.useAvatarStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    role: "img",
    "aria-label": name,
    ...rest,
    __css: styles.label,
    children: name ? getInitials == null ? void 0 : getInitials(name) : null
  });
}
AvatarName.displayName = "AvatarName";
},{"./chunk-QVBG3QXJ.mjs":"Xw8j","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"r4lf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericAvatarIcon = void 0;
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/generic-avatar-icon.tsx

var GenericAvatarIcon = props => /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.svg, {
  viewBox: "0 0 128 128",
  color: "#fff",
  width: "100%",
  height: "100%",
  className: "chakra-avatar__svg",
  ...props,
  children: [/* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
    fill: "currentColor",
    d: "M103,102.1388 C93.094,111.92 79.3504,118 64.1638,118 C48.8056,118 34.9294,111.768 25,101.7892 L25,95.2 C25,86.8096 31.981,80 40.6,80 L87.4,80 C96.019,80 103,86.8096 103,95.2 L103,102.1388 Z"
  }), /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
    fill: "currentColor",
    d: "M63.9961647,24 C51.2938136,24 41,34.2938136 41,46.9961647 C41,59.7061864 51.2938136,70 63.9961647,70 C76.6985159,70 87,59.7061864 87,46.9961647 C87,34.2938136 76.6985159,24 63.9961647,24"
  })]
});
exports.GenericAvatarIcon = GenericAvatarIcon;
},{"@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"aIcM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NativeImage = void 0;
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/native-image.tsx

var NativeImage = (0, _system.forwardRef)(function NativeImage2(props, ref) {
  const {
    htmlWidth,
    htmlHeight,
    alt,
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)("img", {
    width: htmlWidth,
    height: htmlHeight,
    ref,
    alt,
    ...rest
  });
});
exports.NativeImage = NativeImage;
NativeImage.displayName = "NativeImage";
},{"@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"w9EF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldShowFallbackImage = void 0;
exports.useImage = useImage;
var _reactUseSafeLayoutEffect = require("@chakra-ui/react-use-safe-layout-effect");
var _react = require("react");
// src/use-image.ts

function useImage(props) {
  const {
    loading,
    src,
    srcSet,
    onLoad,
    onError,
    crossOrigin,
    sizes,
    ignoreFallback
  } = props;
  const [status, setStatus] = (0, _react.useState)("pending");
  (0, _react.useEffect)(() => {
    setStatus(src ? "loading" : "pending");
  }, [src]);
  const imageRef = (0, _react.useRef)();
  const load = (0, _react.useCallback)(() => {
    if (!src) return;
    flush();
    const img = new Image();
    img.src = src;
    if (crossOrigin) img.crossOrigin = crossOrigin;
    if (srcSet) img.srcset = srcSet;
    if (sizes) img.sizes = sizes;
    if (loading) img.loading = loading;
    img.onload = event => {
      flush();
      setStatus("loaded");
      onLoad == null ? void 0 : onLoad(event);
    };
    img.onerror = error => {
      flush();
      setStatus("failed");
      onError == null ? void 0 : onError(error);
    };
    imageRef.current = img;
  }, [src, crossOrigin, srcSet, sizes, onLoad, onError, loading]);
  const flush = () => {
    if (imageRef.current) {
      imageRef.current.onload = null;
      imageRef.current.onerror = null;
      imageRef.current = null;
    }
  };
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => {
    if (ignoreFallback) return void 0;
    if (status === "loading") {
      load();
    }
    return () => {
      flush();
    };
  }, [status, load, ignoreFallback]);
  return ignoreFallback ? "loaded" : status;
}
var shouldShowFallbackImage = (status, fallbackStrategy) => status !== "loaded" && fallbackStrategy === "beforeLoadOrError" || status === "failed" && fallbackStrategy === "onError";
exports.shouldShowFallbackImage = shouldShowFallbackImage;
},{"@chakra-ui/react-use-safe-layout-effect":"cYtR","react":"n8MK"}],"vqBc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Image = void 0;
var _chunkQBIO4VEB = require("./chunk-QBIO4VEB.mjs");
var _chunkHR33I6FK = require("./chunk-HR33I6FK.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/image.tsx

// ../../utilities/object-utils/src/index.ts
function omit(object, keysToOmit = []) {
  const clone = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone) delete clone[key];
  }
  return clone;
}

// src/image.tsx

var Image = (0, _system.forwardRef)(function Image2(props, ref) {
  const {
    fallbackSrc,
    fallback,
    src,
    srcSet,
    align,
    fit,
    loading,
    ignoreFallback,
    crossOrigin,
    fallbackStrategy = "beforeLoadOrError",
    referrerPolicy,
    ...rest
  } = props;
  const providedFallback = fallbackSrc !== void 0 || fallback !== void 0;
  const shouldIgnoreFallbackImage = loading != null || ignoreFallback || !providedFallback;
  const status = (0, _chunkHR33I6FK.useImage)({
    ...props,
    ignoreFallback: shouldIgnoreFallbackImage
  });
  const showFallbackImage = (0, _chunkHR33I6FK.shouldShowFallbackImage)(status, fallbackStrategy);
  const shared = {
    ref,
    objectFit: fit,
    objectPosition: align,
    ...(shouldIgnoreFallbackImage ? rest : omit(rest, ["onError", "onLoad"]))
  };
  if (showFallbackImage) {
    if (fallback) return fallback;
    return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.img, {
      as: _chunkQBIO4VEB.NativeImage,
      className: "chakra-image__placeholder",
      src: fallbackSrc,
      ...shared
    });
  }
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.img, {
    as: _chunkQBIO4VEB.NativeImage,
    src,
    srcSet,
    crossOrigin,
    loading,
    referrerPolicy,
    className: "chakra-image",
    ...shared
  });
});
exports.Image = Image;
Image.displayName = "Image";
},{"./chunk-QBIO4VEB.mjs":"aIcM","./chunk-HR33I6FK.mjs":"w9EF","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"TTQB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Img = void 0;
var _chunkQBIO4VEB = require("./chunk-QBIO4VEB.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/img.tsx

var Img = (0, _system.forwardRef)((props, ref) => /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.img, {
  ref,
  as: _chunkQBIO4VEB.NativeImage,
  className: "chakra-image",
  ...props
}));
exports.Img = Img;
},{"./chunk-QBIO4VEB.mjs":"aIcM","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"m2EG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _chunkDIQZDILB.Image;
  }
});
Object.defineProperty(exports, "Img", {
  enumerable: true,
  get: function () {
    return _chunkE3YVMML.Img;
  }
});
Object.defineProperty(exports, "shouldShowFallbackImage", {
  enumerable: true,
  get: function () {
    return _chunkHR33I6FK.shouldShowFallbackImage;
  }
});
Object.defineProperty(exports, "useImage", {
  enumerable: true,
  get: function () {
    return _chunkHR33I6FK.useImage;
  }
});
var _chunkDIQZDILB = require("./chunk-DIQZDILB.mjs");
var _chunkE3YVMML = require("./chunk-E3YVMML4.mjs");
require("./chunk-QBIO4VEB.mjs");
var _chunkHR33I6FK = require("./chunk-HR33I6FK.mjs");
},{"./chunk-DIQZDILB.mjs":"vqBc","./chunk-E3YVMML4.mjs":"TTQB","./chunk-QBIO4VEB.mjs":"aIcM","./chunk-HR33I6FK.mjs":"w9EF"}],"GdU5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AvatarImage = AvatarImage;
var _chunkXLTSJSZV = require("./chunk-XLTSJSZV.mjs");
var _chunkZXZNYCCD = require("./chunk-ZXZNYCCD.mjs");
var _image = require("@chakra-ui/image");
var _system = require("@chakra-ui/system");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/avatar-image.tsx

function AvatarImage(props) {
  const {
    src,
    srcSet,
    onError,
    onLoad,
    getInitials,
    name,
    borderRadius,
    loading,
    iconLabel,
    icon = /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkZXZNYCCD.GenericAvatarIcon, {}),
    ignoreFallback,
    referrerPolicy
  } = props;
  const status = (0, _image.useImage)({
    src,
    onError,
    ignoreFallback
  });
  const hasLoaded = status === "loaded";
  const showFallback = !src || !hasLoaded;
  if (showFallback) {
    return name ? /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkXLTSJSZV.AvatarName, {
      className: "chakra-avatar__initials",
      getInitials,
      name
    }) : (0, _react.cloneElement)(icon, {
      role: "img",
      "aria-label": iconLabel
    });
  }
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.img, {
    src,
    srcSet,
    alt: name,
    onLoad,
    referrerPolicy,
    className: "chakra-avatar__img",
    loading,
    __css: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius
    }
  });
}
AvatarImage.displayName = "AvatarImage";
},{"./chunk-XLTSJSZV.mjs":"xK3S","./chunk-ZXZNYCCD.mjs":"r4lf","@chakra-ui/image":"m2EG","@chakra-ui/system":"ogbg","react":"n8MK","react/jsx-runtime":"plwR"}],"EV8j":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.baseStyle = exports.Avatar = void 0;
var _chunkRBT32FI = require("./chunk-RBT32FI6.mjs");
var _chunkXLTSJSZV = require("./chunk-XLTSJSZV.mjs");
var _chunkQVBG3QXJ = require("./chunk-QVBG3QXJ.mjs");
var _chunkZXZNYCCD = require("./chunk-ZXZNYCCD.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/avatar.tsx

var baseStyle = {
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  textAlign: "center",
  textTransform: "uppercase",
  fontWeight: "medium",
  position: "relative",
  flexShrink: 0
};
exports.baseStyle = baseStyle;
var Avatar = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _system.useMultiStyleConfig)("Avatar", props);
  const [isLoaded, setIsLoaded] = (0, _react.useState)(false);
  const {
    src,
    srcSet,
    name,
    showBorder,
    borderRadius = "full",
    onError,
    onLoad: onLoadProp,
    getInitials = _chunkXLTSJSZV.initials,
    icon = /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkZXZNYCCD.GenericAvatarIcon, {}),
    iconLabel = " avatar",
    loading,
    children,
    borderColor,
    ignoreFallback,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const avatarStyles = {
    borderRadius,
    borderWidth: showBorder ? "2px" : void 0,
    ...baseStyle,
    ...styles.container
  };
  if (borderColor) {
    avatarStyles.borderColor = borderColor;
  }
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
    ref,
    ...rest,
    className: (0, _sharedUtils.cx)("chakra-avatar", props.className),
    "data-loaded": (0, _sharedUtils.dataAttr)(isLoaded),
    __css: avatarStyles,
    children: /* @__PURE__ */(0, _jsxRuntime.jsxs)(_chunkQVBG3QXJ.AvatarStylesProvider, {
      value: styles,
      children: [/* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkRBT32FI.AvatarImage, {
        src,
        srcSet,
        loading,
        onLoad: (0, _sharedUtils.callAllHandlers)(onLoadProp, () => {
          setIsLoaded(true);
        }),
        onError,
        getInitials,
        name,
        borderRadius,
        icon,
        iconLabel,
        ignoreFallback
      }), children]
    })
  });
});
exports.Avatar = Avatar;
Avatar.displayName = "Avatar";
},{"./chunk-RBT32FI6.mjs":"GdU5","./chunk-XLTSJSZV.mjs":"xK3S","./chunk-QVBG3QXJ.mjs":"Xw8j","./chunk-ZXZNYCCD.mjs":"r4lf","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"PLf5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValidChildren = getValidChildren;
var _react = require("react");
// src/index.ts

function getValidChildren(children) {
  return _react.Children.toArray(children).filter(child => (0, _react.isValidElement)(child));
}
},{"react":"n8MK"}],"keCp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AvatarGroup = void 0;
var _chunkMASXGPYE = require("./chunk-MASXGPYE.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _reactChildrenUtils = require("@chakra-ui/react-children-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/avatar-group.tsx

// ../../utilities/object-utils/src/index.ts
function compact(object) {
  const clone = Object.assign({}, object);
  for (let key in clone) {
    if (clone[key] === void 0) delete clone[key];
  }
  return clone;
}

// src/avatar-group.tsx

var AvatarGroup = (0, _system.forwardRef)(function AvatarGroup2(props, ref) {
  const styles = (0, _system.useMultiStyleConfig)("Avatar", props);
  const {
    children,
    borderColor,
    max,
    spacing = "-0.75rem",
    borderRadius = "full",
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const validChildren = (0, _reactChildrenUtils.getValidChildren)(children);
  const childrenWithinMax = max ? validChildren.slice(0, max) : validChildren;
  const excess = max != null && validChildren.length - max;
  const reversedChildren = childrenWithinMax.reverse();
  const clones = reversedChildren.map((child, index) => {
    var _a;
    const isFirstAvatar = index === 0;
    const childProps = {
      marginEnd: isFirstAvatar ? 0 : spacing,
      size: props.size,
      borderColor: (_a = child.props.borderColor) != null ? _a : borderColor,
      showBorder: true
    };
    return (0, _react.cloneElement)(child, compact(childProps));
  });
  const groupStyles = {
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-end",
    flexDirection: "row-reverse",
    ...styles.group
  };
  const excessStyles = {
    borderRadius,
    marginStart: spacing,
    ..._chunkMASXGPYE.baseStyle,
    ...styles.excessLabel
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.div, {
    ref,
    role: "group",
    __css: groupStyles,
    ...rest,
    className: (0, _sharedUtils.cx)("chakra-avatar__group", props.className),
    children: [excess > 0 && /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      className: "chakra-avatar__excess",
      __css: excessStyles,
      children: `+${excess}`
    }), clones]
  });
});
exports.AvatarGroup = AvatarGroup;
AvatarGroup.displayName = "AvatarGroup";
},{"./chunk-MASXGPYE.mjs":"EV8j","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","@chakra-ui/react-children-utils":"PLf5","react":"n8MK","react/jsx-runtime":"plwR"}],"CMp1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Avatar", {
  enumerable: true,
  get: function () {
    return _chunkMASXGPYE.Avatar;
  }
});
Object.defineProperty(exports, "AvatarBadge", {
  enumerable: true,
  get: function () {
    return _chunk2RQKHYD.AvatarBadge;
  }
});
Object.defineProperty(exports, "AvatarGroup", {
  enumerable: true,
  get: function () {
    return _chunkQKV3UBLI.AvatarGroup;
  }
});
Object.defineProperty(exports, "GenericAvatarIcon", {
  enumerable: true,
  get: function () {
    return _chunkZXZNYCCD.GenericAvatarIcon;
  }
});
Object.defineProperty(exports, "useAvatarStyles", {
  enumerable: true,
  get: function () {
    return _chunkQVBG3QXJ.useAvatarStyles;
  }
});
var _chunk2RQKHYD = require("./chunk-2RQKHYD2.mjs");
var _chunkQKV3UBLI = require("./chunk-QKV3UBLI.mjs");
var _chunkMASXGPYE = require("./chunk-MASXGPYE.mjs");
require("./chunk-RBT32FI6.mjs");
require("./chunk-XLTSJSZV.mjs");
var _chunkQVBG3QXJ = require("./chunk-QVBG3QXJ.mjs");
var _chunkZXZNYCCD = require("./chunk-ZXZNYCCD.mjs");
},{"./chunk-2RQKHYD2.mjs":"S0TY","./chunk-QKV3UBLI.mjs":"keCp","./chunk-MASXGPYE.mjs":"EV8j","./chunk-RBT32FI6.mjs":"GdU5","./chunk-XLTSJSZV.mjs":"xK3S","./chunk-QVBG3QXJ.mjs":"Xw8j","./chunk-ZXZNYCCD.mjs":"r4lf"}],"Fv0J":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useBreadcrumbStyles = exports.BreadcrumbStylesProvider = void 0;
var _reactContext = require("@chakra-ui/react-context");
// src/breadcrumb-context.ts

var [BreadcrumbStylesProvider, useBreadcrumbStyles] = (0, _reactContext.createContext)({
  name: `BreadcrumbStylesContext`,
  errorMessage: `useBreadcrumbStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Breadcrumb />" `
});
exports.useBreadcrumbStyles = useBreadcrumbStyles;
exports.BreadcrumbStylesProvider = BreadcrumbStylesProvider;
},{"@chakra-ui/react-context":"lT23"}],"vKls":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BreadcrumbLink = void 0;
var _chunkOLDTR4XF = require("./chunk-OLDTR4XF.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/breadcrumb-link.tsx

var BreadcrumbLink = (0, _system.forwardRef)(function BreadcrumbLink2(props, ref) {
  const {
    isCurrentPage,
    as,
    className,
    href,
    ...rest
  } = props;
  const styles = (0, _chunkOLDTR4XF.useBreadcrumbStyles)();
  const sharedProps = {
    ref,
    as,
    className: (0, _sharedUtils.cx)("chakra-breadcrumb__link", className),
    ...rest
  };
  if (isCurrentPage) {
    return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      "aria-current": "page",
      __css: styles.link,
      ...sharedProps
    });
  }
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.a, {
    __css: styles.link,
    href,
    ...sharedProps
  });
});
exports.BreadcrumbLink = BreadcrumbLink;
BreadcrumbLink.displayName = "BreadcrumbLink";
},{"./chunk-OLDTR4XF.mjs":"Fv0J","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"DV8G":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BreadcrumbSeparator = void 0;
var _chunkOLDTR4XF = require("./chunk-OLDTR4XF.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/breadcrumb-separator.tsx

var BreadcrumbSeparator = (0, _system.forwardRef)(function BreadcrumbSeparator2(props, ref) {
  const {
    spacing,
    ...rest
  } = props;
  const styles = (0, _chunkOLDTR4XF.useBreadcrumbStyles)();
  const separatorStyles = {
    mx: spacing,
    ...styles.separator
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
    ref,
    role: "presentation",
    ...rest,
    __css: separatorStyles
  });
});
exports.BreadcrumbSeparator = BreadcrumbSeparator;
BreadcrumbSeparator.displayName = "BreadcrumbSeparator";
},{"./chunk-OLDTR4XF.mjs":"Fv0J","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"PhXB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BreadcrumbItem = void 0;
var _chunkGCVB4LG = require("./chunk-GCVB4LG4.mjs");
var _chunkXCVTFTPE = require("./chunk-XCVTFTPE.mjs");
var _chunkOLDTR4XF = require("./chunk-OLDTR4XF.mjs");
var _system = require("@chakra-ui/system");
var _reactChildrenUtils = require("@chakra-ui/react-children-utils");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/breadcrumb-item.tsx

var BreadcrumbItem = (0, _system.forwardRef)(function BreadcrumbItem2(props, ref) {
  const {
    isCurrentPage,
    separator,
    isLastChild,
    spacing,
    children,
    className,
    ...rest
  } = props;
  const validChildren = (0, _reactChildrenUtils.getValidChildren)(children);
  const clones = validChildren.map(child => {
    if (child.type === _chunkGCVB4LG.BreadcrumbLink) {
      return (0, _react.cloneElement)(child, {
        isCurrentPage
      });
    }
    if (child.type === _chunkXCVTFTPE.BreadcrumbSeparator) {
      return (0, _react.cloneElement)(child, {
        spacing,
        children: child.props.children || separator
      });
    }
    return child;
  });
  const styles = (0, _chunkOLDTR4XF.useBreadcrumbStyles)();
  const itemStyles = {
    display: "inline-flex",
    alignItems: "center",
    ...styles.item
  };
  const _className = (0, _sharedUtils.cx)("chakra-breadcrumb__list-item", className);
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.li, {
    ref,
    className: _className,
    ...rest,
    __css: itemStyles,
    children: [clones, !isLastChild && /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkXCVTFTPE.BreadcrumbSeparator, {
      spacing,
      children: separator
    })]
  });
});
exports.BreadcrumbItem = BreadcrumbItem;
BreadcrumbItem.displayName = "BreadcrumbItem";
},{"./chunk-GCVB4LG4.mjs":"vKls","./chunk-XCVTFTPE.mjs":"DV8G","./chunk-OLDTR4XF.mjs":"Fv0J","@chakra-ui/system":"ogbg","@chakra-ui/react-children-utils":"PLf5","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"bo2c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Breadcrumb = void 0;
var _chunkOLDTR4XF = require("./chunk-OLDTR4XF.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _reactChildrenUtils = require("@chakra-ui/react-children-utils");
var _system = require("@chakra-ui/system");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/breadcrumb.tsx

var Breadcrumb = (0, _system.forwardRef)(function Breadcrumb2(props, ref) {
  const styles = (0, _system.useMultiStyleConfig)("Breadcrumb", props);
  const ownProps = (0, _system.omitThemingProps)(props);
  const {
    children,
    spacing = "0.5rem",
    separator = "/",
    className,
    listProps,
    ...rest
  } = ownProps;
  const validChildren = (0, _reactChildrenUtils.getValidChildren)(children);
  const count = validChildren.length;
  const clones = validChildren.map((child, index) => (0, _react.cloneElement)(child, {
    separator,
    spacing,
    isLastChild: count === index + 1
  }));
  const _className = (0, _sharedUtils.cx)("chakra-breadcrumb", className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.nav, {
    ref,
    "aria-label": "breadcrumb",
    className: _className,
    __css: styles.container,
    ...rest,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkOLDTR4XF.BreadcrumbStylesProvider, {
      value: styles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.ol, {
        className: "chakra-breadcrumb__list",
        ...listProps,
        __css: {
          display: "flex",
          alignItems: "center",
          ...styles.list
        },
        children: clones
      })
    })
  });
});
exports.Breadcrumb = Breadcrumb;
Breadcrumb.displayName = "Breadcrumb";
},{"./chunk-OLDTR4XF.mjs":"Fv0J","@chakra-ui/shared-utils":"gghr","@chakra-ui/react-children-utils":"PLf5","@chakra-ui/system":"ogbg","react":"n8MK","react/jsx-runtime":"plwR"}],"tp1v":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Breadcrumb", {
  enumerable: true,
  get: function () {
    return _chunkRDQRB6BQ.Breadcrumb;
  }
});
Object.defineProperty(exports, "BreadcrumbItem", {
  enumerable: true,
  get: function () {
    return _chunk5BPFTGUI.BreadcrumbItem;
  }
});
Object.defineProperty(exports, "BreadcrumbLink", {
  enumerable: true,
  get: function () {
    return _chunkGCVB4LG.BreadcrumbLink;
  }
});
Object.defineProperty(exports, "BreadcrumbSeparator", {
  enumerable: true,
  get: function () {
    return _chunkXCVTFTPE.BreadcrumbSeparator;
  }
});
Object.defineProperty(exports, "useBreadcrumbStyles", {
  enumerable: true,
  get: function () {
    return _chunkOLDTR4XF.useBreadcrumbStyles;
  }
});
var _chunk5BPFTGUI = require("./chunk-5BPFTGUI.mjs");
var _chunkGCVB4LG = require("./chunk-GCVB4LG4.mjs");
var _chunkXCVTFTPE = require("./chunk-XCVTFTPE.mjs");
var _chunkRDQRB6BQ = require("./chunk-RDQRB6BQ.mjs");
var _chunkOLDTR4XF = require("./chunk-OLDTR4XF.mjs");
},{"./chunk-5BPFTGUI.mjs":"PhXB","./chunk-GCVB4LG4.mjs":"vKls","./chunk-XCVTFTPE.mjs":"DV8G","./chunk-RDQRB6BQ.mjs":"bo2c","./chunk-OLDTR4XF.mjs":"Fv0J"}],"bgUF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useButtonGroup = exports.ButtonGroupProvider = void 0;
var _reactContext = require("@chakra-ui/react-context");
// src/button-context.ts

var [ButtonGroupProvider, useButtonGroup] = (0, _reactContext.createContext)({
  strict: false,
  name: "ButtonGroupContext"
});
exports.useButtonGroup = useButtonGroup;
exports.ButtonGroupProvider = ButtonGroupProvider;
},{"@chakra-ui/react-context":"lT23"}],"YFM9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ButtonGroup = void 0;
var _chunkDGWZA2DU = require("./chunk-DGWZA2DU.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/button-group.tsx

var attachedStyles = {
  horizontal: {
    "> *:first-of-type:not(:last-of-type)": {
      borderEndRadius: 0
    },
    "> *:not(:first-of-type):not(:last-of-type)": {
      borderRadius: 0
    },
    "> *:not(:first-of-type):last-of-type": {
      borderStartRadius: 0
    }
  },
  vertical: {
    "> *:first-of-type:not(:last-of-type)": {
      borderBottomRadius: 0
    },
    "> *:not(:first-of-type):not(:last-of-type)": {
      borderRadius: 0
    },
    "> *:not(:first-of-type):last-of-type": {
      borderTopRadius: 0
    }
  }
};
var gapStyles = {
  horizontal: spacing => ({
    "& > *:not(style) ~ *:not(style)": {
      marginStart: spacing
    }
  }),
  vertical: spacing => ({
    "& > *:not(style) ~ *:not(style)": {
      marginTop: spacing
    }
  })
};
var ButtonGroup = (0, _system.forwardRef)(function ButtonGroup2(props, ref) {
  const {
    size,
    colorScheme,
    variant,
    className,
    spacing = "0.5rem",
    isAttached,
    isDisabled,
    orientation = "horizontal",
    ...rest
  } = props;
  const _className = (0, _sharedUtils.cx)("chakra-button__group", className);
  const context = (0, _react.useMemo)(() => ({
    size,
    colorScheme,
    variant,
    isDisabled
  }), [size, colorScheme, variant, isDisabled]);
  let groupStyles = {
    display: "inline-flex",
    ...(isAttached ? attachedStyles[orientation] : gapStyles[orientation](spacing))
  };
  const isVertical = orientation === "vertical";
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkDGWZA2DU.ButtonGroupProvider, {
    value: context,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
      ref,
      role: "group",
      __css: groupStyles,
      className: _className,
      "data-attached": isAttached ? "" : void 0,
      "data-orientation": orientation,
      flexDir: isVertical ? "column" : void 0,
      ...rest
    })
  });
});
exports.ButtonGroup = ButtonGroup;
ButtonGroup.displayName = "ButtonGroup";
},{"./chunk-DGWZA2DU.mjs":"bgUF","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"lVfg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useButtonType = useButtonType;
var _react = require("react");
// src/use-button-type.tsx

function useButtonType(value) {
  const [isButton, setIsButton] = (0, _react.useState)(!value);
  const refCallback = (0, _react.useCallback)(node => {
    if (!node) return;
    setIsButton(node.tagName === "BUTTON");
  }, []);
  const type = isButton ? "button" : void 0;
  return {
    ref: refCallback,
    type
  };
}
},{"react":"n8MK"}],"yji5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ButtonIcon = ButtonIcon;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/button-icon.tsx

function ButtonIcon(props) {
  const {
    children,
    className,
    ...rest
  } = props;
  const _children = (0, _react.isValidElement)(children) ? (0, _react.cloneElement)(children, {
    "aria-hidden": true,
    focusable: false
  }) : children;
  const _className = (0, _sharedUtils.cx)("chakra-button__icon", className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
    display: "inline-flex",
    alignSelf: "center",
    flexShrink: 0,
    ...rest,
    className: _className,
    children: _children
  });
}
ButtonIcon.displayName = "ButtonIcon";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"iSqg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ButtonSpinner = ButtonSpinner;
var _spinner = require("@chakra-ui/spinner");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/button-spinner.tsx

function ButtonSpinner(props) {
  const {
    label,
    placement,
    spacing = "0.5rem",
    children = /* @__PURE__ */(0, _jsxRuntime.jsx)(_spinner.Spinner, {
      color: "currentColor",
      width: "1em",
      height: "1em"
    }),
    className,
    __css,
    ...rest
  } = props;
  const _className = (0, _sharedUtils.cx)("chakra-button__spinner", className);
  const marginProp = placement === "start" ? "marginEnd" : "marginStart";
  const spinnerStyles = (0, _react.useMemo)(() => ({
    display: "flex",
    alignItems: "center",
    position: label ? "relative" : "absolute",
    [marginProp]: label ? spacing : 0,
    fontSize: "1em",
    lineHeight: "normal",
    ...__css
  }), [__css, label, marginProp, spacing]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    className: _className,
    ...rest,
    __css: spinnerStyles,
    children
  });
}
ButtonSpinner.displayName = "ButtonSpinner";
},{"@chakra-ui/spinner":"tJmI","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"VIeY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Button = void 0;
var _chunkFRFD4OXU = require("./chunk-FRFD4OXU.mjs");
var _chunkDGWZA2DU = require("./chunk-DGWZA2DU.mjs");
var _chunkHCASMTTF = require("./chunk-HCASMTTF.mjs");
var _chunkHNNHG6RU = require("./chunk-HNNHG6RU.mjs");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/button.tsx

var Button = (0, _system.forwardRef)((props, ref) => {
  const group = (0, _chunkDGWZA2DU.useButtonGroup)();
  const styles = (0, _system.useStyleConfig)("Button", {
    ...group,
    ...props
  });
  const {
    isDisabled = group == null ? void 0 : group.isDisabled,
    isLoading,
    isActive,
    children,
    leftIcon,
    rightIcon,
    loadingText,
    iconSpacing = "0.5rem",
    type,
    spinner,
    spinnerPlacement = "start",
    className,
    as,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const buttonStyles = (0, _react.useMemo)(() => {
    const _focus = {
      ...(styles == null ? void 0 : styles["_focus"]),
      zIndex: 1
    };
    return {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      position: "relative",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      outline: "none",
      ...styles,
      ...(!!group && {
        _focus
      })
    };
  }, [styles, group]);
  const {
    ref: _ref,
    type: defaultType
  } = (0, _chunkFRFD4OXU.useButtonType)(as);
  const contentProps = {
    rightIcon,
    leftIcon,
    iconSpacing,
    children
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.button, {
    disabled: isDisabled || isLoading,
    ref: (0, _reactUseMergeRefs.useMergeRefs)(ref, _ref),
    as,
    type: type != null ? type : defaultType,
    "data-active": (0, _sharedUtils.dataAttr)(isActive),
    "data-loading": (0, _sharedUtils.dataAttr)(isLoading),
    __css: buttonStyles,
    className: (0, _sharedUtils.cx)("chakra-button", className),
    ...rest,
    children: [isLoading && spinnerPlacement === "start" && /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkHNNHG6RU.ButtonSpinner, {
      className: "chakra-button__spinner--start",
      label: loadingText,
      placement: "start",
      spacing: iconSpacing,
      children: spinner
    }), isLoading ? loadingText || /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      opacity: 0,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(ButtonContent, {
        ...contentProps
      })
    }) : /* @__PURE__ */(0, _jsxRuntime.jsx)(ButtonContent, {
      ...contentProps
    }), isLoading && spinnerPlacement === "end" && /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkHNNHG6RU.ButtonSpinner, {
      className: "chakra-button__spinner--end",
      label: loadingText,
      placement: "end",
      spacing: iconSpacing,
      children: spinner
    })]
  });
});
exports.Button = Button;
Button.displayName = "Button";
function ButtonContent(props) {
  const {
    leftIcon,
    rightIcon,
    children,
    iconSpacing
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [leftIcon && /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkHCASMTTF.ButtonIcon, {
      marginEnd: iconSpacing,
      children: leftIcon
    }), children, rightIcon && /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkHCASMTTF.ButtonIcon, {
      marginStart: iconSpacing,
      children: rightIcon
    })]
  });
}
},{"./chunk-FRFD4OXU.mjs":"lVfg","./chunk-DGWZA2DU.mjs":"bgUF","./chunk-HCASMTTF.mjs":"yji5","./chunk-HNNHG6RU.mjs":"iSqg","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"bryH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IconButton = void 0;
var _chunk6ZQPWYNL = require("./chunk-6ZQPWYNL.mjs");
var _system = require("@chakra-ui/system");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/icon-button.tsx

var IconButton = (0, _system.forwardRef)((props, ref) => {
  const {
    icon,
    children,
    isRound,
    "aria-label": ariaLabel,
    ...rest
  } = props;
  const element = icon || children;
  const _children = (0, _react.isValidElement)(element) ? (0, _react.cloneElement)(element, {
    "aria-hidden": true,
    focusable: false
  }) : null;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk6ZQPWYNL.Button, {
    padding: "0",
    borderRadius: isRound ? "full" : void 0,
    ref,
    "aria-label": ariaLabel,
    ...rest,
    children: _children
  });
});
exports.IconButton = IconButton;
IconButton.displayName = "IconButton";
},{"./chunk-6ZQPWYNL.mjs":"VIeY","@chakra-ui/system":"ogbg","react":"n8MK","react/jsx-runtime":"plwR"}],"dyFD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Button", {
  enumerable: true,
  get: function () {
    return _chunk6ZQPWYNL.Button;
  }
});
Object.defineProperty(exports, "ButtonGroup", {
  enumerable: true,
  get: function () {
    return _chunkPEYICJIL.ButtonGroup;
  }
});
Object.defineProperty(exports, "ButtonSpinner", {
  enumerable: true,
  get: function () {
    return _chunkHNNHG6RU.ButtonSpinner;
  }
});
Object.defineProperty(exports, "IconButton", {
  enumerable: true,
  get: function () {
    return _chunkUWDONPQN.IconButton;
  }
});
Object.defineProperty(exports, "useButtonGroup", {
  enumerable: true,
  get: function () {
    return _chunkDGWZA2DU.useButtonGroup;
  }
});
var _chunkPEYICJIL = require("./chunk-PEYICJIL.mjs");
var _chunkUWDONPQN = require("./chunk-UWDONPQN.mjs");
var _chunk6ZQPWYNL = require("./chunk-6ZQPWYNL.mjs");
require("./chunk-FRFD4OXU.mjs");
var _chunkDGWZA2DU = require("./chunk-DGWZA2DU.mjs");
require("./chunk-HCASMTTF.mjs");
var _chunkHNNHG6RU = require("./chunk-HNNHG6RU.mjs");
},{"./chunk-PEYICJIL.mjs":"YFM9","./chunk-UWDONPQN.mjs":"bryH","./chunk-6ZQPWYNL.mjs":"VIeY","./chunk-FRFD4OXU.mjs":"lVfg","./chunk-DGWZA2DU.mjs":"bgUF","./chunk-HCASMTTF.mjs":"yji5","./chunk-HNNHG6RU.mjs":"iSqg"}],"iMRW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCardStyles = exports.CardStylesProvider = void 0;
var _system = require("@chakra-ui/system");
// src/card-context.tsx

var [CardStylesProvider, useCardStyles] = (0, _system.createStylesContext)("Card");
exports.useCardStyles = useCardStyles;
exports.CardStylesProvider = CardStylesProvider;
},{"@chakra-ui/system":"ogbg"}],"Mfz7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CardBody = void 0;
var _chunk4DHADF5X = require("./chunk-4DHADF5X.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/card-body.tsx

var CardBody = (0, _system.forwardRef)(function CardBody2(props, ref) {
  const {
    className,
    ...rest
  } = props;
  const styles = (0, _chunk4DHADF5X.useCardStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-card__body", className),
    __css: styles.body,
    ...rest
  });
});
exports.CardBody = CardBody;
},{"./chunk-4DHADF5X.mjs":"iMRW","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"dV3N":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CardFooter = void 0;
var _chunk4DHADF5X = require("./chunk-4DHADF5X.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/card-footer.tsx

var CardFooter = (0, _system.forwardRef)(function CardFooter2(props, ref) {
  const {
    className,
    justify,
    ...rest
  } = props;
  const styles = (0, _chunk4DHADF5X.useCardStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-card__footer", className),
    __css: {
      display: "flex",
      justifyContent: justify,
      ...styles.footer
    },
    ...rest
  });
});
exports.CardFooter = CardFooter;
},{"./chunk-4DHADF5X.mjs":"iMRW","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"Qpjq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CardHeader = void 0;
var _chunk4DHADF5X = require("./chunk-4DHADF5X.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/card-header.tsx

var CardHeader = (0, _system.forwardRef)(function CardHeader2(props, ref) {
  const {
    className,
    ...rest
  } = props;
  const styles = (0, _chunk4DHADF5X.useCardStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-card__header", className),
    __css: styles.header,
    ...rest
  });
});
exports.CardHeader = CardHeader;
},{"./chunk-4DHADF5X.mjs":"iMRW","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"R4gM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Card = void 0;
var _chunk4DHADF5X = require("./chunk-4DHADF5X.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/card.tsx

var Card = (0, _system.forwardRef)(function Card2(props, ref) {
  const {
    className,
    children,
    direction = "column",
    justify,
    align,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const styles = (0, _system.useMultiStyleConfig)("Card", props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-card", className),
    __css: {
      display: "flex",
      flexDirection: direction,
      justifyContent: justify,
      alignItems: align,
      position: "relative",
      minWidth: 0,
      wordWrap: "break-word",
      ...styles.container
    },
    ...rest,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk4DHADF5X.CardStylesProvider, {
      value: styles,
      children
    })
  });
});
exports.Card = Card;
},{"./chunk-4DHADF5X.mjs":"iMRW","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"Tlh4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Card", {
  enumerable: true,
  get: function () {
    return _chunkS432VF2S.Card;
  }
});
Object.defineProperty(exports, "CardBody", {
  enumerable: true,
  get: function () {
    return _chunkKKEJMMX.CardBody;
  }
});
Object.defineProperty(exports, "CardFooter", {
  enumerable: true,
  get: function () {
    return _chunkV3HPETQ.CardFooter;
  }
});
Object.defineProperty(exports, "CardHeader", {
  enumerable: true,
  get: function () {
    return _chunkW3H6TFKV.CardHeader;
  }
});
Object.defineProperty(exports, "useCardStyles", {
  enumerable: true,
  get: function () {
    return _chunk4DHADF5X.useCardStyles;
  }
});
var _chunkKKEJMMX = require("./chunk-KKEJMMX3.mjs");
var _chunkV3HPETQ = require("./chunk-V3HPETQ4.mjs");
var _chunkW3H6TFKV = require("./chunk-W3H6TFKV.mjs");
var _chunkS432VF2S = require("./chunk-S432VF2S.mjs");
var _chunk4DHADF5X = require("./chunk-4DHADF5X.mjs");
},{"./chunk-KKEJMMX3.mjs":"Mfz7","./chunk-V3HPETQ4.mjs":"dV3N","./chunk-W3H6TFKV.mjs":"Qpjq","./chunk-S432VF2S.mjs":"R4gM","./chunk-4DHADF5X.mjs":"iMRW"}],"ALXv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCheckboxGroupContext = exports.CheckboxGroupProvider = void 0;
var _reactContext = require("@chakra-ui/react-context");
// src/checkbox-context.ts

var [CheckboxGroupProvider, useCheckboxGroupContext] = (0, _reactContext.createContext)({
  name: "CheckboxGroupContext",
  strict: false
});
exports.useCheckboxGroupContext = useCheckboxGroupContext;
exports.CheckboxGroupProvider = CheckboxGroupProvider;
},{"@chakra-ui/react-context":"lT23"}],"vq2z":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCheckboxGroup = useCheckboxGroup;
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
var _reactUseControllableState = require("@chakra-ui/react-use-controllable-state");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
// src/use-checkbox-group.ts

function isInputEvent(value) {
  return value && (0, _sharedUtils.isObject)(value) && (0, _sharedUtils.isObject)(value.target);
}
function useCheckboxGroup(props = {}) {
  const {
    defaultValue,
    value: valueProp,
    onChange,
    isDisabled,
    isNative
  } = props;
  const onChangeProp = (0, _reactUseCallbackRef.useCallbackRef)(onChange);
  const [value, setValue] = (0, _reactUseControllableState.useControllableState)({
    value: valueProp,
    defaultValue: defaultValue || [],
    onChange: onChangeProp
  });
  const handleChange = (0, _react.useCallback)(eventOrValue => {
    if (!value) return;
    const isChecked = isInputEvent(eventOrValue) ? eventOrValue.target.checked : !value.includes(eventOrValue);
    const selectedValue = isInputEvent(eventOrValue) ? eventOrValue.target.value : eventOrValue;
    const nextValue = isChecked ? [...value, selectedValue] : value.filter(v => String(v) !== String(selectedValue));
    setValue(nextValue);
  }, [setValue, value]);
  const getCheckboxProps = (0, _react.useCallback)((props2 = {}) => {
    const checkedKey = isNative ? "checked" : "isChecked";
    return {
      ...props2,
      [checkedKey]: value.some(val => String(props2.value) === String(val)),
      onChange: handleChange
    };
  }, [handleChange, isNative, value]);
  return {
    value,
    isDisabled,
    onChange: handleChange,
    setValue,
    getCheckboxProps
  };
}
},{"@chakra-ui/react-use-callback-ref":"PPhG","@chakra-ui/react-use-controllable-state":"DWQz","@chakra-ui/shared-utils":"gghr","react":"n8MK"}],"dlLz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CheckboxGroup = CheckboxGroup;
var _chunk6XFPBTDN = require("./chunk-6XFPBTDN.mjs");
var _chunk5F7ST2TT = require("./chunk-5F7ST2TT.mjs");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/checkbox-group.tsx

function CheckboxGroup(props) {
  const {
    colorScheme,
    size,
    variant,
    children,
    isDisabled
  } = props;
  const {
    value,
    onChange
  } = (0, _chunk5F7ST2TT.useCheckboxGroup)(props);
  const group = (0, _react.useMemo)(() => ({
    size,
    onChange,
    colorScheme,
    value,
    variant,
    isDisabled
  }), [size, onChange, colorScheme, value, variant, isDisabled]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk6XFPBTDN.CheckboxGroupProvider, {
    value: group,
    children
  });
}
CheckboxGroup.displayName = "CheckboxGroup";
},{"./chunk-6XFPBTDN.mjs":"ALXv","./chunk-5F7ST2TT.mjs":"vq2z","react":"n8MK","react/jsx-runtime":"plwR"}],"MKVo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CheckboxIcon = CheckboxIcon;
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/checkbox-icon.tsx

function CheckIcon(props) {
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.svg, {
    width: "1.2em",
    viewBox: "0 0 12 10",
    style: {
      fill: "none",
      strokeWidth: 2,
      stroke: "currentColor",
      strokeDasharray: 16
    },
    ...props,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)("polyline", {
      points: "1.5 6 4.5 9 10.5 1"
    })
  });
}
function IndeterminateIcon(props) {
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.svg, {
    width: "1.2em",
    viewBox: "0 0 24 24",
    style: {
      stroke: "currentColor",
      strokeWidth: 4
    },
    ...props,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)("line", {
      x1: "21",
      x2: "3",
      y1: "12",
      y2: "12"
    })
  });
}
function CheckboxIcon(props) {
  const {
    isIndeterminate,
    isChecked,
    ...rest
  } = props;
  const BaseIcon = isIndeterminate ? IndeterminateIcon : CheckIcon;
  return isChecked || isIndeterminate ? /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      height: "100%"
    },
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(BaseIcon, {
      ...rest
    })
  }) : null;
}
},{"@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"BKzk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFormControlStyles = exports.useFormControlContext = exports.FormHelperText = exports.FormControl = void 0;
var _reactContext = require("@chakra-ui/react-context");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/form-control.tsx

var [FormControlStylesProvider, useFormControlStyles] = (0, _reactContext.createContext)({
  name: `FormControlStylesContext`,
  errorMessage: `useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `
});
exports.useFormControlStyles = useFormControlStyles;
var [FormControlProvider, useFormControlContext] = (0, _reactContext.createContext)({
  strict: false,
  name: "FormControlContext"
});
exports.useFormControlContext = useFormControlContext;
function useFormControlProvider(props) {
  const {
    id: idProp,
    isRequired,
    isInvalid,
    isDisabled,
    isReadOnly,
    ...htmlProps
  } = props;
  const uuid = (0, _react.useId)();
  const id = idProp || `field-${uuid}`;
  const labelId = `${id}-label`;
  const feedbackId = `${id}-feedback`;
  const helpTextId = `${id}-helptext`;
  const [hasFeedbackText, setHasFeedbackText] = (0, _react.useState)(false);
  const [hasHelpText, setHasHelpText] = (0, _react.useState)(false);
  const [isFocused, setFocus] = (0, _react.useState)(false);
  const getHelpTextProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => ({
    id: helpTextId,
    ...props2,
    ref: (0, _reactUseMergeRefs.mergeRefs)(forwardedRef, node => {
      if (!node) return;
      setHasHelpText(true);
    })
  }), [helpTextId]);
  const getLabelProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => {
    var _a, _b;
    return {
      ...props2,
      ref: forwardedRef,
      "data-focus": (0, _sharedUtils.dataAttr)(isFocused),
      "data-disabled": (0, _sharedUtils.dataAttr)(isDisabled),
      "data-invalid": (0, _sharedUtils.dataAttr)(isInvalid),
      "data-readonly": (0, _sharedUtils.dataAttr)(isReadOnly),
      id: (_a = props2.id) != null ? _a : labelId,
      htmlFor: (_b = props2.htmlFor) != null ? _b : id
    };
  }, [id, isDisabled, isFocused, isInvalid, isReadOnly, labelId]);
  const getErrorMessageProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => ({
    id: feedbackId,
    ...props2,
    ref: (0, _reactUseMergeRefs.mergeRefs)(forwardedRef, node => {
      if (!node) return;
      setHasFeedbackText(true);
    }),
    "aria-live": "polite"
  }), [feedbackId]);
  const getRootProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => ({
    ...props2,
    ...htmlProps,
    ref: forwardedRef,
    role: "group"
  }), [htmlProps]);
  const getRequiredIndicatorProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => ({
    ...props2,
    ref: forwardedRef,
    role: "presentation",
    "aria-hidden": true,
    children: props2.children || "*"
  }), []);
  return {
    isRequired: !!isRequired,
    isInvalid: !!isInvalid,
    isReadOnly: !!isReadOnly,
    isDisabled: !!isDisabled,
    isFocused: !!isFocused,
    onFocus: () => setFocus(true),
    onBlur: () => setFocus(false),
    hasFeedbackText,
    setHasFeedbackText,
    hasHelpText,
    setHasHelpText,
    id,
    labelId,
    feedbackId,
    helpTextId,
    htmlProps,
    getHelpTextProps,
    getErrorMessageProps,
    getRootProps,
    getLabelProps,
    getRequiredIndicatorProps
  };
}
var FormControl = (0, _system.forwardRef)(function FormControl2(props, ref) {
  const styles = (0, _system.useMultiStyleConfig)("Form", props);
  const ownProps = (0, _system.omitThemingProps)(props);
  const {
    getRootProps,
    htmlProps: _,
    ...context
  } = useFormControlProvider(ownProps);
  const className = (0, _sharedUtils.cx)("chakra-form-control", props.className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(FormControlProvider, {
    value: context,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(FormControlStylesProvider, {
      value: styles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
        ...getRootProps({}, ref),
        className,
        __css: styles["container"]
      })
    })
  });
});
exports.FormControl = FormControl;
FormControl.displayName = "FormControl";
var FormHelperText = (0, _system.forwardRef)(function FormHelperText2(props, ref) {
  const field = useFormControlContext();
  const styles = useFormControlStyles();
  const className = (0, _sharedUtils.cx)("chakra-form__helper-text", props.className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...(field == null ? void 0 : field.getHelpTextProps(props, ref)),
    __css: styles.helperText,
    className
  });
});
exports.FormHelperText = FormHelperText;
FormHelperText.displayName = "FormHelperText";
},{"@chakra-ui/react-context":"lT23","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"JPri":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFormErrorStyles = exports.FormErrorMessage = exports.FormErrorIcon = void 0;
var _chunkPXXQR4UW = require("./chunk-PXXQR4UW.mjs");
var _icon = require("@chakra-ui/icon");
var _reactContext = require("@chakra-ui/react-context");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/form-error.tsx

var [FormErrorStylesProvider, useFormErrorStyles] = (0, _reactContext.createContext)({
  name: `FormErrorStylesContext`,
  errorMessage: `useFormErrorStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormError />" `
});
exports.useFormErrorStyles = useFormErrorStyles;
var FormErrorMessage = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _system.useMultiStyleConfig)("FormError", props);
  const ownProps = (0, _system.omitThemingProps)(props);
  const field = (0, _chunkPXXQR4UW.useFormControlContext)();
  if (!(field == null ? void 0 : field.isInvalid)) return null;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(FormErrorStylesProvider, {
    value: styles,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
      ...(field == null ? void 0 : field.getErrorMessageProps(ownProps, ref)),
      className: (0, _sharedUtils.cx)("chakra-form__error-message", props.className),
      __css: {
        display: "flex",
        alignItems: "center",
        ...styles.text
      }
    })
  });
});
exports.FormErrorMessage = FormErrorMessage;
FormErrorMessage.displayName = "FormErrorMessage";
var FormErrorIcon = (0, _system.forwardRef)((props, ref) => {
  const styles = useFormErrorStyles();
  const field = (0, _chunkPXXQR4UW.useFormControlContext)();
  if (!(field == null ? void 0 : field.isInvalid)) return null;
  const _className = (0, _sharedUtils.cx)("chakra-form__error-icon", props.className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
    ref,
    "aria-hidden": true,
    ...props,
    __css: styles.icon,
    className: _className,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
      fill: "currentColor",
      d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
    })
  });
});
exports.FormErrorIcon = FormErrorIcon;
FormErrorIcon.displayName = "FormErrorIcon";
},{"./chunk-PXXQR4UW.mjs":"BKzk","@chakra-ui/icon":"aPuf","@chakra-ui/react-context":"lT23","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"TNfu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RequiredIndicator = exports.FormLabel = void 0;
var _chunkPXXQR4UW = require("./chunk-PXXQR4UW.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/form-label.tsx

var FormLabel = (0, _system.forwardRef)(function FormLabel2(passedProps, ref) {
  var _a;
  const styles = (0, _system.useStyleConfig)("FormLabel", passedProps);
  const props = (0, _system.omitThemingProps)(passedProps);
  const {
    className,
    children,
    requiredIndicator = /* @__PURE__ */(0, _jsxRuntime.jsx)(RequiredIndicator, {}),
    optionalIndicator = null,
    ...rest
  } = props;
  const field = (0, _chunkPXXQR4UW.useFormControlContext)();
  const ownProps = (_a = field == null ? void 0 : field.getLabelProps(rest, ref)) != null ? _a : {
    ref,
    ...rest
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.label, {
    ...ownProps,
    className: (0, _sharedUtils.cx)("chakra-form__label", props.className),
    __css: {
      display: "block",
      textAlign: "start",
      ...styles
    },
    children: [children, (field == null ? void 0 : field.isRequired) ? requiredIndicator : optionalIndicator]
  });
});
exports.FormLabel = FormLabel;
FormLabel.displayName = "FormLabel";
var RequiredIndicator = (0, _system.forwardRef)(function RequiredIndicator2(props, ref) {
  const field = (0, _chunkPXXQR4UW.useFormControlContext)();
  const styles = (0, _chunkPXXQR4UW.useFormControlStyles)();
  if (!(field == null ? void 0 : field.isRequired)) return null;
  const className = (0, _sharedUtils.cx)("chakra-form__required-indicator", props.className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
    ...(field == null ? void 0 : field.getRequiredIndicatorProps(props, ref)),
    __css: styles.requiredIndicator,
    className
  });
});
exports.RequiredIndicator = RequiredIndicator;
RequiredIndicator.displayName = "RequiredIndicator";
},{"./chunk-PXXQR4UW.mjs":"BKzk","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"i5gW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFormControl = useFormControl;
exports.useFormControlProps = useFormControlProps;
var _chunkPXXQR4UW = require("./chunk-PXXQR4UW.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
// src/use-form-control.ts

function useFormControl(props) {
  const {
    isDisabled,
    isInvalid,
    isReadOnly,
    isRequired,
    ...rest
  } = useFormControlProps(props);
  return {
    ...rest,
    disabled: isDisabled,
    readOnly: isReadOnly,
    required: isRequired,
    "aria-invalid": (0, _sharedUtils.ariaAttr)(isInvalid),
    "aria-required": (0, _sharedUtils.ariaAttr)(isRequired),
    "aria-readonly": (0, _sharedUtils.ariaAttr)(isReadOnly)
  };
}
function useFormControlProps(props) {
  var _a, _b, _c;
  const field = (0, _chunkPXXQR4UW.useFormControlContext)();
  const {
    id,
    disabled,
    readOnly,
    required,
    isRequired,
    isInvalid,
    isReadOnly,
    isDisabled,
    onFocus,
    onBlur,
    ...rest
  } = props;
  const labelIds = props["aria-describedby"] ? [props["aria-describedby"]] : [];
  if ((field == null ? void 0 : field.hasFeedbackText) && (field == null ? void 0 : field.isInvalid)) {
    labelIds.push(field.feedbackId);
  }
  if (field == null ? void 0 : field.hasHelpText) {
    labelIds.push(field.helpTextId);
  }
  return {
    ...rest,
    "aria-describedby": labelIds.join(" ") || void 0,
    id: id != null ? id : field == null ? void 0 : field.id,
    isDisabled: (_a = disabled != null ? disabled : isDisabled) != null ? _a : field == null ? void 0 : field.isDisabled,
    isReadOnly: (_b = readOnly != null ? readOnly : isReadOnly) != null ? _b : field == null ? void 0 : field.isReadOnly,
    isRequired: (_c = required != null ? required : isRequired) != null ? _c : field == null ? void 0 : field.isRequired,
    isInvalid: isInvalid != null ? isInvalid : field == null ? void 0 : field.isInvalid,
    onFocus: (0, _sharedUtils.callAllHandlers)(field == null ? void 0 : field.onFocus, onFocus),
    onBlur: (0, _sharedUtils.callAllHandlers)(field == null ? void 0 : field.onBlur, onBlur)
  };
}
},{"./chunk-PXXQR4UW.mjs":"BKzk","@chakra-ui/shared-utils":"gghr"}],"fjMD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FormControl", {
  enumerable: true,
  get: function () {
    return _chunkPXXQR4UW.FormControl;
  }
});
Object.defineProperty(exports, "FormErrorIcon", {
  enumerable: true,
  get: function () {
    return _chunkWFX3T3Z.FormErrorIcon;
  }
});
Object.defineProperty(exports, "FormErrorMessage", {
  enumerable: true,
  get: function () {
    return _chunkWFX3T3Z.FormErrorMessage;
  }
});
Object.defineProperty(exports, "FormHelperText", {
  enumerable: true,
  get: function () {
    return _chunkPXXQR4UW.FormHelperText;
  }
});
Object.defineProperty(exports, "FormLabel", {
  enumerable: true,
  get: function () {
    return _chunk3HLJVDJ.FormLabel;
  }
});
Object.defineProperty(exports, "RequiredIndicator", {
  enumerable: true,
  get: function () {
    return _chunk3HLJVDJ.RequiredIndicator;
  }
});
Object.defineProperty(exports, "useFormControl", {
  enumerable: true,
  get: function () {
    return _chunkJSSKUSQH.useFormControl;
  }
});
Object.defineProperty(exports, "useFormControlContext", {
  enumerable: true,
  get: function () {
    return _chunkPXXQR4UW.useFormControlContext;
  }
});
Object.defineProperty(exports, "useFormControlProps", {
  enumerable: true,
  get: function () {
    return _chunkJSSKUSQH.useFormControlProps;
  }
});
Object.defineProperty(exports, "useFormControlStyles", {
  enumerable: true,
  get: function () {
    return _chunkPXXQR4UW.useFormControlStyles;
  }
});
Object.defineProperty(exports, "useFormErrorStyles", {
  enumerable: true,
  get: function () {
    return _chunkWFX3T3Z.useFormErrorStyles;
  }
});
var _chunkWFX3T3Z = require("./chunk-WFX3T3Z6.mjs");
var _chunk3HLJVDJ = require("./chunk-3HLJVDJ7.mjs");
var _chunkJSSKUSQH = require("./chunk-JSSKUSQH.mjs");
var _chunkPXXQR4UW = require("./chunk-PXXQR4UW.mjs");
},{"./chunk-WFX3T3Z6.mjs":"JPri","./chunk-3HLJVDJ7.mjs":"TNfu","./chunk-JSSKUSQH.mjs":"i5gW","./chunk-PXXQR4UW.mjs":"BKzk"}],"IbmB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visuallyHiddenStyle = void 0;
// src/visually-hidden.style.ts
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0, 0, 0, 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: "0",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
exports.visuallyHiddenStyle = visuallyHiddenStyle;
},{}],"rABK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visually_hidden_default = exports.VisuallyHiddenInput = exports.VisuallyHidden = void 0;
var _chunkRSUMUOHR = require("./chunk-RSUMUOHR.mjs");
var _system = require("@chakra-ui/system");
// src/visually-hidden.tsx

var VisuallyHidden = (0, _system.chakra)("span", {
  baseStyle: _chunkRSUMUOHR.visuallyHiddenStyle
});
exports.VisuallyHidden = VisuallyHidden;
VisuallyHidden.displayName = "VisuallyHidden";
var VisuallyHiddenInput = (0, _system.chakra)("input", {
  baseStyle: _chunkRSUMUOHR.visuallyHiddenStyle
});
exports.VisuallyHiddenInput = VisuallyHiddenInput;
VisuallyHiddenInput.displayName = "VisuallyHiddenInput";
var visually_hidden_default = VisuallyHidden;
exports.visually_hidden_default = visually_hidden_default;
},{"./chunk-RSUMUOHR.mjs":"IbmB","@chakra-ui/system":"ogbg"}],"CBEJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VisuallyHidden", {
  enumerable: true,
  get: function () {
    return _chunk74U3PXFJ.VisuallyHidden;
  }
});
Object.defineProperty(exports, "VisuallyHiddenInput", {
  enumerable: true,
  get: function () {
    return _chunk74U3PXFJ.VisuallyHiddenInput;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _chunk74U3PXFJ.visually_hidden_default;
  }
});
Object.defineProperty(exports, "visuallyHiddenStyle", {
  enumerable: true,
  get: function () {
    return _chunkRSUMUOHR.visuallyHiddenStyle;
  }
});
var _chunk74U3PXFJ = require("./chunk-74U3PXFJ.mjs");
var _chunkRSUMUOHR = require("./chunk-RSUMUOHR.mjs");
},{"./chunk-74U3PXFJ.mjs":"rABK","./chunk-RSUMUOHR.mjs":"IbmB"}],"yUYU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trackFocusVisible = trackFocusVisible;
// src/index.ts
var hasSetup = false;
var modality = null;
var hasEventBeforeFocus = false;
var handlers = /* @__PURE__ */new Set();
var isMac = typeof window !== "undefined" && window.navigator != null ? /^Mac/.test(window.navigator.platform) : false;
function isValidKey(event) {
  return !(event.metaKey || !isMac && event.altKey || event.ctrlKey);
}
function trigger(modality2, event) {
  handlers.forEach(handler => handler(modality2, event));
}
function onKeyboardEvent(event) {
  hasEventBeforeFocus = true;
  if (isValidKey(event)) {
    modality = "keyboard";
    trigger("keyboard", event);
  }
}
function onPointerEvent(event) {
  modality = "pointer";
  if (event.type === "mousedown" || event.type === "pointerdown") {
    hasEventBeforeFocus = true;
    trigger("pointer", event);
  }
}
function onWindowFocus(event) {
  if (event.target === window || event.target === document) {
    return;
  }
  if (!hasEventBeforeFocus) {
    modality = "keyboard";
    trigger("keyboard", event);
  }
  hasEventBeforeFocus = false;
}
function onWindowBlur() {
  hasEventBeforeFocus = false;
}
function isFocusVisible() {
  return modality !== "pointer";
}
function setupGlobalFocusEvents() {
  if (typeof window === "undefined" || hasSetup) {
    return;
  }
  const {
    focus
  } = HTMLElement.prototype;
  HTMLElement.prototype.focus = function focusElement(...args) {
    hasEventBeforeFocus = true;
    focus.apply(this, args);
  };
  document.addEventListener("keydown", onKeyboardEvent, true);
  document.addEventListener("keyup", onKeyboardEvent, true);
  window.addEventListener("focus", onWindowFocus, true);
  window.addEventListener("blur", onWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    document.addEventListener("pointerdown", onPointerEvent, true);
    document.addEventListener("pointermove", onPointerEvent, true);
    document.addEventListener("pointerup", onPointerEvent, true);
  } else {
    document.addEventListener("mousedown", onPointerEvent, true);
    document.addEventListener("mousemove", onPointerEvent, true);
    document.addEventListener("mouseup", onPointerEvent, true);
  }
  hasSetup = true;
}
function trackFocusVisible(fn) {
  setupGlobalFocusEvents();
  fn(isFocusVisible());
  const handler = () => fn(isFocusVisible());
  handlers.add(handler);
  return () => {
    handlers.delete(handler);
  };
}
},{}],"m2Yh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCheckbox = useCheckbox;
var _formControl = require("@chakra-ui/form-control");
var _reactUseSafeLayoutEffect = require("@chakra-ui/react-use-safe-layout-effect");
var _reactUseUpdateEffect = require("@chakra-ui/react-use-update-effect");
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _visuallyHidden = require("@chakra-ui/visually-hidden");
var _focusVisible = require("@zag-js/focus-visible");
var _react = require("react");
// src/use-checkbox.ts

// ../../utilities/object-utils/src/index.ts
function omit(object, keysToOmit = []) {
  const clone = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone) delete clone[key];
  }
  return clone;
}

// src/use-checkbox.ts

function useCheckbox(props = {}) {
  const formControlProps = (0, _formControl.useFormControlProps)(props);
  const {
    isDisabled,
    isReadOnly,
    isRequired,
    isInvalid,
    id,
    onBlur,
    onFocus,
    "aria-describedby": ariaDescribedBy
  } = formControlProps;
  const {
    defaultChecked,
    isChecked: checkedProp,
    isFocusable,
    onChange,
    isIndeterminate,
    name,
    value,
    tabIndex = void 0,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-invalid": ariaInvalid,
    ...rest
  } = props;
  const htmlProps = omit(rest, ["isDisabled", "isReadOnly", "isRequired", "isInvalid", "id", "onBlur", "onFocus", "aria-describedby"]);
  const onChangeProp = (0, _reactUseCallbackRef.useCallbackRef)(onChange);
  const onBlurProp = (0, _reactUseCallbackRef.useCallbackRef)(onBlur);
  const onFocusProp = (0, _reactUseCallbackRef.useCallbackRef)(onFocus);
  const [isFocusVisible, setIsFocusVisible] = (0, _react.useState)(false);
  const [isFocused, setFocused] = (0, _react.useState)(false);
  const [isHovered, setHovered] = (0, _react.useState)(false);
  const [isActive, setActive] = (0, _react.useState)(false);
  (0, _react.useEffect)(() => {
    return (0, _focusVisible.trackFocusVisible)(setIsFocusVisible);
  }, []);
  const inputRef = (0, _react.useRef)(null);
  const [rootIsLabelElement, setRootIsLabelElement] = (0, _react.useState)(true);
  const [checkedState, setCheckedState] = (0, _react.useState)(!!defaultChecked);
  const isControlled = checkedProp !== void 0;
  const isChecked = isControlled ? checkedProp : checkedState;
  const handleChange = (0, _react.useCallback)(event => {
    if (isReadOnly || isDisabled) {
      event.preventDefault();
      return;
    }
    if (!isControlled) {
      if (isChecked) {
        setCheckedState(event.target.checked);
      } else {
        setCheckedState(isIndeterminate ? true : event.target.checked);
      }
    }
    onChangeProp == null ? void 0 : onChangeProp(event);
  }, [isReadOnly, isDisabled, isChecked, isControlled, isIndeterminate, onChangeProp]);
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => {
    if (inputRef.current) {
      inputRef.current.indeterminate = Boolean(isIndeterminate);
    }
  }, [isIndeterminate]);
  (0, _reactUseUpdateEffect.useUpdateEffect)(() => {
    if (isDisabled) {
      setFocused(false);
    }
  }, [isDisabled, setFocused]);
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => {
    const el = inputRef.current;
    if (!(el == null ? void 0 : el.form)) return;
    el.form.onreset = () => {
      setCheckedState(!!defaultChecked);
    };
  }, []);
  const trulyDisabled = isDisabled && !isFocusable;
  const onKeyDown = (0, _react.useCallback)(event => {
    if (event.key === " ") {
      setActive(true);
    }
  }, [setActive]);
  const onKeyUp = (0, _react.useCallback)(event => {
    if (event.key === " ") {
      setActive(false);
    }
  }, [setActive]);
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => {
    if (!inputRef.current) return;
    const notInSync = inputRef.current.checked !== isChecked;
    if (notInSync) {
      setCheckedState(inputRef.current.checked);
    }
  }, [inputRef.current]);
  const getCheckboxProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => {
    const onPressDown = event => {
      if (isFocused) {
        event.preventDefault();
      }
      setActive(true);
    };
    return {
      ...props2,
      ref: forwardedRef,
      "data-active": (0, _sharedUtils.dataAttr)(isActive),
      "data-hover": (0, _sharedUtils.dataAttr)(isHovered),
      "data-checked": (0, _sharedUtils.dataAttr)(isChecked),
      "data-focus": (0, _sharedUtils.dataAttr)(isFocused),
      "data-focus-visible": (0, _sharedUtils.dataAttr)(isFocused && isFocusVisible),
      "data-indeterminate": (0, _sharedUtils.dataAttr)(isIndeterminate),
      "data-disabled": (0, _sharedUtils.dataAttr)(isDisabled),
      "data-invalid": (0, _sharedUtils.dataAttr)(isInvalid),
      "data-readonly": (0, _sharedUtils.dataAttr)(isReadOnly),
      "aria-hidden": true,
      onMouseDown: (0, _sharedUtils.callAllHandlers)(props2.onMouseDown, onPressDown),
      onMouseUp: (0, _sharedUtils.callAllHandlers)(props2.onMouseUp, () => setActive(false)),
      onMouseEnter: (0, _sharedUtils.callAllHandlers)(props2.onMouseEnter, () => setHovered(true)),
      onMouseLeave: (0, _sharedUtils.callAllHandlers)(props2.onMouseLeave, () => setHovered(false))
    };
  }, [isActive, isChecked, isDisabled, isFocused, isFocusVisible, isHovered, isIndeterminate, isInvalid, isReadOnly]);
  const getRootProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => ({
    ...htmlProps,
    ...props2,
    ref: (0, _reactUseMergeRefs.mergeRefs)(forwardedRef, node => {
      if (!node) return;
      setRootIsLabelElement(node.tagName === "LABEL");
    }),
    onClick: (0, _sharedUtils.callAllHandlers)(props2.onClick, () => {
      var _a;
      if (!rootIsLabelElement) {
        (_a = inputRef.current) == null ? void 0 : _a.click();
        requestAnimationFrame(() => {
          var _a2;
          (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
        });
      }
    }),
    "data-disabled": (0, _sharedUtils.dataAttr)(isDisabled),
    "data-checked": (0, _sharedUtils.dataAttr)(isChecked),
    "data-invalid": (0, _sharedUtils.dataAttr)(isInvalid)
  }), [htmlProps, isDisabled, isChecked, isInvalid, rootIsLabelElement]);
  const getInputProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => {
    return {
      ...props2,
      ref: (0, _reactUseMergeRefs.mergeRefs)(inputRef, forwardedRef),
      type: "checkbox",
      name,
      value,
      id,
      tabIndex,
      onChange: (0, _sharedUtils.callAllHandlers)(props2.onChange, handleChange),
      onBlur: (0, _sharedUtils.callAllHandlers)(props2.onBlur, onBlurProp, () => setFocused(false)),
      onFocus: (0, _sharedUtils.callAllHandlers)(props2.onFocus, onFocusProp, () => setFocused(true)),
      onKeyDown: (0, _sharedUtils.callAllHandlers)(props2.onKeyDown, onKeyDown),
      onKeyUp: (0, _sharedUtils.callAllHandlers)(props2.onKeyUp, onKeyUp),
      required: isRequired,
      checked: isChecked,
      disabled: trulyDisabled,
      readOnly: isReadOnly,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      "aria-invalid": ariaInvalid ? Boolean(ariaInvalid) : isInvalid,
      "aria-describedby": ariaDescribedBy,
      "aria-disabled": isDisabled,
      style: _visuallyHidden.visuallyHiddenStyle
    };
  }, [name, value, id, handleChange, onBlurProp, onFocusProp, onKeyDown, onKeyUp, isRequired, isChecked, trulyDisabled, isReadOnly, ariaLabel, ariaLabelledBy, ariaInvalid, isInvalid, ariaDescribedBy, isDisabled, tabIndex]);
  const getLabelProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => ({
    ...props2,
    ref: forwardedRef,
    onMouseDown: (0, _sharedUtils.callAllHandlers)(props2.onMouseDown, stopEvent),
    onTouchStart: (0, _sharedUtils.callAllHandlers)(props2.onTouchStart, stopEvent),
    "data-disabled": (0, _sharedUtils.dataAttr)(isDisabled),
    "data-checked": (0, _sharedUtils.dataAttr)(isChecked),
    "data-invalid": (0, _sharedUtils.dataAttr)(isInvalid)
  }), [isChecked, isDisabled, isInvalid]);
  const state = {
    isInvalid,
    isFocused,
    isChecked,
    isActive,
    isHovered,
    isIndeterminate,
    isDisabled,
    isReadOnly,
    isRequired
  };
  return {
    state,
    getRootProps,
    getCheckboxProps,
    getInputProps,
    getLabelProps,
    htmlProps
  };
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
},{"@chakra-ui/form-control":"fjMD","@chakra-ui/react-use-safe-layout-effect":"cYtR","@chakra-ui/react-use-update-effect":"GqG2","@chakra-ui/react-use-callback-ref":"PPhG","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/shared-utils":"gghr","@chakra-ui/visually-hidden":"CBEJ","@zag-js/focus-visible":"yUYU","react":"n8MK"}],"fUqQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Checkbox = void 0;
var _chunk6XFPBTDN = require("./chunk-6XFPBTDN.mjs");
var _chunkDFEUIRKX = require("./chunk-DFEUIRKX.mjs");
var _chunkHLV2TRVT = require("./chunk-HLV2TRVT.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/checkbox.tsx

var controlStyles = {
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  verticalAlign: "top",
  userSelect: "none",
  flexShrink: 0
};
var rootStyles = {
  cursor: "pointer",
  display: "inline-flex",
  alignItems: "center",
  verticalAlign: "top",
  position: "relative"
};
var checkAnim = (0, _system.keyframes)({
  from: {
    opacity: 0,
    strokeDashoffset: 16,
    transform: "scale(0.95)"
  },
  to: {
    opacity: 1,
    strokeDashoffset: 0,
    transform: "scale(1)"
  }
});
var indeterminateOpacityAnim = (0, _system.keyframes)({
  from: {
    opacity: 0
  },
  to: {
    opacity: 1
  }
});
var indeterminateScaleAnim = (0, _system.keyframes)({
  from: {
    transform: "scaleX(0.65)"
  },
  to: {
    transform: "scaleX(1)"
  }
});
var Checkbox = (0, _system.forwardRef)(function Checkbox2(props, ref) {
  const group = (0, _chunk6XFPBTDN.useCheckboxGroupContext)();
  const mergedProps = {
    ...group,
    ...props
  };
  const styles = (0, _system.useMultiStyleConfig)("Checkbox", mergedProps);
  const ownProps = (0, _system.omitThemingProps)(props);
  const {
    spacing = "0.5rem",
    className,
    children,
    iconColor,
    iconSize,
    icon = /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkDFEUIRKX.CheckboxIcon, {}),
    isChecked: isCheckedProp,
    isDisabled = group == null ? void 0 : group.isDisabled,
    onChange: onChangeProp,
    inputProps,
    ...rest
  } = ownProps;
  let isChecked = isCheckedProp;
  if ((group == null ? void 0 : group.value) && ownProps.value) {
    isChecked = group.value.includes(ownProps.value);
  }
  let onChange = onChangeProp;
  if ((group == null ? void 0 : group.onChange) && ownProps.value) {
    onChange = (0, _sharedUtils.callAll)(group.onChange, onChangeProp);
  }
  const {
    state,
    getInputProps,
    getCheckboxProps,
    getLabelProps,
    getRootProps
  } = (0, _chunkHLV2TRVT.useCheckbox)({
    ...rest,
    isDisabled,
    isChecked,
    onChange
  });
  const iconStyles = (0, _react.useMemo)(() => ({
    animation: state.isIndeterminate ? `${indeterminateOpacityAnim} 20ms linear, ${indeterminateScaleAnim} 200ms linear` : `${checkAnim} 200ms linear`,
    fontSize: iconSize,
    color: iconColor,
    ...styles.icon
  }), [iconColor, iconSize,, state.isIndeterminate, styles.icon]);
  const clonedIcon = (0, _react.cloneElement)(icon, {
    __css: iconStyles,
    isIndeterminate: state.isIndeterminate,
    isChecked: state.isChecked
  });
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.label, {
    __css: {
      ...rootStyles,
      ...styles.container
    },
    className: (0, _sharedUtils.cx)("chakra-checkbox", className),
    ...getRootProps(),
    children: [/* @__PURE__ */(0, _jsxRuntime.jsx)("input", {
      className: "chakra-checkbox__input",
      ...getInputProps(inputProps, ref)
    }), /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      __css: {
        ...controlStyles,
        ...styles.control
      },
      className: "chakra-checkbox__control",
      ...getCheckboxProps(),
      children: clonedIcon
    }), children && /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      className: "chakra-checkbox__label",
      ...getLabelProps(),
      __css: {
        marginStart: spacing,
        ...styles.label
      },
      children
    })]
  });
});
exports.Checkbox = Checkbox;
Checkbox.displayName = "Checkbox";
},{"./chunk-6XFPBTDN.mjs":"ALXv","./chunk-DFEUIRKX.mjs":"MKVo","./chunk-HLV2TRVT.mjs":"m2Yh","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"QvbT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Checkbox", {
  enumerable: true,
  get: function () {
    return _chunkQILK4NXY.Checkbox;
  }
});
Object.defineProperty(exports, "CheckboxGroup", {
  enumerable: true,
  get: function () {
    return _chunkY65KPFRX.CheckboxGroup;
  }
});
Object.defineProperty(exports, "CheckboxIcon", {
  enumerable: true,
  get: function () {
    return _chunkDFEUIRKX.CheckboxIcon;
  }
});
Object.defineProperty(exports, "useCheckbox", {
  enumerable: true,
  get: function () {
    return _chunkHLV2TRVT.useCheckbox;
  }
});
Object.defineProperty(exports, "useCheckboxGroup", {
  enumerable: true,
  get: function () {
    return _chunk5F7ST2TT.useCheckboxGroup;
  }
});
var _chunkY65KPFRX = require("./chunk-Y65KPFRX.mjs");
var _chunkQILK4NXY = require("./chunk-QILK4NXY.mjs");
require("./chunk-6XFPBTDN.mjs");
var _chunkDFEUIRKX = require("./chunk-DFEUIRKX.mjs");
var _chunk5F7ST2TT = require("./chunk-5F7ST2TT.mjs");
var _chunkHLV2TRVT = require("./chunk-HLV2TRVT.mjs");
},{"./chunk-Y65KPFRX.mjs":"dlLz","./chunk-QILK4NXY.mjs":"fUqQ","./chunk-6XFPBTDN.mjs":"ALXv","./chunk-DFEUIRKX.mjs":"MKVo","./chunk-5F7ST2TT.mjs":"vq2z","./chunk-HLV2TRVT.mjs":"m2Yh"}],"ztyA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.control_box_default = exports.ControlBox = void 0;
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/control-box.tsx

var ControlBox = props => {
  const {
    type = "checkbox",
    _hover,
    _invalid,
    _disabled,
    _focus,
    _checked,
    _child = {
      opacity: 0
    },
    _checkedAndChild = {
      opacity: 1
    },
    _checkedAndDisabled,
    _checkedAndFocus,
    _checkedAndHover,
    children,
    ...rest
  } = props;
  const checkedAndDisabled = `input[type=${type}]:checked:disabled + &`;
  const checkedAndHover = `input[type=${type}]:checked:hover:not(:disabled) + &`;
  const checkedAndFocus = `input[type=${type}]:checked:focus + &`;
  const disabled = `input[type=${type}]:disabled + &`;
  const focus = `input[type=${type}]:focus + &`;
  const hover = `input[type=${type}]:hover:not(:disabled):not(:checked) + &`;
  const checked = `input[type=${type}]:checked + &, input[type=${type}][aria-checked=mixed] + &`;
  const invalid = `input[type=${type}][aria-invalid=true] + &`;
  const child = `& > *`;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...rest,
    "aria-hidden": true,
    __css: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      transitionProperty: "common",
      transitionDuration: "fast",
      flexShrink: 0,
      [focus]: _focus,
      [hover]: _hover,
      [disabled]: _disabled,
      [invalid]: _invalid,
      [checkedAndDisabled]: _checkedAndDisabled,
      [checkedAndFocus]: _checkedAndFocus,
      [checkedAndHover]: _checkedAndHover,
      [child]: _child,
      [checked]: {
        ..._checked,
        [child]: _checkedAndChild
      }
    },
    children
  });
};
exports.ControlBox = ControlBox;
ControlBox.displayName = "ControlBox";
var control_box_default = ControlBox;
exports.control_box_default = control_box_default;
},{"@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"WYnY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ControlBox", {
  enumerable: true,
  get: function () {
    return _chunkPOK5SEAG.ControlBox;
  }
});
var _chunkPOK5SEAG = require("./chunk-POK5SEAG.mjs");
},{"./chunk-POK5SEAG.mjs":"ztyA"}],"n1rw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clampValue = clampValue;
exports.countDecimalPlaces = countDecimalPlaces;
exports.percentToValue = percentToValue;
exports.roundValueToStep = roundValueToStep;
exports.toPrecision = toPrecision;
exports.valueToPercent = valueToPercent;
// src/index.ts
function toNumber(value) {
  const num = parseFloat(value);
  return typeof num !== "number" || Number.isNaN(num) ? 0 : num;
}
function toPrecision(value, precision) {
  let nextValue = toNumber(value);
  const scaleFactor = 10 ** (precision != null ? precision : 10);
  nextValue = Math.round(nextValue * scaleFactor) / scaleFactor;
  return precision ? nextValue.toFixed(precision) : nextValue.toString();
}
function countDecimalPlaces(value) {
  if (!Number.isFinite(value)) return 0;
  let e = 1;
  let p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
}
function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}
function percentToValue(percent, min, max) {
  return (max - min) * percent + min;
}
function roundValueToStep(value, from, step) {
  const nextValue = Math.round((value - from) / step) * step + from;
  const precision = countDecimalPlaces(step);
  return toPrecision(nextValue, precision);
}
function clampValue(value, min, max) {
  if (value == null) return value;
  if (max < min) {
    console.warn("clamp: max cannot be less than min");
  }
  return Math.min(Math.max(value, min), max);
}
},{}],"lsln":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCounter = useCounter;
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
var _numberUtils = require("@chakra-ui/number-utils");
var _react = require("react");
// src/use-counter.ts

function useCounter(props = {}) {
  const {
    onChange,
    precision: precisionProp,
    defaultValue,
    value: valueProp,
    step: stepProp = 1,
    min = Number.MIN_SAFE_INTEGER,
    max = Number.MAX_SAFE_INTEGER,
    keepWithinRange = true
  } = props;
  const onChangeProp = (0, _reactUseCallbackRef.useCallbackRef)(onChange);
  const [valueState, setValue] = (0, _react.useState)(() => {
    var _a;
    if (defaultValue == null) return "";
    return (_a = cast(defaultValue, stepProp, precisionProp)) != null ? _a : "";
  });
  const isControlled = typeof valueProp !== "undefined";
  const value = isControlled ? valueProp : valueState;
  const decimalPlaces = getDecimalPlaces(parse(value), stepProp);
  const precision = precisionProp != null ? precisionProp : decimalPlaces;
  const update = (0, _react.useCallback)(next => {
    if (next === value) return;
    if (!isControlled) {
      setValue(next.toString());
    }
    onChangeProp == null ? void 0 : onChangeProp(next.toString(), parse(next));
  }, [onChangeProp, isControlled, value]);
  const clamp = (0, _react.useCallback)(value2 => {
    let nextValue = value2;
    if (keepWithinRange) {
      nextValue = (0, _numberUtils.clampValue)(nextValue, min, max);
    }
    return (0, _numberUtils.toPrecision)(nextValue, precision);
  }, [precision, keepWithinRange, max, min]);
  const increment = (0, _react.useCallback)((step = stepProp) => {
    let next;
    if (value === "") {
      next = parse(step);
    } else {
      next = parse(value) + step;
    }
    next = clamp(next);
    update(next);
  }, [clamp, stepProp, update, value]);
  const decrement = (0, _react.useCallback)((step = stepProp) => {
    let next;
    if (value === "") {
      next = parse(-step);
    } else {
      next = parse(value) - step;
    }
    next = clamp(next);
    update(next);
  }, [clamp, stepProp, update, value]);
  const reset = (0, _react.useCallback)(() => {
    var _a;
    let next;
    if (defaultValue == null) {
      next = "";
    } else {
      next = (_a = cast(defaultValue, stepProp, precisionProp)) != null ? _a : min;
    }
    update(next);
  }, [defaultValue, precisionProp, stepProp, update, min]);
  const castValue = (0, _react.useCallback)(value2 => {
    var _a;
    const nextValue = (_a = cast(value2, stepProp, precision)) != null ? _a : min;
    update(nextValue);
  }, [precision, stepProp, update, min]);
  const valueAsNumber = parse(value);
  const isOutOfRange = valueAsNumber > max || valueAsNumber < min;
  const isAtMax = valueAsNumber === max;
  const isAtMin = valueAsNumber === min;
  return {
    isOutOfRange,
    isAtMax,
    isAtMin,
    precision,
    value,
    valueAsNumber,
    update,
    reset,
    increment,
    decrement,
    clamp,
    cast: castValue,
    setValue
  };
}
function parse(value) {
  return parseFloat(value.toString().replace(/[^\w.-]+/g, ""));
}
function getDecimalPlaces(value, step) {
  return Math.max((0, _numberUtils.countDecimalPlaces)(step), (0, _numberUtils.countDecimalPlaces)(value));
}
function cast(value, step, precision) {
  const parsedValue = parse(value);
  if (Number.isNaN(parsedValue)) return void 0;
  const decimalPlaces = getDecimalPlaces(parsedValue, step);
  return (0, _numberUtils.toPrecision)(parsedValue, precision != null ? precision : decimalPlaces);
}
},{"@chakra-ui/react-use-callback-ref":"PPhG","@chakra-ui/number-utils":"n1rw","react":"n8MK"}],"yOVB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "useCounter", {
  enumerable: true,
  get: function () {
    return _chunkO3YOOUZ.useCounter;
  }
});
var _chunkO3YOOUZ = require("./chunk-O3YOOUZ7.mjs");
},{"./chunk-O3YOOUZ7.mjs":"lsln"}],"TMtf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEditableStyles = exports.useEditableContext = exports.EditableStylesProvider = exports.EditableProvider = void 0;
var _reactContext = require("@chakra-ui/react-context");
// src/editable-context.ts

var [EditableStylesProvider, useEditableStyles] = (0, _reactContext.createContext)({
  name: `EditableStylesContext`,
  errorMessage: `useEditableStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Editable />" `
});
exports.useEditableStyles = useEditableStyles;
exports.EditableStylesProvider = EditableStylesProvider;
var [EditableProvider, useEditableContext] = (0, _reactContext.createContext)({
  name: "EditableContext",
  errorMessage: "useEditableContext: context is undefined. Seems you forgot to wrap the editable components in `<Editable />`"
});
exports.useEditableContext = useEditableContext;
exports.EditableProvider = EditableProvider;
},{"@chakra-ui/react-context":"lT23"}],"K5K1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEditableState = useEditableState;
var _chunkWADSSRGF = require("./chunk-WADSSRGF.mjs");
// src/use-editable-state.tsx
function useEditableState() {
  const {
    isEditing,
    onSubmit,
    onCancel,
    onEdit,
    isDisabled
  } = (0, _chunkWADSSRGF.useEditableContext)();
  return {
    isEditing,
    onSubmit,
    onCancel,
    onEdit,
    isDisabled
  };
}
},{"./chunk-WADSSRGF.mjs":"TMtf"}],"Aygn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.commonStyles = void 0;
// src/shared.ts
var commonStyles = {
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent"
};
exports.commonStyles = commonStyles;
},{}],"DOVZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditableInput = void 0;
var _chunkLA6GBQAD = require("./chunk-LA6GBQAD.mjs");
var _chunkWADSSRGF = require("./chunk-WADSSRGF.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/editable-input.tsx

var EditableInput = (0, _system.forwardRef)(function EditableInput2(props, ref) {
  const {
    getInputProps
  } = (0, _chunkWADSSRGF.useEditableContext)();
  const styles = (0, _chunkWADSSRGF.useEditableStyles)();
  const inputProps = getInputProps(props, ref);
  const _className = (0, _sharedUtils.cx)("chakra-editable__input", props.className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.input, {
    ...inputProps,
    __css: {
      outline: 0,
      ..._chunkLA6GBQAD.commonStyles,
      ...styles.input
    },
    className: _className
  });
});
exports.EditableInput = EditableInput;
EditableInput.displayName = "EditableInput";
},{"./chunk-LA6GBQAD.mjs":"Aygn","./chunk-WADSSRGF.mjs":"TMtf","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"ojCY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditablePreview = void 0;
var _chunkLA6GBQAD = require("./chunk-LA6GBQAD.mjs");
var _chunkWADSSRGF = require("./chunk-WADSSRGF.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/editable-preview.tsx

var EditablePreview = (0, _system.forwardRef)(function EditablePreview2(props, ref) {
  const {
    getPreviewProps
  } = (0, _chunkWADSSRGF.useEditableContext)();
  const styles = (0, _chunkWADSSRGF.useEditableStyles)();
  const previewProps = getPreviewProps(props, ref);
  const _className = (0, _sharedUtils.cx)("chakra-editable__preview", props.className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
    ...previewProps,
    __css: {
      cursor: "text",
      display: "inline-block",
      ..._chunkLA6GBQAD.commonStyles,
      ...styles.preview
    },
    className: _className
  });
});
exports.EditablePreview = EditablePreview;
EditablePreview.displayName = "EditablePreview";
},{"./chunk-LA6GBQAD.mjs":"Aygn","./chunk-WADSSRGF.mjs":"TMtf","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"PChO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditableTextarea = void 0;
var _chunkLA6GBQAD = require("./chunk-LA6GBQAD.mjs");
var _chunkWADSSRGF = require("./chunk-WADSSRGF.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/editable-textarea.tsx

var EditableTextarea = (0, _system.forwardRef)(function EditableTextarea2(props, ref) {
  const {
    getTextareaProps
  } = (0, _chunkWADSSRGF.useEditableContext)();
  const styles = (0, _chunkWADSSRGF.useEditableStyles)();
  const textareaProps = getTextareaProps(props, ref);
  const _className = (0, _sharedUtils.cx)("chakra-editable__textarea", props.className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.textarea, {
    ...textareaProps,
    __css: {
      outline: 0,
      ..._chunkLA6GBQAD.commonStyles,
      ...styles.textarea
    },
    className: _className
  });
});
exports.EditableTextarea = EditableTextarea;
EditableTextarea.displayName = "EditableTextarea";
},{"./chunk-LA6GBQAD.mjs":"Aygn","./chunk-WADSSRGF.mjs":"TMtf","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"Lu7g":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEventListener = useEventListener;
var _react = require("react");
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
// src/index.ts

function useEventListener(target, event, handler, options) {
  const listener = (0, _reactUseCallbackRef.useCallbackRef)(handler);
  (0, _react.useEffect)(() => {
    const node = typeof target === "function" ? target() : target != null ? target : document;
    if (!handler || !node) return;
    node.addEventListener(event, listener, options);
    return () => {
      node.removeEventListener(event, listener, options);
    };
  }, [event, target, options, listener, handler]);
  return () => {
    const node = typeof target === "function" ? target() : target != null ? target : document;
    node == null ? void 0 : node.removeEventListener(event, listener, options);
  };
}
},{"react":"n8MK","@chakra-ui/react-use-callback-ref":"PPhG"}],"B5wa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFocusOnPointerDown = useFocusOnPointerDown;
var _reactUseEventListener = require("@chakra-ui/react-use-event-listener");
// src/index.ts

function isRefObject(val) {
  return "current" in val;
}
var isDom = () => typeof window !== "undefined";
function getPlatform() {
  var _a;
  const agent = navigator.userAgentData;
  return (_a = agent == null ? void 0 : agent.platform) != null ? _a : navigator.platform;
}
var vn = v => isDom() && v.test(navigator.vendor);
var pt = v => isDom() && v.test(getPlatform());
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isSafari = () => isApple() && vn(/apple/i);
function useFocusOnPointerDown(props) {
  const {
    ref,
    elements,
    enabled
  } = props;
  const doc = () => {
    var _a, _b;
    return (_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument) != null ? _b : document;
  };
  (0, _reactUseEventListener.useEventListener)(doc, "pointerdown", event => {
    if (!isSafari() || !enabled) return;
    const target = event.target;
    const els = elements != null ? elements : [ref];
    const isValidTarget = els.some(elementOrRef => {
      const el = isRefObject(elementOrRef) ? elementOrRef.current : elementOrRef;
      return (el == null ? void 0 : el.contains(target)) || el === target;
    });
    if (doc().activeElement !== target && isValidTarget) {
      event.preventDefault();
      target.focus();
    }
  });
}
},{"@chakra-ui/react-use-event-listener":"Lu7g"}],"gXiD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEditable = useEditable;
var _reactUseFocusOnPointerDown = require("@chakra-ui/react-use-focus-on-pointer-down");
var _reactUseSafeLayoutEffect = require("@chakra-ui/react-use-safe-layout-effect");
var _reactUseUpdateEffect = require("@chakra-ui/react-use-update-effect");
var _reactUseControllableState = require("@chakra-ui/react-use-controllable-state");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
// src/use-editable.ts

function contains(parent, child) {
  if (!parent) return false;
  return parent === child || parent.contains(child);
}
function useEditable(props = {}) {
  const {
    onChange: onChangeProp,
    onCancel: onCancelProp,
    onSubmit: onSubmitProp,
    value: valueProp,
    isDisabled,
    defaultValue,
    startWithEditView,
    isPreviewFocusable = true,
    submitOnBlur = true,
    selectAllOnFocus = true,
    placeholder,
    onEdit: onEditCallback,
    ...htmlProps
  } = props;
  const onEditProp = (0, _reactUseCallbackRef.useCallbackRef)(onEditCallback);
  const defaultIsEditing = Boolean(startWithEditView && !isDisabled);
  const [isEditing, setIsEditing] = (0, _react.useState)(defaultIsEditing);
  const [value, setValue] = (0, _reactUseControllableState.useControllableState)({
    defaultValue: defaultValue || "",
    value: valueProp,
    onChange: onChangeProp
  });
  const [prevValue, setPrevValue] = (0, _react.useState)(value);
  const inputRef = (0, _react.useRef)(null);
  const previewRef = (0, _react.useRef)(null);
  const editButtonRef = (0, _react.useRef)(null);
  const cancelButtonRef = (0, _react.useRef)(null);
  const submitButtonRef = (0, _react.useRef)(null);
  (0, _reactUseFocusOnPointerDown.useFocusOnPointerDown)({
    ref: inputRef,
    enabled: isEditing,
    elements: [cancelButtonRef, submitButtonRef]
  });
  const isInteractive = !isEditing && !isDisabled;
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => {
    var _a, _b;
    if (isEditing) {
      (_a = inputRef.current) == null ? void 0 : _a.focus();
      if (selectAllOnFocus) (_b = inputRef.current) == null ? void 0 : _b.select();
    }
  }, []);
  (0, _reactUseUpdateEffect.useUpdateEffect)(() => {
    var _a, _b, _c;
    if (!isEditing) {
      (_a = editButtonRef.current) == null ? void 0 : _a.focus();
      return;
    }
    (_b = inputRef.current) == null ? void 0 : _b.focus();
    if (selectAllOnFocus) {
      (_c = inputRef.current) == null ? void 0 : _c.select();
    }
    onEditProp == null ? void 0 : onEditProp();
  }, [isEditing, onEditProp, selectAllOnFocus]);
  const onEdit = (0, _react.useCallback)(() => {
    if (isInteractive) {
      setIsEditing(true);
    }
  }, [isInteractive]);
  const onUpdatePrevValue = (0, _react.useCallback)(() => {
    setPrevValue(value);
  }, [value]);
  const onCancel = (0, _react.useCallback)(() => {
    setIsEditing(false);
    setValue(prevValue);
    onCancelProp == null ? void 0 : onCancelProp(prevValue);
  }, [onCancelProp, setValue, prevValue]);
  const onSubmit = (0, _react.useCallback)(() => {
    setIsEditing(false);
    setPrevValue(value);
    onSubmitProp == null ? void 0 : onSubmitProp(value);
  }, [value, onSubmitProp]);
  (0, _react.useEffect)(() => {
    if (isEditing) return;
    const inputEl = inputRef.current;
    if ((inputEl == null ? void 0 : inputEl.ownerDocument.activeElement) === inputEl) {
      inputEl == null ? void 0 : inputEl.blur();
    }
  }, [isEditing]);
  const onChange = (0, _react.useCallback)(event => {
    setValue(event.currentTarget.value);
  }, [setValue]);
  const onKeyDown = (0, _react.useCallback)(event => {
    const eventKey = event.key;
    const keyMap = {
      Escape: onCancel,
      Enter: event2 => {
        if (!event2.shiftKey && !event2.metaKey) {
          onSubmit();
        }
      }
    };
    const action = keyMap[eventKey];
    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [onCancel, onSubmit]);
  const onKeyDownWithoutSubmit = (0, _react.useCallback)(event => {
    const eventKey = event.key;
    const keyMap = {
      Escape: onCancel
    };
    const action = keyMap[eventKey];
    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [onCancel]);
  const isValueEmpty = value.length === 0;
  const onBlur = (0, _react.useCallback)(event => {
    var _a;
    if (!isEditing) return;
    const doc = event.currentTarget.ownerDocument;
    const relatedTarget = (_a = event.relatedTarget) != null ? _a : doc.activeElement;
    const targetIsCancel = contains(cancelButtonRef.current, relatedTarget);
    const targetIsSubmit = contains(submitButtonRef.current, relatedTarget);
    const isValidBlur = !targetIsCancel && !targetIsSubmit;
    if (isValidBlur) {
      if (submitOnBlur) {
        onSubmit();
      } else {
        onCancel();
      }
    }
  }, [submitOnBlur, onSubmit, onCancel, isEditing]);
  const getPreviewProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    const tabIndex = isInteractive && isPreviewFocusable ? 0 : void 0;
    return {
      ...props2,
      ref: (0, _reactUseMergeRefs.mergeRefs)(ref, previewRef),
      children: isValueEmpty ? placeholder : value,
      hidden: isEditing,
      "aria-disabled": (0, _sharedUtils.ariaAttr)(isDisabled),
      tabIndex,
      onFocus: (0, _sharedUtils.callAllHandlers)(props2.onFocus, onEdit, onUpdatePrevValue)
    };
  }, [isDisabled, isEditing, isInteractive, isPreviewFocusable, isValueEmpty, onEdit, onUpdatePrevValue, placeholder, value]);
  const getInputProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    hidden: !isEditing,
    placeholder,
    ref: (0, _reactUseMergeRefs.mergeRefs)(ref, inputRef),
    disabled: isDisabled,
    "aria-disabled": (0, _sharedUtils.ariaAttr)(isDisabled),
    value,
    onBlur: (0, _sharedUtils.callAllHandlers)(props2.onBlur, onBlur),
    onChange: (0, _sharedUtils.callAllHandlers)(props2.onChange, onChange),
    onKeyDown: (0, _sharedUtils.callAllHandlers)(props2.onKeyDown, onKeyDown),
    onFocus: (0, _sharedUtils.callAllHandlers)(props2.onFocus, onUpdatePrevValue)
  }), [isDisabled, isEditing, onBlur, onChange, onKeyDown, onUpdatePrevValue, placeholder, value]);
  const getTextareaProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    hidden: !isEditing,
    placeholder,
    ref: (0, _reactUseMergeRefs.mergeRefs)(ref, inputRef),
    disabled: isDisabled,
    "aria-disabled": (0, _sharedUtils.ariaAttr)(isDisabled),
    value,
    onBlur: (0, _sharedUtils.callAllHandlers)(props2.onBlur, onBlur),
    onChange: (0, _sharedUtils.callAllHandlers)(props2.onChange, onChange),
    onKeyDown: (0, _sharedUtils.callAllHandlers)(props2.onKeyDown, onKeyDownWithoutSubmit),
    onFocus: (0, _sharedUtils.callAllHandlers)(props2.onFocus, onUpdatePrevValue)
  }), [isDisabled, isEditing, onBlur, onChange, onKeyDownWithoutSubmit, onUpdatePrevValue, placeholder, value]);
  const getEditButtonProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    "aria-label": "Edit",
    ...props2,
    type: "button",
    onClick: (0, _sharedUtils.callAllHandlers)(props2.onClick, onEdit),
    ref: (0, _reactUseMergeRefs.mergeRefs)(ref, editButtonRef),
    disabled: isDisabled
  }), [onEdit, isDisabled]);
  const getSubmitButtonProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    "aria-label": "Submit",
    ref: (0, _reactUseMergeRefs.mergeRefs)(submitButtonRef, ref),
    type: "button",
    onClick: (0, _sharedUtils.callAllHandlers)(props2.onClick, onSubmit),
    disabled: isDisabled
  }), [onSubmit, isDisabled]);
  const getCancelButtonProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    "aria-label": "Cancel",
    id: "cancel",
    ...props2,
    ref: (0, _reactUseMergeRefs.mergeRefs)(cancelButtonRef, ref),
    type: "button",
    onClick: (0, _sharedUtils.callAllHandlers)(props2.onClick, onCancel),
    disabled: isDisabled
  }), [onCancel, isDisabled]);
  return {
    isEditing,
    isDisabled,
    isValueEmpty,
    value,
    onEdit,
    onCancel,
    onSubmit,
    getPreviewProps,
    getInputProps,
    getTextareaProps,
    getEditButtonProps,
    getSubmitButtonProps,
    getCancelButtonProps,
    htmlProps
  };
}
},{"@chakra-ui/react-use-focus-on-pointer-down":"B5wa","@chakra-ui/react-use-safe-layout-effect":"cYtR","@chakra-ui/react-use-update-effect":"GqG2","@chakra-ui/react-use-controllable-state":"DWQz","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/react-use-callback-ref":"PPhG","@chakra-ui/shared-utils":"gghr","react":"n8MK"}],"ZUua":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Editable = void 0;
var _chunkDFL5UVBL = require("./chunk-DFL5UVBL.mjs");
var _chunkWADSSRGF = require("./chunk-WADSSRGF.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/editable.tsx

var Editable = (0, _system.forwardRef)(function Editable2(props, ref) {
  const styles = (0, _system.useMultiStyleConfig)("Editable", props);
  const ownProps = (0, _system.omitThemingProps)(props);
  const {
    htmlProps,
    ...context
  } = (0, _chunkDFL5UVBL.useEditable)(ownProps);
  const {
    isEditing,
    onSubmit,
    onCancel,
    onEdit
  } = context;
  const _className = (0, _sharedUtils.cx)("chakra-editable", props.className);
  const children = (0, _sharedUtils.runIfFn)(props.children, {
    isEditing,
    onSubmit,
    onCancel,
    onEdit
  });
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkWADSSRGF.EditableProvider, {
    value: context,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkWADSSRGF.EditableStylesProvider, {
      value: styles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
        ref,
        ...htmlProps,
        className: _className,
        children
      })
    })
  });
});
exports.Editable = Editable;
Editable.displayName = "Editable";
},{"./chunk-DFL5UVBL.mjs":"gXiD","./chunk-WADSSRGF.mjs":"TMtf","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"pvFk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEditableControls = useEditableControls;
var _chunkWADSSRGF = require("./chunk-WADSSRGF.mjs");
// src/use-editable-controls.tsx
function useEditableControls() {
  const {
    isEditing,
    getEditButtonProps,
    getCancelButtonProps,
    getSubmitButtonProps
  } = (0, _chunkWADSSRGF.useEditableContext)();
  return {
    isEditing,
    getEditButtonProps,
    getCancelButtonProps,
    getSubmitButtonProps
  };
}
},{"./chunk-WADSSRGF.mjs":"TMtf"}],"BjNi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Editable", {
  enumerable: true,
  get: function () {
    return _chunkQPHHI44J.Editable;
  }
});
Object.defineProperty(exports, "EditableInput", {
  enumerable: true,
  get: function () {
    return _chunk6EW6LXRD.EditableInput;
  }
});
Object.defineProperty(exports, "EditablePreview", {
  enumerable: true,
  get: function () {
    return _chunkE6ECLSN.EditablePreview;
  }
});
Object.defineProperty(exports, "EditableTextarea", {
  enumerable: true,
  get: function () {
    return _chunkJ2WJP66L.EditableTextarea;
  }
});
Object.defineProperty(exports, "useEditable", {
  enumerable: true,
  get: function () {
    return _chunkDFL5UVBL.useEditable;
  }
});
Object.defineProperty(exports, "useEditableControls", {
  enumerable: true,
  get: function () {
    return _chunkCPGHDSNL.useEditableControls;
  }
});
Object.defineProperty(exports, "useEditableState", {
  enumerable: true,
  get: function () {
    return _chunkZPXE4ZLM.useEditableState;
  }
});
Object.defineProperty(exports, "useEditableStyles", {
  enumerable: true,
  get: function () {
    return _chunkWADSSRGF.useEditableStyles;
  }
});
var _chunkZPXE4ZLM = require("./chunk-ZPXE4ZLM.mjs");
var _chunk6EW6LXRD = require("./chunk-6EW6LXRD.mjs");
var _chunkE6ECLSN = require("./chunk-E6ECLSN7.mjs");
var _chunkJ2WJP66L = require("./chunk-J2WJP66L.mjs");
var _chunkQPHHI44J = require("./chunk-QPHHI44J.mjs");
var _chunkDFL5UVBL = require("./chunk-DFL5UVBL.mjs");
require("./chunk-LA6GBQAD.mjs");
var _chunkCPGHDSNL = require("./chunk-CPGHDSNL.mjs");
var _chunkWADSSRGF = require("./chunk-WADSSRGF.mjs");
},{"./chunk-ZPXE4ZLM.mjs":"K5K1","./chunk-6EW6LXRD.mjs":"DOVZ","./chunk-E6ECLSN7.mjs":"ojCY","./chunk-J2WJP66L.mjs":"PChO","./chunk-QPHHI44J.mjs":"ZUua","./chunk-DFL5UVBL.mjs":"gXiD","./chunk-LA6GBQAD.mjs":"Aygn","./chunk-CPGHDSNL.mjs":"pvFk","./chunk-WADSSRGF.mjs":"TMtf"}],"JMEI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePrevious = usePrevious;
var _react = require("react");
// src/use-previous.ts

function usePrevious(value) {
  const ref = (0, _react.useRef)();
  (0, _react.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
},{"react":"n8MK"}],"PFE7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useShortcut = useShortcut;
var _react = require("react");
// src/use-shortcut.ts

function isPrintableCharacter(event) {
  const {
    key
  } = event;
  return key.length === 1 || key.length > 1 && /[^a-zA-Z0-9]/.test(key);
}
function useShortcut(props = {}) {
  const {
    timeout = 300,
    preventDefault = () => true
  } = props;
  const [keys, setKeys] = (0, _react.useState)([]);
  const timeoutRef = (0, _react.useRef)();
  const flush = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  };
  const clearKeysAfterDelay = () => {
    flush();
    timeoutRef.current = setTimeout(() => {
      setKeys([]);
      timeoutRef.current = null;
    }, timeout);
  };
  (0, _react.useEffect)(() => flush, []);
  function onKeyDown(fn) {
    return event => {
      if (event.key === "Backspace") {
        const keysCopy = [...keys];
        keysCopy.pop();
        setKeys(keysCopy);
        return;
      }
      if (isPrintableCharacter(event)) {
        const keysCopy = keys.concat(event.key);
        if (preventDefault(event)) {
          event.preventDefault();
          event.stopPropagation();
        }
        setKeys(keysCopy);
        fn(keysCopy.join(""));
        clearKeysAfterDelay();
      }
    };
  }
  return onKeyDown;
}
},{"react":"n8MK"}],"JvpQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSafeLayoutEffect = void 0;
var _utils = require("@chakra-ui/utils");
var _react = require("react");
// src/use-safe-layout-effect.ts

var useSafeLayoutEffect = _utils.isBrowser ? _react.useLayoutEffect : _react.useEffect;
exports.useSafeLayoutEffect = useSafeLayoutEffect;
},{"@chakra-ui/utils":"Yp4B","react":"n8MK"}],"T1GQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCallbackRef = useCallbackRef;
var _chunkIYF65QR = require("./chunk-IYF65QR3.mjs");
var _react = require("react");
// src/use-callback-ref.ts

function useCallbackRef(fn, deps = []) {
  const ref = (0, _react.useRef)(fn);
  (0, _chunkIYF65QR.useSafeLayoutEffect)(() => {
    ref.current = fn;
  });
  return (0, _react.useCallback)((...args) => {
    var _a;
    return (_a = ref.current) == null ? void 0 : _a.call(ref, ...args);
  }, deps);
}
},{"./chunk-IYF65QR3.mjs":"JvpQ","react":"n8MK"}],"pjvQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTimeout = useTimeout;
var _chunkTFWETJDV = require("./chunk-TFWETJDV.mjs");
var _react = require("react");
// src/use-timeout.ts

function useTimeout(callback, delay) {
  const fn = (0, _chunkTFWETJDV.useCallbackRef)(callback);
  (0, _react.useEffect)(() => {
    if (delay == null) return void 0;
    let timeoutId = null;
    timeoutId = window.setTimeout(() => {
      fn();
    }, delay);
    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [delay, fn]);
}
},{"./chunk-TFWETJDV.mjs":"T1GQ","react":"n8MK"}],"EFuI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useWhyDidYouUpdate = useWhyDidYouUpdate;
var _react = require("react");
// src/use-why-update.ts

function useWhyDidYouUpdate(name, props) {
  const previousProps = (0, _react.useRef)();
  (0, _react.useEffect)(() => {
    if (previousProps.current) {
      const allKeys = Object.keys({
        ...previousProps.current,
        ...props
      });
      const changesObj = {};
      allKeys.forEach(key => {
        if (previousProps.current[key] !== props[key]) {
          changesObj[key] = {
            from: previousProps.current[key],
            to: props[key]
          };
        }
      });
      if (Object.keys(changesObj).length) {
        console.log("[why-did-you-update]", name, changesObj);
      }
    }
    previousProps.current = props;
  });
}
},{"react":"n8MK"}],"CZ1e":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInterval = useInterval;
var _chunkTFWETJDV = require("./chunk-TFWETJDV.mjs");
var _react = require("react");
// src/use-interval.ts

function useInterval(callback, delay) {
  const fn = (0, _chunkTFWETJDV.useCallbackRef)(callback);
  (0, _react.useEffect)(() => {
    let intervalId = null;
    const tick = () => fn();
    if (delay !== null) {
      intervalId = window.setInterval(tick, delay);
    }
    return () => {
      if (intervalId) {
        window.clearInterval(intervalId);
      }
    };
  }, [delay, fn]);
}
},{"./chunk-TFWETJDV.mjs":"T1GQ","react":"n8MK"}],"ZJ2M":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useLatestRef = useLatestRef;
var _react = require("react");
// src/use-latest-ref.ts

function useLatestRef(value) {
  const ref = (0, _react.useRef)(null);
  ref.current = value;
  return ref;
}
},{"react":"n8MK"}],"hji3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assignRef = assignRef;
exports.useMergeRefs = useMergeRefs;
var _react = require("react");
// src/use-merge-refs.ts

function assignRef(ref, value) {
  if (ref == null) return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function useMergeRefs(...refs) {
  return (0, _react.useMemo)(() => {
    if (refs.every(ref => ref == null)) {
      return null;
    }
    return node => {
      refs.forEach(ref => {
        if (ref) assignRef(ref, node);
      });
    };
  }, refs);
}
},{"react":"n8MK"}],"WMB0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEventListener = useEventListener;
var _chunkTFWETJDV = require("./chunk-TFWETJDV.mjs");
var _utils = require("@chakra-ui/utils");
var _react = require("react");
// src/use-event-listener.ts

function useEventListener(event, handler, env, options) {
  const listener = (0, _chunkTFWETJDV.useCallbackRef)(handler);
  (0, _react.useEffect)(() => {
    var _a;
    const node = (_a = (0, _utils.runIfFn)(env)) != null ? _a : document;
    if (!handler) {
      return;
    }
    node.addEventListener(event, listener, options);
    return () => {
      node.removeEventListener(event, listener, options);
    };
  }, [event, env, options, listener, handler]);
  return () => {
    var _a;
    const node = (_a = (0, _utils.runIfFn)(env)) != null ? _a : document;
    node.removeEventListener(event, listener, options);
  };
}
},{"./chunk-TFWETJDV.mjs":"T1GQ","@chakra-ui/utils":"Yp4B","react":"n8MK"}],"NJmJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMouseDownRef = useMouseDownRef;
var _chunk34PRFZWK = require("./chunk-34PRFZWK.mjs");
var _react = require("react");
// src/use-mouse-down-ref.ts

function useMouseDownRef(shouldListen = true) {
  const mouseDownRef = (0, _react.useRef)();
  (0, _chunk34PRFZWK.useEventListener)("mousedown", event => {
    if (shouldListen) {
      mouseDownRef.current = event.target;
    }
  });
  return mouseDownRef;
}
},{"./chunk-34PRFZWK.mjs":"WMB0","react":"n8MK"}],"WNcG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useOutsideClick = useOutsideClick;
var _chunkTFWETJDV = require("./chunk-TFWETJDV.mjs");
var _utils = require("@chakra-ui/utils");
var _react = require("react");
// src/use-outside-click.ts

function useOutsideClick(props) {
  const {
    ref,
    handler,
    enabled = true
  } = props;
  const savedHandler = (0, _chunkTFWETJDV.useCallbackRef)(handler);
  const stateRef = (0, _react.useRef)({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  const state = stateRef.current;
  (0, _react.useEffect)(() => {
    if (!enabled) return;
    const onPointerDown = e => {
      if (isValidEvent(e, ref)) {
        state.isPointerDown = true;
      }
    };
    const onMouseUp = event => {
      if (state.ignoreEmulatedMouseEvents) {
        state.ignoreEmulatedMouseEvents = false;
        return;
      }
      if (state.isPointerDown && handler && isValidEvent(event, ref)) {
        state.isPointerDown = false;
        savedHandler(event);
      }
    };
    const onTouchEnd = event => {
      state.ignoreEmulatedMouseEvents = true;
      if (handler && state.isPointerDown && isValidEvent(event, ref)) {
        state.isPointerDown = false;
        savedHandler(event);
      }
    };
    const doc = (0, _utils.getOwnerDocument)(ref.current);
    doc.addEventListener("mousedown", onPointerDown, true);
    doc.addEventListener("mouseup", onMouseUp, true);
    doc.addEventListener("touchstart", onPointerDown, true);
    doc.addEventListener("touchend", onTouchEnd, true);
    return () => {
      doc.removeEventListener("mousedown", onPointerDown, true);
      doc.removeEventListener("mouseup", onMouseUp, true);
      doc.removeEventListener("touchstart", onPointerDown, true);
      doc.removeEventListener("touchend", onTouchEnd, true);
    };
  }, [handler, ref, savedHandler, state, enabled]);
}
function isValidEvent(event, ref) {
  var _a;
  const target = event.target;
  if (event.button > 0) return false;
  if (target) {
    const doc = (0, _utils.getOwnerDocument)(target);
    if (!doc.contains(target)) return false;
  }
  return !((_a = ref.current) == null ? void 0 : _a.contains(target));
}
},{"./chunk-TFWETJDV.mjs":"T1GQ","@chakra-ui/utils":"Yp4B","react":"n8MK"}],"MLFa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePointerEvent = usePointerEvent;
var _chunk34PRFZWK = require("./chunk-34PRFZWK.mjs");
var _utils = require("@chakra-ui/utils");
// src/use-pointer-event.ts

function usePointerEvent(env, eventName, handler, options) {
  return (0, _chunk34PRFZWK.useEventListener)((0, _utils.getPointerEventName)(eventName), (0, _utils.wrapPointerEventHandler)(handler, eventName === "pointerdown"), env, options);
}
},{"./chunk-34PRFZWK.mjs":"WMB0","@chakra-ui/utils":"Yp4B"}],"tHOX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useUnmountEffect = useUnmountEffect;
var _react = require("react");
// src/use-unmount-effect.ts

function useUnmountEffect(fn, deps = []) {
  return (0, _react.useEffect)(() => () => fn(), deps);
}
},{"react":"n8MK"}],"kpiM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePanGesture = usePanGesture;
var _chunkCF2OMLUG = require("./chunk-CF2OMLUG.mjs");
var _chunk3YZIECTS = require("./chunk-3YZIECTS.mjs");
var _utils = require("@chakra-ui/utils");
var _react = require("react");
// src/use-pan-gesture.ts

function usePanGesture(ref, props) {
  const {
    onPan,
    onPanStart,
    onPanEnd,
    onPanSessionStart,
    onPanSessionEnd,
    threshold
  } = props;
  const hasPanEvents = Boolean(onPan || onPanStart || onPanEnd || onPanSessionStart || onPanSessionEnd);
  const panSession = (0, _react.useRef)(null);
  const handlers = {
    onSessionStart: onPanSessionStart,
    onSessionEnd: onPanSessionEnd,
    onStart: onPanStart,
    onMove: onPan,
    onEnd(event, info) {
      panSession.current = null;
      onPanEnd == null ? void 0 : onPanEnd(event, info);
    }
  };
  (0, _react.useEffect)(() => {
    var _a;
    (_a = panSession.current) == null ? void 0 : _a.updateHandlers(handlers);
  });
  function onPointerDown(event) {
    panSession.current = new _utils.PanSession(event, handlers, threshold);
  }
  (0, _chunkCF2OMLUG.usePointerEvent)(() => ref.current, "pointerdown", hasPanEvents ? onPointerDown : _utils.noop);
  (0, _chunk3YZIECTS.useUnmountEffect)(() => {
    var _a;
    (_a = panSession.current) == null ? void 0 : _a.end();
    panSession.current = null;
  });
}
},{"./chunk-CF2OMLUG.mjs":"MLFa","./chunk-3YZIECTS.mjs":"tHOX","@chakra-ui/utils":"Yp4B","react":"n8MK"}],"q62c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useId = useId;
exports.useIds = useIds;
exports.useOptionalPart = useOptionalPart;
var _react = require("react");
// src/use-id.ts

function useId(idProp, prefix) {
  const id = (0, _react.useId)();
  return (0, _react.useMemo)(() => idProp || [prefix, id].filter(Boolean).join("-"), [idProp, prefix, id]);
}
function useIds(idProp, ...prefixes) {
  const id = useId(idProp);
  return (0, _react.useMemo)(() => {
    return prefixes.map(prefix => `${prefix}-${id}`);
  }, [id, prefixes]);
}
function useOptionalPart(partId) {
  const [id, setId] = (0, _react.useState)(null);
  const ref = (0, _react.useCallback)(node => {
    setId(node ? partId : null);
  }, [partId]);
  return {
    ref,
    id,
    isRendered: Boolean(id)
  };
}
},{"react":"n8MK"}],"MeUc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useControllableProp = useControllableProp;
exports.useControllableState = useControllableState;
var _chunkTFWETJDV = require("./chunk-TFWETJDV.mjs");
var _utils = require("@chakra-ui/utils");
var _react = require("react");
// src/use-controllable.ts

function useControllableProp(prop, state) {
  const isControlled = prop !== void 0;
  const value = isControlled && typeof prop !== "undefined" ? prop : state;
  return [isControlled, value];
}
function useControllableState(props) {
  const {
    value: valueProp,
    defaultValue,
    onChange,
    shouldUpdate = (prev, next) => prev !== next
  } = props;
  const onChangeProp = (0, _chunkTFWETJDV.useCallbackRef)(onChange);
  const shouldUpdateProp = (0, _chunkTFWETJDV.useCallbackRef)(shouldUpdate);
  const [valueState, setValue] = (0, _react.useState)(defaultValue);
  const isControlled = valueProp !== void 0;
  const value = isControlled ? valueProp : valueState;
  const updateValue = (0, _react.useCallback)(next => {
    const nextValue = (0, _utils.runIfFn)(next, value);
    if (!shouldUpdateProp(value, nextValue)) {
      return;
    }
    if (!isControlled) {
      setValue(nextValue);
    }
    onChangeProp(nextValue);
  }, [isControlled, onChangeProp, value, shouldUpdateProp]);
  return [value, updateValue];
}
},{"./chunk-TFWETJDV.mjs":"T1GQ","@chakra-ui/utils":"Yp4B","react":"n8MK"}],"NwU5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDisclosure = useDisclosure;
var _chunkEGV7XMQK = require("./chunk-EGV7XMQK.mjs");
var _chunkNUQE4USX = require("./chunk-NUQE4USX.mjs");
var _chunkTFWETJDV = require("./chunk-TFWETJDV.mjs");
var _utils = require("@chakra-ui/utils");
var _react = require("react");
// src/use-disclosure.ts

function useDisclosure(props = {}) {
  const {
    onClose: onCloseProp,
    onOpen: onOpenProp,
    isOpen: isOpenProp,
    id: idProp
  } = props;
  const onOpenPropCallbackRef = (0, _chunkTFWETJDV.useCallbackRef)(onOpenProp);
  const onClosePropCallbackRef = (0, _chunkTFWETJDV.useCallbackRef)(onCloseProp);
  const [isOpenState, setIsOpen] = (0, _react.useState)(props.defaultIsOpen || false);
  const [isControlled, isOpen] = (0, _chunkNUQE4USX.useControllableProp)(isOpenProp, isOpenState);
  const id = (0, _chunkEGV7XMQK.useId)(idProp, "disclosure");
  const onClose = (0, _react.useCallback)(() => {
    if (!isControlled) {
      setIsOpen(false);
    }
    onClosePropCallbackRef == null ? void 0 : onClosePropCallbackRef();
  }, [isControlled, onClosePropCallbackRef]);
  const onOpen = (0, _react.useCallback)(() => {
    if (!isControlled) {
      setIsOpen(true);
    }
    onOpenPropCallbackRef == null ? void 0 : onOpenPropCallbackRef();
  }, [isControlled, onOpenPropCallbackRef]);
  const onToggle = (0, _react.useCallback)(() => {
    const action = isOpen ? onClose : onOpen;
    action();
  }, [isOpen, onOpen, onClose]);
  return {
    isOpen: !!isOpen,
    onOpen,
    onClose,
    onToggle,
    isControlled,
    getButtonProps: (props2 = {}) => ({
      ...props2,
      "aria-expanded": isOpen,
      "aria-controls": id,
      onClick: (0, _utils.callAllHandlers)(props2.onClick, onToggle)
    }),
    getDisclosureProps: (props2 = {}) => ({
      ...props2,
      hidden: !isOpen,
      id
    })
  };
}
},{"./chunk-EGV7XMQK.mjs":"q62c","./chunk-NUQE4USX.mjs":"MeUc","./chunk-TFWETJDV.mjs":"T1GQ","@chakra-ui/utils":"Yp4B","react":"n8MK"}],"hYGh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEventListenerMap = useEventListenerMap;
var _utils = require("@chakra-ui/utils");
var _react = require("react");
// src/use-event-listener-map.ts

function useEventListenerMap() {
  const listeners = (0, _react.useRef)( /* @__PURE__ */new Map());
  const currentListeners = listeners.current;
  const add = (0, _react.useCallback)((el, type, listener, options) => {
    const pointerEventListener = (0, _utils.wrapPointerEventHandler)(listener, type === "pointerdown");
    listeners.current.set(listener, {
      __listener: pointerEventListener,
      type: (0, _utils.getPointerEventName)(type),
      el,
      options
    });
    el.addEventListener(type, pointerEventListener, options);
  }, []);
  const remove = (0, _react.useCallback)((el, type, listener, options) => {
    const {
      __listener: pointerEventListener
    } = listeners.current.get(listener);
    el.removeEventListener(type, pointerEventListener, options);
    listeners.current.delete(pointerEventListener);
  }, []);
  (0, _react.useEffect)(() => () => {
    currentListeners.forEach((value, key) => {
      remove(value.el, value.type, key, value.options);
    });
  }, [remove, currentListeners]);
  return {
    add,
    remove
  };
}
},{"@chakra-ui/utils":"Yp4B","react":"n8MK"}],"JI89":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useUpdateEffect = void 0;
var _react = require("react");
// src/use-update-effect.ts

var useUpdateEffect = (effect, deps) => {
  const renderCycleRef = (0, _react.useRef)(false);
  const effectCycleRef = (0, _react.useRef)(false);
  (0, _react.useEffect)(() => {
    const isMounted = renderCycleRef.current;
    const shouldRun = isMounted && effectCycleRef.current;
    if (shouldRun) {
      return effect();
    }
    effectCycleRef.current = true;
  }, deps);
  (0, _react.useEffect)(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
};
exports.useUpdateEffect = useUpdateEffect;
},{"react":"n8MK"}],"NdsJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFocusEffect = useFocusEffect;
var _chunk5AOLTBA = require("./chunk-5AOLTBA4.mjs");
var _utils = require("@chakra-ui/utils");
// src/use-focus-effect.ts

function useFocusEffect(ref, options) {
  const {
    shouldFocus,
    preventScroll
  } = options;
  (0, _chunk5AOLTBA.useUpdateEffect)(() => {
    const node = ref.current;
    if (!node || !shouldFocus) return;
    if (!(0, _utils.hasFocusWithin)(node)) {
      (0, _utils.focus)(node, {
        preventScroll,
        nextTick: true
      });
    }
  }, [shouldFocus, ref, preventScroll]);
}
},{"./chunk-5AOLTBA4.mjs":"JI89","@chakra-ui/utils":"Yp4B"}],"ckeP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFocusOnHide = useFocusOnHide;
var _chunk5AOLTBA = require("./chunk-5AOLTBA4.mjs");
var _utils = require("@chakra-ui/utils");
// src/use-focus-on-hide.ts

function preventReturnFocus(containerRef) {
  const el = containerRef.current;
  if (!el) return false;
  const activeElement = (0, _utils.getActiveElement)(el);
  if (!activeElement) return false;
  if ((0, _utils.contains)(el, activeElement)) return false;
  if ((0, _utils.isTabbable)(activeElement)) return true;
  return false;
}
function useFocusOnHide(containerRef, options) {
  const {
    shouldFocus: shouldFocusProp,
    visible,
    focusRef
  } = options;
  const shouldFocus = shouldFocusProp && !visible;
  (0, _chunk5AOLTBA.useUpdateEffect)(() => {
    if (!shouldFocus) return;
    if (preventReturnFocus(containerRef)) {
      return;
    }
    const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;
    if (el) {
      (0, _utils.focus)(el, {
        nextTick: true
      });
    }
  }, [shouldFocus, containerRef, focusRef]);
}
},{"./chunk-5AOLTBA4.mjs":"JI89","@chakra-ui/utils":"Yp4B"}],"S1oE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFocusOnPointerDown = useFocusOnPointerDown;
var _chunkCF2OMLUG = require("./chunk-CF2OMLUG.mjs");
var _utils = require("@chakra-ui/utils");
// src/use-focus-on-pointerdown.ts

function useFocusOnPointerDown(props) {
  const {
    ref,
    elements,
    enabled
  } = props;
  const isSafari = (0, _utils.detectBrowser)("Safari");
  const doc = () => (0, _utils.getOwnerDocument)(ref.current);
  (0, _chunkCF2OMLUG.usePointerEvent)(doc, "pointerdown", event => {
    if (!isSafari || !enabled) return;
    const target = event.target;
    const els = elements != null ? elements : [ref];
    const isValidTarget = els.some(elementOrRef => {
      const el = (0, _utils.isRefObject)(elementOrRef) ? elementOrRef.current : elementOrRef;
      return (0, _utils.contains)(el, target);
    });
    if (!(0, _utils.isActiveElement)(target) && isValidTarget) {
      event.preventDefault();
      (0, _utils.focus)(target);
    }
  });
}
},{"./chunk-CF2OMLUG.mjs":"MLFa","@chakra-ui/utils":"Yp4B"}],"nbP9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFocusOnShow = useFocusOnShow;
var _chunk5AOLTBA = require("./chunk-5AOLTBA4.mjs");
var _chunk34PRFZWK = require("./chunk-34PRFZWK.mjs");
var _chunkIYF65QR = require("./chunk-IYF65QR3.mjs");
var _utils = require("@chakra-ui/utils");
var _react = require("react");
// src/use-focus-on-show.ts

var defaultOptions = {
  preventScroll: true,
  shouldFocus: false
};
function useFocusOnShow(target, options = defaultOptions) {
  const {
    focusRef,
    preventScroll,
    shouldFocus,
    visible
  } = options;
  const element = (0, _utils.isRefObject)(target) ? target.current : target;
  const autoFocusValue = shouldFocus && visible;
  const autoFocusRef = (0, _react.useRef)(autoFocusValue);
  const lastVisibleRef = (0, _react.useRef)(visible);
  (0, _chunkIYF65QR.useSafeLayoutEffect)(() => {
    if (!lastVisibleRef.current && visible) {
      autoFocusRef.current = autoFocusValue;
    }
    lastVisibleRef.current = visible;
  }, [visible, autoFocusValue]);
  const onFocus = (0, _react.useCallback)(() => {
    if (!visible || !element || !autoFocusRef.current) return;
    autoFocusRef.current = false;
    if ((0, _utils.contains)(element, document.activeElement)) return;
    if (focusRef == null ? void 0 : focusRef.current) {
      (0, _utils.focus)(focusRef.current, {
        preventScroll,
        nextTick: true
      });
    } else {
      const tabbableEls = (0, _utils.getAllFocusable)(element);
      if (tabbableEls.length > 0) {
        (0, _utils.focus)(tabbableEls[0], {
          preventScroll,
          nextTick: true
        });
      }
    }
  }, [visible, preventScroll, element, focusRef]);
  (0, _chunk5AOLTBA.useUpdateEffect)(() => {
    onFocus();
  }, [onFocus]);
  (0, _chunk34PRFZWK.useEventListener)("transitionend", onFocus, element);
}
},{"./chunk-5AOLTBA4.mjs":"JI89","./chunk-34PRFZWK.mjs":"WMB0","./chunk-IYF65QR3.mjs":"JvpQ","@chakra-ui/utils":"Yp4B","react":"n8MK"}],"dPz6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useForceUpdate = useForceUpdate;
var _chunk3YZIECTS = require("./chunk-3YZIECTS.mjs");
var _react = require("react");
// src/use-force-update.ts

function useForceUpdate() {
  const unloadingRef = (0, _react.useRef)(false);
  const [count, setCount] = (0, _react.useState)(0);
  (0, _chunk3YZIECTS.useUnmountEffect)(() => {
    unloadingRef.current = true;
  });
  return (0, _react.useCallback)(() => {
    if (!unloadingRef.current) {
      setCount(count + 1);
    }
  }, [count]);
}
},{"./chunk-3YZIECTS.mjs":"tHOX","react":"n8MK"}],"sVoK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAnimationState = useAnimationState;
var _chunk34PRFZWK = require("./chunk-34PRFZWK.mjs");
var _utils = require("@chakra-ui/utils");
var _react = require("react");
// src/use-animation-state.ts

function useAnimationState(props) {
  const {
    isOpen,
    ref
  } = props;
  const [mounted, setMounted] = (0, _react.useState)(isOpen);
  const [once, setOnce] = (0, _react.useState)(false);
  (0, _react.useEffect)(() => {
    if (!once) {
      setMounted(isOpen);
      setOnce(true);
    }
  }, [isOpen, once, mounted]);
  (0, _chunk34PRFZWK.useEventListener)("animationend", () => {
    setMounted(isOpen);
  }, () => ref.current);
  const hidden = isOpen ? false : !mounted;
  return {
    present: !hidden,
    onComplete() {
      var _a;
      const win = (0, _utils.getOwnerWindow)(ref.current);
      const evt = new win.CustomEvent("animationend", {
        bubbles: true
      });
      (_a = ref.current) == null ? void 0 : _a.dispatchEvent(evt);
    }
  };
}
},{"./chunk-34PRFZWK.mjs":"WMB0","@chakra-ui/utils":"Yp4B","react":"n8MK"}],"Azot":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useBoolean = useBoolean;
var _react = require("react");
// src/use-boolean.ts

function useBoolean(initialState = false) {
  const [value, setValue] = (0, _react.useState)(initialState);
  const callbacks = (0, _react.useMemo)(() => ({
    on: () => setValue(true),
    off: () => setValue(false),
    toggle: () => setValue(prev => !prev)
  }), []);
  return [value, callbacks];
}
},{"react":"n8MK"}],"JUot":[function(require,module,exports) {

module.exports = function () {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function () {};
  }
  var active = document.activeElement;

  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }

  switch (active.tagName.toUpperCase()) { // .toUpperCase handles XHTML
    case 'INPUT':
    case 'TEXTAREA':
      active.blur();
      break;

    default:
      active = null;
      break;
  }

  selection.removeAllRanges();
  return function () {
    selection.type === 'Caret' &&
    selection.removeAllRanges();

    if (!selection.rangeCount) {
      ranges.forEach(function(range) {
        selection.addRange(range);
      });
    }

    active &&
    active.focus();
  };
};

},{}],"xbqV":[function(require,module,exports) {
"use strict";

var deselectCurrent = require("toggle-selection");

var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
}

var defaultMessage = "Copy to clipboard: #{key}, Enter";

function format(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}

function copy(text, options) {
  var debug,
    message,
    reselectPrevious,
    range,
    selection,
    mark,
    success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();

    range = document.createRange();
    selection = document.getSelection();

    mark = document.createElement("span");
    mark.textContent = text;
    // reset user styles for span element
    mark.style.all = "unset";
    // prevents scrolling to the end of the page
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    // used to preserve spaces and line breaks
    mark.style.whiteSpace = "pre";
    // do not inherit user-select (it may be `none`)
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e) {
      e.stopPropagation();
      if (options.format) {
        e.preventDefault();
        if (typeof e.clipboardData === "undefined") { // IE 11
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"]
          window.clipboardData.setData(format, text);
        } else { // all other browsers
          e.clipboardData.clearData();
          e.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e.preventDefault();
        options.onCopy(e.clipboardData);
      }
    });

    document.body.appendChild(mark);

    range.selectNodeContents(mark);
    selection.addRange(range);

    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err) {
      debug && console.error("unable to copy using clipboardData: ", err);
      debug && console.error("falling back to prompt");
      message = format("message" in options ? options.message : defaultMessage);
      window.prompt(message, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range);
      } else {
        selection.removeAllRanges();
      }
    }

    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }

  return success;
}

module.exports = copy;

},{"toggle-selection":"JUot"}],"BzB6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useClipboard = useClipboard;
var _react = require("react");
var _copyToClipboard = _interopRequireDefault(require("copy-to-clipboard"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// src/use-clipboard.ts

function useClipboard(initialValue, optionsOrTimeout = {}) {
  const [hasCopied, setHasCopied] = (0, _react.useState)(false);
  const [value, setValue] = (0, _react.useState)(initialValue);
  const {
    timeout = 1500,
    ...copyOptions
  } = typeof optionsOrTimeout === "number" ? {
    timeout: optionsOrTimeout
  } : optionsOrTimeout;
  const onCopy = (0, _react.useCallback)(() => {
    const didCopy = (0, _copyToClipboard.default)(value, copyOptions);
    setHasCopied(didCopy);
  }, [value, copyOptions]);
  (0, _react.useEffect)(() => {
    let timeoutId = null;
    if (hasCopied) {
      timeoutId = window.setTimeout(() => {
        setHasCopied(false);
      }, timeout);
    }
    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [timeout, hasCopied]);
  return {
    value,
    setValue,
    onCopy,
    hasCopied
  };
}
},{"react":"n8MK","copy-to-clipboard":"xbqV"}],"cfgT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useConst = useConst;
var _react = require("react");
// src/use-const.ts

function useConst(init) {
  const ref = (0, _react.useRef)(null);
  if (ref.current === null) {
    ref.current = typeof init === "function" ? init() : init;
  }
  return ref.current;
}
},{"react":"n8MK"}],"uQ3u":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDimensions = useDimensions;
var _chunkIYF65QR = require("./chunk-IYF65QR3.mjs");
var _utils = require("@chakra-ui/utils");
var _react = require("react");
// src/use-dimensions.ts

function useDimensions(ref, observe) {
  const [dimensions, setDimensions] = (0, _react.useState)(null);
  const rafId = (0, _react.useRef)();
  (0, _chunkIYF65QR.useSafeLayoutEffect)(() => {
    if (!ref.current) return void 0;
    const node = ref.current;
    function measure() {
      rafId.current = requestAnimationFrame(() => {
        const boxModel = (0, _utils.getBox)(node);
        setDimensions(boxModel);
      });
    }
    measure();
    if (observe) {
      window.addEventListener("resize", measure);
      window.addEventListener("scroll", measure);
    }
    return () => {
      if (observe) {
        window.removeEventListener("resize", measure);
        window.removeEventListener("scroll", measure);
      }
      if (rafId.current) {
        cancelAnimationFrame(rafId.current);
      }
    };
  }, [observe]);
  return dimensions;
}
},{"./chunk-IYF65QR3.mjs":"JvpQ","@chakra-ui/utils":"Yp4B","react":"n8MK"}],"UytI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assignRef", {
  enumerable: true,
  get: function () {
    return _chunkQJA5SDDN.assignRef;
  }
});
Object.defineProperty(exports, "useAnimationState", {
  enumerable: true,
  get: function () {
    return _chunkF6ZRLFYH.useAnimationState;
  }
});
Object.defineProperty(exports, "useBoolean", {
  enumerable: true,
  get: function () {
    return _chunk4EVXJTLA.useBoolean;
  }
});
Object.defineProperty(exports, "useCallbackRef", {
  enumerable: true,
  get: function () {
    return _chunkTFWETJDV.useCallbackRef;
  }
});
Object.defineProperty(exports, "useClipboard", {
  enumerable: true,
  get: function () {
    return _chunkILZWKQXY.useClipboard;
  }
});
Object.defineProperty(exports, "useConst", {
  enumerable: true,
  get: function () {
    return _chunkY4UXA3TD.useConst;
  }
});
Object.defineProperty(exports, "useControllableProp", {
  enumerable: true,
  get: function () {
    return _chunkNUQE4USX.useControllableProp;
  }
});
Object.defineProperty(exports, "useControllableState", {
  enumerable: true,
  get: function () {
    return _chunkNUQE4USX.useControllableState;
  }
});
Object.defineProperty(exports, "useDimensions", {
  enumerable: true,
  get: function () {
    return _chunk4EHPOZP.useDimensions;
  }
});
Object.defineProperty(exports, "useDisclosure", {
  enumerable: true,
  get: function () {
    return _chunkCHB4ZXZG.useDisclosure;
  }
});
Object.defineProperty(exports, "useEventListener", {
  enumerable: true,
  get: function () {
    return _chunk34PRFZWK.useEventListener;
  }
});
Object.defineProperty(exports, "useEventListenerMap", {
  enumerable: true,
  get: function () {
    return _chunk6QJ3DAN.useEventListenerMap;
  }
});
Object.defineProperty(exports, "useFocusEffect", {
  enumerable: true,
  get: function () {
    return _chunkMQIGJ23T.useFocusEffect;
  }
});
Object.defineProperty(exports, "useFocusOnHide", {
  enumerable: true,
  get: function () {
    return _chunkH54GS5SN.useFocusOnHide;
  }
});
Object.defineProperty(exports, "useFocusOnPointerDown", {
  enumerable: true,
  get: function () {
    return _chunk4DMQJ6FO.useFocusOnPointerDown;
  }
});
Object.defineProperty(exports, "useFocusOnShow", {
  enumerable: true,
  get: function () {
    return _chunkS5MINBBA.useFocusOnShow;
  }
});
Object.defineProperty(exports, "useForceUpdate", {
  enumerable: true,
  get: function () {
    return _chunkXB3WN4FS.useForceUpdate;
  }
});
Object.defineProperty(exports, "useId", {
  enumerable: true,
  get: function () {
    return _chunkEGV7XMQK.useId;
  }
});
Object.defineProperty(exports, "useIds", {
  enumerable: true,
  get: function () {
    return _chunkEGV7XMQK.useIds;
  }
});
Object.defineProperty(exports, "useInterval", {
  enumerable: true,
  get: function () {
    return _chunkVHPIVGMD.useInterval;
  }
});
Object.defineProperty(exports, "useLatestRef", {
  enumerable: true,
  get: function () {
    return _chunkR6ZZD2KB.useLatestRef;
  }
});
Object.defineProperty(exports, "useMergeRefs", {
  enumerable: true,
  get: function () {
    return _chunkQJA5SDDN.useMergeRefs;
  }
});
Object.defineProperty(exports, "useMouseDownRef", {
  enumerable: true,
  get: function () {
    return _chunk5DGH2NZZ.useMouseDownRef;
  }
});
Object.defineProperty(exports, "useOptionalPart", {
  enumerable: true,
  get: function () {
    return _chunkEGV7XMQK.useOptionalPart;
  }
});
Object.defineProperty(exports, "useOutsideClick", {
  enumerable: true,
  get: function () {
    return _chunkHIFPCJML.useOutsideClick;
  }
});
Object.defineProperty(exports, "usePanGesture", {
  enumerable: true,
  get: function () {
    return _chunkOQ6S7YI.usePanGesture;
  }
});
Object.defineProperty(exports, "usePointerEvent", {
  enumerable: true,
  get: function () {
    return _chunkCF2OMLUG.usePointerEvent;
  }
});
Object.defineProperty(exports, "usePrevious", {
  enumerable: true,
  get: function () {
    return _chunkR4O7V45P.usePrevious;
  }
});
Object.defineProperty(exports, "useSafeLayoutEffect", {
  enumerable: true,
  get: function () {
    return _chunkIYF65QR.useSafeLayoutEffect;
  }
});
Object.defineProperty(exports, "useShortcut", {
  enumerable: true,
  get: function () {
    return _chunkCLDV4JKZ.useShortcut;
  }
});
Object.defineProperty(exports, "useTimeout", {
  enumerable: true,
  get: function () {
    return _chunk7LXDCNGU.useTimeout;
  }
});
Object.defineProperty(exports, "useUnmountEffect", {
  enumerable: true,
  get: function () {
    return _chunk3YZIECTS.useUnmountEffect;
  }
});
Object.defineProperty(exports, "useUpdateEffect", {
  enumerable: true,
  get: function () {
    return _chunk5AOLTBA.useUpdateEffect;
  }
});
Object.defineProperty(exports, "useWhyDidYouUpdate", {
  enumerable: true,
  get: function () {
    return _chunkR3AU57R.useWhyDidYouUpdate;
  }
});
var _chunkR4O7V45P = require("./chunk-R4O7V45P.mjs");
var _chunkCLDV4JKZ = require("./chunk-CLDV4JKZ.mjs");
var _chunk7LXDCNGU = require("./chunk-7LXDCNGU.mjs");
var _chunkR3AU57R = require("./chunk-R3AU57R3.mjs");
var _chunkVHPIVGMD = require("./chunk-VHPIVGMD.mjs");
var _chunkR6ZZD2KB = require("./chunk-R6ZZD2KB.mjs");
var _chunkQJA5SDDN = require("./chunk-QJA5SDDN.mjs");
var _chunk5DGH2NZZ = require("./chunk-5DGH2NZZ.mjs");
var _chunkHIFPCJML = require("./chunk-HIFPCJML.mjs");
var _chunkOQ6S7YI = require("./chunk-OQ6S7YI3.mjs");
var _chunkCHB4ZXZG = require("./chunk-CHB4ZXZG.mjs");
var _chunkEGV7XMQK = require("./chunk-EGV7XMQK.mjs");
var _chunk6QJ3DAN = require("./chunk-6QJ3DAN2.mjs");
var _chunkMQIGJ23T = require("./chunk-MQIGJ23T.mjs");
var _chunkH54GS5SN = require("./chunk-H54GS5SN.mjs");
var _chunk4DMQJ6FO = require("./chunk-4DMQJ6FO.mjs");
var _chunkCF2OMLUG = require("./chunk-CF2OMLUG.mjs");
var _chunkS5MINBBA = require("./chunk-S5MINBBA.mjs");
var _chunk5AOLTBA = require("./chunk-5AOLTBA4.mjs");
var _chunkXB3WN4FS = require("./chunk-XB3WN4FS.mjs");
var _chunk3YZIECTS = require("./chunk-3YZIECTS.mjs");
var _chunkF6ZRLFYH = require("./chunk-F6ZRLFYH.mjs");
var _chunk34PRFZWK = require("./chunk-34PRFZWK.mjs");
var _chunk4EVXJTLA = require("./chunk-4EVXJTLA.mjs");
var _chunkILZWKQXY = require("./chunk-ILZWKQXY.mjs");
var _chunkY4UXA3TD = require("./chunk-Y4UXA3TD.mjs");
var _chunkNUQE4USX = require("./chunk-NUQE4USX.mjs");
var _chunkTFWETJDV = require("./chunk-TFWETJDV.mjs");
var _chunk4EHPOZP = require("./chunk-4EHPOZP5.mjs");
var _chunkIYF65QR = require("./chunk-IYF65QR3.mjs");
},{"./chunk-R4O7V45P.mjs":"JMEI","./chunk-CLDV4JKZ.mjs":"PFE7","./chunk-7LXDCNGU.mjs":"pjvQ","./chunk-R3AU57R3.mjs":"EFuI","./chunk-VHPIVGMD.mjs":"CZ1e","./chunk-R6ZZD2KB.mjs":"ZJ2M","./chunk-QJA5SDDN.mjs":"hji3","./chunk-5DGH2NZZ.mjs":"NJmJ","./chunk-HIFPCJML.mjs":"WNcG","./chunk-OQ6S7YI3.mjs":"kpiM","./chunk-CHB4ZXZG.mjs":"NwU5","./chunk-EGV7XMQK.mjs":"q62c","./chunk-6QJ3DAN2.mjs":"hYGh","./chunk-MQIGJ23T.mjs":"NdsJ","./chunk-H54GS5SN.mjs":"ckeP","./chunk-4DMQJ6FO.mjs":"S1oE","./chunk-CF2OMLUG.mjs":"MLFa","./chunk-S5MINBBA.mjs":"nbP9","./chunk-5AOLTBA4.mjs":"JI89","./chunk-XB3WN4FS.mjs":"dPz6","./chunk-3YZIECTS.mjs":"tHOX","./chunk-F6ZRLFYH.mjs":"sVoK","./chunk-34PRFZWK.mjs":"WMB0","./chunk-4EVXJTLA.mjs":"Azot","./chunk-ILZWKQXY.mjs":"BzB6","./chunk-Y4UXA3TD.mjs":"cfgT","./chunk-NUQE4USX.mjs":"MeUc","./chunk-TFWETJDV.mjs":"T1GQ","./chunk-4EHPOZP5.mjs":"uQ3u","./chunk-IYF65QR3.mjs":"JvpQ"}],"vt0q":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compact = compact;
exports.omit = omit;
exports.pick = pick;
exports.split = split;
// src/index.ts
function compact(object) {
  const clone = Object.assign({}, object);
  for (let key in clone) {
    if (clone[key] === void 0) delete clone[key];
  }
  return clone;
}
function omit(object, keysToOmit = []) {
  const clone = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone) delete clone[key];
  }
  return clone;
}
function pick(object, keysToPick) {
  const result = {};
  for (const key of keysToPick) {
    if (key in object) {
      result[key] = object[key];
    }
  }
  return result;
}
function split(object, keys) {
  const picked = {};
  const omitted = {};
  for (const [key, value] of Object.entries(object)) {
    if (keys.includes(key)) picked[key] = value;else omitted[key] = value;
  }
  return [picked, omitted];
}
},{}],"lVgj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInputGroupStyles = exports.InputGroup = void 0;
var _reactContext = require("@chakra-ui/react-context");
var _reactChildrenUtils = require("@chakra-ui/react-children-utils");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _objectUtils = require("@chakra-ui/object-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/input-group.tsx

var [InputGroupStylesProvider, useInputGroupStyles] = (0, _reactContext.createContext)({
  name: `InputGroupStylesContext`,
  errorMessage: `useInputGroupStyles returned is 'undefined'. Seems you forgot to wrap the components in "<InputGroup />" `
});
exports.useInputGroupStyles = useInputGroupStyles;
var InputGroup = (0, _system.forwardRef)(function InputGroup2(props, ref) {
  const styles = (0, _system.useMultiStyleConfig)("Input", props);
  const {
    children,
    className,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const _className = (0, _sharedUtils.cx)("chakra-input__group", className);
  const groupStyles = {};
  const validChildren = (0, _reactChildrenUtils.getValidChildren)(children);
  const input = styles.field;
  validChildren.forEach(child => {
    var _a, _b;
    if (!styles) return;
    if (input && child.type.id === "InputLeftElement") {
      groupStyles.paddingStart = (_a = input.height) != null ? _a : input.h;
    }
    if (input && child.type.id === "InputRightElement") {
      groupStyles.paddingEnd = (_b = input.height) != null ? _b : input.h;
    }
    if (child.type.id === "InputRightAddon") {
      groupStyles.borderEndRadius = 0;
    }
    if (child.type.id === "InputLeftAddon") {
      groupStyles.borderStartRadius = 0;
    }
  });
  const clones = validChildren.map(child => {
    var _a, _b;
    const theming = (0, _objectUtils.compact)({
      size: ((_a = child.props) == null ? void 0 : _a.size) || props.size,
      variant: ((_b = child.props) == null ? void 0 : _b.variant) || props.variant
    });
    return child.type.id !== "Input" ? (0, _react.cloneElement)(child, theming) : (0, _react.cloneElement)(child, Object.assign(theming, groupStyles, child.props));
  });
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    className: _className,
    ref,
    __css: {
      width: "100%",
      display: "flex",
      position: "relative"
    },
    ...rest,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(InputGroupStylesProvider, {
      value: styles,
      children: clones
    })
  });
});
exports.InputGroup = InputGroup;
InputGroup.displayName = "InputGroup";
},{"@chakra-ui/react-context":"lT23","@chakra-ui/react-children-utils":"PLf5","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","@chakra-ui/object-utils":"vt0q","react":"n8MK","react/jsx-runtime":"plwR"}],"p16s":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputRightAddon = exports.InputLeftAddon = exports.InputAddon = void 0;
var _chunkROYHMHZX = require("./chunk-ROYHMHZX.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/input-addon.tsx

var placements = {
  left: {
    marginEnd: "-1px",
    borderEndRadius: 0,
    borderEndColor: "transparent"
  },
  right: {
    marginStart: "-1px",
    borderStartRadius: 0,
    borderStartColor: "transparent"
  }
};
var StyledAddon = (0, _system.chakra)("div", {
  baseStyle: {
    flex: "0 0 auto",
    width: "auto",
    display: "flex",
    alignItems: "center",
    whiteSpace: "nowrap"
  }
});
var InputAddon = (0, _system.forwardRef)(function InputAddon2(props, ref) {
  var _a;
  const {
    placement = "left",
    ...rest
  } = props;
  const placementStyles = (_a = placements[placement]) != null ? _a : {};
  const styles = (0, _chunkROYHMHZX.useInputGroupStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(StyledAddon, {
    ref,
    ...rest,
    __css: {
      ...styles.addon,
      ...placementStyles
    }
  });
});
exports.InputAddon = InputAddon;
InputAddon.displayName = "InputAddon";
var InputLeftAddon = (0, _system.forwardRef)(function InputLeftAddon2(props, ref) {
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(InputAddon, {
    ref,
    placement: "left",
    ...props,
    className: (0, _sharedUtils.cx)("chakra-input__left-addon", props.className)
  });
});
exports.InputLeftAddon = InputLeftAddon;
InputLeftAddon.displayName = "InputLeftAddon";
InputLeftAddon.id = "InputLeftAddon";
var InputRightAddon = (0, _system.forwardRef)(function InputRightAddon2(props, ref) {
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(InputAddon, {
    ref,
    placement: "right",
    ...props,
    className: (0, _sharedUtils.cx)("chakra-input__right-addon", props.className)
  });
});
exports.InputRightAddon = InputRightAddon;
InputRightAddon.displayName = "InputRightAddon";
InputRightAddon.id = "InputRightAddon";
},{"./chunk-ROYHMHZX.mjs":"lVgj","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"VVLD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputRightElement = exports.InputLeftElement = void 0;
var _chunkROYHMHZX = require("./chunk-ROYHMHZX.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/input-element.tsx

var StyledInputElement = (0, _system.chakra)("div", {
  baseStyle: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    top: "0",
    zIndex: 2
  }
});
var InputElement = (0, _system.forwardRef)(function InputElement2(props, ref) {
  var _a, _b;
  const {
    placement = "left",
    ...rest
  } = props;
  const styles = (0, _chunkROYHMHZX.useInputGroupStyles)();
  const input = styles.field;
  const attr = placement === "left" ? "insetStart" : "insetEnd";
  const elementStyles = {
    [attr]: "0",
    width: (_a = input == null ? void 0 : input.height) != null ? _a : input == null ? void 0 : input.h,
    height: (_b = input == null ? void 0 : input.height) != null ? _b : input == null ? void 0 : input.h,
    fontSize: input == null ? void 0 : input.fontSize,
    ...styles.element
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(StyledInputElement, {
    ref,
    __css: elementStyles,
    ...rest
  });
});
InputElement.id = "InputElement";
InputElement.displayName = "InputElement";
var InputLeftElement = (0, _system.forwardRef)(function InputLeftElement2(props, ref) {
  const {
    className,
    ...rest
  } = props;
  const _className = (0, _sharedUtils.cx)("chakra-input__left-element", className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(InputElement, {
    ref,
    placement: "left",
    className: _className,
    ...rest
  });
});
exports.InputLeftElement = InputLeftElement;
InputLeftElement.id = "InputLeftElement";
InputLeftElement.displayName = "InputLeftElement";
var InputRightElement = (0, _system.forwardRef)(function InputRightElement2(props, ref) {
  const {
    className,
    ...rest
  } = props;
  const _className = (0, _sharedUtils.cx)("chakra-input__right-element", className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(InputElement, {
    ref,
    placement: "right",
    className: _className,
    ...rest
  });
});
exports.InputRightElement = InputRightElement;
InputRightElement.id = "InputRightElement";
InputRightElement.displayName = "InputRightElement";
},{"./chunk-ROYHMHZX.mjs":"lVgj","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"PgBt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Input = void 0;
var _formControl = require("@chakra-ui/form-control");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/input.tsx

var Input = (0, _system.forwardRef)(function Input2(props, ref) {
  const {
    htmlSize,
    ...rest
  } = props;
  const styles = (0, _system.useMultiStyleConfig)("Input", rest);
  const ownProps = (0, _system.omitThemingProps)(rest);
  const input = (0, _formControl.useFormControl)(ownProps);
  const _className = (0, _sharedUtils.cx)("chakra-input", props.className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.input, {
    size: htmlSize,
    ...input,
    __css: styles.field,
    ref,
    className: _className
  });
});
exports.Input = Input;
Input.displayName = "Input";
Input.id = "Input";
},{"@chakra-ui/form-control":"fjMD","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"K9fq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Input", {
  enumerable: true,
  get: function () {
    return _chunkGYFRIY2Z.Input;
  }
});
Object.defineProperty(exports, "InputAddon", {
  enumerable: true,
  get: function () {
    return _chunkELVH7PA.InputAddon;
  }
});
Object.defineProperty(exports, "InputGroup", {
  enumerable: true,
  get: function () {
    return _chunkROYHMHZX.InputGroup;
  }
});
Object.defineProperty(exports, "InputLeftAddon", {
  enumerable: true,
  get: function () {
    return _chunkELVH7PA.InputLeftAddon;
  }
});
Object.defineProperty(exports, "InputLeftElement", {
  enumerable: true,
  get: function () {
    return _chunkMSKRUQCS.InputLeftElement;
  }
});
Object.defineProperty(exports, "InputRightAddon", {
  enumerable: true,
  get: function () {
    return _chunkELVH7PA.InputRightAddon;
  }
});
Object.defineProperty(exports, "InputRightElement", {
  enumerable: true,
  get: function () {
    return _chunkMSKRUQCS.InputRightElement;
  }
});
Object.defineProperty(exports, "useInputGroupStyles", {
  enumerable: true,
  get: function () {
    return _chunkROYHMHZX.useInputGroupStyles;
  }
});
var _chunkELVH7PA = require("./chunk-ELVH7PA7.mjs");
var _chunkMSKRUQCS = require("./chunk-MSKRUQCS.mjs");
var _chunkROYHMHZX = require("./chunk-ROYHMHZX.mjs");
var _chunkGYFRIY2Z = require("./chunk-GYFRIY2Z.mjs");
},{"./chunk-ELVH7PA7.mjs":"p16s","./chunk-MSKRUQCS.mjs":"VVLD","./chunk-ROYHMHZX.mjs":"lVgj","./chunk-GYFRIY2Z.mjs":"PgBt"}],"vs63":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useListStyles = exports.UnorderedList = exports.OrderedList = exports.ListItem = exports.ListIcon = exports.List = void 0;
var _icon = require("@chakra-ui/icon");
var _reactContext = require("@chakra-ui/react-context");
var _reactChildrenUtils = require("@chakra-ui/react-children-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/list.tsx

var [ListStylesProvider, useListStyles] = (0, _reactContext.createContext)({
  name: `ListStylesContext`,
  errorMessage: `useListStyles returned is 'undefined'. Seems you forgot to wrap the components in "<List />" `
});
exports.useListStyles = useListStyles;
var List = (0, _system.forwardRef)(function List2(props, ref) {
  const styles = (0, _system.useMultiStyleConfig)("List", props);
  const {
    children,
    styleType = "none",
    stylePosition,
    spacing,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const validChildren = (0, _reactChildrenUtils.getValidChildren)(children);
  const selector = "& > *:not(style) ~ *:not(style)";
  const spacingStyle = spacing ? {
    [selector]: {
      mt: spacing
    }
  } : {};
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(ListStylesProvider, {
    value: styles,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.ul, {
      ref,
      listStyleType: styleType,
      listStylePosition: stylePosition,
      role: "list",
      __css: {
        ...styles.container,
        ...spacingStyle
      },
      ...rest,
      children: validChildren
    })
  });
});
exports.List = List;
List.displayName = "List";
var OrderedList = (0, _system.forwardRef)((props, ref) => {
  const {
    as,
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(List, {
    ref,
    as: "ol",
    styleType: "decimal",
    marginStart: "1em",
    ...rest
  });
});
exports.OrderedList = OrderedList;
OrderedList.displayName = "OrderedList";
var UnorderedList = (0, _system.forwardRef)(function UnorderedList2(props, ref) {
  const {
    as,
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(List, {
    ref,
    as: "ul",
    styleType: "initial",
    marginStart: "1em",
    ...rest
  });
});
exports.UnorderedList = UnorderedList;
UnorderedList.displayName = "UnorderedList";
var ListItem = (0, _system.forwardRef)(function ListItem2(props, ref) {
  const styles = useListStyles();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.li, {
    ref,
    ...props,
    __css: styles.item
  });
});
exports.ListItem = ListItem;
ListItem.displayName = "ListItem";
var ListIcon = (0, _system.forwardRef)(function ListIcon2(props, ref) {
  const styles = useListStyles();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
    ref,
    role: "presentation",
    ...props,
    __css: styles.icon
  });
});
exports.ListIcon = ListIcon;
ListIcon.displayName = "ListIcon";
},{"@chakra-ui/icon":"aPuf","@chakra-ui/react-context":"lT23","@chakra-ui/react-children-utils":"PLf5","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"l2k1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Grid = void 0;
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/grid.tsx

var Grid = (0, _system.forwardRef)(function Grid2(props, ref) {
  const {
    templateAreas,
    gap,
    rowGap,
    columnGap,
    column,
    row,
    autoFlow,
    autoRows,
    templateRows,
    autoColumns,
    templateColumns,
    ...rest
  } = props;
  const styles = {
    display: "grid",
    gridTemplateAreas: templateAreas,
    gridGap: gap,
    gridRowGap: rowGap,
    gridColumnGap: columnGap,
    gridAutoColumns: autoColumns,
    gridColumn: column,
    gridRow: row,
    gridAutoFlow: autoFlow,
    gridAutoRows: autoRows,
    gridTemplateRows: templateRows,
    gridTemplateColumns: templateColumns
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    __css: styles,
    ...rest
  });
});
exports.Grid = Grid;
Grid.displayName = "Grid";
},{"@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"sirC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.analyzeBreakpoints = analyzeBreakpoints;
exports.px = px;
exports.toMediaQueryString = toMediaQueryString;
var _sharedUtils = require("@chakra-ui/shared-utils");
// src/breakpoint.ts

function getLastItem(array) {
  const length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
function analyzeCSSValue(value) {
  const num = parseFloat(value.toString());
  const unit = value.toString().replace(String(num), "");
  return {
    unitless: !unit,
    value: num,
    unit
  };
}
function px(value) {
  if (value == null) return value;
  const {
    unitless
  } = analyzeCSSValue(value);
  return unitless || typeof value === "number" ? `${value}px` : value;
}
var sortByBreakpointValue = (a, b) => parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;
var sortBps = breakpoints => Object.fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue));
function normalize(breakpoints) {
  const sorted = sortBps(breakpoints);
  return Object.assign(Object.values(sorted), sorted);
}
function keys(breakpoints) {
  const value = Object.keys(sortBps(breakpoints));
  return new Set(value);
}
var OFFSET = 0.02;
function subtract(value) {
  var _a;
  if (!value) return value;
  value = (_a = px(value)) != null ? _a : value;
  const factor = value.endsWith("px") ? -OFFSET : -(OFFSET / 16);
  return typeof value === "number" ? `${value + factor}` : value.replace(/(\d+\.?\d*)/u, m => `${parseFloat(m) + factor}`);
}
function toMediaQueryString(min, max) {
  const query = ["@media screen"];
  if (min) query.push("and", `(min-width: ${px(min)})`);
  if (max) query.push("and", `(max-width: ${px(max)})`);
  return query.join(" ");
}
function analyzeBreakpoints(breakpoints) {
  var _a;
  if (!breakpoints) return null;
  breakpoints.base = (_a = breakpoints.base) != null ? _a : "0px";
  const normalized = normalize(breakpoints);
  const queries = Object.entries(breakpoints).sort(sortByBreakpointValue).map(([breakpoint, minW], index, entry) => {
    var _a2;
    let [, maxW] = (_a2 = entry[index + 1]) != null ? _a2 : [];
    maxW = parseFloat(maxW) > 0 ? subtract(maxW) : void 0;
    return {
      _minW: subtract(minW),
      breakpoint,
      minW,
      maxW,
      maxWQuery: toMediaQueryString(null, maxW),
      minWQuery: toMediaQueryString(minW),
      minMaxQuery: toMediaQueryString(minW, maxW)
    };
  });
  const _keys = keys(breakpoints);
  const _keysArr = Array.from(_keys.values());
  return {
    keys: _keys,
    normalized,
    isResponsive(test) {
      const keys2 = Object.keys(test);
      return keys2.length > 0 && keys2.every(key => _keys.has(key));
    },
    asObject: sortBps(breakpoints),
    asArray: normalize(breakpoints),
    details: queries,
    media: [null, ...normalized.map(minW => toMediaQueryString(minW)).slice(1)],
    toArrayValue(test) {
      if (!(0, _sharedUtils.isObject)(test)) {
        throw new Error("toArrayValue: value must be an object");
      }
      const result = _keysArr.map(bp => {
        var _a2;
        return (_a2 = test[bp]) != null ? _a2 : null;
      });
      while (getLastItem(result) === null) {
        result.pop();
      }
      return result;
    },
    toObjectValue(test) {
      if (!Array.isArray(test)) {
        throw new Error("toObjectValue: value must be an array");
      }
      return test.reduce((acc, value, index) => {
        const key = _keysArr[index];
        if (key != null && value != null) acc[key] = value;
        return acc;
      }, {});
    }
  };
}
},{"@chakra-ui/shared-utils":"gghr"}],"uG5G":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayToObjectNotation = arrayToObjectNotation;
exports.isCustomBreakpoint = exports.breakpoints = void 0;
exports.isResponsiveObjectLike = isResponsiveObjectLike;
exports.mapResponsive = mapResponsive;
exports.objectToArrayNotation = objectToArrayNotation;
var _sharedUtils = require("@chakra-ui/shared-utils");
// src/responsive.ts

var breakpoints = Object.freeze(["base", "sm", "md", "lg", "xl", "2xl"]);
exports.breakpoints = breakpoints;
function mapResponsive(prop, mapper) {
  if (Array.isArray(prop)) {
    return prop.map(item => item === null ? null : mapper(item));
  }
  if ((0, _sharedUtils.isObject)(prop)) {
    return Object.keys(prop).reduce((result, key) => {
      result[key] = mapper(prop[key]);
      return result;
    }, {});
  }
  if (prop != null) {
    return mapper(prop);
  }
  return null;
}
function objectToArrayNotation(obj, bps = breakpoints) {
  const result = bps.map(br => {
    var _a;
    return (_a = obj[br]) != null ? _a : null;
  });
  const lastItem = result[result.length - 1];
  while (lastItem === null) result.pop();
  return result;
}
function arrayToObjectNotation(values, bps = breakpoints) {
  const result = {};
  values.forEach((value, index) => {
    const key = bps[index];
    if (value == null) return;
    result[key] = value;
  });
  return result;
}
function isResponsiveObjectLike(obj, bps = breakpoints) {
  const keys = Object.keys(obj);
  return keys.length > 0 && keys.every(key => bps.includes(key));
}
var isCustomBreakpoint = v => Number.isNaN(Number(v));
exports.isCustomBreakpoint = isCustomBreakpoint;
},{"@chakra-ui/shared-utils":"gghr"}],"RIno":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "analyzeBreakpoints", {
  enumerable: true,
  get: function () {
    return _chunk4SQBRFVZ.analyzeBreakpoints;
  }
});
Object.defineProperty(exports, "arrayToObjectNotation", {
  enumerable: true,
  get: function () {
    return _chunkG72KV6MB.arrayToObjectNotation;
  }
});
Object.defineProperty(exports, "breakpoints", {
  enumerable: true,
  get: function () {
    return _chunkG72KV6MB.breakpoints;
  }
});
Object.defineProperty(exports, "isCustomBreakpoint", {
  enumerable: true,
  get: function () {
    return _chunkG72KV6MB.isCustomBreakpoint;
  }
});
Object.defineProperty(exports, "isResponsiveObjectLike", {
  enumerable: true,
  get: function () {
    return _chunkG72KV6MB.isResponsiveObjectLike;
  }
});
Object.defineProperty(exports, "mapResponsive", {
  enumerable: true,
  get: function () {
    return _chunkG72KV6MB.mapResponsive;
  }
});
Object.defineProperty(exports, "objectToArrayNotation", {
  enumerable: true,
  get: function () {
    return _chunkG72KV6MB.objectToArrayNotation;
  }
});
Object.defineProperty(exports, "px", {
  enumerable: true,
  get: function () {
    return _chunk4SQBRFVZ.px;
  }
});
Object.defineProperty(exports, "toMediaQueryString", {
  enumerable: true,
  get: function () {
    return _chunk4SQBRFVZ.toMediaQueryString;
  }
});
var _chunk4SQBRFVZ = require("./chunk-4SQBRFVZ.mjs");
var _chunkG72KV6MB = require("./chunk-G72KV6MB.mjs");
},{"./chunk-4SQBRFVZ.mjs":"sirC","./chunk-G72KV6MB.mjs":"uG5G"}],"aCrm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SimpleGrid = void 0;
var _chunk5FO2ZLZM = require("./chunk-5FO2ZLZM.mjs");
var _system = require("@chakra-ui/system");
var _breakpointUtils = require("@chakra-ui/breakpoint-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/simple-grid.tsx

var SimpleGrid = (0, _system.forwardRef)(function SimpleGrid2(props, ref) {
  const {
    columns,
    spacingX,
    spacingY,
    spacing,
    minChildWidth,
    ...rest
  } = props;
  const theme = (0, _system.useTheme)();
  const templateColumns = minChildWidth ? widthToColumns(minChildWidth, theme) : countToColumns(columns);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk5FO2ZLZM.Grid, {
    ref,
    gap: spacing,
    columnGap: spacingX,
    rowGap: spacingY,
    templateColumns,
    ...rest
  });
});
exports.SimpleGrid = SimpleGrid;
SimpleGrid.displayName = "SimpleGrid";
function toPx(n) {
  return typeof n === "number" ? `${n}px` : n;
}
function widthToColumns(width, theme) {
  return (0, _breakpointUtils.mapResponsive)(width, value => {
    const _value = (0, _system.getToken)("sizes", value, toPx(value))(theme);
    return value === null ? null : `repeat(auto-fit, minmax(${_value}, 1fr))`;
  });
}
function countToColumns(count) {
  return (0, _breakpointUtils.mapResponsive)(count, value => value === null ? null : `repeat(${value}, minmax(0, 1fr))`);
}
},{"./chunk-5FO2ZLZM.mjs":"l2k1","@chakra-ui/system":"ogbg","@chakra-ui/breakpoint-utils":"RIno","react/jsx-runtime":"plwR"}],"vSQ9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spacer = void 0;
var _system = require("@chakra-ui/system");
// src/spacer.tsx

var Spacer = (0, _system.chakra)("div", {
  baseStyle: {
    flex: 1,
    justifySelf: "stretch",
    alignSelf: "stretch"
  }
});
exports.Spacer = Spacer;
Spacer.displayName = "Spacer";
},{"@chakra-ui/system":"ogbg"}],"U3XN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Text = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _objectUtils = require("@chakra-ui/object-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/text.tsx

var Text = (0, _system.forwardRef)(function Text2(props, ref) {
  const styles = (0, _system.useStyleConfig)("Text", props);
  const {
    className,
    align,
    decoration,
    casing,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const aliasedProps = (0, _objectUtils.compact)({
    textAlign: props.align,
    textDecoration: props.decoration,
    textTransform: props.casing
  });
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.p, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-text", props.className),
    ...aliasedProps,
    ...rest,
    __css: styles
  });
});
exports.Text = Text;
Text.displayName = "Text";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","@chakra-ui/object-utils":"vt0q","react/jsx-runtime":"plwR"}],"heza":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WrapItem = exports.Wrap = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _breakpointUtils = require("@chakra-ui/breakpoint-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/wrap.tsx

function px(value) {
  return typeof value === "number" ? `${value}px` : value;
}
var Wrap = (0, _system.forwardRef)(function Wrap2(props, ref) {
  const {
    spacing = "0.5rem",
    spacingX,
    spacingY,
    children,
    justify,
    direction,
    align,
    className,
    shouldWrapChildren,
    ...rest
  } = props;
  const styles = (0, _react.useMemo)(() => {
    const {
      spacingX: x = spacing,
      spacingY: y = spacing
    } = {
      spacingX,
      spacingY
    };
    return {
      "--chakra-wrap-x-spacing": theme => (0, _breakpointUtils.mapResponsive)(x, value => px((0, _system.tokenToCSSVar)("space", value)(theme))),
      "--chakra-wrap-y-spacing": theme => (0, _breakpointUtils.mapResponsive)(y, value => px((0, _system.tokenToCSSVar)("space", value)(theme))),
      "--wrap-x-spacing": "calc(var(--chakra-wrap-x-spacing) / 2)",
      "--wrap-y-spacing": "calc(var(--chakra-wrap-y-spacing) / 2)",
      display: "flex",
      flexWrap: "wrap",
      justifyContent: justify,
      alignItems: align,
      flexDirection: direction,
      listStyleType: "none",
      padding: "0",
      margin: "calc(var(--wrap-y-spacing) * -1) calc(var(--wrap-x-spacing) * -1)",
      "& > *:not(style)": {
        margin: "var(--wrap-y-spacing) var(--wrap-x-spacing)"
      }
    };
  }, [spacing, spacingX, spacingY, justify, align, direction]);
  const childrenToRender = (0, _react.useMemo)(() => shouldWrapChildren ? _react.Children.map(children, (child, index) => /* @__PURE__ */(0, _jsxRuntime.jsx)(WrapItem, {
    children: child
  }, index)) : children, [children, shouldWrapChildren]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-wrap", className),
    overflow: "hidden",
    ...rest,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.ul, {
      className: "chakra-wrap__list",
      __css: styles,
      children: childrenToRender
    })
  });
});
exports.Wrap = Wrap;
Wrap.displayName = "Wrap";
var WrapItem = (0, _system.forwardRef)(function WrapItem2(props, ref) {
  const {
    className,
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.li, {
    ref,
    __css: {
      display: "flex",
      alignItems: "flex-start"
    },
    className: (0, _sharedUtils.cx)("chakra-wrap__listitem", className),
    ...rest
  });
});
exports.WrapItem = WrapItem;
WrapItem.displayName = "WrapItem";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","@chakra-ui/breakpoint-utils":"RIno","react":"n8MK","react/jsx-runtime":"plwR"}],"LOwO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StackItem = void 0;
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/stack/stack-item.tsx

var StackItem = props => /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
  className: "chakra-stack__item",
  ...props,
  __css: {
    display: "inline-block",
    flex: "0 0 auto",
    minWidth: 0,
    ...props["__css"]
  }
});
exports.StackItem = StackItem;
StackItem.displayName = "StackItem";
},{"@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"P830":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDividerStyles = getDividerStyles;
exports.getStackStyles = getStackStyles;
exports.selector = void 0;
var _breakpointUtils = require("@chakra-ui/breakpoint-utils");
// src/stack/stack.utils.tsx

var selector = "& > *:not(style) ~ *:not(style)";
exports.selector = selector;
function getStackStyles(options) {
  const {
    spacing,
    direction
  } = options;
  const directionStyles = {
    column: {
      marginTop: spacing,
      marginEnd: 0,
      marginBottom: 0,
      marginStart: 0
    },
    row: {
      marginTop: 0,
      marginEnd: 0,
      marginBottom: 0,
      marginStart: spacing
    },
    "column-reverse": {
      marginTop: 0,
      marginEnd: 0,
      marginBottom: spacing,
      marginStart: 0
    },
    "row-reverse": {
      marginTop: 0,
      marginEnd: spacing,
      marginBottom: 0,
      marginStart: 0
    }
  };
  return {
    flexDirection: direction,
    [selector]: (0, _breakpointUtils.mapResponsive)(direction, value => directionStyles[value])
  };
}
function getDividerStyles(options) {
  const {
    spacing,
    direction
  } = options;
  const dividerStyles = {
    column: {
      my: spacing,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    "column-reverse": {
      my: spacing,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    row: {
      mx: spacing,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    },
    "row-reverse": {
      mx: spacing,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    }
  };
  return {
    "&": (0, _breakpointUtils.mapResponsive)(direction, value => dividerStyles[value])
  };
}
},{"@chakra-ui/breakpoint-utils":"RIno"}],"mNR5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Stack = void 0;
var _chunkAMDSPU3E = require("./chunk-AMDSPU3E.mjs");
var _chunkV4DIVZKN = require("./chunk-V4DIVZKN.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _reactChildrenUtils = require("@chakra-ui/react-children-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/stack/stack.tsx

var Stack = (0, _system.forwardRef)((props, ref) => {
  const {
    isInline,
    direction: directionProp,
    align,
    justify,
    spacing = "0.5rem",
    wrap,
    children,
    divider,
    className,
    shouldWrapChildren,
    ...rest
  } = props;
  const direction = isInline ? "row" : directionProp != null ? directionProp : "column";
  const styles = (0, _react.useMemo)(() => (0, _chunkV4DIVZKN.getStackStyles)({
    direction,
    spacing
  }), [direction, spacing]);
  const dividerStyle = (0, _react.useMemo)(() => (0, _chunkV4DIVZKN.getDividerStyles)({
    spacing,
    direction
  }), [spacing, direction]);
  const hasDivider = !!divider;
  const shouldUseChildren = !shouldWrapChildren && !hasDivider;
  const clones = (0, _react.useMemo)(() => {
    const validChildren = (0, _reactChildrenUtils.getValidChildren)(children);
    return shouldUseChildren ? validChildren : validChildren.map((child, index) => {
      const key = typeof child.key !== "undefined" ? child.key : index;
      const isLast = index + 1 === validChildren.length;
      const wrappedChild = /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkAMDSPU3E.StackItem, {
        children: child
      }, key);
      const _child = shouldWrapChildren ? wrappedChild : child;
      if (!hasDivider) return _child;
      const clonedDivider = (0, _react.cloneElement)(divider, {
        __css: dividerStyle
      });
      const _divider = isLast ? null : clonedDivider;
      return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_react.Fragment, {
        children: [_child, _divider]
      }, key);
    });
  }, [divider, dividerStyle, hasDivider, shouldUseChildren, shouldWrapChildren, children]);
  const _className = (0, _sharedUtils.cx)("chakra-stack", className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    display: "flex",
    alignItems: align,
    justifyContent: justify,
    flexDirection: styles.flexDirection,
    flexWrap: wrap,
    className: _className,
    __css: hasDivider ? {} : {
      [_chunkV4DIVZKN.selector]: styles[_chunkV4DIVZKN.selector]
    },
    ...rest,
    children: clones
  });
});
exports.Stack = Stack;
Stack.displayName = "Stack";
},{"./chunk-AMDSPU3E.mjs":"LOwO","./chunk-V4DIVZKN.mjs":"P830","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","@chakra-ui/react-children-utils":"PLf5","react":"n8MK","react/jsx-runtime":"plwR"}],"VRUY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VStack = void 0;
var _chunkO5CRURSQ = require("./chunk-O5CRURSQ.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/stack/v-stack.tsx

var VStack = (0, _system.forwardRef)((props, ref) => /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkO5CRURSQ.Stack, {
  align: "center",
  ...props,
  direction: "column",
  ref
}));
exports.VStack = VStack;
VStack.displayName = "VStack";
},{"./chunk-O5CRURSQ.mjs":"mNR5","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"LcLL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HStack = void 0;
var _chunkO5CRURSQ = require("./chunk-O5CRURSQ.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/stack/h-stack.tsx

var HStack = (0, _system.forwardRef)((props, ref) => /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkO5CRURSQ.Stack, {
  align: "center",
  ...props,
  direction: "row",
  ref
}));
exports.HStack = HStack;
HStack.displayName = "HStack";
},{"./chunk-O5CRURSQ.mjs":"mNR5","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"JXeW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StackDivider = void 0;
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/stack/stack-divider.tsx

var StackDivider = props => /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
  className: "chakra-stack__divider",
  ...props,
  __css: {
    ...props["__css"],
    borderWidth: 0,
    alignSelf: "stretch",
    borderColor: "inherit",
    width: "auto",
    height: "auto"
  }
});
exports.StackDivider = StackDivider;
StackDivider.displayName = "StackDivider";
},{"@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"c17S":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GridItem = void 0;
var _system = require("@chakra-ui/system");
var _objectUtils = require("@chakra-ui/object-utils");
var _breakpointUtils = require("@chakra-ui/breakpoint-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/grid-item.tsx

function spanFn(span) {
  return (0, _breakpointUtils.mapResponsive)(span, value => value === "auto" ? "auto" : `span ${value}/span ${value}`);
}
var GridItem = (0, _system.forwardRef)(function GridItem2(props, ref) {
  const {
    area,
    colSpan,
    colStart,
    colEnd,
    rowEnd,
    rowSpan,
    rowStart,
    ...rest
  } = props;
  const styles = (0, _objectUtils.compact)({
    gridArea: area,
    gridColumn: spanFn(colSpan),
    gridRow: spanFn(rowSpan),
    gridColumnStart: colStart,
    gridColumnEnd: colEnd,
    gridRowStart: rowStart,
    gridRowEnd: rowEnd
  });
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    __css: styles,
    ...rest
  });
});
exports.GridItem = GridItem;
GridItem.displayName = "GridItem";
},{"@chakra-ui/system":"ogbg","@chakra-ui/object-utils":"vt0q","@chakra-ui/breakpoint-utils":"RIno","react/jsx-runtime":"plwR"}],"ryoC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Heading = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/heading.tsx

var Heading = (0, _system.forwardRef)(function Heading2(props, ref) {
  const styles = (0, _system.useStyleConfig)("Heading", props);
  const {
    className,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.h2, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-heading", props.className),
    ...rest,
    __css: styles
  });
});
exports.Heading = Heading;
Heading.displayName = "Heading";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"RYtO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Square = exports.Circle = exports.Box = void 0;
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/box.tsx

var Box = (0, _system.chakra)("div");
exports.Box = Box;
Box.displayName = "Box";
var Square = (0, _system.forwardRef)(function Square2(props, ref) {
  const {
    size,
    centerContent = true,
    ...rest
  } = props;
  const styles = centerContent ? {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  } : {};
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(Box, {
    ref,
    boxSize: size,
    __css: {
      ...styles,
      flexShrink: 0,
      flexGrow: 0
    },
    ...rest
  });
});
exports.Square = Square;
Square.displayName = "Square";
var Circle = (0, _system.forwardRef)(function Circle2(props, ref) {
  const {
    size,
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(Square, {
    size,
    ref,
    borderRadius: "9999px",
    ...rest
  });
});
exports.Circle = Circle;
Circle.displayName = "Circle";
},{"@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"jOJa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Highlight = Highlight;
exports.Mark = void 0;
exports.useHighlight = useHighlight;
var _chunk6CSUKJP = require("./chunk-6CSUKJP7.mjs");
var _system = require("@chakra-ui/system");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/highlight.tsx

var escapeRegexp = term => term.replace(/[|\\{}()[\]^$+*?.-]/g, char => `\\${char}`);
function buildRegex(query) {
  const _query = query.filter(text => text.length !== 0).map(text => escapeRegexp(text.trim()));
  if (!_query.length) {
    return null;
  }
  return new RegExp(`(${_query.join("|")})`, "ig");
}
function highlightWords({
  text,
  query
}) {
  const regex = buildRegex(Array.isArray(query) ? query : [query]);
  if (!regex) {
    return [{
      text,
      match: false
    }];
  }
  const result = text.split(regex).filter(Boolean);
  return result.map(str => ({
    text: str,
    match: regex.test(str)
  }));
}
function useHighlight(props) {
  const {
    text,
    query
  } = props;
  return (0, _react.useMemo)(() => highlightWords({
    text,
    query
  }), [text, query]);
}
var Mark = (0, _system.forwardRef)(function Mark2(props, ref) {
  const styles = (0, _system.useStyleConfig)("Mark", props);
  const ownProps = (0, _system.omitThemingProps)(props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk6CSUKJP.Box, {
    ref,
    ...ownProps,
    as: "mark",
    __css: {
      bg: "transparent",
      whiteSpace: "nowrap",
      ...styles
    }
  });
});
exports.Mark = Mark;
function Highlight(props) {
  const {
    children,
    query,
    styles
  } = props;
  if (typeof children !== "string") {
    throw new Error("The children prop of Highlight must be a string");
  }
  const chunks = useHighlight({
    query,
    text: children
  });
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: chunks.map((chunk, index) => {
      return chunk.match ? /* @__PURE__ */(0, _jsxRuntime.jsx)(Mark, {
        sx: styles,
        children: chunk.text
      }, index) : /* @__PURE__ */(0, _jsxRuntime.jsx)(_react.Fragment, {
        children: chunk.text
      }, index);
    })
  });
}
},{"./chunk-6CSUKJP7.mjs":"RYtO","@chakra-ui/system":"ogbg","react":"n8MK","react/jsx-runtime":"plwR"}],"UYOR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Kbd = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/kbd.tsx

var Kbd = (0, _system.forwardRef)(function Kbd2(props, ref) {
  const styles = (0, _system.useStyleConfig)("Kbd", props);
  const {
    className,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.kbd, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-kbd", className),
    ...rest,
    __css: {
      fontFamily: "mono",
      ...styles
    }
  });
});
exports.Kbd = Kbd;
Kbd.displayName = "Kbd";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"ka2k":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LinkOverlay = exports.LinkBox = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/link-box.tsx

var LinkOverlay = (0, _system.forwardRef)(function LinkOverlay2(props, ref) {
  const {
    isExternal,
    target,
    rel,
    className,
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.a, {
    ...rest,
    ref,
    className: (0, _sharedUtils.cx)("chakra-linkbox__overlay", className),
    rel: isExternal ? "noopener noreferrer" : rel,
    target: isExternal ? "_blank" : target,
    __css: {
      position: "static",
      "&::before": {
        content: "''",
        cursor: "inherit",
        display: "block",
        position: "absolute",
        top: 0,
        left: 0,
        zIndex: 0,
        width: "100%",
        height: "100%"
      }
    }
  });
});
exports.LinkOverlay = LinkOverlay;
var LinkBox = (0, _system.forwardRef)(function LinkBox2(props, ref) {
  const {
    className,
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    position: "relative",
    ...rest,
    className: (0, _sharedUtils.cx)("chakra-linkbox", className),
    __css: {
      "a[href]:not(.chakra-linkbox__overlay), abbr[title]": {
        position: "relative",
        zIndex: 1
      }
    }
  });
});
exports.LinkBox = LinkBox;
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"GNRD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Link = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/link.tsx

var Link = (0, _system.forwardRef)(function Link2(props, ref) {
  const styles = (0, _system.useStyleConfig)("Link", props);
  const {
    className,
    isExternal,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.a, {
    target: isExternal ? "_blank" : void 0,
    rel: isExternal ? "noopener" : void 0,
    ref,
    className: (0, _sharedUtils.cx)("chakra-link", className),
    ...rest,
    __css: styles
  });
});
exports.Link = Link;
Link.displayName = "Link";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"RCH5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AspectRatio = void 0;
var _system = require("@chakra-ui/system");
var _breakpointUtils = require("@chakra-ui/breakpoint-utils");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/aspect-ratio.tsx

var AspectRatio = (0, _system.forwardRef)(function (props, ref) {
  const {
    ratio = 4 / 3,
    children,
    className,
    ...rest
  } = props;
  const child = _react.Children.only(children);
  const _className = (0, _sharedUtils.cx)("chakra-aspect-ratio", className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    position: "relative",
    className: _className,
    _before: {
      height: 0,
      content: `""`,
      display: "block",
      paddingBottom: (0, _breakpointUtils.mapResponsive)(ratio, r => `${1 / r * 100}%`)
    },
    __css: {
      "& > *:not(style)": {
        overflow: "hidden",
        position: "absolute",
        top: "0",
        right: "0",
        bottom: "0",
        left: "0",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%"
      },
      "& > img, & > video": {
        objectFit: "cover"
      }
    },
    ...rest,
    children: child
  });
});
exports.AspectRatio = AspectRatio;
AspectRatio.displayName = "AspectRatio";
},{"@chakra-ui/system":"ogbg","@chakra-ui/breakpoint-utils":"RIno","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"jMxp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Badge = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/badge.tsx

var Badge = (0, _system.forwardRef)(function Badge2(props, ref) {
  const styles = (0, _system.useStyleConfig)("Badge", props);
  const {
    className,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-badge", props.className),
    ...rest,
    __css: {
      display: "inline-block",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      ...styles
    }
  });
});
exports.Badge = Badge;
Badge.displayName = "Badge";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"MpJB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Center = exports.AbsoluteCenter = void 0;
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/center.tsx

var Center = (0, _system.chakra)("div", {
  baseStyle: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }
});
exports.Center = Center;
Center.displayName = "Center";
var centerStyles = {
  horizontal: {
    insetStart: "50%",
    transform: "translateX(-50%)"
  },
  vertical: {
    top: "50%",
    transform: "translateY(-50%)"
  },
  both: {
    insetStart: "50%",
    top: "50%",
    transform: "translate(-50%, -50%)"
  }
};
var AbsoluteCenter = (0, _system.forwardRef)(function AbsoluteCenter2(props, ref) {
  const {
    axis = "both",
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    __css: centerStyles[axis],
    ...rest,
    position: "absolute"
  });
});
exports.AbsoluteCenter = AbsoluteCenter;
},{"@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"lkzd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Code = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/code.tsx

var Code = (0, _system.forwardRef)(function Code2(props, ref) {
  const styles = (0, _system.useStyleConfig)("Code", props);
  const {
    className,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.code, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-code", props.className),
    ...rest,
    __css: {
      display: "inline-block",
      ...styles
    }
  });
});
exports.Code = Code;
Code.displayName = "Code";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"Xh5m":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Container = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/container.tsx

var Container = (0, _system.forwardRef)(function Container2(props, ref) {
  const {
    className,
    centerContent,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const styles = (0, _system.useStyleConfig)("Container", props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-container", className),
    ...rest,
    __css: {
      ...styles,
      ...(centerContent && {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      })
    }
  });
});
exports.Container = Container;
Container.displayName = "Container";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"C6rn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Divider = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/divider.tsx

var Divider = (0, _system.forwardRef)(function Divider2(props, ref) {
  const {
    borderLeftWidth,
    borderBottomWidth,
    borderTopWidth,
    borderRightWidth,
    borderWidth,
    borderStyle,
    borderColor,
    ...styles
  } = (0, _system.useStyleConfig)("Divider", props);
  const {
    className,
    orientation = "horizontal",
    __css,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const dividerStyles = {
    vertical: {
      borderLeftWidth: borderLeftWidth || borderRightWidth || borderWidth || "1px",
      height: "100%"
    },
    horizontal: {
      borderBottomWidth: borderBottomWidth || borderTopWidth || borderWidth || "1px",
      width: "100%"
    }
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.hr, {
    ref,
    "aria-orientation": orientation,
    ...rest,
    __css: {
      ...styles,
      border: "0",
      borderColor,
      borderStyle,
      ...dividerStyles[orientation],
      ...__css
    },
    className: (0, _sharedUtils.cx)("chakra-divider", className)
  });
});
exports.Divider = Divider;
Divider.displayName = "Divider";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"mICm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Flex = void 0;
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/flex.tsx

var Flex = (0, _system.forwardRef)(function Flex2(props, ref) {
  const {
    direction,
    align,
    justify,
    wrap,
    basis,
    grow,
    shrink,
    ...rest
  } = props;
  const styles = {
    display: "flex",
    flexDirection: direction,
    alignItems: align,
    justifyContent: justify,
    flexWrap: wrap,
    flexBasis: basis,
    flexGrow: grow,
    flexShrink: shrink
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    __css: styles,
    ...rest
  });
});
exports.Flex = Flex;
Flex.displayName = "Flex";
},{"@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"VBd8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AbsoluteCenter", {
  enumerable: true,
  get: function () {
    return _chunk3V5HNFOM.AbsoluteCenter;
  }
});
Object.defineProperty(exports, "AspectRatio", {
  enumerable: true,
  get: function () {
    return _chunkDPSEBQMG.AspectRatio;
  }
});
Object.defineProperty(exports, "Badge", {
  enumerable: true,
  get: function () {
    return _chunkFQXH56BT.Badge;
  }
});
Object.defineProperty(exports, "Box", {
  enumerable: true,
  get: function () {
    return _chunk6CSUKJP.Box;
  }
});
Object.defineProperty(exports, "Center", {
  enumerable: true,
  get: function () {
    return _chunk3V5HNFOM.Center;
  }
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function () {
    return _chunk6CSUKJP.Circle;
  }
});
Object.defineProperty(exports, "Code", {
  enumerable: true,
  get: function () {
    return _chunkMVNZWEQB.Code;
  }
});
Object.defineProperty(exports, "Container", {
  enumerable: true,
  get: function () {
    return _chunkSRMZVY4F.Container;
  }
});
Object.defineProperty(exports, "Divider", {
  enumerable: true,
  get: function () {
    return _chunkYGVX4ESO.Divider;
  }
});
Object.defineProperty(exports, "Flex", {
  enumerable: true,
  get: function () {
    return _chunkMPFPK3CX.Flex;
  }
});
Object.defineProperty(exports, "Grid", {
  enumerable: true,
  get: function () {
    return _chunk5FO2ZLZM.Grid;
  }
});
Object.defineProperty(exports, "GridItem", {
  enumerable: true,
  get: function () {
    return _chunkIWVFML3N.GridItem;
  }
});
Object.defineProperty(exports, "HStack", {
  enumerable: true,
  get: function () {
    return _chunkHUQHYERK.HStack;
  }
});
Object.defineProperty(exports, "Heading", {
  enumerable: true,
  get: function () {
    return _chunkB2MGPQRJ.Heading;
  }
});
Object.defineProperty(exports, "Highlight", {
  enumerable: true,
  get: function () {
    return _chunkU2ZO4DDB.Highlight;
  }
});
Object.defineProperty(exports, "Kbd", {
  enumerable: true,
  get: function () {
    return _chunkYV2Z46CE.Kbd;
  }
});
Object.defineProperty(exports, "Link", {
  enumerable: true,
  get: function () {
    return _chunkYTV6DHKL.Link;
  }
});
Object.defineProperty(exports, "LinkBox", {
  enumerable: true,
  get: function () {
    return _chunkUNOISFZK.LinkBox;
  }
});
Object.defineProperty(exports, "LinkOverlay", {
  enumerable: true,
  get: function () {
    return _chunkUNOISFZK.LinkOverlay;
  }
});
Object.defineProperty(exports, "List", {
  enumerable: true,
  get: function () {
    return _chunkZ47J5YMH.List;
  }
});
Object.defineProperty(exports, "ListIcon", {
  enumerable: true,
  get: function () {
    return _chunkZ47J5YMH.ListIcon;
  }
});
Object.defineProperty(exports, "ListItem", {
  enumerable: true,
  get: function () {
    return _chunkZ47J5YMH.ListItem;
  }
});
Object.defineProperty(exports, "Mark", {
  enumerable: true,
  get: function () {
    return _chunkU2ZO4DDB.Mark;
  }
});
Object.defineProperty(exports, "OrderedList", {
  enumerable: true,
  get: function () {
    return _chunkZ47J5YMH.OrderedList;
  }
});
Object.defineProperty(exports, "SimpleGrid", {
  enumerable: true,
  get: function () {
    return _chunkQJDVAY5Z.SimpleGrid;
  }
});
Object.defineProperty(exports, "Spacer", {
  enumerable: true,
  get: function () {
    return _chunk6FWJQRCB.Spacer;
  }
});
Object.defineProperty(exports, "Square", {
  enumerable: true,
  get: function () {
    return _chunk6CSUKJP.Square;
  }
});
Object.defineProperty(exports, "Stack", {
  enumerable: true,
  get: function () {
    return _chunkO5CRURSQ.Stack;
  }
});
Object.defineProperty(exports, "StackDivider", {
  enumerable: true,
  get: function () {
    return _chunkMZBQPWGD.StackDivider;
  }
});
Object.defineProperty(exports, "StackItem", {
  enumerable: true,
  get: function () {
    return _chunkAMDSPU3E.StackItem;
  }
});
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function () {
    return _chunkP74GIWPW.Text;
  }
});
Object.defineProperty(exports, "UnorderedList", {
  enumerable: true,
  get: function () {
    return _chunkZ47J5YMH.UnorderedList;
  }
});
Object.defineProperty(exports, "VStack", {
  enumerable: true,
  get: function () {
    return _chunkMUMUYFOI.VStack;
  }
});
Object.defineProperty(exports, "Wrap", {
  enumerable: true,
  get: function () {
    return _chunkCRIDK7KT.Wrap;
  }
});
Object.defineProperty(exports, "WrapItem", {
  enumerable: true,
  get: function () {
    return _chunkCRIDK7KT.WrapItem;
  }
});
Object.defineProperty(exports, "getDividerStyles", {
  enumerable: true,
  get: function () {
    return _chunkV4DIVZKN.getDividerStyles;
  }
});
Object.defineProperty(exports, "getStackStyles", {
  enumerable: true,
  get: function () {
    return _chunkV4DIVZKN.getStackStyles;
  }
});
Object.defineProperty(exports, "selector", {
  enumerable: true,
  get: function () {
    return _chunkV4DIVZKN.selector;
  }
});
Object.defineProperty(exports, "useHighlight", {
  enumerable: true,
  get: function () {
    return _chunkU2ZO4DDB.useHighlight;
  }
});
Object.defineProperty(exports, "useListStyles", {
  enumerable: true,
  get: function () {
    return _chunkZ47J5YMH.useListStyles;
  }
});
var _chunkZ47J5YMH = require("./chunk-Z47J5YMH.mjs");
var _chunkQJDVAY5Z = require("./chunk-QJDVAY5Z.mjs");
var _chunk6FWJQRCB = require("./chunk-6FWJQRCB.mjs");
var _chunkP74GIWPW = require("./chunk-P74GIWPW.mjs");
var _chunkCRIDK7KT = require("./chunk-CRIDK7KT.mjs");
require("./chunk-GCMP4FVN.mjs");
var _chunkMUMUYFOI = require("./chunk-MUMUYFOI.mjs");
var _chunkHUQHYERK = require("./chunk-HUQHYERK.mjs");
var _chunkO5CRURSQ = require("./chunk-O5CRURSQ.mjs");
var _chunkAMDSPU3E = require("./chunk-AMDSPU3E.mjs");
var _chunkV4DIVZKN = require("./chunk-V4DIVZKN.mjs");
var _chunkMZBQPWGD = require("./chunk-MZBQPWGD.mjs");
var _chunkIWVFML3N = require("./chunk-IWVFML3N.mjs");
var _chunk5FO2ZLZM = require("./chunk-5FO2ZLZM.mjs");
var _chunkB2MGPQRJ = require("./chunk-B2MGPQRJ.mjs");
var _chunkU2ZO4DDB = require("./chunk-U2ZO4DDB.mjs");
var _chunkYV2Z46CE = require("./chunk-YV2Z46CE.mjs");
var _chunkUNOISFZK = require("./chunk-UNOISFZK.mjs");
var _chunkYTV6DHKL = require("./chunk-YTV6DHKL.mjs");
var _chunkDPSEBQMG = require("./chunk-DPSEBQMG.mjs");
var _chunkFQXH56BT = require("./chunk-FQXH56BT.mjs");
var _chunk6CSUKJP = require("./chunk-6CSUKJP7.mjs");
var _chunk3V5HNFOM = require("./chunk-3V5HNFOM.mjs");
var _chunkMVNZWEQB = require("./chunk-MVNZWEQB.mjs");
var _chunkSRMZVY4F = require("./chunk-SRMZVY4F.mjs");
var _chunkYGVX4ESO = require("./chunk-YGVX4ESO.mjs");
var _chunkMPFPK3CX = require("./chunk-MPFPK3CX.mjs");
},{"./chunk-Z47J5YMH.mjs":"vs63","./chunk-QJDVAY5Z.mjs":"aCrm","./chunk-6FWJQRCB.mjs":"vSQ9","./chunk-P74GIWPW.mjs":"U3XN","./chunk-CRIDK7KT.mjs":"heza","./chunk-GCMP4FVN.mjs":"Tnu0","./chunk-MUMUYFOI.mjs":"VRUY","./chunk-HUQHYERK.mjs":"LcLL","./chunk-O5CRURSQ.mjs":"mNR5","./chunk-AMDSPU3E.mjs":"LOwO","./chunk-V4DIVZKN.mjs":"P830","./chunk-MZBQPWGD.mjs":"JXeW","./chunk-IWVFML3N.mjs":"c17S","./chunk-5FO2ZLZM.mjs":"l2k1","./chunk-B2MGPQRJ.mjs":"ryoC","./chunk-U2ZO4DDB.mjs":"jOJa","./chunk-YV2Z46CE.mjs":"UYOR","./chunk-UNOISFZK.mjs":"ka2k","./chunk-YTV6DHKL.mjs":"GNRD","./chunk-DPSEBQMG.mjs":"RCH5","./chunk-FQXH56BT.mjs":"jMxp","./chunk-6CSUKJP7.mjs":"RYtO","./chunk-3V5HNFOM.mjs":"MpJB","./chunk-MVNZWEQB.mjs":"lkzd","./chunk-SRMZVY4F.mjs":"Xh5m","./chunk-YGVX4ESO.mjs":"C6rn","./chunk-MPFPK3CX.mjs":"mICm"}],"sb2r":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMediaQuery = useMediaQuery;
var _reactEnv = require("@chakra-ui/react-env");
var _react = require("react");
// src/use-media-query.ts

function useMediaQuery(query, options = {}) {
  const {
    ssr = true,
    fallback
  } = options;
  const env = (0, _reactEnv.useEnvironment)();
  const queries = Array.isArray(query) ? query : [query];
  let fallbackValues = Array.isArray(fallback) ? fallback : [fallback];
  fallbackValues = fallbackValues.filter(v => v != null);
  const [value, setValue] = (0, _react.useState)(() => {
    return queries.map((query2, index) => ({
      media: query2,
      matches: ssr ? !!fallbackValues[index] : env.window.matchMedia(query2).matches
    }));
  });
  (0, _react.useEffect)(() => {
    setValue(queries.map(query2 => ({
      media: query2,
      matches: env.window.matchMedia(query2).matches
    })));
    const mql = queries.map(query2 => env.window.matchMedia(query2));
    const handler = evt => {
      setValue(prev => {
        return prev.slice().map(item => {
          if (item.media === evt.media) return {
            ...item,
            matches: evt.matches
          };
          return item;
        });
      });
    };
    mql.forEach(mql2 => {
      if (typeof mql2.addListener === "function") {
        mql2.addListener(handler);
      } else {
        mql2.addEventListener("change", handler);
      }
    });
    return () => {
      mql.forEach(mql2 => {
        if (typeof mql2.removeListener === "function") {
          mql2.removeListener(handler);
        } else {
          mql2.removeEventListener("change", handler);
        }
      });
    };
  }, [env.window]);
  return value.map(item => item.matches);
}
},{"@chakra-ui/react-env":"v0AH","react":"n8MK"}],"El6n":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Visibility = Visibility;
var _chunkCOQJTHYC = require("./chunk-COQJTHYC.mjs");
// src/visibility.tsx
function Visibility(props) {
  const {
    breakpoint,
    hide,
    children,
    ssr
  } = props;
  const [show] = (0, _chunkCOQJTHYC.useMediaQuery)(breakpoint, {
    ssr
  });
  const isVisible = hide ? !show : show;
  const rendered = isVisible ? children : null;
  return rendered;
}
},{"./chunk-COQJTHYC.mjs":"sb2r"}],"Fev4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useQuery = useQuery;
var _system = require("@chakra-ui/system");
// src/media-query.tsx

var getBreakpoint = (theme, value) => {
  var _a, _b;
  return (_b = (_a = theme == null ? void 0 : theme.breakpoints) == null ? void 0 : _a[value]) != null ? _b : value;
};
function useQuery(props) {
  const {
    breakpoint = "",
    below,
    above
  } = props;
  const theme = (0, _system.useTheme)();
  const bpBelow = getBreakpoint(theme, below);
  const bpAbove = getBreakpoint(theme, above);
  let query = breakpoint;
  if (bpBelow) {
    query = `(max-width: ${bpBelow})`;
  } else if (bpAbove) {
    query = `(min-width: ${bpAbove})`;
  }
  return query;
}
},{"@chakra-ui/system":"ogbg"}],"gYLJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hide = Hide;
var _chunk2XZ5GOGB = require("./chunk-2XZ5GOGB.mjs");
var _chunkR3K6W4OF = require("./chunk-R3K6W4OF.mjs");
var _jsxRuntime = require("react/jsx-runtime");
// src/hide.tsx

function Hide(props) {
  const {
    children,
    ssr
  } = props;
  const query = (0, _chunkR3K6W4OF.useQuery)(props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk2XZ5GOGB.Visibility, {
    breakpoint: query,
    hide: true,
    ssr,
    children
  });
}
Hide.displayName = "Hide";
},{"./chunk-2XZ5GOGB.mjs":"El6n","./chunk-R3K6W4OF.mjs":"Fev4","react/jsx-runtime":"plwR"}],"SwBP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useColorModePreference = useColorModePreference;
exports.usePrefersReducedMotion = usePrefersReducedMotion;
var _chunkCOQJTHYC = require("./chunk-COQJTHYC.mjs");
// src/media-query.hook.ts
function usePrefersReducedMotion(options) {
  const [prefersReducedMotion] = (0, _chunkCOQJTHYC.useMediaQuery)("(prefers-reduced-motion: reduce)", options);
  return prefersReducedMotion;
}
function useColorModePreference(options) {
  const [isLight, isDark] = (0, _chunkCOQJTHYC.useMediaQuery)(["(prefers-color-scheme: light)", "(prefers-color-scheme: dark)"], options);
  if (isLight) return "light";
  if (isDark) return "dark";
  return void 0;
}
},{"./chunk-COQJTHYC.mjs":"sb2r"}],"uxY2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Show = Show;
var _chunk2XZ5GOGB = require("./chunk-2XZ5GOGB.mjs");
var _chunkR3K6W4OF = require("./chunk-R3K6W4OF.mjs");
var _jsxRuntime = require("react/jsx-runtime");
// src/show.tsx

function Show(props) {
  const {
    children,
    ssr
  } = props;
  const query = (0, _chunkR3K6W4OF.useQuery)(props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk2XZ5GOGB.Visibility, {
    breakpoint: query,
    ssr,
    children
  });
}
Show.displayName = "Show";
},{"./chunk-2XZ5GOGB.mjs":"El6n","./chunk-R3K6W4OF.mjs":"Fev4","react/jsx-runtime":"plwR"}],"QjEk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getClosestValue = getClosestValue;
var _breakpointUtils = require("@chakra-ui/breakpoint-utils");
// src/media-query.utils.ts

function getClosestValue(values, breakpoint, breakpoints = _breakpointUtils.breakpoints) {
  let index = Object.keys(values).indexOf(breakpoint);
  if (index !== -1) {
    return values[breakpoint];
  }
  let stopIndex = breakpoints.indexOf(breakpoint);
  while (stopIndex >= 0) {
    const key = breakpoints[stopIndex];
    if (values.hasOwnProperty(key)) {
      index = stopIndex;
      break;
    }
    stopIndex -= 1;
  }
  if (index !== -1) {
    const key = breakpoints[index];
    return values[key];
  }
  return void 0;
}
},{"@chakra-ui/breakpoint-utils":"RIno"}],"GPe6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useBreakpoint = useBreakpoint;
var _chunkCOQJTHYC = require("./chunk-COQJTHYC.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
// src/use-breakpoint.ts

function useBreakpoint(arg) {
  var _a, _b;
  const opts = (0, _sharedUtils.isObject)(arg) ? arg : {
    fallback: arg != null ? arg : "base"
  };
  const theme = (0, _system.useTheme)();
  const breakpoints = theme.__breakpoints.details.map(({
    minMaxQuery,
    breakpoint
  }) => ({
    breakpoint,
    query: minMaxQuery.replace("@media screen and ", "")
  }));
  const fallback = breakpoints.map(bp => bp.breakpoint === opts.fallback);
  const values = (0, _chunkCOQJTHYC.useMediaQuery)(breakpoints.map(bp => bp.query), {
    fallback,
    ssr: opts.ssr
  });
  const index = values.findIndex(value => value == true);
  return (_b = (_a = breakpoints[index]) == null ? void 0 : _a.breakpoint) != null ? _b : opts.fallback;
}
},{"./chunk-COQJTHYC.mjs":"sb2r","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr"}],"TwLJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useBreakpointValue = useBreakpointValue;
var _chunkG4WB2JLN = require("./chunk-G4WB2JLN.mjs");
var _chunkLKNFHLSN = require("./chunk-LKNFHLSN.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _breakpointUtils = require("@chakra-ui/breakpoint-utils");
// src/use-breakpoint-value.ts

function useBreakpointValue(values, arg) {
  var _a;
  const opts = (0, _sharedUtils.isObject)(arg) ? arg : {
    fallback: arg != null ? arg : "base"
  };
  const breakpoint = (0, _chunkLKNFHLSN.useBreakpoint)(opts);
  const theme = (0, _system.useTheme)();
  if (!breakpoint) return;
  const breakpoints = Array.from(((_a = theme.__breakpoints) == null ? void 0 : _a.keys) || []);
  const obj = Array.isArray(values) ? Object.fromEntries(Object.entries((0, _breakpointUtils.arrayToObjectNotation)(values, breakpoints)).map(([key, value]) => [key, value])) : values;
  return (0, _chunkG4WB2JLN.getClosestValue)(obj, breakpoint, breakpoints);
}
},{"./chunk-G4WB2JLN.mjs":"QjEk","./chunk-LKNFHLSN.mjs":"GPe6","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","@chakra-ui/breakpoint-utils":"RIno"}],"cY5H":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Hide", {
  enumerable: true,
  get: function () {
    return _chunkY66KU3PT.Hide;
  }
});
Object.defineProperty(exports, "Show", {
  enumerable: true,
  get: function () {
    return _chunkNQSHWFVW.Show;
  }
});
Object.defineProperty(exports, "useBreakpoint", {
  enumerable: true,
  get: function () {
    return _chunkLKNFHLSN.useBreakpoint;
  }
});
Object.defineProperty(exports, "useBreakpointValue", {
  enumerable: true,
  get: function () {
    return _chunkZP6GWHFY.useBreakpointValue;
  }
});
Object.defineProperty(exports, "useColorModePreference", {
  enumerable: true,
  get: function () {
    return _chunkSLVHMJUL.useColorModePreference;
  }
});
Object.defineProperty(exports, "useMediaQuery", {
  enumerable: true,
  get: function () {
    return _chunkCOQJTHYC.useMediaQuery;
  }
});
Object.defineProperty(exports, "usePrefersReducedMotion", {
  enumerable: true,
  get: function () {
    return _chunkSLVHMJUL.usePrefersReducedMotion;
  }
});
Object.defineProperty(exports, "useQuery", {
  enumerable: true,
  get: function () {
    return _chunkR3K6W4OF.useQuery;
  }
});
var _chunkY66KU3PT = require("./chunk-Y66KU3PT.mjs");
var _chunkSLVHMJUL = require("./chunk-SLVHMJUL.mjs");
var _chunkNQSHWFVW = require("./chunk-NQSHWFVW.mjs");
require("./chunk-2XZ5GOGB.mjs");
var _chunkR3K6W4OF = require("./chunk-R3K6W4OF.mjs");
var _chunkZP6GWHFY = require("./chunk-ZP6GWHFY.mjs");
require("./chunk-G4WB2JLN.mjs");
var _chunkLKNFHLSN = require("./chunk-LKNFHLSN.mjs");
var _chunkCOQJTHYC = require("./chunk-COQJTHYC.mjs");
},{"./chunk-Y66KU3PT.mjs":"gYLJ","./chunk-SLVHMJUL.mjs":"SwBP","./chunk-NQSHWFVW.mjs":"uxY2","./chunk-2XZ5GOGB.mjs":"El6n","./chunk-R3K6W4OF.mjs":"Fev4","./chunk-ZP6GWHFY.mjs":"TwLJ","./chunk-G4WB2JLN.mjs":"QjEk","./chunk-LKNFHLSN.mjs":"GPe6","./chunk-COQJTHYC.mjs":"sb2r"}],"TgGo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNextItemFromSearch = getNextItemFromSearch;
// src/get-next-item-from-search.ts
function getNextItemFromSearch(items, searchString, itemToString, currentItem) {
  if (searchString == null) {
    return currentItem;
  }
  if (!currentItem) {
    const foundItem = items.find(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()));
    return foundItem;
  }
  const matchingItems = items.filter(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()));
  if (matchingItems.length > 0) {
    let nextIndex;
    if (matchingItems.includes(currentItem)) {
      const currentIndex = matchingItems.indexOf(currentItem);
      nextIndex = currentIndex + 1;
      if (nextIndex === matchingItems.length) {
        nextIndex = 0;
      }
      return matchingItems[nextIndex];
    }
    nextIndex = items.indexOf(matchingItems[0]);
    return items[nextIndex];
  }
  return currentItem;
}
},{}],"cPxC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEventListeners = useEventListeners;
var _react = require("react");
// src/use-event-listeners.ts

function useEventListeners() {
  const listeners = (0, _react.useRef)( /* @__PURE__ */new Map());
  const currentListeners = listeners.current;
  const add = (0, _react.useCallback)((el, type, listener, options) => {
    listeners.current.set(listener, {
      type,
      el,
      options
    });
    el.addEventListener(type, listener, options);
  }, []);
  const remove = (0, _react.useCallback)((el, type, listener, options) => {
    el.removeEventListener(type, listener, options);
    listeners.current.delete(listener);
  }, []);
  (0, _react.useEffect)(() => () => {
    currentListeners.forEach((value, key) => {
      remove(value.el, value.type, key, value.options);
    });
  }, [remove, currentListeners]);
  return {
    add,
    remove
  };
}
},{"react":"n8MK"}],"ft89":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useClickable = useClickable;
var _chunkYGQKU5RK = require("./chunk-YGQKU5RK.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _react = require("react");
// src/use-clickable.ts

function isValidElement(event) {
  const element = event.target;
  const {
    tagName,
    isContentEditable
  } = element;
  return tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable !== true;
}
function useClickable(props = {}) {
  const {
    ref: htmlRef,
    isDisabled,
    isFocusable,
    clickOnEnter = true,
    clickOnSpace = true,
    onMouseDown,
    onMouseUp,
    onClick,
    onKeyDown,
    onKeyUp,
    tabIndex: tabIndexProp,
    onMouseOver,
    onMouseLeave,
    ...htmlProps
  } = props;
  const [isButton, setIsButton] = (0, _react.useState)(true);
  const [isPressed, setIsPressed] = (0, _react.useState)(false);
  const listeners = (0, _chunkYGQKU5RK.useEventListeners)();
  const refCallback = node => {
    if (!node) return;
    if (node.tagName !== "BUTTON") {
      setIsButton(false);
    }
  };
  const tabIndex = isButton ? tabIndexProp : tabIndexProp || 0;
  const trulyDisabled = isDisabled && !isFocusable;
  const handleClick = (0, _react.useCallback)(event => {
    if (isDisabled) {
      event.stopPropagation();
      event.preventDefault();
      return;
    }
    const self = event.currentTarget;
    self.focus();
    onClick == null ? void 0 : onClick(event);
  }, [isDisabled, onClick]);
  const onDocumentKeyUp = (0, _react.useCallback)(e => {
    if (isPressed && isValidElement(e)) {
      e.preventDefault();
      e.stopPropagation();
      setIsPressed(false);
      listeners.remove(document, "keyup", onDocumentKeyUp, false);
    }
  }, [isPressed, listeners]);
  const handleKeyDown = (0, _react.useCallback)(event => {
    onKeyDown == null ? void 0 : onKeyDown(event);
    if (isDisabled || event.defaultPrevented || event.metaKey) {
      return;
    }
    if (!isValidElement(event.nativeEvent) || isButton) return;
    const shouldClickOnEnter = clickOnEnter && event.key === "Enter";
    const shouldClickOnSpace = clickOnSpace && event.key === " ";
    if (shouldClickOnSpace) {
      event.preventDefault();
      setIsPressed(true);
    }
    if (shouldClickOnEnter) {
      event.preventDefault();
      const self = event.currentTarget;
      self.click();
    }
    listeners.add(document, "keyup", onDocumentKeyUp, false);
  }, [isDisabled, isButton, onKeyDown, clickOnEnter, clickOnSpace, listeners, onDocumentKeyUp]);
  const handleKeyUp = (0, _react.useCallback)(event => {
    onKeyUp == null ? void 0 : onKeyUp(event);
    if (isDisabled || event.defaultPrevented || event.metaKey) return;
    if (!isValidElement(event.nativeEvent) || isButton) return;
    const shouldClickOnSpace = clickOnSpace && event.key === " ";
    if (shouldClickOnSpace) {
      event.preventDefault();
      setIsPressed(false);
      const self = event.currentTarget;
      self.click();
    }
  }, [clickOnSpace, isButton, isDisabled, onKeyUp]);
  const onDocumentMouseUp = (0, _react.useCallback)(event => {
    if (event.button !== 0) return;
    setIsPressed(false);
    listeners.remove(document, "mouseup", onDocumentMouseUp, false);
  }, [listeners]);
  const handleMouseDown = (0, _react.useCallback)(event => {
    if (event.button !== 0) return;
    if (isDisabled) {
      event.stopPropagation();
      event.preventDefault();
      return;
    }
    if (!isButton) {
      setIsPressed(true);
    }
    const target = event.currentTarget;
    target.focus({
      preventScroll: true
    });
    listeners.add(document, "mouseup", onDocumentMouseUp, false);
    onMouseDown == null ? void 0 : onMouseDown(event);
  }, [isDisabled, isButton, onMouseDown, listeners, onDocumentMouseUp]);
  const handleMouseUp = (0, _react.useCallback)(event => {
    if (event.button !== 0) return;
    if (!isButton) {
      setIsPressed(false);
    }
    onMouseUp == null ? void 0 : onMouseUp(event);
  }, [onMouseUp, isButton]);
  const handleMouseOver = (0, _react.useCallback)(event => {
    if (isDisabled) {
      event.preventDefault();
      return;
    }
    onMouseOver == null ? void 0 : onMouseOver(event);
  }, [isDisabled, onMouseOver]);
  const handleMouseLeave = (0, _react.useCallback)(event => {
    if (isPressed) {
      event.preventDefault();
      setIsPressed(false);
    }
    onMouseLeave == null ? void 0 : onMouseLeave(event);
  }, [isPressed, onMouseLeave]);
  const ref = (0, _reactUseMergeRefs.mergeRefs)(htmlRef, refCallback);
  if (isButton) {
    return {
      ...htmlProps,
      ref,
      type: "button",
      "aria-disabled": trulyDisabled ? void 0 : isDisabled,
      disabled: trulyDisabled,
      onClick: handleClick,
      onMouseDown,
      onMouseUp,
      onKeyUp,
      onKeyDown,
      onMouseOver,
      onMouseLeave
    };
  }
  return {
    ...htmlProps,
    ref,
    role: "button",
    "data-active": (0, _sharedUtils.dataAttr)(isPressed),
    "aria-disabled": isDisabled ? "true" : void 0,
    tabIndex: trulyDisabled ? void 0 : tabIndex,
    onClick: handleClick,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onKeyUp: handleKeyUp,
    onKeyDown: handleKeyDown,
    onMouseOver: handleMouseOver,
    onMouseLeave: handleMouseLeave
  };
}
},{"./chunk-YGQKU5RK.mjs":"cPxC","@chakra-ui/shared-utils":"gghr","@chakra-ui/react-use-merge-refs":"EUzL","react":"n8MK"}],"T7OC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "useClickable", {
  enumerable: true,
  get: function () {
    return _chunkXHZNOLJR.useClickable;
  }
});
var _chunkXHZNOLJR = require("./chunk-XHZNOLJR.mjs");
require("./chunk-YGQKU5RK.mjs");
},{"./chunk-XHZNOLJR.mjs":"ft89","./chunk-YGQKU5RK.mjs":"cPxC"}],"I3IU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.contains = contains;
exports.getActiveElement = getActiveElement;
exports.getEventWindow = getEventWindow;
exports.getOwnerDocument = getOwnerDocument;
exports.getOwnerWindow = getOwnerWindow;
exports.isBrowser = isBrowser;
exports.isElement = isElement;
exports.isHTMLElement = isHTMLElement;
// src/dom.ts
function isElement(el) {
  return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
}
function isHTMLElement(el) {
  var _a;
  if (!isElement(el)) return false;
  const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
  return el instanceof win.HTMLElement;
}
function getOwnerWindow(node) {
  var _a, _b;
  return (_b = (_a = getOwnerDocument(node)) == null ? void 0 : _a.defaultView) != null ? _b : window;
}
function getOwnerDocument(node) {
  return isElement(node) ? node.ownerDocument : document;
}
function getEventWindow(event) {
  var _a;
  return (_a = event.view) != null ? _a : window;
}
function isBrowser() {
  return Boolean(globalThis == null ? void 0 : globalThis.document);
}
function getActiveElement(node) {
  return getOwnerDocument(node).activeElement;
}
function contains(parent, child) {
  if (!parent) return false;
  return parent === child || parent.contains(child);
}
},{}],"kAyN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasDisplayNone = void 0;
exports.hasFocusWithin = hasFocusWithin;
exports.hasTabIndex = exports.hasNegativeTabIndex = void 0;
exports.isActiveElement = isActiveElement;
exports.isContentEditable = isContentEditable;
exports.isDisabled = isDisabled;
exports.isFocusable = isFocusable;
exports.isHidden = isHidden;
exports.isInputElement = isInputElement;
exports.isTabbable = isTabbable;
var _chunk3XANSPY = require("./chunk-3XANSPY5.mjs");
// src/tabbable.ts
var hasDisplayNone = element => window.getComputedStyle(element).display === "none";
exports.hasDisplayNone = hasDisplayNone;
var hasTabIndex = element => element.hasAttribute("tabindex");
exports.hasTabIndex = hasTabIndex;
var hasNegativeTabIndex = element => hasTabIndex(element) && element.tabIndex === -1;
exports.hasNegativeTabIndex = hasNegativeTabIndex;
function isDisabled(element) {
  return Boolean(element.getAttribute("disabled")) === true || Boolean(element.getAttribute("aria-disabled")) === true;
}
function isInputElement(element) {
  return (0, _chunk3XANSPY.isHTMLElement)(element) && element.localName === "input" && "select" in element;
}
function isActiveElement(element) {
  const doc = (0, _chunk3XANSPY.isHTMLElement)(element) ? (0, _chunk3XANSPY.getOwnerDocument)(element) : document;
  return doc.activeElement === element;
}
function hasFocusWithin(element) {
  if (!document.activeElement) return false;
  return element.contains(document.activeElement);
}
function isHidden(element) {
  if (element.parentElement && isHidden(element.parentElement)) return true;
  return element.hidden;
}
function isContentEditable(element) {
  const value = element.getAttribute("contenteditable");
  return value !== "false" && value != null;
}
function isFocusable(element) {
  if (!(0, _chunk3XANSPY.isHTMLElement)(element) || isHidden(element) || isDisabled(element)) {
    return false;
  }
  const {
    localName
  } = element;
  const focusableTags = ["input", "select", "textarea", "button"];
  if (focusableTags.indexOf(localName) >= 0) return true;
  const others = {
    a: () => element.hasAttribute("href"),
    audio: () => element.hasAttribute("controls"),
    video: () => element.hasAttribute("controls")
  };
  if (localName in others) {
    return others[localName]();
  }
  if (isContentEditable(element)) return true;
  return hasTabIndex(element);
}
function isTabbable(element) {
  if (!element) return false;
  return (0, _chunk3XANSPY.isHTMLElement)(element) && isFocusable(element) && !hasNegativeTabIndex(element);
}
},{"./chunk-3XANSPY5.mjs":"I3IU"}],"p6n0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "contains", {
  enumerable: true,
  get: function () {
    return _chunk3XANSPY.contains;
  }
});
Object.defineProperty(exports, "getActiveElement", {
  enumerable: true,
  get: function () {
    return _chunk3XANSPY.getActiveElement;
  }
});
exports.getAllFocusable = getAllFocusable;
exports.getAllTabbable = getAllTabbable;
Object.defineProperty(exports, "getEventWindow", {
  enumerable: true,
  get: function () {
    return _chunk3XANSPY.getEventWindow;
  }
});
exports.getFirstFocusable = getFirstFocusable;
exports.getFirstTabbableIn = getFirstTabbableIn;
exports.getLastTabbableIn = getLastTabbableIn;
exports.getNextTabbable = getNextTabbable;
Object.defineProperty(exports, "getOwnerDocument", {
  enumerable: true,
  get: function () {
    return _chunk3XANSPY.getOwnerDocument;
  }
});
Object.defineProperty(exports, "getOwnerWindow", {
  enumerable: true,
  get: function () {
    return _chunk3XANSPY.getOwnerWindow;
  }
});
exports.getPreviousTabbable = getPreviousTabbable;
Object.defineProperty(exports, "hasDisplayNone", {
  enumerable: true,
  get: function () {
    return _chunkROURZMX.hasDisplayNone;
  }
});
Object.defineProperty(exports, "hasFocusWithin", {
  enumerable: true,
  get: function () {
    return _chunkROURZMX.hasFocusWithin;
  }
});
Object.defineProperty(exports, "hasNegativeTabIndex", {
  enumerable: true,
  get: function () {
    return _chunkROURZMX.hasNegativeTabIndex;
  }
});
Object.defineProperty(exports, "hasTabIndex", {
  enumerable: true,
  get: function () {
    return _chunkROURZMX.hasTabIndex;
  }
});
Object.defineProperty(exports, "isActiveElement", {
  enumerable: true,
  get: function () {
    return _chunkROURZMX.isActiveElement;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _chunk3XANSPY.isBrowser;
  }
});
Object.defineProperty(exports, "isContentEditable", {
  enumerable: true,
  get: function () {
    return _chunkROURZMX.isContentEditable;
  }
});
Object.defineProperty(exports, "isDisabled", {
  enumerable: true,
  get: function () {
    return _chunkROURZMX.isDisabled;
  }
});
Object.defineProperty(exports, "isElement", {
  enumerable: true,
  get: function () {
    return _chunk3XANSPY.isElement;
  }
});
Object.defineProperty(exports, "isFocusable", {
  enumerable: true,
  get: function () {
    return _chunkROURZMX.isFocusable;
  }
});
Object.defineProperty(exports, "isHTMLElement", {
  enumerable: true,
  get: function () {
    return _chunk3XANSPY.isHTMLElement;
  }
});
Object.defineProperty(exports, "isHidden", {
  enumerable: true,
  get: function () {
    return _chunkROURZMX.isHidden;
  }
});
Object.defineProperty(exports, "isInputElement", {
  enumerable: true,
  get: function () {
    return _chunkROURZMX.isInputElement;
  }
});
Object.defineProperty(exports, "isTabbable", {
  enumerable: true,
  get: function () {
    return _chunkROURZMX.isTabbable;
  }
});
var _chunkROURZMX = require("./chunk-ROURZMX4.mjs");
var _chunk3XANSPY = require("./chunk-3XANSPY5.mjs");
// src/index.ts
var focusableElList = ["input:not(:disabled):not([disabled])", "select:not(:disabled):not([disabled])", "textarea:not(:disabled):not([disabled])", "embed", "iframe", "object", "a[href]", "area[href]", "button:not(:disabled):not([disabled])", "[tabindex]", "audio[controls]", "video[controls]", "*[tabindex]:not([aria-disabled])", "*[contenteditable]"];
var focusableElSelector = focusableElList.join();
var isVisible = el => el.offsetWidth > 0 && el.offsetHeight > 0;
function getAllFocusable(container) {
  const focusableEls = Array.from(container.querySelectorAll(focusableElSelector));
  focusableEls.unshift(container);
  return focusableEls.filter(el => (0, _chunkROURZMX.isFocusable)(el) && isVisible(el));
}
function getFirstFocusable(container) {
  const allFocusable = getAllFocusable(container);
  return allFocusable.length ? allFocusable[0] : null;
}
function getAllTabbable(container, fallbackToFocusable) {
  const allFocusable = Array.from(container.querySelectorAll(focusableElSelector));
  const allTabbable = allFocusable.filter(_chunkROURZMX.isTabbable);
  if ((0, _chunkROURZMX.isTabbable)(container)) {
    allTabbable.unshift(container);
  }
  if (!allTabbable.length && fallbackToFocusable) {
    return allFocusable;
  }
  return allTabbable;
}
function getFirstTabbableIn(container, fallbackToFocusable) {
  const [first] = getAllTabbable(container, fallbackToFocusable);
  return first || null;
}
function getLastTabbableIn(container, fallbackToFocusable) {
  const allTabbable = getAllTabbable(container, fallbackToFocusable);
  return allTabbable[allTabbable.length - 1] || null;
}
function getNextTabbable(container, fallbackToFocusable) {
  const allFocusable = getAllFocusable(container);
  const index = allFocusable.indexOf(document.activeElement);
  const slice = allFocusable.slice(index + 1);
  return slice.find(_chunkROURZMX.isTabbable) || allFocusable.find(_chunkROURZMX.isTabbable) || (fallbackToFocusable ? slice[0] : null);
}
function getPreviousTabbable(container, fallbackToFocusable) {
  const allFocusable = getAllFocusable(container).reverse();
  const index = allFocusable.indexOf(document.activeElement);
  const slice = allFocusable.slice(index + 1);
  return slice.find(_chunkROURZMX.isTabbable) || allFocusable.find(_chunkROURZMX.isTabbable) || (fallbackToFocusable ? slice[0] : null);
}
},{"./chunk-ROURZMX4.mjs":"kAyN","./chunk-3XANSPY5.mjs":"I3IU"}],"fXis":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFocusOnHide = useFocusOnHide;
exports.useFocusOnShow = useFocusOnShow;
var _domUtils = require("@chakra-ui/dom-utils");
var _reactUseEventListener = require("@chakra-ui/react-use-event-listener");
var _reactUseSafeLayoutEffect = require("@chakra-ui/react-use-safe-layout-effect");
var _reactUseUpdateEffect = require("@chakra-ui/react-use-update-effect");
var _react = require("react");
// src/index.ts

function preventReturnFocus(containerRef) {
  const el = containerRef.current;
  if (!el) return false;
  const activeElement = (0, _domUtils.getActiveElement)(el);
  if (!activeElement) return false;
  if (el.contains(activeElement)) return false;
  if ((0, _domUtils.isTabbable)(activeElement)) return true;
  return false;
}
function useFocusOnHide(containerRef, options) {
  const {
    shouldFocus: shouldFocusProp,
    visible,
    focusRef
  } = options;
  const shouldFocus = shouldFocusProp && !visible;
  (0, _reactUseUpdateEffect.useUpdateEffect)(() => {
    if (!shouldFocus) return;
    if (preventReturnFocus(containerRef)) {
      return;
    }
    const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;
    if (el) {
      requestAnimationFrame(() => {
        el.focus();
      });
    }
  }, [shouldFocus, containerRef, focusRef]);
}
var defaultOptions = {
  preventScroll: true,
  shouldFocus: false
};
function useFocusOnShow(target, options = defaultOptions) {
  const {
    focusRef,
    preventScroll,
    shouldFocus,
    visible
  } = options;
  const element = isRefObject(target) ? target.current : target;
  const autoFocusValue = shouldFocus && visible;
  const autoFocusRef = (0, _react.useRef)(autoFocusValue);
  const lastVisibleRef = (0, _react.useRef)(visible);
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => {
    if (!lastVisibleRef.current && visible) {
      autoFocusRef.current = autoFocusValue;
    }
    lastVisibleRef.current = visible;
  }, [visible, autoFocusValue]);
  const onFocus = (0, _react.useCallback)(() => {
    if (!visible || !element || !autoFocusRef.current) return;
    autoFocusRef.current = false;
    if (element.contains(document.activeElement)) return;
    if (focusRef == null ? void 0 : focusRef.current) {
      requestAnimationFrame(() => {
        var _a;
        (_a = focusRef.current) == null ? void 0 : _a.focus({
          preventScroll
        });
      });
    } else {
      const tabbableEls = (0, _domUtils.getAllFocusable)(element);
      if (tabbableEls.length > 0) {
        requestAnimationFrame(() => {
          tabbableEls[0].focus({
            preventScroll
          });
        });
      }
    }
  }, [visible, preventScroll, element, focusRef]);
  (0, _reactUseUpdateEffect.useUpdateEffect)(() => {
    onFocus();
  }, [onFocus]);
  (0, _reactUseEventListener.useEventListener)(element, "transitionend", onFocus);
}
function isRefObject(val) {
  return "current" in val;
}
},{"@chakra-ui/dom-utils":"p6n0","@chakra-ui/react-use-event-listener":"Lu7g","@chakra-ui/react-use-safe-layout-effect":"cYtR","@chakra-ui/react-use-update-effect":"GqG2","react":"n8MK"}],"zC9F":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cssVars = void 0;
exports.getBoxShadow = getBoxShadow;
exports.getEventListenerOptions = getEventListenerOptions;
exports.toTransformOrigin = void 0;
// src/utils.ts
var toVar = (value, fallback) => ({
  var: value,
  varRef: fallback ? `var(${value}, ${fallback})` : `var(${value})`
});
var cssVars = {
  arrowShadowColor: toVar("--popper-arrow-shadow-color"),
  arrowSize: toVar("--popper-arrow-size", "8px"),
  arrowSizeHalf: toVar("--popper-arrow-size-half"),
  arrowBg: toVar("--popper-arrow-bg"),
  transformOrigin: toVar("--popper-transform-origin"),
  arrowOffset: toVar("--popper-arrow-offset")
};
exports.cssVars = cssVars;
function getBoxShadow(placement) {
  if (placement.includes("top")) return `1px 1px 1px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("bottom")) return `-1px -1px 1px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("right")) return `-1px 1px 1px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("left")) return `1px -1px 1px 0 var(--popper-arrow-shadow-color)`;
}
var transforms = {
  top: "bottom center",
  "top-start": "bottom left",
  "top-end": "bottom right",
  bottom: "top center",
  "bottom-start": "top left",
  "bottom-end": "top right",
  left: "right center",
  "left-start": "right top",
  "left-end": "right bottom",
  right: "left center",
  "right-start": "left top",
  "right-end": "left bottom"
};
var toTransformOrigin = placement => transforms[placement];
exports.toTransformOrigin = toTransformOrigin;
var defaultEventListeners = {
  scroll: true,
  resize: true
};
function getEventListenerOptions(value) {
  let eventListeners;
  if (typeof value === "object") {
    eventListeners = {
      enabled: true,
      options: {
        ...defaultEventListeners,
        ...value
      }
    };
  } else {
    eventListeners = {
      enabled: value,
      options: defaultEventListeners
    };
  }
  return eventListeners;
}
},{}],"FAAS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformOrigin = exports.positionArrow = exports.matchWidth = exports.innerArrow = void 0;
var _chunkQAKUNGSB = require("./chunk-QAKUNGSB.mjs");
// src/modifiers.ts
var matchWidth = {
  name: "matchWidth",
  enabled: true,
  phase: "beforeWrite",
  requires: ["computeStyles"],
  fn: ({
    state
  }) => {
    state.styles.popper.width = `${state.rects.reference.width}px`;
  },
  effect: ({
    state
  }) => () => {
    const reference = state.elements.reference;
    state.elements.popper.style.width = `${reference.offsetWidth}px`;
  }
};
exports.matchWidth = matchWidth;
var transformOrigin = {
  name: "transformOrigin",
  enabled: true,
  phase: "write",
  fn: ({
    state
  }) => {
    setTransformOrigin(state);
  },
  effect: ({
    state
  }) => () => {
    setTransformOrigin(state);
  }
};
exports.transformOrigin = transformOrigin;
var setTransformOrigin = state => {
  state.elements.popper.style.setProperty(_chunkQAKUNGSB.cssVars.transformOrigin.var, (0, _chunkQAKUNGSB.toTransformOrigin)(state.placement));
};
var positionArrow = {
  name: "positionArrow",
  enabled: true,
  phase: "afterWrite",
  fn: ({
    state
  }) => {
    setArrowStyles(state);
  }
};
exports.positionArrow = positionArrow;
var setArrowStyles = state => {
  var _a;
  if (!state.placement) return;
  const overrides = getArrowStyle(state.placement);
  if (((_a = state.elements) == null ? void 0 : _a.arrow) && overrides) {
    Object.assign(state.elements.arrow.style, {
      [overrides.property]: overrides.value,
      width: _chunkQAKUNGSB.cssVars.arrowSize.varRef,
      height: _chunkQAKUNGSB.cssVars.arrowSize.varRef,
      zIndex: -1
    });
    const vars = {
      [_chunkQAKUNGSB.cssVars.arrowSizeHalf.var]: `calc(${_chunkQAKUNGSB.cssVars.arrowSize.varRef} / 2)`,
      [_chunkQAKUNGSB.cssVars.arrowOffset.var]: `calc(${_chunkQAKUNGSB.cssVars.arrowSizeHalf.varRef} * -1)`
    };
    for (const property in vars) {
      state.elements.arrow.style.setProperty(property, vars[property]);
    }
  }
};
var getArrowStyle = placement => {
  if (placement.startsWith("top")) {
    return {
      property: "bottom",
      value: _chunkQAKUNGSB.cssVars.arrowOffset.varRef
    };
  }
  if (placement.startsWith("bottom")) {
    return {
      property: "top",
      value: _chunkQAKUNGSB.cssVars.arrowOffset.varRef
    };
  }
  if (placement.startsWith("left")) {
    return {
      property: "right",
      value: _chunkQAKUNGSB.cssVars.arrowOffset.varRef
    };
  }
  if (placement.startsWith("right")) {
    return {
      property: "left",
      value: _chunkQAKUNGSB.cssVars.arrowOffset.varRef
    };
  }
};
var innerArrow = {
  name: "innerArrow",
  enabled: true,
  phase: "main",
  requires: ["arrow"],
  fn: ({
    state
  }) => {
    setInnerArrowStyles(state);
  },
  effect: ({
    state
  }) => () => {
    setInnerArrowStyles(state);
  }
};
exports.innerArrow = innerArrow;
var setInnerArrowStyles = state => {
  if (!state.elements.arrow) return;
  const inner = state.elements.arrow.querySelector("[data-popper-arrow-inner]");
  if (!inner) return;
  const boxShadow = (0, _chunkQAKUNGSB.getBoxShadow)(state.placement);
  if (boxShadow) {
    inner.style.setProperty("--popper-arrow-default-shadow", boxShadow);
  }
  Object.assign(inner.style, {
    transform: "rotate(45deg)",
    background: _chunkQAKUNGSB.cssVars.arrowBg.varRef,
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    position: "absolute",
    zIndex: "inherit",
    boxShadow: `var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))`
  });
};
},{"./chunk-QAKUNGSB.mjs":"zC9F"}],"fNdf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPopperPlacement = getPopperPlacement;
// src/popper.placement.ts
var logicals = {
  "start-start": {
    ltr: "left-start",
    rtl: "right-start"
  },
  "start-end": {
    ltr: "left-end",
    rtl: "right-end"
  },
  "end-start": {
    ltr: "right-start",
    rtl: "left-start"
  },
  "end-end": {
    ltr: "right-end",
    rtl: "left-end"
  },
  start: {
    ltr: "left",
    rtl: "right"
  },
  end: {
    ltr: "right",
    rtl: "left"
  }
};
var opposites = {
  "auto-start": "auto-end",
  "auto-end": "auto-start",
  "top-start": "top-end",
  "top-end": "top-start",
  "bottom-start": "bottom-end",
  "bottom-end": "bottom-start"
};
function getPopperPlacement(placement, dir = "ltr") {
  var _a, _b;
  const value = ((_a = logicals[placement]) == null ? void 0 : _a[dir]) || placement;
  if (dir === "ltr") return value;
  return (_b = opposites[placement]) != null ? _b : value;
}
},{}],"XHUo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.write = exports.viewport = exports.variationPlacements = exports.top = exports.start = exports.right = exports.reference = exports.read = exports.popper = exports.placements = exports.modifierPhases = exports.main = exports.left = exports.end = exports.clippingParents = exports.bottom = exports.beforeWrite = exports.beforeRead = exports.beforeMain = exports.basePlacements = exports.auto = exports.afterWrite = exports.afterRead = exports.afterMain = void 0;
var top = 'top';
exports.top = top;
var bottom = 'bottom';
exports.bottom = bottom;
var right = 'right';
exports.right = right;
var left = 'left';
exports.left = left;
var auto = 'auto';
exports.auto = auto;
var basePlacements = [top, bottom, right, left];
exports.basePlacements = basePlacements;
var start = 'start';
exports.start = start;
var end = 'end';
exports.end = end;
var clippingParents = 'clippingParents';
exports.clippingParents = clippingParents;
var viewport = 'viewport';
exports.viewport = viewport;
var popper = 'popper';
exports.popper = popper;
var reference = 'reference';
exports.reference = reference;
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
exports.variationPlacements = variationPlacements;
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM
exports.placements = placements;
var beforeRead = 'beforeRead';
exports.beforeRead = beforeRead;
var read = 'read';
exports.read = read;
var afterRead = 'afterRead'; // pure-logic modifiers
exports.afterRead = afterRead;
var beforeMain = 'beforeMain';
exports.beforeMain = beforeMain;
var main = 'main';
exports.main = main;
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)
exports.afterMain = afterMain;
var beforeWrite = 'beforeWrite';
exports.beforeWrite = beforeWrite;
var write = 'write';
exports.write = write;
var afterWrite = 'afterWrite';
exports.afterWrite = afterWrite;
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
exports.modifierPhases = modifierPhases;
},{}],"B1zX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getNodeName;
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}
},{}],"QiNa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getWindow;
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
},{}],"wsKO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isElement = isElement;
exports.isHTMLElement = isHTMLElement;
exports.isShadowRoot = isShadowRoot;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isElement(node) {
  var OwnElement = (0, _getWindow.default)(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = (0, _getWindow.default)(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  var OwnElement = (0, _getWindow.default)(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
},{"./getWindow.js":"QiNa"}],"D2nT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _getNodeName = _interopRequireDefault(require("../dom-utils/getNodeName.js"));
var _instanceOf = require("../dom-utils/instanceOf.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0, _instanceOf.isHTMLElement)(element) || !(0, _getNodeName.default)(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]

    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];
      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0, _instanceOf.isHTMLElement)(element) || !(0, _getNodeName.default)(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules
var _default = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
};
exports.default = _default;
},{"../dom-utils/getNodeName.js":"B1zX","../dom-utils/instanceOf.js":"wsKO"}],"QS9h":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBasePlacement;
var _enums = require("../enums.js");
function getBasePlacement(placement) {
  return placement.split('-')[0];
}
},{"../enums.js":"XHUo"}],"FuL6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.round = exports.min = exports.max = void 0;
var max = Math.max;
exports.max = max;
var min = Math.min;
exports.min = min;
var round = Math.round;
exports.round = round;
},{}],"iVQY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getUAString;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }
  return navigator.userAgent;
}
},{}],"Y717":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isLayoutViewport;
var _userAgent = _interopRequireDefault(require("../utils/userAgent.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test((0, _userAgent.default)());
}
},{"../utils/userAgent.js":"iVQY"}],"W8bA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBoundingClientRect;
var _instanceOf = require("./instanceOf.js");
var _math = require("../utils/math.js");
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _isLayoutViewport = _interopRequireDefault(require("./isLayoutViewport.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && (0, _instanceOf.isHTMLElement)(element)) {
    scaleX = element.offsetWidth > 0 ? (0, _math.round)(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? (0, _math.round)(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = (0, _instanceOf.isElement)(element) ? (0, _getWindow.default)(element) : window,
    visualViewport = _ref.visualViewport;
  var addVisualOffsets = !(0, _isLayoutViewport.default)() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}
},{"./instanceOf.js":"wsKO","../utils/math.js":"FuL6","./getWindow.js":"QiNa","./isLayoutViewport.js":"Y717"}],"wDsK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getLayoutRect;
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = (0, _getBoundingClientRect.default)(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}
},{"./getBoundingClientRect.js":"W8bA"}],"x3Ja":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = contains;
var _instanceOf = require("./instanceOf.js");
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && (0, _instanceOf.isShadowRoot)(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      } // $FlowFixMe[prop-missing]: need a better way to handle this...

      next = next.parentNode || next.host;
    } while (next);
  } // Give up, the result is false

  return false;
}
},{"./instanceOf.js":"wsKO"}],"S6rb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getComputedStyle;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getComputedStyle(element) {
  return (0, _getWindow.default)(element).getComputedStyle(element);
}
},{"./getWindow.js":"QiNa"}],"rK11":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isTableElement;
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0, _getNodeName.default)(element)) >= 0;
}
},{"./getNodeName.js":"B1zX"}],"sJcE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getDocumentElement;
var _instanceOf = require("./instanceOf.js");
function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return (((0, _instanceOf.isElement)(element) ? element.ownerDocument :
  // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}
},{"./instanceOf.js":"wsKO"}],"IVKl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getParentNode;
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _instanceOf = require("./instanceOf.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getParentNode(element) {
  if ((0, _getNodeName.default)(element) === 'html') {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot ||
    // step into the shadow DOM of the parent of a slotted node
    element.parentNode || (
    // DOM Element detected
    (0, _instanceOf.isShadowRoot)(element) ? element.host : null) ||
    // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0, _getDocumentElement.default)(element) // fallback
  );
}
},{"./getNodeName.js":"B1zX","./getDocumentElement.js":"sJcE","./instanceOf.js":"wsKO"}],"CUhI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOffsetParent;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));
var _instanceOf = require("./instanceOf.js");
var _isTableElement = _interopRequireDefault(require("./isTableElement.js"));
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _userAgent = _interopRequireDefault(require("../utils/userAgent.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getTrueOffsetParent(element) {
  if (!(0, _instanceOf.isHTMLElement)(element) ||
  // https://github.com/popperjs/popper-core/issues/837
  (0, _getComputedStyle.default)(element).position === 'fixed') {
    return null;
  }
  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block

function getContainingBlock(element) {
  var isFirefox = /firefox/i.test((0, _userAgent.default)());
  var isIE = /Trident/i.test((0, _userAgent.default)());
  if (isIE && (0, _instanceOf.isHTMLElement)(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = (0, _getComputedStyle.default)(element);
    if (elementCss.position === 'fixed') {
      return null;
    }
  }
  var currentNode = (0, _getParentNode.default)(element);
  if ((0, _instanceOf.isShadowRoot)(currentNode)) {
    currentNode = currentNode.host;
  }
  while ((0, _instanceOf.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0, _getNodeName.default)(currentNode)) < 0) {
    var css = (0, _getComputedStyle.default)(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.

function getOffsetParent(element) {
  var window = (0, _getWindow.default)(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && (0, _isTableElement.default)(offsetParent) && (0, _getComputedStyle.default)(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && ((0, _getNodeName.default)(offsetParent) === 'html' || (0, _getNodeName.default)(offsetParent) === 'body' && (0, _getComputedStyle.default)(offsetParent).position === 'static')) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}
},{"./getWindow.js":"QiNa","./getNodeName.js":"B1zX","./getComputedStyle.js":"S6rb","./instanceOf.js":"wsKO","./isTableElement.js":"rK11","./getParentNode.js":"IVKl","../utils/userAgent.js":"iVQY"}],"PMyK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getMainAxisFromPlacement;
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}
},{}],"FbIu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.within = within;
exports.withinMaxClamp = withinMaxClamp;
var _math = require("./math.js");
function within(min, value, max) {
  return (0, _math.max)(min, (0, _math.min)(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}
},{"./math.js":"FuL6"}],"a0QL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFreshSideObject;
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
},{}],"SCz0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mergePaddingObject;
var _getFreshSideObject = _interopRequireDefault(require("./getFreshSideObject.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0, _getFreshSideObject.default)(), paddingObject);
}
},{"./getFreshSideObject.js":"a0QL"}],"sYkG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = expandToHashMap;
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
},{}],"zJlD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getLayoutRect = _interopRequireDefault(require("../dom-utils/getLayoutRect.js"));
var _contains = _interopRequireDefault(require("../dom-utils/contains.js"));
var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));
var _getMainAxisFromPlacement = _interopRequireDefault(require("../utils/getMainAxisFromPlacement.js"));
var _within = require("../utils/within.js");
var _mergePaddingObject = _interopRequireDefault(require("../utils/mergePaddingObject.js"));
var _expandToHashMap = _interopRequireDefault(require("../utils/expandToHashMap.js"));
var _enums = require("../enums.js");
var _instanceOf = require("../dom-utils/instanceOf.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return (0, _mergePaddingObject.default)(typeof padding !== 'number' ? padding : (0, _expandToHashMap.default)(padding, _enums.basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state,
    name = _ref.name,
    options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0, _getBasePlacement.default)(state.placement);
  var axis = (0, _getMainAxisFromPlacement.default)(basePlacement);
  var isVertical = [_enums.left, _enums.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';
  if (!arrowElement || !popperOffsets) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = (0, _getLayoutRect.default)(arrowElement);
  var minProp = axis === 'y' ? _enums.top : _enums.left;
  var maxProp = axis === 'y' ? _enums.bottom : _enums.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0, _getOffsetParent.default)(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0, _within.within)(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
  var state = _ref2.state,
    options = _ref2.options;
  var _options$element = options.element,
    arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
  if (arrowElement == null) {
    return;
  } // CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if ("production" !== "production") {
    if (!(0, _instanceOf.isHTMLElement)(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }
  if (!(0, _contains.default)(state.elements.popper, arrowElement)) {
    if ("production" !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }
    return;
  }
  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules
var _default = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};
exports.default = _default;
},{"../utils/getBasePlacement.js":"QS9h","../dom-utils/getLayoutRect.js":"wDsK","../dom-utils/contains.js":"x3Ja","../dom-utils/getOffsetParent.js":"CUhI","../utils/getMainAxisFromPlacement.js":"PMyK","../utils/within.js":"FbIu","../utils/mergePaddingObject.js":"SCz0","../utils/expandToHashMap.js":"sYkG","../enums.js":"XHUo","../dom-utils/instanceOf.js":"wsKO"}],"auH8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getVariation;
function getVariation(placement) {
  return placement.split('-')[1];
}
},{}],"ebtt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.mapToStyles = mapToStyles;
var _enums = require("../enums.js");
var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));
var _getWindow = _interopRequireDefault(require("../dom-utils/getWindow.js"));
var _getDocumentElement = _interopRequireDefault(require("../dom-utils/getDocumentElement.js"));
var _getComputedStyle = _interopRequireDefault(require("../dom-utils/getComputedStyle.js"));
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
    y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: (0, _math.round)(x * dpr) / dpr || 0,
    y: (0, _math.round)(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper = _ref2.popper,
    popperRect = _ref2.popperRect,
    placement = _ref2.placement,
    variation = _ref2.variation,
    offsets = _ref2.offsets,
    position = _ref2.position,
    gpuAcceleration = _ref2.gpuAcceleration,
    adaptive = _ref2.adaptive,
    roundOffsets = _ref2.roundOffsets,
    isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
    x = _offsets$x === void 0 ? 0 : _offsets$x,
    _offsets$y = offsets.y,
    y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums.left;
  var sideY = _enums.top;
  var win = window;
  if (adaptive) {
    var offsetParent = (0, _getOffsetParent.default)(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';
    if (offsetParent === (0, _getWindow.default)(popper)) {
      offsetParent = (0, _getDocumentElement.default)(popper);
      if ((0, _getComputedStyle.default)(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    offsetParent = offsetParent;
    if (placement === _enums.top || (placement === _enums.left || placement === _enums.right) && variation === _enums.end) {
      sideY = _enums.bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :
      // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === _enums.left || (placement === _enums.top || placement === _enums.bottom) && variation === _enums.end) {
      sideX = _enums.right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :
      // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state,
    options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
    gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
    _options$adaptive = options.adaptive,
    adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
    _options$roundOffsets = options.roundOffsets,
    roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if ("production" !== "production") {
    var transitionProperty = (0, _getComputedStyle.default)(state.elements.popper).transitionProperty || '';
    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }
  var commonStyles = {
    placement: (0, _getBasePlacement.default)(state.placement),
    variation: (0, _getVariation.default)(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules
var _default = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};
exports.default = _default;
},{"../enums.js":"XHUo","../dom-utils/getOffsetParent.js":"CUhI","../dom-utils/getWindow.js":"QiNa","../dom-utils/getDocumentElement.js":"sJcE","../dom-utils/getComputedStyle.js":"S6rb","../utils/getBasePlacement.js":"QS9h","../utils/getVariation.js":"auH8","../utils/math.js":"FuL6"}],"psGJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _getWindow = _interopRequireDefault(require("../dom-utils/getWindow.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state,
    instance = _ref.instance,
    options = _ref.options;
  var _options$scroll = options.scroll,
    scroll = _options$scroll === void 0 ? true : _options$scroll,
    _options$resize = options.resize,
    resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0, _getWindow.default)(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }
  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }
  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }
    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules
var _default = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};
exports.default = _default;
},{"../dom-utils/getWindow.js":"QiNa"}],"M6e4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOppositePlacement;
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
},{}],"lLmA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOppositeVariationPlacement;
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}
},{}],"oJ75":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getWindowScroll;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getWindowScroll(node) {
  var win = (0, _getWindow.default)(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}
},{"./getWindow.js":"QiNa"}],"zwcJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getWindowScrollBarX;
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0, _getBoundingClientRect.default)((0, _getDocumentElement.default)(element)).left + (0, _getWindowScroll.default)(element).scrollLeft;
}
},{"./getBoundingClientRect.js":"W8bA","./getDocumentElement.js":"sJcE","./getWindowScroll.js":"oJ75"}],"E2lw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getViewportRect;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));
var _isLayoutViewport = _interopRequireDefault(require("./isLayoutViewport.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getViewportRect(element, strategy) {
  var win = (0, _getWindow.default)(element);
  var html = (0, _getDocumentElement.default)(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = (0, _isLayoutViewport.default)();
    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width,
    height: height,
    x: x + (0, _getWindowScrollBarX.default)(element),
    y: y
  };
}
},{"./getWindow.js":"QiNa","./getDocumentElement.js":"sJcE","./getWindowScrollBarX.js":"zwcJ","./isLayoutViewport.js":"Y717"}],"yEje":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getDocumentRect;
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));
var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));
var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = (0, _getDocumentElement.default)(element);
  var winScroll = (0, _getWindowScroll.default)(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = (0, _math.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = (0, _math.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + (0, _getWindowScrollBarX.default)(element);
  var y = -winScroll.scrollTop;
  if ((0, _getComputedStyle.default)(body || html).direction === 'rtl') {
    x += (0, _math.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}
},{"./getDocumentElement.js":"sJcE","./getComputedStyle.js":"S6rb","./getWindowScrollBarX.js":"zwcJ","./getWindowScroll.js":"oJ75","../utils/math.js":"FuL6"}],"j3Hf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isScrollParent;
var _getComputedStyle2 = _interopRequireDefault(require("./getComputedStyle.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0, _getComputedStyle2.default)(element),
    overflow = _getComputedStyle.overflow,
    overflowX = _getComputedStyle.overflowX,
    overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
},{"./getComputedStyle.js":"S6rb"}],"Qnrt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getScrollParent;
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _instanceOf = require("./instanceOf.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0, _getNodeName.default)(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }
  if ((0, _instanceOf.isHTMLElement)(node) && (0, _isScrollParent.default)(node)) {
    return node;
  }
  return getScrollParent((0, _getParentNode.default)(node));
}
},{"./getParentNode.js":"IVKl","./isScrollParent.js":"j3Hf","./getNodeName.js":"B1zX","./instanceOf.js":"wsKO"}],"m3DJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = listScrollParents;
var _getScrollParent = _interopRequireDefault(require("./getScrollParent.js"));
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = (0, _getScrollParent.default)(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = (0, _getWindow.default)(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0, _isScrollParent.default)(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList :
  // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0, _getParentNode.default)(target)));
}
},{"./getScrollParent.js":"Qnrt","./getParentNode.js":"IVKl","./getWindow.js":"QiNa","./isScrollParent.js":"j3Hf"}],"rB0G":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rectToClientRect;
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
},{}],"M7BJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getClippingRect;
var _enums = require("../enums.js");
var _getViewportRect = _interopRequireDefault(require("./getViewportRect.js"));
var _getDocumentRect = _interopRequireDefault(require("./getDocumentRect.js"));
var _listScrollParents = _interopRequireDefault(require("./listScrollParents.js"));
var _getOffsetParent = _interopRequireDefault(require("./getOffsetParent.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));
var _instanceOf = require("./instanceOf.js");
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _contains = _interopRequireDefault(require("./contains.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _rectToClientRect = _interopRequireDefault(require("../utils/rectToClientRect.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getInnerBoundingClientRect(element, strategy) {
  var rect = (0, _getBoundingClientRect.default)(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === _enums.viewport ? (0, _rectToClientRect.default)((0, _getViewportRect.default)(element, strategy)) : (0, _instanceOf.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0, _rectToClientRect.default)((0, _getDocumentRect.default)((0, _getDocumentElement.default)(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`

function getClippingParents(element) {
  var clippingParents = (0, _listScrollParents.default)((0, _getParentNode.default)(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0, _getComputedStyle.default)(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0, _instanceOf.isHTMLElement)(element) ? (0, _getOffsetParent.default)(element) : element;
  if (!(0, _instanceOf.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

  return clippingParents.filter(function (clippingParent) {
    return (0, _instanceOf.isElement)(clippingParent) && (0, _contains.default)(clippingParent, clipperElement) && (0, _getNodeName.default)(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents

function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = (0, _math.max)(rect.top, accRect.top);
    accRect.right = (0, _math.min)(rect.right, accRect.right);
    accRect.bottom = (0, _math.min)(rect.bottom, accRect.bottom);
    accRect.left = (0, _math.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
},{"../enums.js":"XHUo","./getViewportRect.js":"E2lw","./getDocumentRect.js":"yEje","./listScrollParents.js":"m3DJ","./getOffsetParent.js":"CUhI","./getDocumentElement.js":"sJcE","./getComputedStyle.js":"S6rb","./instanceOf.js":"wsKO","./getBoundingClientRect.js":"W8bA","./getParentNode.js":"IVKl","./contains.js":"x3Ja","./getNodeName.js":"B1zX","../utils/rectToClientRect.js":"rB0G","../utils/math.js":"FuL6"}],"dvfD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = computeOffsets;
var _getBasePlacement = _interopRequireDefault(require("./getBasePlacement.js"));
var _getVariation = _interopRequireDefault(require("./getVariation.js"));
var _getMainAxisFromPlacement = _interopRequireDefault(require("./getMainAxisFromPlacement.js"));
var _enums = require("../enums.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function computeOffsets(_ref) {
  var reference = _ref.reference,
    element = _ref.element,
    placement = _ref.placement;
  var basePlacement = placement ? (0, _getBasePlacement.default)(placement) : null;
  var variation = placement ? (0, _getVariation.default)(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case _enums.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;
    case _enums.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case _enums.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case _enums.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }
  var mainAxis = basePlacement ? (0, _getMainAxisFromPlacement.default)(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';
    switch (variation) {
      case _enums.start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;
      case _enums.end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}
},{"./getBasePlacement.js":"QS9h","./getVariation.js":"auH8","./getMainAxisFromPlacement.js":"PMyK","../enums.js":"XHUo"}],"Moke":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = detectOverflow;
var _getClippingRect = _interopRequireDefault(require("../dom-utils/getClippingRect.js"));
var _getDocumentElement = _interopRequireDefault(require("../dom-utils/getDocumentElement.js"));
var _getBoundingClientRect = _interopRequireDefault(require("../dom-utils/getBoundingClientRect.js"));
var _computeOffsets = _interopRequireDefault(require("./computeOffsets.js"));
var _rectToClientRect = _interopRequireDefault(require("./rectToClientRect.js"));
var _enums = require("../enums.js");
var _instanceOf = require("../dom-utils/instanceOf.js");
var _mergePaddingObject = _interopRequireDefault(require("./mergePaddingObject.js"));
var _expandToHashMap = _interopRequireDefault(require("./expandToHashMap.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    _options$placement = _options.placement,
    placement = _options$placement === void 0 ? state.placement : _options$placement,
    _options$strategy = _options.strategy,
    strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
    _options$boundary = _options.boundary,
    boundary = _options$boundary === void 0 ? _enums.clippingParents : _options$boundary,
    _options$rootBoundary = _options.rootBoundary,
    rootBoundary = _options$rootBoundary === void 0 ? _enums.viewport : _options$rootBoundary,
    _options$elementConte = _options.elementContext,
    elementContext = _options$elementConte === void 0 ? _enums.popper : _options$elementConte,
    _options$altBoundary = _options.altBoundary,
    altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
    _options$padding = _options.padding,
    padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0, _mergePaddingObject.default)(typeof padding !== 'number' ? padding : (0, _expandToHashMap.default)(padding, _enums.basePlacements));
  var altContext = elementContext === _enums.popper ? _enums.reference : _enums.popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0, _getClippingRect.default)((0, _instanceOf.isElement)(element) ? element : element.contextElement || (0, _getDocumentElement.default)(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = (0, _getBoundingClientRect.default)(state.elements.reference);
  var popperOffsets = (0, _computeOffsets.default)({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0, _rectToClientRect.default)(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === _enums.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums.right, _enums.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums.top, _enums.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }
  return overflowOffsets;
}
},{"../dom-utils/getClippingRect.js":"M7BJ","../dom-utils/getDocumentElement.js":"sJcE","../dom-utils/getBoundingClientRect.js":"W8bA","./computeOffsets.js":"dvfD","./rectToClientRect.js":"rB0G","../enums.js":"XHUo","../dom-utils/instanceOf.js":"wsKO","./mergePaddingObject.js":"SCz0","./expandToHashMap.js":"sYkG"}],"HhJi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = computeAutoPlacement;
var _getVariation = _interopRequireDefault(require("./getVariation.js"));
var _enums = require("../enums.js");
var _detectOverflow = _interopRequireDefault(require("./detectOverflow.js"));
var _getBasePlacement = _interopRequireDefault(require("./getBasePlacement.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    placement = _options.placement,
    boundary = _options.boundary,
    rootBoundary = _options.rootBoundary,
    padding = _options.padding,
    flipVariations = _options.flipVariations,
    _options$allowedAutoP = _options.allowedAutoPlacements,
    allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums.placements : _options$allowedAutoP;
  var variation = (0, _getVariation.default)(placement);
  var placements = variation ? flipVariations ? _enums.variationPlacements : _enums.variationPlacements.filter(function (placement) {
    return (0, _getVariation.default)(placement) === variation;
  }) : _enums.basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;
    if ("production" !== "production") {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = (0, _detectOverflow.default)(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0, _getBasePlacement.default)(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}
},{"./getVariation.js":"auH8","../enums.js":"XHUo","./detectOverflow.js":"Moke","./getBasePlacement.js":"QS9h"}],"rNoN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _getOppositePlacement = _interopRequireDefault(require("../utils/getOppositePlacement.js"));
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getOppositeVariationPlacement = _interopRequireDefault(require("../utils/getOppositeVariationPlacement.js"));
var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));
var _computeAutoPlacement = _interopRequireDefault(require("../utils/computeAutoPlacement.js"));
var _enums = require("../enums.js");
var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0, _getBasePlacement.default)(placement) === _enums.auto) {
    return [];
  }
  var oppositePlacement = (0, _getOppositePlacement.default)(placement);
  return [(0, _getOppositeVariationPlacement.default)(placement), oppositePlacement, (0, _getOppositeVariationPlacement.default)(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
    specifiedFallbackPlacements = options.fallbackPlacements,
    padding = options.padding,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    _options$flipVariatio = options.flipVariations,
    flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
    allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0, _getBasePlacement.default)(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0, _getOppositePlacement.default)(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0, _getBasePlacement.default)(placement) === _enums.auto ? (0, _computeAutoPlacement.default)(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];
  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];
    var _basePlacement = (0, _getBasePlacement.default)(placement);
    var isStartVariation = (0, _getVariation.default)(placement) === _enums.start;
    var isVertical = [_enums.top, _enums.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0, _detectOverflow.default)(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums.right : _enums.left : isStartVariation ? _enums.bottom : _enums.top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0, _getOppositePlacement.default)(mainVariationSide);
    }
    var altVariationSide = (0, _getOppositePlacement.default)(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules
var _default = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};
exports.default = _default;
},{"../utils/getOppositePlacement.js":"M6e4","../utils/getBasePlacement.js":"QS9h","../utils/getOppositeVariationPlacement.js":"lLmA","../utils/detectOverflow.js":"Moke","../utils/computeAutoPlacement.js":"HhJi","../enums.js":"XHUo","../utils/getVariation.js":"auH8"}],"jhaw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _enums = require("../enums.js");
var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [_enums.top, _enums.right, _enums.bottom, _enums.left].some(function (side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state,
    name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0, _detectOverflow.default)(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0, _detectOverflow.default)(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules
var _default = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};
exports.default = _default;
},{"../enums.js":"XHUo","../utils/detectOverflow.js":"Moke"}],"aUNc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.distanceAndSkiddingToXY = distanceAndSkiddingToXY;
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _enums = require("../enums.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0, _getBasePlacement.default)(placement);
  var invertDistance = [_enums.left, _enums.top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
    skidding = _ref[0],
    distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums.left, _enums.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state,
    options = _ref2.options,
    name = _ref2.name;
  var _options$offset = options.offset,
    offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
    x = _data$state$placement.x,
    y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
var _default = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};
exports.default = _default;
},{"../utils/getBasePlacement.js":"QS9h","../enums.js":"XHUo"}],"Pf8x":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _computeOffsets = _interopRequireDefault(require("../utils/computeOffsets.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function popperOffsets(_ref) {
  var state = _ref.state,
    name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0, _computeOffsets.default)({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules
var _default = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};
exports.default = _default;
},{"../utils/computeOffsets.js":"dvfD"}],"YGKJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getAltAxis;
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
},{}],"RwXk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _enums = require("../enums.js");
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getMainAxisFromPlacement = _interopRequireDefault(require("../utils/getMainAxisFromPlacement.js"));
var _getAltAxis = _interopRequireDefault(require("../utils/getAltAxis.js"));
var _within = require("../utils/within.js");
var _getLayoutRect = _interopRequireDefault(require("../dom-utils/getLayoutRect.js"));
var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));
var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));
var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));
var _getFreshSideObject = _interopRequireDefault(require("../utils/getFreshSideObject.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function preventOverflow(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    padding = options.padding,
    _options$tether = options.tether,
    tether = _options$tether === void 0 ? true : _options$tether,
    _options$tetherOffset = options.tetherOffset,
    tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0, _detectOverflow.default)(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0, _getBasePlacement.default)(state.placement);
  var variation = (0, _getVariation.default)(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0, _getMainAxisFromPlacement.default)(basePlacement);
  var altAxis = (0, _getAltAxis.default)(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === 'y' ? _enums.top : _enums.left;
    var altSide = mainAxis === 'y' ? _enums.bottom : _enums.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0, _getLayoutRect.default)(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0, _getFreshSideObject.default)();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0, _within.within)(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && (0, _getOffsetParent.default)(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = (0, _within.within)(tether ? (0, _math.min)(min, tetherMin) : min, offset, tether ? (0, _math.max)(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === 'x' ? _enums.top : _enums.left;
    var _altSide = mainAxis === 'x' ? _enums.bottom : _enums.right;
    var _offset = popperOffsets[altAxis];
    var _len = altAxis === 'y' ? 'height' : 'width';
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [_enums.top, _enums.left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? (0, _within.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0, _within.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
var _default = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};
exports.default = _default;
},{"../enums.js":"XHUo","../utils/getBasePlacement.js":"QS9h","../utils/getMainAxisFromPlacement.js":"PMyK","../utils/getAltAxis.js":"YGKJ","../utils/within.js":"FbIu","../dom-utils/getLayoutRect.js":"wDsK","../dom-utils/getOffsetParent.js":"CUhI","../utils/detectOverflow.js":"Moke","../utils/getVariation.js":"auH8","../utils/getFreshSideObject.js":"a0QL","../utils/math.js":"FuL6"}],"TOq4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "applyStyles", {
  enumerable: true,
  get: function () {
    return _applyStyles.default;
  }
});
Object.defineProperty(exports, "arrow", {
  enumerable: true,
  get: function () {
    return _arrow.default;
  }
});
Object.defineProperty(exports, "computeStyles", {
  enumerable: true,
  get: function () {
    return _computeStyles.default;
  }
});
Object.defineProperty(exports, "eventListeners", {
  enumerable: true,
  get: function () {
    return _eventListeners.default;
  }
});
Object.defineProperty(exports, "flip", {
  enumerable: true,
  get: function () {
    return _flip.default;
  }
});
Object.defineProperty(exports, "hide", {
  enumerable: true,
  get: function () {
    return _hide.default;
  }
});
Object.defineProperty(exports, "offset", {
  enumerable: true,
  get: function () {
    return _offset.default;
  }
});
Object.defineProperty(exports, "popperOffsets", {
  enumerable: true,
  get: function () {
    return _popperOffsets.default;
  }
});
Object.defineProperty(exports, "preventOverflow", {
  enumerable: true,
  get: function () {
    return _preventOverflow.default;
  }
});
var _applyStyles = _interopRequireDefault(require("./applyStyles.js"));
var _arrow = _interopRequireDefault(require("./arrow.js"));
var _computeStyles = _interopRequireDefault(require("./computeStyles.js"));
var _eventListeners = _interopRequireDefault(require("./eventListeners.js"));
var _flip = _interopRequireDefault(require("./flip.js"));
var _hide = _interopRequireDefault(require("./hide.js"));
var _offset = _interopRequireDefault(require("./offset.js"));
var _popperOffsets = _interopRequireDefault(require("./popperOffsets.js"));
var _preventOverflow = _interopRequireDefault(require("./preventOverflow.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./applyStyles.js":"D2nT","./arrow.js":"zJlD","./computeStyles.js":"ebtt","./eventListeners.js":"psGJ","./flip.js":"rNoN","./hide.js":"jhaw","./offset.js":"aUNc","./popperOffsets.js":"Pf8x","./preventOverflow.js":"RwXk"}],"uy7N":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHTMLElementScroll;
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
},{}],"Cbix":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getNodeScroll;
var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _instanceOf = require("./instanceOf.js");
var _getHTMLElementScroll = _interopRequireDefault(require("./getHTMLElementScroll.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getNodeScroll(node) {
  if (node === (0, _getWindow.default)(node) || !(0, _instanceOf.isHTMLElement)(node)) {
    return (0, _getWindowScroll.default)(node);
  } else {
    return (0, _getHTMLElementScroll.default)(node);
  }
}
},{"./getWindowScroll.js":"oJ75","./getWindow.js":"QiNa","./instanceOf.js":"wsKO","./getHTMLElementScroll.js":"uy7N"}],"FCaM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getCompositeRect;
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
var _getNodeScroll = _interopRequireDefault(require("./getNodeScroll.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _instanceOf = require("./instanceOf.js");
var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = (0, _math.round)(rect.width) / element.offsetWidth || 1;
  var scaleY = (0, _math.round)(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = (0, _instanceOf.isHTMLElement)(offsetParent);
  var offsetParentIsScaled = (0, _instanceOf.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
  var documentElement = (0, _getDocumentElement.default)(offsetParent);
  var rect = (0, _getBoundingClientRect.default)(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0, _getNodeName.default)(offsetParent) !== 'body' ||
    // https://github.com/popperjs/popper-core/issues/1078
    (0, _isScrollParent.default)(documentElement)) {
      scroll = (0, _getNodeScroll.default)(offsetParent);
    }
    if ((0, _instanceOf.isHTMLElement)(offsetParent)) {
      offsets = (0, _getBoundingClientRect.default)(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0, _getWindowScrollBarX.default)(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
},{"./getBoundingClientRect.js":"W8bA","./getNodeScroll.js":"Cbix","./getNodeName.js":"B1zX","./instanceOf.js":"wsKO","./getWindowScrollBarX.js":"zwcJ","./getDocumentElement.js":"sJcE","./isScrollParent.js":"j3Hf","../utils/math.js":"FuL6"}],"mxvt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = orderModifiers;
var _enums = require("../enums.js");
// source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
},{"../enums.js":"XHUo"}],"mGsv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = debounce;
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}
},{}],"JD7L":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = format;
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}
},{}],"nr2q":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateModifiers;
var _format = _interopRequireDefault(require("./format.js"));
var _enums = require("../enums.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
    .filter(function (value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }
          break;
        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }
          break;
        case 'phase':
          if (_enums.modifierPhases.indexOf(modifier.phase) < 0) {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + _enums.modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }
          break;
        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }
          break;
        case 'effect':
          if (modifier.effect != null && typeof modifier.effect !== 'function') {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }
          break;
        case 'requires':
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }
          break;
        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }
          break;
        case 'options':
        case 'data':
          break;
        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }
      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error((0, _format.default)(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}
},{"./format.js":"JD7L","../enums.js":"XHUo"}],"AjzX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uniqueBy;
function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
},{}],"pDli":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mergeByName;
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}
},{}],"rg1d":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPopper = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function () {
    return _detectOverflow.default;
  }
});
exports.popperGenerator = popperGenerator;
var _getCompositeRect = _interopRequireDefault(require("./dom-utils/getCompositeRect.js"));
var _getLayoutRect = _interopRequireDefault(require("./dom-utils/getLayoutRect.js"));
var _listScrollParents = _interopRequireDefault(require("./dom-utils/listScrollParents.js"));
var _getOffsetParent = _interopRequireDefault(require("./dom-utils/getOffsetParent.js"));
var _getComputedStyle2 = _interopRequireDefault(require("./dom-utils/getComputedStyle.js"));
var _orderModifiers = _interopRequireDefault(require("./utils/orderModifiers.js"));
var _debounce = _interopRequireDefault(require("./utils/debounce.js"));
var _validateModifiers = _interopRequireDefault(require("./utils/validateModifiers.js"));
var _uniqueBy = _interopRequireDefault(require("./utils/uniqueBy.js"));
var _getBasePlacement = _interopRequireDefault(require("./utils/getBasePlacement.js"));
var _mergeByName = _interopRequireDefault(require("./utils/mergeByName.js"));
var _detectOverflow = _interopRequireDefault(require("./utils/detectOverflow.js"));
var _instanceOf = require("./dom-utils/instanceOf.js");
var _enums = require("./enums.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions,
    _generatorOptions$def = _generatorOptions.defaultModifiers,
    defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
    _generatorOptions$def2 = _generatorOptions.defaultOptions,
    defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: (0, _instanceOf.isElement)(reference) ? (0, _listScrollParents.default)(reference) : reference.contextElement ? (0, _listScrollParents.default)(reference.contextElement) : [],
          popper: (0, _listScrollParents.default)(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0, _orderModifiers.default)((0, _mergeByName.default)([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if ("production" !== "production") {
          var modifiers = (0, _uniqueBy.default)([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          (0, _validateModifiers.default)(modifiers);
          if ((0, _getBasePlacement.default)(state.options.placement) === _enums.auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }
          var _getComputedStyle = (0, _getComputedStyle2.default)(popper),
            marginTop = _getComputedStyle.marginTop,
            marginRight = _getComputedStyle.marginRight,
            marginBottom = _getComputedStyle.marginBottom,
            marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer

          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements,
          reference = _state$elements.reference,
          popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if ("production" !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        } // Store the reference and popper rects to be read by modifiers

        state.rects = {
          reference: (0, _getCompositeRect.default)(reference, (0, _getOffsetParent.default)(popper), state.options.strategy === 'fixed'),
          popper: (0, _getLayoutRect.default)(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if ("production" !== "production") {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index],
            fn = _state$orderedModifie.fn,
            _state$orderedModifie2 = _state$orderedModifie.options,
            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
            name = _state$orderedModifie.name;
          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0, _debounce.default)(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference, popper)) {
      if ("production" !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
          _ref3$options = _ref3.options,
          options = _ref3$options === void 0 ? {} : _ref3$options,
          effect = _ref3.effect;
        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });
          var noopFn = function noopFn() {};
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules
exports.createPopper = createPopper;
},{"./dom-utils/getCompositeRect.js":"FCaM","./dom-utils/getLayoutRect.js":"wDsK","./dom-utils/listScrollParents.js":"m3DJ","./dom-utils/getOffsetParent.js":"CUhI","./dom-utils/getComputedStyle.js":"S6rb","./utils/orderModifiers.js":"mxvt","./utils/debounce.js":"mGsv","./utils/validateModifiers.js":"nr2q","./utils/uniqueBy.js":"AjzX","./utils/getBasePlacement.js":"QS9h","./utils/mergeByName.js":"pDli","./utils/detectOverflow.js":"Moke","./dom-utils/instanceOf.js":"wsKO","./enums.js":"XHUo"}],"hwU4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultModifiers = exports.createPopper = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function () {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function () {
    return _createPopper.popperGenerator;
  }
});
var _createPopper = require("./createPopper.js");
var _eventListeners = _interopRequireDefault(require("./modifiers/eventListeners.js"));
var _popperOffsets = _interopRequireDefault(require("./modifiers/popperOffsets.js"));
var _computeStyles = _interopRequireDefault(require("./modifiers/computeStyles.js"));
var _applyStyles = _interopRequireDefault(require("./modifiers/applyStyles.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var defaultModifiers = [_eventListeners.default, _popperOffsets.default, _computeStyles.default, _applyStyles.default];
exports.defaultModifiers = defaultModifiers;
var createPopper = /*#__PURE__*/(0, _createPopper.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules
exports.createPopper = createPopper;
},{"./createPopper.js":"rg1d","./modifiers/eventListeners.js":"psGJ","./modifiers/popperOffsets.js":"Pf8x","./modifiers/computeStyles.js":"ebtt","./modifiers/applyStyles.js":"D2nT"}],"cujj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createPopper: true,
  defaultModifiers: true,
  popperGenerator: true,
  detectOverflow: true,
  createPopperLite: true
};
exports.createPopper = void 0;
Object.defineProperty(exports, "createPopperLite", {
  enumerable: true,
  get: function () {
    return _popperLite.createPopper;
  }
});
exports.defaultModifiers = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function () {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function () {
    return _createPopper.popperGenerator;
  }
});
var _createPopper = require("./createPopper.js");
var _eventListeners = _interopRequireDefault(require("./modifiers/eventListeners.js"));
var _popperOffsets = _interopRequireDefault(require("./modifiers/popperOffsets.js"));
var _computeStyles = _interopRequireDefault(require("./modifiers/computeStyles.js"));
var _applyStyles = _interopRequireDefault(require("./modifiers/applyStyles.js"));
var _offset = _interopRequireDefault(require("./modifiers/offset.js"));
var _flip = _interopRequireDefault(require("./modifiers/flip.js"));
var _preventOverflow = _interopRequireDefault(require("./modifiers/preventOverflow.js"));
var _arrow = _interopRequireDefault(require("./modifiers/arrow.js"));
var _hide = _interopRequireDefault(require("./modifiers/hide.js"));
var _popperLite = require("./popper-lite.js");
var _index = require("./modifiers/index.js");
Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var defaultModifiers = [_eventListeners.default, _popperOffsets.default, _computeStyles.default, _applyStyles.default, _offset.default, _flip.default, _preventOverflow.default, _arrow.default, _hide.default];
exports.defaultModifiers = defaultModifiers;
var createPopper = /*#__PURE__*/(0, _createPopper.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules
exports.createPopper = createPopper;
},{"./createPopper.js":"rg1d","./modifiers/eventListeners.js":"psGJ","./modifiers/popperOffsets.js":"Pf8x","./modifiers/computeStyles.js":"ebtt","./modifiers/applyStyles.js":"D2nT","./modifiers/offset.js":"aUNc","./modifiers/flip.js":"rNoN","./modifiers/preventOverflow.js":"RwXk","./modifiers/arrow.js":"zJlD","./modifiers/hide.js":"jhaw","./popper-lite.js":"hwU4","./modifiers/index.js":"TOq4"}],"vePw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  popperGenerator: true,
  detectOverflow: true,
  createPopperBase: true,
  createPopper: true,
  createPopperLite: true
};
Object.defineProperty(exports, "createPopper", {
  enumerable: true,
  get: function () {
    return _popper.createPopper;
  }
});
Object.defineProperty(exports, "createPopperBase", {
  enumerable: true,
  get: function () {
    return _createPopper.createPopper;
  }
});
Object.defineProperty(exports, "createPopperLite", {
  enumerable: true,
  get: function () {
    return _popperLite.createPopper;
  }
});
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function () {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function () {
    return _createPopper.popperGenerator;
  }
});
var _enums = require("./enums.js");
Object.keys(_enums).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _enums[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _enums[key];
    }
  });
});
var _index = require("./modifiers/index.js");
Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});
var _createPopper = require("./createPopper.js");
var _popper = require("./popper.js");
var _popperLite = require("./popper-lite.js");
},{"./enums.js":"XHUo","./modifiers/index.js":"TOq4","./createPopper.js":"rg1d","./popper.js":"cujj","./popper-lite.js":"hwU4"}],"lCnP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePopper = usePopper;
var _chunkSSFABIB = require("./chunk-SSFABIB2.mjs");
var _chunk6DG2E3QO = require("./chunk-6DG2E3QO.mjs");
var _chunkQAKUNGSB = require("./chunk-QAKUNGSB.mjs");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _core = require("@popperjs/core");
var _react = require("react");
// src/use-popper.ts

function usePopper(props = {}) {
  const {
    enabled = true,
    modifiers,
    placement: placementProp = "bottom",
    strategy = "absolute",
    arrowPadding = 8,
    eventListeners = true,
    offset,
    gutter = 8,
    flip = true,
    boundary = "clippingParents",
    preventOverflow = true,
    matchWidth: matchWidth2,
    direction = "ltr"
  } = props;
  const reference = (0, _react.useRef)(null);
  const popper = (0, _react.useRef)(null);
  const instance = (0, _react.useRef)(null);
  const placement = (0, _chunk6DG2E3QO.getPopperPlacement)(placementProp, direction);
  const cleanup = (0, _react.useRef)(() => {});
  const setupPopper = (0, _react.useCallback)(() => {
    var _a;
    if (!enabled || !reference.current || !popper.current) return;
    (_a = cleanup.current) == null ? void 0 : _a.call(cleanup);
    instance.current = (0, _core.createPopper)(reference.current, popper.current, {
      placement,
      modifiers: [_chunkSSFABIB.innerArrow, _chunkSSFABIB.positionArrow, _chunkSSFABIB.transformOrigin, {
        ..._chunkSSFABIB.matchWidth,
        enabled: !!matchWidth2
      }, {
        name: "eventListeners",
        ...(0, _chunkQAKUNGSB.getEventListenerOptions)(eventListeners)
      }, {
        name: "arrow",
        options: {
          padding: arrowPadding
        }
      }, {
        name: "offset",
        options: {
          offset: offset != null ? offset : [0, gutter]
        }
      }, {
        name: "flip",
        enabled: !!flip,
        options: {
          padding: 8
        }
      }, {
        name: "preventOverflow",
        enabled: !!preventOverflow,
        options: {
          boundary
        }
      }, ...(modifiers != null ? modifiers : [])],
      strategy
    });
    instance.current.forceUpdate();
    cleanup.current = instance.current.destroy;
  }, [placement, enabled, modifiers, matchWidth2, eventListeners, arrowPadding, offset, gutter, flip, preventOverflow, boundary, strategy]);
  (0, _react.useEffect)(() => {
    return () => {
      var _a;
      if (!reference.current && !popper.current) {
        (_a = instance.current) == null ? void 0 : _a.destroy();
        instance.current = null;
      }
    };
  }, []);
  const referenceRef = (0, _react.useCallback)(node => {
    reference.current = node;
    setupPopper();
  }, [setupPopper]);
  const getReferenceProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref: (0, _reactUseMergeRefs.mergeRefs)(referenceRef, ref)
  }), [referenceRef]);
  const popperRef = (0, _react.useCallback)(node => {
    popper.current = node;
    setupPopper();
  }, [setupPopper]);
  const getPopperProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref: (0, _reactUseMergeRefs.mergeRefs)(popperRef, ref),
    style: {
      ...props2.style,
      position: strategy,
      minWidth: matchWidth2 ? void 0 : "max-content",
      inset: "0 auto auto 0"
    }
  }), [strategy, popperRef, matchWidth2]);
  const getArrowProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    const {
      size,
      shadowColor,
      bg,
      style,
      ...rest
    } = props2;
    return {
      ...rest,
      ref,
      "data-popper-arrow": "",
      style: getArrowStyle(props2)
    };
  }, []);
  const getArrowInnerProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref,
    "data-popper-arrow-inner": ""
  }), []);
  return {
    update() {
      var _a;
      (_a = instance.current) == null ? void 0 : _a.update();
    },
    forceUpdate() {
      var _a;
      (_a = instance.current) == null ? void 0 : _a.forceUpdate();
    },
    transformOrigin: _chunkQAKUNGSB.cssVars.transformOrigin.varRef,
    referenceRef,
    popperRef,
    getPopperProps,
    getArrowProps,
    getArrowInnerProps,
    getReferenceProps
  };
}
function getArrowStyle(props) {
  const {
    size,
    shadowColor,
    bg,
    style
  } = props;
  const computedStyle = {
    ...style,
    position: "absolute"
  };
  if (size) {
    computedStyle["--popper-arrow-size"] = size;
  }
  if (shadowColor) {
    computedStyle["--popper-arrow-shadow-color"] = shadowColor;
  }
  if (bg) {
    computedStyle["--popper-arrow-bg"] = bg;
  }
  return computedStyle;
}
},{"./chunk-SSFABIB2.mjs":"FAAS","./chunk-6DG2E3QO.mjs":"fNdf","./chunk-QAKUNGSB.mjs":"zC9F","@chakra-ui/react-use-merge-refs":"EUzL","@popperjs/core":"vePw","react":"n8MK"}],"gOdA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "popperCSSVars", {
  enumerable: true,
  get: function () {
    return _chunkQAKUNGSB.cssVars;
  }
});
Object.defineProperty(exports, "usePopper", {
  enumerable: true,
  get: function () {
    return _chunkHJWVQQGO.usePopper;
  }
});
var _chunkHJWVQQGO = require("./chunk-HJWVQQGO.mjs");
require("./chunk-SSFABIB2.mjs");
require("./chunk-6DG2E3QO.mjs");
var _chunkQAKUNGSB = require("./chunk-QAKUNGSB.mjs");
},{"./chunk-HJWVQQGO.mjs":"lCnP","./chunk-SSFABIB2.mjs":"FAAS","./chunk-6DG2E3QO.mjs":"fNdf","./chunk-QAKUNGSB.mjs":"zC9F"}],"xJYi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDisclosure = useDisclosure;
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
var _react = require("react");
// src/index.ts

function useDisclosure(props = {}) {
  const {
    onClose: onCloseProp,
    onOpen: onOpenProp,
    isOpen: isOpenProp,
    id: idProp
  } = props;
  const handleOpen = (0, _reactUseCallbackRef.useCallbackRef)(onOpenProp);
  const handleClose = (0, _reactUseCallbackRef.useCallbackRef)(onCloseProp);
  const [isOpenState, setIsOpen] = (0, _react.useState)(props.defaultIsOpen || false);
  const isOpen = isOpenProp !== void 0 ? isOpenProp : isOpenState;
  const isControlled = isOpenProp !== void 0;
  const uid = (0, _react.useId)();
  const id = idProp != null ? idProp : `disclosure-${uid}`;
  const onClose = (0, _react.useCallback)(() => {
    if (!isControlled) {
      setIsOpen(false);
    }
    handleClose == null ? void 0 : handleClose();
  }, [isControlled, handleClose]);
  const onOpen = (0, _react.useCallback)(() => {
    if (!isControlled) {
      setIsOpen(true);
    }
    handleOpen == null ? void 0 : handleOpen();
  }, [isControlled, handleOpen]);
  const onToggle = (0, _react.useCallback)(() => {
    if (isOpen) {
      onClose();
    } else {
      onOpen();
    }
  }, [isOpen, onOpen, onClose]);
  function getButtonProps(props2 = {}) {
    return {
      ...props2,
      "aria-expanded": isOpen,
      "aria-controls": id,
      onClick(event) {
        var _a;
        (_a = props2.onClick) == null ? void 0 : _a.call(props2, event);
        onToggle();
      }
    };
  }
  function getDisclosureProps(props2 = {}) {
    return {
      ...props2,
      hidden: !isOpen,
      id
    };
  }
  return {
    isOpen,
    onOpen,
    onClose,
    onToggle,
    isControlled,
    getButtonProps,
    getDisclosureProps
  };
}
},{"@chakra-ui/react-use-callback-ref":"PPhG","react":"n8MK"}],"GryS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useOutsideClick = useOutsideClick;
var _react = require("react");
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
// src/index.ts

function useOutsideClick(props) {
  const {
    ref,
    handler,
    enabled = true
  } = props;
  const savedHandler = (0, _reactUseCallbackRef.useCallbackRef)(handler);
  const stateRef = (0, _react.useRef)({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  const state = stateRef.current;
  (0, _react.useEffect)(() => {
    if (!enabled) return;
    const onPointerDown = e => {
      if (isValidEvent(e, ref)) {
        state.isPointerDown = true;
      }
    };
    const onMouseUp = event => {
      if (state.ignoreEmulatedMouseEvents) {
        state.ignoreEmulatedMouseEvents = false;
        return;
      }
      if (state.isPointerDown && handler && isValidEvent(event, ref)) {
        state.isPointerDown = false;
        savedHandler(event);
      }
    };
    const onTouchEnd = event => {
      state.ignoreEmulatedMouseEvents = true;
      if (handler && state.isPointerDown && isValidEvent(event, ref)) {
        state.isPointerDown = false;
        savedHandler(event);
      }
    };
    const doc = getOwnerDocument(ref.current);
    doc.addEventListener("mousedown", onPointerDown, true);
    doc.addEventListener("mouseup", onMouseUp, true);
    doc.addEventListener("touchstart", onPointerDown, true);
    doc.addEventListener("touchend", onTouchEnd, true);
    return () => {
      doc.removeEventListener("mousedown", onPointerDown, true);
      doc.removeEventListener("mouseup", onMouseUp, true);
      doc.removeEventListener("touchstart", onPointerDown, true);
      doc.removeEventListener("touchend", onTouchEnd, true);
    };
  }, [handler, ref, savedHandler, state, enabled]);
}
function isValidEvent(event, ref) {
  var _a;
  const target = event.target;
  if (event.button > 0) return false;
  if (target) {
    const doc = getOwnerDocument(target);
    if (!doc.contains(target)) return false;
  }
  return !((_a = ref.current) == null ? void 0 : _a.contains(target));
}
function getOwnerDocument(node) {
  var _a;
  return (_a = node == null ? void 0 : node.ownerDocument) != null ? _a : document;
}
},{"react":"n8MK","@chakra-ui/react-use-callback-ref":"PPhG"}],"Qgbt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAnimationState = useAnimationState;
var _react = require("react");
var _reactUseEventListener = require("@chakra-ui/react-use-event-listener");
var _domUtils = require("@chakra-ui/dom-utils");
// src/index.ts

function useAnimationState(props) {
  const {
    isOpen,
    ref
  } = props;
  const [mounted, setMounted] = (0, _react.useState)(isOpen);
  const [once, setOnce] = (0, _react.useState)(false);
  (0, _react.useEffect)(() => {
    if (!once) {
      setMounted(isOpen);
      setOnce(true);
    }
  }, [isOpen, once, mounted]);
  (0, _reactUseEventListener.useEventListener)(() => ref.current, "animationend", () => {
    setMounted(isOpen);
  });
  const hidden = isOpen ? false : !mounted;
  return {
    present: !hidden,
    onComplete() {
      var _a;
      const win = (0, _domUtils.getOwnerWindow)(ref.current);
      const evt = new win.CustomEvent("animationend", {
        bubbles: true
      });
      (_a = ref.current) == null ? void 0 : _a.dispatchEvent(evt);
    }
  };
}
},{"react":"n8MK","@chakra-ui/react-use-event-listener":"Lu7g","@chakra-ui/dom-utils":"p6n0"}],"wsFr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lazyDisclosure = lazyDisclosure;
// src/index.ts
function lazyDisclosure(options) {
  const {
    wasSelected,
    enabled,
    isSelected,
    mode = "unmount"
  } = options;
  if (!enabled) return true;
  if (isSelected) return true;
  if (mode === "keepMounted" && wasSelected) return true;
  return false;
}
},{}],"aIyp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuProvider = exports.MenuDescendantsProvider = void 0;
exports.useMenu = useMenu;
exports.useMenuButton = useMenuButton;
exports.useMenuDescendantsContext = exports.useMenuDescendants = exports.useMenuDescendant = exports.useMenuContext = void 0;
exports.useMenuItem = useMenuItem;
exports.useMenuList = useMenuList;
exports.useMenuOption = useMenuOption;
exports.useMenuOptionGroup = useMenuOptionGroup;
exports.useMenuPositioner = useMenuPositioner;
exports.useMenuState = useMenuState;
var _chunkCLDV4JKZ = require("./chunk-CLDV4JKZ.mjs");
var _chunkB4RAWM5W = require("./chunk-B4RAWM5W.mjs");
var _clickable = require("@chakra-ui/clickable");
var _descendant = require("@chakra-ui/descendant");
var _reactUseFocusEffect = require("@chakra-ui/react-use-focus-effect");
var _popper = require("@chakra-ui/popper");
var _reactUseDisclosure = require("@chakra-ui/react-use-disclosure");
var _reactUseOutsideClick = require("@chakra-ui/react-use-outside-click");
var _reactUseAnimationState = require("@chakra-ui/react-use-animation-state");
var _reactContext = require("@chakra-ui/react-context");
var _reactChildrenUtils = require("@chakra-ui/react-children-utils");
var _reactUseControllableState = require("@chakra-ui/react-use-controllable-state");
var _reactUseUpdateEffect = require("@chakra-ui/react-use-update-effect");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _lazyUtils = require("@chakra-ui/lazy-utils");
var _react = require("react");
// src/use-menu.ts

var [MenuDescendantsProvider, useMenuDescendantsContext, useMenuDescendants, useMenuDescendant] = (0, _descendant.createDescendantContext)();
exports.useMenuDescendant = useMenuDescendant;
exports.useMenuDescendants = useMenuDescendants;
exports.useMenuDescendantsContext = useMenuDescendantsContext;
exports.MenuDescendantsProvider = MenuDescendantsProvider;
var [MenuProvider, useMenuContext] = (0, _reactContext.createContext)({
  strict: false,
  name: "MenuContext"
});
exports.useMenuContext = useMenuContext;
exports.MenuProvider = MenuProvider;
function useIds(idProp, ...prefixes) {
  const reactId = (0, _react.useId)();
  const id = idProp || reactId;
  return (0, _react.useMemo)(() => {
    return prefixes.map(prefix => `${prefix}-${id}`);
  }, [id, prefixes]);
}
function getOwnerDocument(node) {
  var _a;
  return (_a = node == null ? void 0 : node.ownerDocument) != null ? _a : document;
}
function isActiveElement(element) {
  const doc = getOwnerDocument(element);
  return doc.activeElement === element;
}
function useMenu(props = {}) {
  const {
    id,
    closeOnSelect = true,
    closeOnBlur = true,
    initialFocusRef,
    autoSelect = true,
    isLazy,
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenProp,
    placement = "bottom-start",
    lazyBehavior = "unmount",
    direction,
    computePositionOnMount = false,
    ...popperProps
  } = props;
  const menuRef = (0, _react.useRef)(null);
  const buttonRef = (0, _react.useRef)(null);
  const descendants = useMenuDescendants();
  const focusMenu = (0, _react.useCallback)(() => {
    requestAnimationFrame(() => {
      var _a;
      (_a = menuRef.current) == null ? void 0 : _a.focus({
        preventScroll: false
      });
    });
  }, []);
  const focusFirstItem = (0, _react.useCallback)(() => {
    const id2 = setTimeout(() => {
      var _a;
      if (initialFocusRef) {
        (_a = initialFocusRef.current) == null ? void 0 : _a.focus();
      } else {
        const first = descendants.firstEnabled();
        if (first) setFocusedIndex(first.index);
      }
    });
    timeoutIds.current.add(id2);
  }, [descendants, initialFocusRef]);
  const focusLastItem = (0, _react.useCallback)(() => {
    const id2 = setTimeout(() => {
      const last = descendants.lastEnabled();
      if (last) setFocusedIndex(last.index);
    });
    timeoutIds.current.add(id2);
  }, [descendants]);
  const onOpenInternal = (0, _react.useCallback)(() => {
    onOpenProp == null ? void 0 : onOpenProp();
    if (autoSelect) {
      focusFirstItem();
    } else {
      focusMenu();
    }
  }, [autoSelect, focusFirstItem, focusMenu, onOpenProp]);
  const {
    isOpen,
    onOpen,
    onClose,
    onToggle
  } = (0, _reactUseDisclosure.useDisclosure)({
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenInternal
  });
  (0, _reactUseOutsideClick.useOutsideClick)({
    enabled: isOpen && closeOnBlur,
    ref: menuRef,
    handler: event => {
      var _a;
      if (!((_a = buttonRef.current) == null ? void 0 : _a.contains(event.target))) {
        onClose();
      }
    }
  });
  const popper = (0, _popper.usePopper)({
    ...popperProps,
    enabled: isOpen || computePositionOnMount,
    placement,
    direction
  });
  const [focusedIndex, setFocusedIndex] = (0, _react.useState)(-1);
  (0, _reactUseUpdateEffect.useUpdateEffect)(() => {
    if (!isOpen) {
      setFocusedIndex(-1);
    }
  }, [isOpen]);
  (0, _reactUseFocusEffect.useFocusOnHide)(menuRef, {
    focusRef: buttonRef,
    visible: isOpen,
    shouldFocus: true
  });
  const animationState = (0, _reactUseAnimationState.useAnimationState)({
    isOpen,
    ref: menuRef
  });
  const [buttonId, menuId] = useIds(id, `menu-button`, `menu-list`);
  const openAndFocusMenu = (0, _react.useCallback)(() => {
    onOpen();
    focusMenu();
  }, [onOpen, focusMenu]);
  const timeoutIds = (0, _react.useRef)( /* @__PURE__ */new Set([]));
  useUnmountEffect(() => {
    timeoutIds.current.forEach(id2 => clearTimeout(id2));
    timeoutIds.current.clear();
  });
  const openAndFocusFirstItem = (0, _react.useCallback)(() => {
    onOpen();
    focusFirstItem();
  }, [focusFirstItem, onOpen]);
  const openAndFocusLastItem = (0, _react.useCallback)(() => {
    onOpen();
    focusLastItem();
  }, [onOpen, focusLastItem]);
  const refocus = (0, _react.useCallback)(() => {
    var _a, _b;
    const doc = getOwnerDocument(menuRef.current);
    const hasFocusWithin = (_a = menuRef.current) == null ? void 0 : _a.contains(doc.activeElement);
    const shouldRefocus = isOpen && !hasFocusWithin;
    if (!shouldRefocus) return;
    const node = (_b = descendants.item(focusedIndex)) == null ? void 0 : _b.node;
    node == null ? void 0 : node.focus();
  }, [isOpen, focusedIndex, descendants]);
  return {
    openAndFocusMenu,
    openAndFocusFirstItem,
    openAndFocusLastItem,
    onTransitionEnd: refocus,
    unstable__animationState: animationState,
    descendants,
    popper,
    buttonId,
    menuId,
    forceUpdate: popper.forceUpdate,
    orientation: "vertical",
    isOpen,
    onToggle,
    onOpen,
    onClose,
    menuRef,
    buttonRef,
    focusedIndex,
    closeOnSelect,
    closeOnBlur,
    autoSelect,
    setFocusedIndex,
    isLazy,
    lazyBehavior,
    initialFocusRef
  };
}
function useMenuButton(props = {}, externalRef = null) {
  const menu = useMenuContext();
  const {
    onToggle,
    popper,
    openAndFocusFirstItem,
    openAndFocusLastItem
  } = menu;
  const onKeyDown = (0, _react.useCallback)(event => {
    const eventKey = event.key;
    const keyMap = {
      Enter: openAndFocusFirstItem,
      ArrowDown: openAndFocusFirstItem,
      ArrowUp: openAndFocusLastItem
    };
    const action = keyMap[eventKey];
    if (action) {
      event.preventDefault();
      event.stopPropagation();
      action(event);
    }
  }, [openAndFocusFirstItem, openAndFocusLastItem]);
  return {
    ...props,
    ref: (0, _reactUseMergeRefs.mergeRefs)(menu.buttonRef, externalRef, popper.referenceRef),
    id: menu.buttonId,
    "data-active": (0, _sharedUtils.dataAttr)(menu.isOpen),
    "aria-expanded": menu.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": menu.menuId,
    onClick: (0, _sharedUtils.callAllHandlers)(props.onClick, onToggle),
    onKeyDown: (0, _sharedUtils.callAllHandlers)(props.onKeyDown, onKeyDown)
  };
}
function isTargetMenuItem(target) {
  var _a;
  return isHTMLElement(target) && !!((_a = target == null ? void 0 : target.getAttribute("role")) == null ? void 0 : _a.startsWith("menuitem"));
}
function useMenuList(props = {}, ref = null) {
  const menu = useMenuContext();
  if (!menu) {
    throw new Error(`useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`);
  }
  const {
    focusedIndex,
    setFocusedIndex,
    menuRef,
    isOpen,
    onClose,
    menuId,
    isLazy,
    lazyBehavior,
    unstable__animationState: animated
  } = menu;
  const descendants = useMenuDescendantsContext();
  const createTypeaheadHandler = (0, _chunkCLDV4JKZ.useShortcut)({
    preventDefault: event => event.key !== " " && isTargetMenuItem(event.target)
  });
  const onKeyDown = (0, _react.useCallback)(event => {
    const eventKey = event.key;
    const keyMap = {
      Tab: event2 => event2.preventDefault(),
      Escape: onClose,
      ArrowDown: () => {
        const next = descendants.nextEnabled(focusedIndex);
        if (next) setFocusedIndex(next.index);
      },
      ArrowUp: () => {
        const prev = descendants.prevEnabled(focusedIndex);
        if (prev) setFocusedIndex(prev.index);
      }
    };
    const fn = keyMap[eventKey];
    if (fn) {
      event.preventDefault();
      fn(event);
      return;
    }
    const onTypeahead = createTypeaheadHandler(character => {
      const nextItem = (0, _chunkB4RAWM5W.getNextItemFromSearch)(descendants.values(), character, item => {
        var _a, _b;
        return (_b = (_a = item == null ? void 0 : item.node) == null ? void 0 : _a.textContent) != null ? _b : "";
      }, descendants.item(focusedIndex));
      if (nextItem) {
        const index = descendants.indexOf(nextItem.node);
        setFocusedIndex(index);
      }
    });
    if (isTargetMenuItem(event.target)) {
      onTypeahead(event);
    }
  }, [descendants, focusedIndex, createTypeaheadHandler, onClose, setFocusedIndex]);
  const hasBeenOpened = (0, _react.useRef)(false);
  if (isOpen) {
    hasBeenOpened.current = true;
  }
  const shouldRenderChildren = (0, _lazyUtils.lazyDisclosure)({
    wasSelected: hasBeenOpened.current,
    enabled: isLazy,
    mode: lazyBehavior,
    isSelected: animated.present
  });
  return {
    ...props,
    ref: (0, _reactUseMergeRefs.mergeRefs)(menuRef, ref),
    children: shouldRenderChildren ? props.children : null,
    tabIndex: -1,
    role: "menu",
    id: menuId,
    style: {
      ...props.style,
      transformOrigin: "var(--popper-transform-origin)"
    },
    "aria-orientation": "vertical",
    onKeyDown: (0, _sharedUtils.callAllHandlers)(props.onKeyDown, onKeyDown)
  };
}
function useMenuPositioner(props = {}) {
  const {
    popper,
    isOpen
  } = useMenuContext();
  return popper.getPopperProps({
    ...props,
    style: {
      visibility: isOpen ? "visible" : "hidden",
      ...props.style
    }
  });
}
function useMenuItem(props = {}, externalRef = null) {
  const {
    onMouseEnter: onMouseEnterProp,
    onMouseMove: onMouseMoveProp,
    onMouseLeave: onMouseLeaveProp,
    onClick: onClickProp,
    onFocus: onFocusProp,
    isDisabled,
    isFocusable,
    closeOnSelect,
    type: typeProp,
    ...htmlProps
  } = props;
  const menu = useMenuContext();
  const {
    setFocusedIndex,
    focusedIndex,
    closeOnSelect: menuCloseOnSelect,
    onClose,
    menuRef,
    isOpen,
    menuId
  } = menu;
  const ref = (0, _react.useRef)(null);
  const id = `${menuId}-menuitem-${(0, _react.useId)()}`;
  const {
    index,
    register
  } = useMenuDescendant({
    disabled: isDisabled && !isFocusable
  });
  const onMouseEnter = (0, _react.useCallback)(event => {
    onMouseEnterProp == null ? void 0 : onMouseEnterProp(event);
    if (isDisabled) return;
    setFocusedIndex(index);
  }, [setFocusedIndex, index, isDisabled, onMouseEnterProp]);
  const onMouseMove = (0, _react.useCallback)(event => {
    onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
    if (ref.current && !isActiveElement(ref.current)) {
      onMouseEnter(event);
    }
  }, [onMouseEnter, onMouseMoveProp]);
  const onMouseLeave = (0, _react.useCallback)(event => {
    onMouseLeaveProp == null ? void 0 : onMouseLeaveProp(event);
    if (isDisabled) return;
    setFocusedIndex(-1);
  }, [setFocusedIndex, isDisabled, onMouseLeaveProp]);
  const onClick = (0, _react.useCallback)(event => {
    onClickProp == null ? void 0 : onClickProp(event);
    if (!isTargetMenuItem(event.currentTarget)) return;
    if (closeOnSelect != null ? closeOnSelect : menuCloseOnSelect) {
      onClose();
    }
  }, [onClose, onClickProp, menuCloseOnSelect, closeOnSelect]);
  const onFocus = (0, _react.useCallback)(event => {
    onFocusProp == null ? void 0 : onFocusProp(event);
    setFocusedIndex(index);
  }, [setFocusedIndex, onFocusProp, index]);
  const isFocused = index === focusedIndex;
  const trulyDisabled = isDisabled && !isFocusable;
  (0, _reactUseUpdateEffect.useUpdateEffect)(() => {
    if (!isOpen) return;
    if (isFocused && !trulyDisabled && ref.current) {
      requestAnimationFrame(() => {
        var _a;
        (_a = ref.current) == null ? void 0 : _a.focus();
      });
    } else if (menuRef.current && !isActiveElement(menuRef.current)) {
      menuRef.current.focus();
    }
  }, [isFocused, trulyDisabled, menuRef, isOpen]);
  const clickableProps = (0, _clickable.useClickable)({
    onClick,
    onFocus,
    onMouseEnter,
    onMouseMove,
    onMouseLeave,
    ref: (0, _reactUseMergeRefs.mergeRefs)(register, ref, externalRef),
    isDisabled,
    isFocusable
  });
  return {
    ...htmlProps,
    ...clickableProps,
    type: typeProp != null ? typeProp : clickableProps.type,
    id,
    role: "menuitem",
    tabIndex: isFocused ? 0 : -1
  };
}
function useMenuOption(props = {}, ref = null) {
  const {
    type = "radio",
    isChecked,
    ...rest
  } = props;
  const ownProps = useMenuItem(rest, ref);
  return {
    ...ownProps,
    role: `menuitem${type}`,
    "aria-checked": isChecked
  };
}
function useMenuOptionGroup(props = {}) {
  const {
    children,
    type = "radio",
    value: valueProp,
    defaultValue,
    onChange: onChangeProp,
    ...htmlProps
  } = props;
  const isRadio = type === "radio";
  const fallback = isRadio ? "" : [];
  const [value, setValue] = (0, _reactUseControllableState.useControllableState)({
    defaultValue: defaultValue != null ? defaultValue : fallback,
    value: valueProp,
    onChange: onChangeProp
  });
  const onChange = (0, _react.useCallback)(selectedValue => {
    if (type === "radio" && typeof value === "string") {
      setValue(selectedValue);
    }
    if (type === "checkbox" && Array.isArray(value)) {
      const nextValue = value.includes(selectedValue) ? value.filter(item => item !== selectedValue) : value.concat(selectedValue);
      setValue(nextValue);
    }
  }, [value, setValue, type]);
  const validChildren = (0, _reactChildrenUtils.getValidChildren)(children);
  const clones = validChildren.map(child => {
    if (child.type.id !== "MenuItemOption") return child;
    const onClick = event => {
      var _a, _b;
      onChange(child.props.value);
      (_b = (_a = child.props).onClick) == null ? void 0 : _b.call(_a, event);
    };
    const isChecked = type === "radio" ? child.props.value === value : value.includes(child.props.value);
    return (0, _react.cloneElement)(child, {
      type,
      onClick,
      isChecked
    });
  });
  return {
    ...htmlProps,
    children: clones
  };
}
function useMenuState() {
  const {
    isOpen,
    onClose
  } = useMenuContext();
  return {
    isOpen,
    onClose
  };
}
function isHTMLElement(el) {
  var _a;
  if (!isElement(el)) return false;
  const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
  return el instanceof win.HTMLElement;
}
function isElement(el) {
  return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
}
function useUnmountEffect(fn, deps = []) {
  return (0, _react.useEffect)(() => () => fn(), deps);
}
},{"./chunk-CLDV4JKZ.mjs":"PFE7","./chunk-B4RAWM5W.mjs":"TgGo","@chakra-ui/clickable":"T7OC","@chakra-ui/descendant":"HJpF","@chakra-ui/react-use-focus-effect":"fXis","@chakra-ui/popper":"gOdA","@chakra-ui/react-use-disclosure":"xJYi","@chakra-ui/react-use-outside-click":"GryS","@chakra-ui/react-use-animation-state":"Qgbt","@chakra-ui/react-context":"lT23","@chakra-ui/react-children-utils":"PLf5","@chakra-ui/react-use-controllable-state":"DWQz","@chakra-ui/react-use-update-effect":"GqG2","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/shared-utils":"gghr","@chakra-ui/lazy-utils":"wsFr","react":"n8MK"}],"WJ93":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMenuStyles = exports.Menu = void 0;
var _chunkCRQSZOKU = require("./chunk-CRQSZOKU.mjs");
var _reactContext = require("@chakra-ui/react-context");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/menu.tsx

var [MenuStylesProvider, useMenuStyles] = (0, _reactContext.createContext)({
  name: `MenuStylesContext`,
  errorMessage: `useMenuStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />" `
});
exports.useMenuStyles = useMenuStyles;
var Menu = props => {
  const {
    children
  } = props;
  const styles = (0, _system.useMultiStyleConfig)("Menu", props);
  const ownProps = (0, _system.omitThemingProps)(props);
  const {
    direction
  } = (0, _system.useTheme)();
  const {
    descendants,
    ...ctx
  } = (0, _chunkCRQSZOKU.useMenu)({
    ...ownProps,
    direction
  });
  const context = (0, _react.useMemo)(() => ctx, [ctx]);
  const {
    isOpen,
    onClose,
    forceUpdate
  } = context;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkCRQSZOKU.MenuDescendantsProvider, {
    value: descendants,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkCRQSZOKU.MenuProvider, {
      value: context,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(MenuStylesProvider, {
        value: styles,
        children: (0, _sharedUtils.runIfFn)(children, {
          isOpen,
          onClose,
          forceUpdate
        })
      })
    })
  });
};
exports.Menu = Menu;
Menu.displayName = "Menu";
},{"./chunk-CRQSZOKU.mjs":"aIyp","@chakra-ui/react-context":"lT23","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"qYEE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuCommand = void 0;
var _chunkZ6E7Q7NQ = require("./chunk-Z6E7Q7NQ.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/menu-command.tsx

var MenuCommand = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _chunkZ6E7Q7NQ.useMenuStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
    ref,
    ...props,
    __css: styles.command,
    className: "chakra-menu__command"
  });
});
exports.MenuCommand = MenuCommand;
MenuCommand.displayName = "MenuCommand";
},{"./chunk-Z6E7Q7NQ.mjs":"WJ93","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"n6Jw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StyledMenuItem = void 0;
var _chunkZ6E7Q7NQ = require("./chunk-Z6E7Q7NQ.mjs");
var _system = require("@chakra-ui/system");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/styled-menu-item.tsx

var StyledMenuItem = (0, _system.forwardRef)((props, ref) => {
  const {
    type,
    ...rest
  } = props;
  const styles = (0, _chunkZ6E7Q7NQ.useMenuStyles)();
  const btnType = rest.as || type ? type != null ? type : void 0 : "button";
  const buttonStyles = (0, _react.useMemo)(() => ({
    textDecoration: "none",
    color: "inherit",
    userSelect: "none",
    display: "flex",
    width: "100%",
    alignItems: "center",
    textAlign: "start",
    flex: "0 0 auto",
    outline: 0,
    ...styles.item
  }), [styles.item]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.button, {
    ref,
    type: btnType,
    ...rest,
    __css: buttonStyles
  });
});
exports.StyledMenuItem = StyledMenuItem;
},{"./chunk-Z6E7Q7NQ.mjs":"WJ93","@chakra-ui/system":"ogbg","react":"n8MK","react/jsx-runtime":"plwR"}],"f8xF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuIcon = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/menu-icon.tsx

var MenuIcon = props => {
  const {
    className,
    children,
    ...rest
  } = props;
  const child = _react.Children.only(children);
  const clone = (0, _react.isValidElement)(child) ? (0, _react.cloneElement)(child, {
    focusable: "false",
    "aria-hidden": true,
    className: (0, _sharedUtils.cx)("chakra-menu__icon", child.props.className)
  }) : null;
  const _className = (0, _sharedUtils.cx)("chakra-menu__icon-wrapper", className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
    className: _className,
    ...rest,
    __css: {
      flexShrink: 0
    },
    children: clone
  });
};
exports.MenuIcon = MenuIcon;
MenuIcon.displayName = "MenuIcon";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"jRQG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuItem = void 0;
var _chunkAQGCZC6V = require("./chunk-AQGCZC6V.mjs");
var _chunk65QGG7UJ = require("./chunk-65QGG7UJ.mjs");
var _chunkCRQSZOKU = require("./chunk-CRQSZOKU.mjs");
var _chunkI3AUOXDN = require("./chunk-I3AUOXDN.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/menu-item.tsx

var MenuItem = (0, _system.forwardRef)((props, ref) => {
  const {
    icon,
    iconSpacing = "0.75rem",
    command,
    commandSpacing = "0.75rem",
    children,
    ...rest
  } = props;
  const menuitemProps = (0, _chunkCRQSZOKU.useMenuItem)(rest, ref);
  const shouldWrap = icon || command;
  const _children = shouldWrap ? /* @__PURE__ */(0, _jsxRuntime.jsx)("span", {
    style: {
      pointerEvents: "none",
      flex: 1
    },
    children
  }) : children;
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_chunk65QGG7UJ.StyledMenuItem, {
    ...menuitemProps,
    className: (0, _sharedUtils.cx)("chakra-menu__menuitem", menuitemProps.className),
    children: [icon && /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkI3AUOXDN.MenuIcon, {
      fontSize: "0.8em",
      marginEnd: iconSpacing,
      children: icon
    }), _children, command && /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkAQGCZC6V.MenuCommand, {
      marginStart: commandSpacing,
      children: command
    })]
  });
});
exports.MenuItem = MenuItem;
MenuItem.displayName = "MenuItem";
},{"./chunk-AQGCZC6V.mjs":"qYEE","./chunk-65QGG7UJ.mjs":"n6Jw","./chunk-CRQSZOKU.mjs":"aIyp","./chunk-I3AUOXDN.mjs":"f8xF","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"Q4z3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuList = void 0;
var _chunkZ6E7Q7NQ = require("./chunk-Z6E7Q7NQ.mjs");
var _chunkCRQSZOKU = require("./chunk-CRQSZOKU.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _framerMotion = require("framer-motion");
var _jsxRuntime = require("react/jsx-runtime");
// src/menu-list.tsx

var motionVariants = {
  enter: {
    visibility: "visible",
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    transitionEnd: {
      visibility: "hidden"
    },
    opacity: 0,
    scale: 0.8,
    transition: {
      duration: 0.1,
      easings: "easeOut"
    }
  }
};
var MenuTransition = (0, _system.chakra)(_framerMotion.motion.div);
var MenuList = (0, _system.forwardRef)(function MenuList2(props, ref) {
  var _a, _b;
  const {
    rootProps,
    motionProps,
    ...rest
  } = props;
  const {
    isOpen,
    onTransitionEnd,
    unstable__animationState: animated
  } = (0, _chunkCRQSZOKU.useMenuContext)();
  const listProps = (0, _chunkCRQSZOKU.useMenuList)(rest, ref);
  const positionerProps = (0, _chunkCRQSZOKU.useMenuPositioner)(rootProps);
  const styles = (0, _chunkZ6E7Q7NQ.useMenuStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...positionerProps,
    __css: {
      zIndex: (_b = props.zIndex) != null ? _b : (_a = styles.list) == null ? void 0 : _a.zIndex
    },
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(MenuTransition, {
      variants: motionVariants,
      initial: false,
      animate: isOpen ? "enter" : "exit",
      __css: {
        outline: 0,
        ...styles.list
      },
      ...motionProps,
      className: (0, _sharedUtils.cx)("chakra-menu__menu-list", listProps.className),
      ...listProps,
      onUpdate: onTransitionEnd,
      onAnimationComplete: (0, _sharedUtils.callAll)(animated.onComplete, listProps.onAnimationComplete)
    })
  });
});
exports.MenuList = MenuList;
MenuList.displayName = "MenuList";
},{"./chunk-Z6E7Q7NQ.mjs":"WJ93","./chunk-CRQSZOKU.mjs":"aIyp","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","framer-motion":"gNpu","react/jsx-runtime":"plwR"}],"zd6F":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuGroup = void 0;
var _chunkZ6E7Q7NQ = require("./chunk-Z6E7Q7NQ.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/menu-group.tsx

var MenuGroup = (0, _system.forwardRef)((props, ref) => {
  const {
    title,
    children,
    className,
    ...rest
  } = props;
  const _className = (0, _sharedUtils.cx)("chakra-menu__group__title", className);
  const styles = (0, _chunkZ6E7Q7NQ.useMenuStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)("div", {
    ref,
    className: "chakra-menu__group",
    role: "group",
    children: [title && /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.p, {
      className: _className,
      ...rest,
      __css: styles.groupTitle,
      children: title
    }), children]
  });
});
exports.MenuGroup = MenuGroup;
MenuGroup.displayName = "MenuGroup";
},{"./chunk-Z6E7Q7NQ.mjs":"WJ93","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"BL7V":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuOptionGroup = void 0;
var _chunkFVM7ZLPA = require("./chunk-FVM7ZLPA.mjs");
var _chunkCRQSZOKU = require("./chunk-CRQSZOKU.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/menu-option-group.tsx

var MenuOptionGroup = props => {
  const {
    className,
    title,
    ...rest
  } = props;
  const ownProps = (0, _chunkCRQSZOKU.useMenuOptionGroup)(rest);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkFVM7ZLPA.MenuGroup, {
    title,
    className: (0, _sharedUtils.cx)("chakra-menu__option-group", className),
    ...ownProps
  });
};
exports.MenuOptionGroup = MenuOptionGroup;
MenuOptionGroup.displayName = "MenuOptionGroup";
},{"./chunk-FVM7ZLPA.mjs":"zd6F","./chunk-CRQSZOKU.mjs":"aIyp","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"CXyM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuButton = void 0;
var _chunkZ6E7Q7NQ = require("./chunk-Z6E7Q7NQ.mjs");
var _chunkCRQSZOKU = require("./chunk-CRQSZOKU.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/menu-button.tsx

var StyledMenuButton = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _chunkZ6E7Q7NQ.useMenuStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.button, {
    ref,
    ...props,
    __css: {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      outline: 0,
      ...styles.button
    }
  });
});
var MenuButton = (0, _system.forwardRef)((props, ref) => {
  const {
    children,
    as: As,
    ...rest
  } = props;
  const buttonProps = (0, _chunkCRQSZOKU.useMenuButton)(rest, ref);
  const Element = As || StyledMenuButton;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(Element, {
    ...buttonProps,
    className: (0, _sharedUtils.cx)("chakra-menu__menu-button", props.className),
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      __css: {
        pointerEvents: "none",
        flex: "1 1 auto",
        minW: 0
      },
      children: props.children
    })
  });
});
exports.MenuButton = MenuButton;
MenuButton.displayName = "MenuButton";
},{"./chunk-Z6E7Q7NQ.mjs":"WJ93","./chunk-CRQSZOKU.mjs":"aIyp","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"UwFQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuDivider = void 0;
var _chunkZ6E7Q7NQ = require("./chunk-Z6E7Q7NQ.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/menu-divider.tsx

var MenuDivider = props => {
  const {
    className,
    ...rest
  } = props;
  const styles = (0, _chunkZ6E7Q7NQ.useMenuStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.hr, {
    "aria-orientation": "horizontal",
    className: (0, _sharedUtils.cx)("chakra-menu__divider", className),
    ...rest,
    __css: styles.divider
  });
};
exports.MenuDivider = MenuDivider;
MenuDivider.displayName = "MenuDivider";
},{"./chunk-Z6E7Q7NQ.mjs":"WJ93","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"FtIz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuItemOption = void 0;
var _chunk65QGG7UJ = require("./chunk-65QGG7UJ.mjs");
var _chunkCRQSZOKU = require("./chunk-CRQSZOKU.mjs");
var _chunkI3AUOXDN = require("./chunk-I3AUOXDN.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/menu-item-option.tsx

var CheckIcon = props => /* @__PURE__ */(0, _jsxRuntime.jsx)("svg", {
  viewBox: "0 0 14 14",
  width: "1em",
  height: "1em",
  ...props,
  children: /* @__PURE__ */(0, _jsxRuntime.jsx)("polygon", {
    fill: "currentColor",
    points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
  })
});
var MenuItemOption = (0, _system.forwardRef)((props, ref) => {
  const {
    icon,
    iconSpacing = "0.75rem",
    ...rest
  } = props;
  const optionProps = (0, _chunkCRQSZOKU.useMenuOption)(rest, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_chunk65QGG7UJ.StyledMenuItem, {
    ...optionProps,
    className: (0, _sharedUtils.cx)("chakra-menu__menuitem-option", rest.className),
    children: [icon !== null && /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkI3AUOXDN.MenuIcon, {
      fontSize: "0.8em",
      marginEnd: iconSpacing,
      opacity: props.isChecked ? 1 : 0,
      children: icon || /* @__PURE__ */(0, _jsxRuntime.jsx)(CheckIcon, {})
    }), /* @__PURE__ */(0, _jsxRuntime.jsx)("span", {
      style: {
        flex: 1
      },
      children: optionProps.children
    })]
  });
});
exports.MenuItemOption = MenuItemOption;
MenuItemOption.id = "MenuItemOption";
MenuItemOption.displayName = "MenuItemOption";
},{"./chunk-65QGG7UJ.mjs":"n6Jw","./chunk-CRQSZOKU.mjs":"aIyp","./chunk-I3AUOXDN.mjs":"f8xF","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"q1K0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Menu", {
  enumerable: true,
  get: function () {
    return _chunkZ6E7Q7NQ.Menu;
  }
});
Object.defineProperty(exports, "MenuButton", {
  enumerable: true,
  get: function () {
    return _chunk7SUBCGSP.MenuButton;
  }
});
Object.defineProperty(exports, "MenuCommand", {
  enumerable: true,
  get: function () {
    return _chunkAQGCZC6V.MenuCommand;
  }
});
Object.defineProperty(exports, "MenuDescendantsProvider", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.MenuDescendantsProvider;
  }
});
Object.defineProperty(exports, "MenuDivider", {
  enumerable: true,
  get: function () {
    return _chunkG2TB6MMX.MenuDivider;
  }
});
Object.defineProperty(exports, "MenuGroup", {
  enumerable: true,
  get: function () {
    return _chunkFVM7ZLPA.MenuGroup;
  }
});
Object.defineProperty(exports, "MenuIcon", {
  enumerable: true,
  get: function () {
    return _chunkI3AUOXDN.MenuIcon;
  }
});
Object.defineProperty(exports, "MenuItem", {
  enumerable: true,
  get: function () {
    return _chunkVM7O7UWC.MenuItem;
  }
});
Object.defineProperty(exports, "MenuItemOption", {
  enumerable: true,
  get: function () {
    return _chunkNG7X32H.MenuItemOption;
  }
});
Object.defineProperty(exports, "MenuList", {
  enumerable: true,
  get: function () {
    return _chunk5DPVNQWT.MenuList;
  }
});
Object.defineProperty(exports, "MenuOptionGroup", {
  enumerable: true,
  get: function () {
    return _chunkP5VAFC3G.MenuOptionGroup;
  }
});
Object.defineProperty(exports, "MenuProvider", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.MenuProvider;
  }
});
Object.defineProperty(exports, "useMenu", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenu;
  }
});
Object.defineProperty(exports, "useMenuButton", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenuButton;
  }
});
Object.defineProperty(exports, "useMenuContext", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenuContext;
  }
});
Object.defineProperty(exports, "useMenuDescendant", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenuDescendant;
  }
});
Object.defineProperty(exports, "useMenuDescendants", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenuDescendants;
  }
});
Object.defineProperty(exports, "useMenuDescendantsContext", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenuDescendantsContext;
  }
});
Object.defineProperty(exports, "useMenuItem", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenuItem;
  }
});
Object.defineProperty(exports, "useMenuList", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenuList;
  }
});
Object.defineProperty(exports, "useMenuOption", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenuOption;
  }
});
Object.defineProperty(exports, "useMenuOptionGroup", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenuOptionGroup;
  }
});
Object.defineProperty(exports, "useMenuPositioner", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenuPositioner;
  }
});
Object.defineProperty(exports, "useMenuState", {
  enumerable: true,
  get: function () {
    return _chunkCRQSZOKU.useMenuState;
  }
});
Object.defineProperty(exports, "useMenuStyles", {
  enumerable: true,
  get: function () {
    return _chunkZ6E7Q7NQ.useMenuStyles;
  }
});
var _chunkVM7O7UWC = require("./chunk-VM7O7UWC.mjs");
var _chunk5DPVNQWT = require("./chunk-5DPVNQWT.mjs");
var _chunkP5VAFC3G = require("./chunk-P5VAFC3G.mjs");
var _chunk7SUBCGSP = require("./chunk-7SUBCGSP.mjs");
var _chunkAQGCZC6V = require("./chunk-AQGCZC6V.mjs");
var _chunkG2TB6MMX = require("./chunk-G2TB6MMX.mjs");
var _chunkFVM7ZLPA = require("./chunk-FVM7ZLPA.mjs");
var _chunkNG7X32H = require("./chunk-NG7X32H5.mjs");
require("./chunk-65QGG7UJ.mjs");
var _chunkZ6E7Q7NQ = require("./chunk-Z6E7Q7NQ.mjs");
var _chunkCRQSZOKU = require("./chunk-CRQSZOKU.mjs");
require("./chunk-CLDV4JKZ.mjs");
require("./chunk-B4RAWM5W.mjs");
var _chunkI3AUOXDN = require("./chunk-I3AUOXDN.mjs");
},{"./chunk-VM7O7UWC.mjs":"jRQG","./chunk-5DPVNQWT.mjs":"Q4z3","./chunk-P5VAFC3G.mjs":"BL7V","./chunk-7SUBCGSP.mjs":"CXyM","./chunk-AQGCZC6V.mjs":"qYEE","./chunk-G2TB6MMX.mjs":"UwFQ","./chunk-FVM7ZLPA.mjs":"zd6F","./chunk-NG7X32H5.mjs":"FtIz","./chunk-65QGG7UJ.mjs":"n6Jw","./chunk-Z6E7Q7NQ.mjs":"WJ93","./chunk-CRQSZOKU.mjs":"aIyp","./chunk-CLDV4JKZ.mjs":"PFE7","./chunk-B4RAWM5W.mjs":"TgGo","./chunk-I3AUOXDN.mjs":"f8xF"}],"aPMz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModalTransition = void 0;
var _system = require("@chakra-ui/system");
var _transition = require("@chakra-ui/transition");
var _framerMotion = require("framer-motion");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/modal-transition.tsx

var transitions = {
  slideInBottom: {
    ..._transition.slideFadeConfig,
    custom: {
      offsetY: 16,
      reverse: true
    }
  },
  slideInRight: {
    ..._transition.slideFadeConfig,
    custom: {
      offsetX: 16,
      reverse: true
    }
  },
  scale: {
    ..._transition.scaleFadeConfig,
    custom: {
      initialScale: 0.95,
      reverse: true
    }
  },
  none: {}
};
var MotionSection = (0, _system.chakra)(_framerMotion.motion.section);
var getMotionProps = preset => {
  return transitions[preset || "none"];
};
var ModalTransition = (0, _react.forwardRef)((props, ref) => {
  const {
    preset,
    motionProps = getMotionProps(preset),
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(MotionSection, {
    ref,
    ...motionProps,
    ...rest
  });
});
exports.ModalTransition = ModalTransition;
ModalTransition.displayName = "ModalTransition";
},{"@chakra-ui/system":"ogbg","@chakra-ui/transition":"H7Ru","framer-motion":"gNpu","react":"n8MK","react/jsx-runtime":"plwR"}],"B0SQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.manager = void 0;
exports.useModalManager = useModalManager;
var _chunkNHABU = require("./chunk-NHABU752.mjs");
var _react = require("react");
// src/modal-manager.ts

var ModalManager = class {
  constructor() {
    (0, _chunkNHABU.__publicField)(this, "modals");
    this.modals = [];
  }
  add(modal) {
    this.modals.push(modal);
  }
  remove(modal) {
    this.modals = this.modals.filter(_modal => _modal !== modal);
  }
  isTopModal(modal) {
    const topmostModal = this.modals[this.modals.length - 1];
    return topmostModal === modal;
  }
};
var manager = new ModalManager();
exports.manager = manager;
function useModalManager(ref, isOpen) {
  (0, _react.useEffect)(() => {
    if (isOpen) {
      manager.add(ref);
    }
    return () => {
      manager.remove(ref);
    };
  }, [isOpen, ref]);
}
},{"./chunk-NHABU752.mjs":"e2uv","react":"n8MK"}],"kbgD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.suppressOthers = exports.supportsInert = exports.inertOthers = exports.hideOthers = void 0;
var getDefaultParent = function getDefaultParent(originalTarget) {
  if (typeof document === 'undefined') {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = new WeakMap();
var uncontrolledNodes = new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function unwrapHost(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function correctTargets(parent, targets) {
  return targets.map(function (target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing');
    return null;
  }).filter(function (x) {
    return Boolean(x);
  });
};
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @param {String} [controlAttribute] - html Attribute to control
 * @return {Undo} undo command
 */
var applyAttributeToOthers = function applyAttributeToOthers(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = new Set();
  var elementsToStop = new Set(targets);
  var keep = function keep(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function deep(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function (node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        var attr = node.getAttribute(controlAttribute);
        var alreadyHidden = attr !== null && attr !== 'false';
        var counterValue = (counterMap.get(node) || 0) + 1;
        var markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, 'true');
        }
        if (!alreadyHidden) {
          node.setAttribute(controlAttribute, 'true');
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function () {
    hiddenNodes.forEach(function (node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      // clear
      counterMap = new WeakMap();
      counterMap = new WeakMap();
      uncontrolledNodes = new WeakMap();
      markerMap = {};
    }
  };
};
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @return {Undo} undo command
 */
var hideOthers = function hideOthers(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = 'data-aria-hidden';
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function () {
      return null;
    };
  }
  // we should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live]')));
  return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');
};
/**
 * Marks everything except given node(or nodes) as inert
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @return {Undo} undo command
 */
exports.hideOthers = hideOthers;
var inertOthers = function inertOthers(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = 'data-inert-ed';
  }
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function () {
      return null;
    };
  }
  return applyAttributeToOthers(originalTarget, activeParentNode, markerName, 'inert');
};
/**
 * @returns if current browser supports inert
 */
exports.inertOthers = inertOthers;
var supportsInert = function supportsInert() {
  return typeof HTMLElement !== 'undefined' && HTMLElement.prototype.hasOwnProperty('inert');
};
/**
 * Automatic function to "suppress" DOM elements - _hide_ or _inert_ in the best possible way
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @return {Undo} undo command
 */
exports.supportsInert = supportsInert;
var suppressOthers = function suppressOthers(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = 'data-suppressed';
  }
  return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);
};
exports.suppressOthers = suppressOthers;
},{}],"V7IG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAriaHidden = useAriaHidden;
exports.useModal = useModal;
var _chunkBR5VXYQ = require("./chunk-BR5VXYQ3.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _ariaHidden = require("aria-hidden");
var _react = require("react");
// src/use-modal.ts

function useModal(props) {
  const {
    isOpen,
    onClose,
    id,
    closeOnOverlayClick = true,
    closeOnEsc = true,
    useInert = true,
    onOverlayClick: onOverlayClickProp,
    onEsc
  } = props;
  const dialogRef = (0, _react.useRef)(null);
  const overlayRef = (0, _react.useRef)(null);
  const [dialogId, headerId, bodyId] = useIds(id, `chakra-modal`, `chakra-modal--header`, `chakra-modal--body`);
  useAriaHidden(dialogRef, isOpen && useInert);
  (0, _chunkBR5VXYQ.useModalManager)(dialogRef, isOpen);
  const mouseDownTarget = (0, _react.useRef)(null);
  const onMouseDown = (0, _react.useCallback)(event => {
    mouseDownTarget.current = event.target;
  }, []);
  const onKeyDown = (0, _react.useCallback)(event => {
    if (event.key === "Escape") {
      event.stopPropagation();
      if (closeOnEsc) {
        onClose == null ? void 0 : onClose();
      }
      onEsc == null ? void 0 : onEsc();
    }
  }, [closeOnEsc, onClose, onEsc]);
  const [headerMounted, setHeaderMounted] = (0, _react.useState)(false);
  const [bodyMounted, setBodyMounted] = (0, _react.useState)(false);
  const getDialogProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    role: "dialog",
    ...props2,
    ref: (0, _reactUseMergeRefs.mergeRefs)(ref, dialogRef),
    id: dialogId,
    tabIndex: -1,
    "aria-modal": true,
    "aria-labelledby": headerMounted ? headerId : void 0,
    "aria-describedby": bodyMounted ? bodyId : void 0,
    onClick: (0, _sharedUtils.callAllHandlers)(props2.onClick, event => event.stopPropagation())
  }), [bodyId, bodyMounted, dialogId, headerId, headerMounted]);
  const onOverlayClick = (0, _react.useCallback)(event => {
    event.stopPropagation();
    if (mouseDownTarget.current !== event.target) return;
    if (!_chunkBR5VXYQ.manager.isTopModal(dialogRef)) return;
    if (closeOnOverlayClick) {
      onClose == null ? void 0 : onClose();
    }
    onOverlayClickProp == null ? void 0 : onOverlayClickProp();
  }, [onClose, closeOnOverlayClick, onOverlayClickProp]);
  const getDialogContainerProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref: (0, _reactUseMergeRefs.mergeRefs)(ref, overlayRef),
    onClick: (0, _sharedUtils.callAllHandlers)(props2.onClick, onOverlayClick),
    onKeyDown: (0, _sharedUtils.callAllHandlers)(props2.onKeyDown, onKeyDown),
    onMouseDown: (0, _sharedUtils.callAllHandlers)(props2.onMouseDown, onMouseDown)
  }), [onKeyDown, onMouseDown, onOverlayClick]);
  return {
    isOpen,
    onClose,
    headerId,
    bodyId,
    setBodyMounted,
    setHeaderMounted,
    dialogRef,
    overlayRef,
    getDialogProps,
    getDialogContainerProps
  };
}
function useAriaHidden(ref, shouldHide) {
  const currentElement = ref.current;
  (0, _react.useEffect)(() => {
    if (!ref.current || !shouldHide) return void 0;
    return (0, _ariaHidden.hideOthers)(ref.current);
  }, [shouldHide, ref, currentElement]);
}
function useIds(idProp, ...prefixes) {
  const reactId = (0, _react.useId)();
  const id = idProp || reactId;
  return (0, _react.useMemo)(() => {
    return prefixes.map(prefix => `${prefix}-${id}`);
  }, [id, prefixes]);
}
},{"./chunk-BR5VXYQ3.mjs":"B0SQ","@chakra-ui/shared-utils":"gghr","@chakra-ui/react-use-merge-refs":"EUzL","aria-hidden":"kbgD","react":"n8MK"}],"PTTK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useModalStyles = exports.useModalContext = exports.ModalContextProvider = exports.Modal = void 0;
var _chunk3JMIHPMG = require("./chunk-3JMIHPMG.mjs");
var _portal = require("@chakra-ui/portal");
var _reactContext = require("@chakra-ui/react-context");
var _system = require("@chakra-ui/system");
var _framerMotion = require("framer-motion");
var _jsxRuntime = require("react/jsx-runtime");
// src/modal.tsx

var [ModalStylesProvider, useModalStyles] = (0, _reactContext.createContext)({
  name: `ModalStylesContext`,
  errorMessage: `useModalStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Modal />" `
});
exports.useModalStyles = useModalStyles;
var [ModalContextProvider, useModalContext] = (0, _reactContext.createContext)({
  strict: true,
  name: "ModalContext",
  errorMessage: "useModalContext: `context` is undefined. Seems you forgot to wrap modal components in `<Modal />`"
});
exports.useModalContext = useModalContext;
exports.ModalContextProvider = ModalContextProvider;
var Modal = props => {
  const modalProps = {
    scrollBehavior: "outside",
    autoFocus: true,
    trapFocus: true,
    returnFocusOnClose: true,
    blockScrollOnMount: true,
    allowPinchZoom: false,
    motionPreset: "scale",
    lockFocusAcrossFrames: true,
    ...props
  };
  const {
    portalProps,
    children,
    autoFocus,
    trapFocus,
    initialFocusRef,
    finalFocusRef,
    returnFocusOnClose,
    blockScrollOnMount,
    allowPinchZoom,
    preserveScrollBarGap,
    motionPreset,
    lockFocusAcrossFrames,
    onCloseComplete
  } = modalProps;
  const styles = (0, _system.useMultiStyleConfig)("Modal", modalProps);
  const modal = (0, _chunk3JMIHPMG.useModal)(modalProps);
  const context = {
    ...modal,
    autoFocus,
    trapFocus,
    initialFocusRef,
    finalFocusRef,
    returnFocusOnClose,
    blockScrollOnMount,
    allowPinchZoom,
    preserveScrollBarGap,
    motionPreset,
    lockFocusAcrossFrames
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(ModalContextProvider, {
    value: context,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(ModalStylesProvider, {
      value: styles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.AnimatePresence, {
        onExitComplete: onCloseComplete,
        children: context.isOpen && /* @__PURE__ */(0, _jsxRuntime.jsx)(_portal.Portal, {
          ...portalProps,
          children
        })
      })
    })
  });
};
exports.Modal = Modal;
Modal.displayName = "Modal";
},{"./chunk-3JMIHPMG.mjs":"V7IG","@chakra-ui/portal":"HPzc","@chakra-ui/react-context":"lT23","@chakra-ui/system":"ogbg","framer-motion":"gNpu","react/jsx-runtime":"plwR"}],"Vabl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _objectWithoutPropertiesLoose;
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
},{}],"Asjh":[function(require,module,exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

},{}],"wVGV":[function(require,module,exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

},{"./lib/ReactPropTypesSecret":"Asjh"}],"D9Od":[function(require,module,exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if ("production" !== 'production') {
  var ReactIs = require('react-is');

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}
},{"./factoryWithThrowingShims":"wVGV"}],"MRzZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FOCUS_NO_AUTOFOCUS = exports.FOCUS_GROUP = exports.FOCUS_DISABLED = exports.FOCUS_AUTO = exports.FOCUS_ALLOW = void 0;
/**
 * defines a focus group
 */
var FOCUS_GROUP = 'data-focus-lock';
/**
 * disables element discovery inside a group marked by key
 */
exports.FOCUS_GROUP = FOCUS_GROUP;
var FOCUS_DISABLED = 'data-focus-lock-disabled';
/**
 * allows uncontrolled focus within the marked area, effectively disabling focus lock for it's content
 */
exports.FOCUS_DISABLED = FOCUS_DISABLED;
var FOCUS_ALLOW = 'data-no-focus-lock';
/**
 * instructs autofocus engine to pick default autofocus inside a given node
 * can be set on the element or container
 */
exports.FOCUS_ALLOW = FOCUS_ALLOW;
var FOCUS_AUTO = 'data-autofocus-inside';
/**
 * instructs autofocus to ignore elements within a given node
 * can be set on the element or container
 */
exports.FOCUS_AUTO = FOCUS_AUTO;
var FOCUS_NO_AUTOFOCUS = 'data-no-autofocus';
exports.FOCUS_NO_AUTOFOCUS = FOCUS_NO_AUTOFOCUS;
},{}],"aUq2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assignRef = assignRef;
/**
 * Assigns a value for a given ref, no matter of the ref format
 * @param {RefObject} ref - a callback function or ref object
 * @param value - a new value
 *
 * @see https://github.com/theKashey/use-callback-ref#assignref
 * @example
 * const refObject = useRef();
 * const refFn = (ref) => {....}
 *
 * assignRef(refObject, "refValue");
 * assignRef(refFn, "refValue");
 */
function assignRef(ref, value) {
  if (typeof ref === 'function') {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
},{}],"PrZo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCallbackRef = useCallbackRef;
var _react = require("react");
/**
 * creates a MutableRef with ref change callback
 * @param initialValue - initial ref value
 * @param {Function} callback - a callback to run when value changes
 *
 * @example
 * const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);
 * ref.current = 1;
 * // prints 0 -> 1
 *
 * @see https://reactjs.org/docs/hooks-reference.html#useref
 * @see https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref
 * @returns {MutableRefObject}
 */
function useCallbackRef(initialValue, callback) {
  var ref = (0, _react.useState)(function () {
    return {
      // value
      value: initialValue,
      // last callback
      callback: callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  // update callback
  ref.callback = callback;
  return ref.facade;
}
},{"react":"n8MK"}],"FilY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCallbackRef = createCallbackRef;
/**
 * creates a Ref object with on change callback
 * @param callback
 * @returns {RefObject}
 *
 * @see {@link useCallbackRef}
 * @see https://reactjs.org/docs/refs-and-the-dom.html#creating-refs
 */
function createCallbackRef(callback) {
  var current = null;
  return {
    get current() {
      return current;
    },
    set current(value) {
      var last = current;
      if (last !== value) {
        current = value;
        callback(value, last);
      }
    }
  };
}
},{}],"ehk7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeRefs = mergeRefs;
var _assignRef = require("./assignRef");
var _createRef = require("./createRef");
/**
 * Merges two or more refs together providing a single interface to set their value
 * @param {RefObject|Ref} refs
 * @returns {MutableRefObject} - a new ref, which translates all changes to {refs}
 *
 * @see {@link useMergeRefs} to be used in ReactComponents
 * @example
 * const Component = React.forwardRef((props, ref) => {
 *   const ownRef = useRef();
 *   const domRef = mergeRefs([ref, ownRef]); // 👈 merge together
 *   return <div ref={domRef}>...</div>
 * }
 */
function mergeRefs(refs) {
  return (0, _createRef.createCallbackRef)(function (newValue) {
    return refs.forEach(function (ref) {
      return (0, _assignRef.assignRef)(ref, newValue);
    });
  });
}
},{"./assignRef":"aUq2","./createRef":"FilY"}],"pIRT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMergeRefs = useMergeRefs;
var _assignRef = require("./assignRef");
var _useRef = require("./useRef");
/**
 * Merges two or more refs together providing a single interface to set their value
 * @param {RefObject|Ref} refs
 * @returns {MutableRefObject} - a new ref, which translates all changes to {refs}
 *
 * @see {@link mergeRefs} a version without buit-in memoization
 * @see https://github.com/theKashey/use-callback-ref#usemergerefs
 * @example
 * const Component = React.forwardRef((props, ref) => {
 *   const ownRef = useRef();
 *   const domRef = useMergeRefs([ref, ownRef]); // 👈 merge together
 *   return <div ref={domRef}>...</div>
 * }
 */
function useMergeRefs(refs, defaultValue) {
  return (0, _useRef.useCallbackRef)(defaultValue || null, function (newValue) {
    return refs.forEach(function (ref) {
      return (0, _assignRef.assignRef)(ref, newValue);
    });
  });
}
},{"./assignRef":"aUq2","./useRef":"PrZo"}],"jSDV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTransformRef = useTransformRef;
var _assignRef = require("./assignRef");
var _useRef = require("./useRef");
/**
 * Create a _lense_ on Ref, making it possible to transform ref value
 * @param {ReactRef} ref
 * @param {Function} transformer. 👉 Ref would be __NOT updated__ on `transformer` update.
 * @returns {RefObject}
 *
 * @see https://github.com/theKashey/use-callback-ref#usetransformref-to-replace-reactuseimperativehandle
 * @example
 *
 * const ResizableWithRef = forwardRef((props, ref) =>
 *  <Resizable {...props} ref={useTransformRef(ref, i => i ? i.resizable : null)}/>
 * );
 */
function useTransformRef(ref, transformer) {
  return (0, _useRef.useCallbackRef)(null, function (value) {
    return (0, _assignRef.assignRef)(ref, transformer(value));
  });
}
},{"./assignRef":"aUq2","./useRef":"PrZo"}],"fdG1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformRef = transformRef;
var _assignRef = require("./assignRef");
var _createRef = require("./createRef");
/**
 * Transforms one ref to another
 * @example
 * ```tsx
 * const ResizableWithRef = forwardRef((props, ref) =>
 *   <Resizable {...props} ref={transformRef(ref, i => i ? i.resizable : null)}/>
 * );
 * ```
 */
function transformRef(ref, transformer) {
  return (0, _createRef.createCallbackRef)(function (value) {
    return (0, _assignRef.assignRef)(ref, transformer(value));
  });
}
},{"./assignRef":"aUq2","./createRef":"FilY"}],"znRQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.refToCallback = refToCallback;
exports.useRefToCallback = useRefToCallback;
/**
 * Unmemoized version of {@link useRefToCallback}
 * @see {@link useRefToCallback}
 * @param ref
 */
function refToCallback(ref) {
  return function (newValue) {
    if (typeof ref === 'function') {
      ref(newValue);
    } else if (ref) {
      ref.current = newValue;
    }
  };
}
var nullCallback = function nullCallback() {
  return null;
};
// lets maintain a weak ref to, well, ref :)
// not using `kashe` to keep this package small
var weakMem = new WeakMap();
var weakMemoize = function weakMemoize(ref) {
  var usedRef = ref || nullCallback;
  var storedRef = weakMem.get(usedRef);
  if (storedRef) {
    return storedRef;
  }
  var cb = refToCallback(usedRef);
  weakMem.set(usedRef, cb);
  return cb;
};
/**
 * Transforms a given `ref` into `callback`.
 *
 * To transform `callback` into ref use {@link useCallbackRef|useCallbackRef(undefined, callback)}
 *
 * @param {ReactRef} ref
 * @returns {Function}
 *
 * @see https://github.com/theKashey/use-callback-ref#reftocallback
 *
 * @example
 * const ref = useRef(0);
 * const setRef = useRefToCallback(ref);
 * 👉 setRef(10);
 * ✅ ref.current === 10
 */
function useRefToCallback(ref) {
  return weakMemoize(ref);
}
},{}],"QPxv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assignRef", {
  enumerable: true,
  get: function () {
    return _assignRef.assignRef;
  }
});
Object.defineProperty(exports, "createCallbackRef", {
  enumerable: true,
  get: function () {
    return _createRef.createCallbackRef;
  }
});
Object.defineProperty(exports, "mergeRefs", {
  enumerable: true,
  get: function () {
    return _mergeRef.mergeRefs;
  }
});
Object.defineProperty(exports, "refToCallback", {
  enumerable: true,
  get: function () {
    return _refToCallback.refToCallback;
  }
});
Object.defineProperty(exports, "transformRef", {
  enumerable: true,
  get: function () {
    return _transformRef.transformRef;
  }
});
Object.defineProperty(exports, "useCallbackRef", {
  enumerable: true,
  get: function () {
    return _useRef.useCallbackRef;
  }
});
Object.defineProperty(exports, "useMergeRefs", {
  enumerable: true,
  get: function () {
    return _useMergeRef.useMergeRefs;
  }
});
Object.defineProperty(exports, "useRefToCallback", {
  enumerable: true,
  get: function () {
    return _refToCallback.useRefToCallback;
  }
});
Object.defineProperty(exports, "useTransformRef", {
  enumerable: true,
  get: function () {
    return _useTransformRef.useTransformRef;
  }
});
var _assignRef = require("./assignRef");
var _useRef = require("./useRef");
var _createRef = require("./createRef");
var _mergeRef = require("./mergeRef");
var _useMergeRef = require("./useMergeRef");
var _useTransformRef = require("./useTransformRef");
var _transformRef = require("./transformRef");
var _refToCallback = require("./refToCallback");
},{"./assignRef":"aUq2","./useRef":"PrZo","./createRef":"FilY","./mergeRef":"ehk7","./useMergeRef":"pIRT","./useTransformRef":"jSDV","./transformRef":"fdG1","./refToCallback":"znRQ"}],"dzMM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hiddenGuard = exports.default = void 0;
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var hiddenGuard = {
  width: '1px',
  height: '0px',
  padding: 0,
  overflow: 'hidden',
  position: 'fixed',
  top: '1px',
  left: '1px'
};
exports.hiddenGuard = hiddenGuard;
var InFocusGuard = function InFocusGuard(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    key: "guard-first",
    "data-focus-guard": true,
    "data-focus-auto-guard": true,
    style: hiddenGuard
  }), children, children && /*#__PURE__*/React.createElement("div", {
    key: "guard-last",
    "data-focus-guard": true,
    "data-focus-auto-guard": true,
    style: hiddenGuard
  }));
};
InFocusGuard.propTypes = "production" !== "production" ? {
  children: _propTypes.default.node
} : {};
InFocusGuard.defaultProps = {
  children: null
};
var _default = InFocusGuard;
exports.default = _default;
},{"react":"n8MK","prop-types":"D9Od"}],"wFuW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNode = void 0;
const isNode = false;
exports.isNode = isNode;
},{}],"Bb9c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.env = void 0;
var _detectNodeEs = require("detect-node-es");
var env = {
  isNode: _detectNodeEs.isNode,
  forceCache: false
};
exports.env = env;
},{"detect-node-es":"wFuW"}],"rN5r":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSidecar = useSidecar;
var _react = require("react");
var _env = require("./env");
var cache = new WeakMap();
var NO_OPTIONS = {};
function useSidecar(importer, effect) {
  var options = effect && effect.options || NO_OPTIONS;
  if (_env.env.isNode && !options.ssr) {
    return [null, null];
  }
  // eslint-disable-next-line react-hooks/rules-of-hooks
  return useRealSidecar(importer, effect);
}
function useRealSidecar(importer, effect) {
  var options = effect && effect.options || NO_OPTIONS;
  var couldUseCache = _env.env.forceCache || _env.env.isNode && !!options.ssr || !options.async;
  var _a = (0, _react.useState)(couldUseCache ? function () {
      return cache.get(importer);
    } : undefined),
    Car = _a[0],
    setCar = _a[1];
  var _b = (0, _react.useState)(null),
    error = _b[0],
    setError = _b[1];
  (0, _react.useEffect)(function () {
    if (!Car) {
      importer().then(function (car) {
        var resolved = effect ? effect.read() : car.default || car;
        if (!resolved) {
          console.error('Sidecar error: with importer', importer);
          var error_1;
          if (effect) {
            console.error('Sidecar error: with medium', effect);
            error_1 = new Error('Sidecar medium was not found');
          } else {
            error_1 = new Error('Sidecar was not found in exports');
          }
          setError(function () {
            return error_1;
          });
          throw error_1;
        }
        cache.set(importer, resolved);
        setCar(function () {
          return resolved;
        });
      }, function (e) {
        return setError(function () {
          return e;
        });
      });
    }
  }, []);
  return [Car, error];
}
},{"react":"n8MK","./env":"Bb9c"}],"M7Tu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sidecar = sidecar;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
var _hook = require("./hook");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// eslint-disable-next-line @typescript-eslint/ban-types
function sidecar(importer, errorComponent) {
  var ErrorCase = function ErrorCase() {
    return errorComponent;
  };
  return function Sidecar(props) {
    var _a = (0, _hook.useSidecar)(importer, props.sideCar),
      Car = _a[0],
      error = _a[1];
    if (error && errorComponent) {
      return ErrorCase;
    }
    // @ts-expect-error type shenanigans
    return Car ? React.createElement(Car, (0, _tslib.__assign)({}, props)) : null;
  };
}
},{"tslib":"vCxL","react":"n8MK","./hook":"rN5r"}],"uzSp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setConfig = exports.config = void 0;
var config = {
  onError: function onError(e) {
    return console.error(e);
  }
};
exports.config = config;
var setConfig = function setConfig(conf) {
  Object.assign(config, conf);
};
exports.setConfig = setConfig;
},{}],"qC77":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMedium = createMedium;
exports.createSidecarMedium = createSidecarMedium;
var _tslib = require("tslib");
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function read() {
      if (assigned) {
        throw new Error('Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.');
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function useMedium(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function () {
        buffer = buffer.filter(function (x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function assignSyncMedium(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function push(x) {
          return cb(x);
        },
        filter: function filter() {
          return buffer;
        }
      };
    },
    assignMedium: function assignMedium(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function executeQueue() {
        var cbs = pendingQueue;
        pendingQueue = [];
        cbs.forEach(cb);
      };
      var cycle = function cycle() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function push(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function filter(_filter) {
          pendingQueue = pendingQueue.filter(_filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  return innerCreateMedium(defaults, middleware);
}
// eslint-disable-next-line @typescript-eslint/ban-types
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = (0, _tslib.__assign)({
    async: true,
    ssr: false
  }, options);
  return medium;
}
},{"tslib":"vCxL"}],"iLQP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderCar = renderCar;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function renderCar(WrappedComponent, defaults) {
  function State(_a) {
    var stateRef = _a.stateRef,
      props = _a.props;
    var renderTarget = (0, React.useCallback)(function SideTarget() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      (0, React.useLayoutEffect)(function () {
        stateRef.current(args);
      });
      return null;
    }, []);
    // @ts-ignore
    return React.createElement(WrappedComponent, (0, _tslib.__assign)({}, props, {
      children: renderTarget
    }));
  }
  var Children = React.memo(function (_a) {
    var stateRef = _a.stateRef,
      defaultState = _a.defaultState,
      children = _a.children;
    var _b = (0, React.useState)(defaultState.current),
      state = _b[0],
      setState = _b[1];
    (0, React.useEffect)(function () {
      stateRef.current = setState;
    }, []);
    return children.apply(void 0, state);
  }, function () {
    return true;
  });
  return function Combiner(props) {
    var defaultState = React.useRef(defaults(props));
    var ref = React.useRef(function (state) {
      return defaultState.current = state;
    });
    return React.createElement(React.Fragment, null, React.createElement(State, {
      stateRef: ref,
      props: props
    }), React.createElement(Children, {
      stateRef: ref,
      defaultState: defaultState,
      children: props.children
    }));
  };
}
},{"tslib":"vCxL","react":"n8MK"}],"gzBA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exportSidecar = exportSidecar;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var SideCar = function SideCar(_a) {
  var sideCar = _a.sideCar,
    rest = (0, _tslib.__rest)(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error('Sidecar: please provide `sideCar` property to import the right car');
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error('Sidecar medium not found');
  }
  return React.createElement(Target, (0, _tslib.__assign)({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}
},{"tslib":"vCxL","react":"n8MK"}],"eYAk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "createMedium", {
  enumerable: true,
  get: function () {
    return _medium.createMedium;
  }
});
Object.defineProperty(exports, "createSidecarMedium", {
  enumerable: true,
  get: function () {
    return _medium.createSidecarMedium;
  }
});
Object.defineProperty(exports, "exportSidecar", {
  enumerable: true,
  get: function () {
    return _exports.exportSidecar;
  }
});
Object.defineProperty(exports, "renderCar", {
  enumerable: true,
  get: function () {
    return _renderProp.renderCar;
  }
});
Object.defineProperty(exports, "setConfig", {
  enumerable: true,
  get: function () {
    return _config.setConfig;
  }
});
Object.defineProperty(exports, "sidecar", {
  enumerable: true,
  get: function () {
    return _hoc.sidecar;
  }
});
Object.defineProperty(exports, "useSidecar", {
  enumerable: true,
  get: function () {
    return _hook.useSidecar;
  }
});
var _hoc = require("./hoc");
var _hook = require("./hook");
var _config = require("./config");
var _medium = require("./medium");
var _renderProp = require("./renderProp");
var _exports = require("./exports");
},{"./hoc":"M7Tu","./hook":"rN5r","./config":"uzSp","./medium":"qC77","./renderProp":"iLQP","./exports":"gzBA"}],"bmnZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mediumSidecar = exports.mediumFocus = exports.mediumEffect = exports.mediumBlur = void 0;
var _useSidecar = require("use-sidecar");
var mediumFocus = (0, _useSidecar.createMedium)({}, function (_ref) {
  var target = _ref.target,
    currentTarget = _ref.currentTarget;
  return {
    target: target,
    currentTarget: currentTarget
  };
});
exports.mediumFocus = mediumFocus;
var mediumBlur = (0, _useSidecar.createMedium)();
exports.mediumBlur = mediumBlur;
var mediumEffect = (0, _useSidecar.createMedium)();
exports.mediumEffect = mediumEffect;
var mediumSidecar = (0, _useSidecar.createSidecarMedium)({
  async: true // focus-lock sidecar is not required on the server
  // however, it might be required for JSDOM tests
  // ssr: true,
});
exports.mediumSidecar = mediumSidecar;
},{"use-sidecar":"eYAk"}],"KGNx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends3 = _interopRequireDefault(require("@babel/runtime/helpers/esm/extends"));
var React = _interopRequireWildcard(require("react"));
var _propTypes = require("prop-types");
var constants = _interopRequireWildcard(require("focus-lock/constants"));
var _useCallbackRef = require("use-callback-ref");
var _FocusGuard = require("./FocusGuard");
var _medium = require("./medium");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var emptyArray = [];
var FocusLock = /*#__PURE__*/React.forwardRef(function FocusLockUI(props, parentRef) {
  var _extends2;
  var _React$useState = React.useState(),
    realObserved = _React$useState[0],
    setObserved = _React$useState[1];
  var observed = React.useRef();
  var isActive = React.useRef(false);
  var originalFocusedElement = React.useRef(null);
  var children = props.children,
    disabled = props.disabled,
    noFocusGuards = props.noFocusGuards,
    persistentFocus = props.persistentFocus,
    crossFrame = props.crossFrame,
    autoFocus = props.autoFocus,
    allowTextSelection = props.allowTextSelection,
    group = props.group,
    className = props.className,
    whiteList = props.whiteList,
    hasPositiveIndices = props.hasPositiveIndices,
    _props$shards = props.shards,
    shards = _props$shards === void 0 ? emptyArray : _props$shards,
    _props$as = props.as,
    Container = _props$as === void 0 ? 'div' : _props$as,
    _props$lockProps = props.lockProps,
    containerProps = _props$lockProps === void 0 ? {} : _props$lockProps,
    SideCar = props.sideCar,
    shouldReturnFocus = props.returnFocus,
    focusOptions = props.focusOptions,
    onActivationCallback = props.onActivation,
    onDeactivationCallback = props.onDeactivation;
  var _React$useState2 = React.useState({}),
    id = _React$useState2[0]; // SIDE EFFECT CALLBACKS

  var onActivation = React.useCallback(function () {
    originalFocusedElement.current = originalFocusedElement.current || document && document.activeElement;
    if (observed.current && onActivationCallback) {
      onActivationCallback(observed.current);
    }
    isActive.current = true;
  }, [onActivationCallback]);
  var onDeactivation = React.useCallback(function () {
    isActive.current = false;
    if (onDeactivationCallback) {
      onDeactivationCallback(observed.current);
    }
  }, [onDeactivationCallback]);
  (0, React.useEffect)(function () {
    if (!disabled) {
      // cleanup return focus on trap deactivation
      // sideEffect/returnFocus should happen by this time
      originalFocusedElement.current = null;
    }
  }, []);
  var returnFocus = React.useCallback(function (allowDefer) {
    var returnFocusTo = originalFocusedElement.current;
    if (returnFocusTo && returnFocusTo.focus) {
      var howToReturnFocus = typeof shouldReturnFocus === 'function' ? shouldReturnFocus(returnFocusTo) : shouldReturnFocus;
      if (howToReturnFocus) {
        var returnFocusOptions = typeof howToReturnFocus === 'object' ? howToReturnFocus : undefined;
        originalFocusedElement.current = null;
        if (allowDefer) {
          // React might return focus after update
          // it's safer to defer the action
          Promise.resolve().then(function () {
            return returnFocusTo.focus(returnFocusOptions);
          });
        } else {
          returnFocusTo.focus(returnFocusOptions);
        }
      }
    }
  }, [shouldReturnFocus]); // MEDIUM CALLBACKS

  var onFocus = React.useCallback(function (event) {
    if (isActive.current) {
      _medium.mediumFocus.useMedium(event);
    }
  }, []);
  var onBlur = _medium.mediumBlur.useMedium; // REF PROPAGATION
  // not using real refs due to race conditions

  var setObserveNode = React.useCallback(function (newObserved) {
    if (observed.current !== newObserved) {
      observed.current = newObserved;
      setObserved(newObserved);
    }
  }, []);
  if ("production" !== 'production') {
    if (typeof allowTextSelection !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn('React-Focus-Lock: allowTextSelection is deprecated and enabled by default');
    }
    React.useEffect(function () {
      // report incorrect integration - https://github.com/theKashey/react-focus-lock/issues/123
      if (!observed.current && typeof Container !== 'string') {
        // eslint-disable-next-line no-console
        console.error('FocusLock: could not obtain ref to internal node');
      }
    }, []);
  }
  var lockProps = (0, _extends3.default)((_extends2 = {}, _extends2[constants.FOCUS_DISABLED] = disabled && 'disabled', _extends2[constants.FOCUS_GROUP] = group, _extends2), containerProps);
  var hasLeadingGuards = noFocusGuards !== true;
  var hasTailingGuards = hasLeadingGuards && noFocusGuards !== 'tail';
  var mergedRef = (0, _useCallbackRef.useMergeRefs)([parentRef, setObserveNode]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, hasLeadingGuards && [/*#__PURE__*/
  // nearest focus guard
  React.createElement("div", {
    key: "guard-first",
    "data-focus-guard": true,
    tabIndex: disabled ? -1 : 0,
    style: _FocusGuard.hiddenGuard
  }),
  // first tabbed element guard
  hasPositiveIndices ? /*#__PURE__*/React.createElement("div", {
    key: "guard-nearest",
    "data-focus-guard": true,
    tabIndex: disabled ? -1 : 1,
    style: _FocusGuard.hiddenGuard
  }) : null], !disabled && /*#__PURE__*/React.createElement(SideCar, {
    id: id,
    sideCar: _medium.mediumSidecar,
    observed: realObserved,
    disabled: disabled,
    persistentFocus: persistentFocus,
    crossFrame: crossFrame,
    autoFocus: autoFocus,
    whiteList: whiteList,
    shards: shards,
    onActivation: onActivation,
    onDeactivation: onDeactivation,
    returnFocus: returnFocus,
    focusOptions: focusOptions
  }), /*#__PURE__*/React.createElement(Container, (0, _extends3.default)({
    ref: mergedRef
  }, lockProps, {
    className: className,
    onBlur: onBlur,
    onFocus: onFocus
  }), children), hasTailingGuards && /*#__PURE__*/React.createElement("div", {
    "data-focus-guard": true,
    tabIndex: disabled ? -1 : 0,
    style: _FocusGuard.hiddenGuard
  }));
});
FocusLock.propTypes = "production" !== "production" ? {
  children: _propTypes.node,
  disabled: _propTypes.bool,
  returnFocus: (0, _propTypes.oneOfType)([_propTypes.bool, _propTypes.object, _propTypes.func]),
  focusOptions: _propTypes.object,
  noFocusGuards: _propTypes.bool,
  hasPositiveIndices: _propTypes.bool,
  allowTextSelection: _propTypes.bool,
  autoFocus: _propTypes.bool,
  persistentFocus: _propTypes.bool,
  crossFrame: _propTypes.bool,
  group: _propTypes.string,
  className: _propTypes.string,
  whiteList: _propTypes.func,
  shards: (0, _propTypes.arrayOf)(_propTypes.any),
  as: (0, _propTypes.oneOfType)([_propTypes.string, _propTypes.func, _propTypes.object]),
  lockProps: _propTypes.object,
  onActivation: _propTypes.func,
  onDeactivation: _propTypes.func,
  sideCar: _propTypes.any.isRequired
} : {};
FocusLock.defaultProps = {
  children: undefined,
  disabled: false,
  returnFocus: false,
  focusOptions: undefined,
  noFocusGuards: false,
  autoFocus: true,
  persistentFocus: false,
  crossFrame: true,
  hasPositiveIndices: undefined,
  allowTextSelection: undefined,
  group: undefined,
  className: undefined,
  whiteList: undefined,
  shards: undefined,
  as: 'div',
  lockProps: {},
  onActivation: undefined,
  onDeactivation: undefined
};
var _default = FocusLock;
exports.default = _default;
},{"@babel/runtime/helpers/esm/extends":"SpjQ","react":"n8MK","prop-types":"D9Od","focus-lock/constants":"MRzZ","use-callback-ref":"QPxv","./FocusGuard":"dzMM","./medium":"bmnZ"}],"hewo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _setPrototypeOf;
function _setPrototypeOf(o, p) {
  exports.default = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
},{}],"S11h":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _inheritsLoose;
var _setPrototypeOf = _interopRequireDefault(require("./setPrototypeOf.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  (0, _setPrototypeOf.default)(subClass, superClass);
}
},{"./setPrototypeOf.js":"hewo"}],"xLw6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _typeof;
function _typeof(obj) {
  "@babel/helpers - typeof";

  return exports.default = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
},{}],"e6xy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _toPrimitive;
var _typeof2 = _interopRequireDefault(require("./typeof.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toPrimitive(input, hint) {
  if ((0, _typeof2.default)(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if ((0, _typeof2.default)(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
},{"./typeof.js":"xLw6"}],"JGj9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _toPropertyKey;
var _typeof2 = _interopRequireDefault(require("./typeof.js"));
var _toPrimitive = _interopRequireDefault(require("./toPrimitive.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toPropertyKey(arg) {
  var key = (0, _toPrimitive.default)(arg, "string");
  return (0, _typeof2.default)(key) === "symbol" ? key : String(key);
}
},{"./typeof.js":"xLw6","./toPrimitive.js":"e6xy"}],"gpd2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _defineProperty;
var _toPropertyKey = _interopRequireDefault(require("./toPropertyKey.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) {
  key = (0, _toPropertyKey.default)(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
},{"./toPropertyKey.js":"JGj9"}],"x8bj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inheritsLoose"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function withSideEffect(reducePropsToState, handleStateChangeOnClient) {
  if ("production" !== "production") {
    if (typeof reducePropsToState !== 'function') {
      throw new Error('Expected reducePropsToState to be a function.');
    }
    if (typeof handleStateChangeOnClient !== 'function') {
      throw new Error('Expected handleStateChangeOnClient to be a function.');
    }
  }
  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'Component';
  }
  return function wrap(WrappedComponent) {
    if ("production" !== "production") {
      if (typeof WrappedComponent !== 'function') {
        throw new Error('Expected WrappedComponent to be a React component.');
      }
    }
    var mountedInstances = [];
    var state;
    function emitChange() {
      state = reducePropsToState(mountedInstances.map(function (instance) {
        return instance.props;
      }));
      handleStateChangeOnClient(state);
    }
    var SideEffect = /*#__PURE__*/function (_PureComponent) {
      (0, _inheritsLoose2.default)(SideEffect, _PureComponent);
      function SideEffect() {
        return _PureComponent.apply(this, arguments) || this;
      }

      // Try to use displayName of wrapped component
      SideEffect.peek = function peek() {
        return state;
      };
      var _proto = SideEffect.prototype;
      _proto.componentDidMount = function componentDidMount() {
        mountedInstances.push(this);
        emitChange();
      };
      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        var index = mountedInstances.indexOf(this);
        mountedInstances.splice(index, 1);
        emitChange();
      };
      _proto.render = function render() {
        return /*#__PURE__*/_react.default.createElement(WrappedComponent, this.props);
      };
      return SideEffect;
    }(_react.PureComponent);
    (0, _defineProperty2.default)(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");
    return SideEffect;
  };
}
var _default = withSideEffect;
exports.default = _default;
},{"@babel/runtime/helpers/esm/inheritsLoose":"S11h","@babel/runtime/helpers/esm/defineProperty":"gpd2","react":"n8MK"}],"amJv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArray = exports.asArray = void 0;
/*
IE11 support
 */
var toArray = function toArray(a) {
  var ret = Array(a.length);
  for (var i = 0; i < a.length; ++i) {
    ret[i] = a[i];
  }
  return ret;
};
exports.toArray = toArray;
var asArray = function asArray(a) {
  return Array.isArray(a) ? a : [a];
};
exports.asArray = asArray;
},{}],"TrUa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.notHiddenInput = exports.isVisibleCached = exports.isRadioElement = exports.isNotAGuard = exports.isHTMLInputElement = exports.isHTMLButtonElement = exports.isGuard = exports.isDefined = exports.isAutoFocusAllowedCached = exports.isAutoFocusAllowed = exports.getDataset = void 0;
var _constants = require("../constants");
var isElementHidden = function isElementHidden(node) {
  // we can measure only "elements"
  // consider others as "visible"
  if (node.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  var computedStyle = window.getComputedStyle(node, null);
  if (!computedStyle || !computedStyle.getPropertyValue) {
    return false;
  }
  return computedStyle.getPropertyValue('display') === 'none' || computedStyle.getPropertyValue('visibility') === 'hidden';
};
var getParentNode = function getParentNode(node) {
  // DOCUMENT_FRAGMENT_NODE can also point on ShadowRoot. In this case .host will point on the next node
  return node.parentNode && node.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ?
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  node.parentNode.host : node.parentNode;
};
var isTopNode = function isTopNode(node) {
  // @ts-ignore
  return node === document || node && node.nodeType === Node.DOCUMENT_NODE;
};
var isVisibleUncached = function isVisibleUncached(node, checkParent) {
  return !node || isTopNode(node) || !isElementHidden(node) && checkParent(getParentNode(node));
};
var isVisibleCached = function isVisibleCached(visibilityCache, node) {
  var cached = visibilityCache.get(node);
  if (cached !== undefined) {
    return cached;
  }
  var result = isVisibleUncached(node, isVisibleCached.bind(undefined, visibilityCache));
  visibilityCache.set(node, result);
  return result;
};
exports.isVisibleCached = isVisibleCached;
var isAutoFocusAllowedUncached = function isAutoFocusAllowedUncached(node, checkParent) {
  return node && !isTopNode(node) ? isAutoFocusAllowed(node) ? checkParent(getParentNode(node)) : false : true;
};
var isAutoFocusAllowedCached = function isAutoFocusAllowedCached(cache, node) {
  var cached = cache.get(node);
  if (cached !== undefined) {
    return cached;
  }
  var result = isAutoFocusAllowedUncached(node, isAutoFocusAllowedCached.bind(undefined, cache));
  cache.set(node, result);
  return result;
};
exports.isAutoFocusAllowedCached = isAutoFocusAllowedCached;
var getDataset = function getDataset(node) {
  // @ts-ignore
  return node.dataset;
};
exports.getDataset = getDataset;
var isHTMLButtonElement = function isHTMLButtonElement(node) {
  return node.tagName === 'BUTTON';
};
exports.isHTMLButtonElement = isHTMLButtonElement;
var isHTMLInputElement = function isHTMLInputElement(node) {
  return node.tagName === 'INPUT';
};
exports.isHTMLInputElement = isHTMLInputElement;
var isRadioElement = function isRadioElement(node) {
  return isHTMLInputElement(node) && node.type === 'radio';
};
exports.isRadioElement = isRadioElement;
var notHiddenInput = function notHiddenInput(node) {
  return !((isHTMLInputElement(node) || isHTMLButtonElement(node)) && (node.type === 'hidden' || node.disabled));
};
exports.notHiddenInput = notHiddenInput;
var isAutoFocusAllowed = function isAutoFocusAllowed(node) {
  var attribute = node.getAttribute(_constants.FOCUS_NO_AUTOFOCUS);
  return ![true, 'true', ''].includes(attribute);
};
exports.isAutoFocusAllowed = isAutoFocusAllowed;
var isGuard = function isGuard(node) {
  var _a;
  return Boolean(node && ((_a = getDataset(node)) === null || _a === void 0 ? void 0 : _a.focusGuard));
};
exports.isGuard = isGuard;
var isNotAGuard = function isNotAGuard(node) {
  return !isGuard(node);
};
exports.isNotAGuard = isNotAGuard;
var isDefined = function isDefined(x) {
  return Boolean(x);
};
exports.isDefined = isDefined;
},{"../constants":"MRzZ"}],"uKAn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tabSort = exports.orderByTabIndex = void 0;
var _array = require("./array");
var tabSort = function tabSort(a, b) {
  var tabDiff = a.tabIndex - b.tabIndex;
  var indexDiff = a.index - b.index;
  if (tabDiff) {
    if (!a.tabIndex) {
      return 1;
    }
    if (!b.tabIndex) {
      return -1;
    }
  }
  return tabDiff || indexDiff;
};
exports.tabSort = tabSort;
var orderByTabIndex = function orderByTabIndex(nodes, filterNegative, keepGuards) {
  return (0, _array.toArray)(nodes).map(function (node, index) {
    return {
      node: node,
      index: index,
      tabIndex: keepGuards && node.tabIndex === -1 ? (node.dataset || {}).focusGuard ? 0 : -1 : node.tabIndex
    };
  }).filter(function (data) {
    return !filterNegative || data.tabIndex >= 0;
  }).sort(tabSort);
};
exports.orderByTabIndex = orderByTabIndex;
},{"./array":"amJv"}],"Hvmu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tabbables = void 0;
/**
 * list of the object to be considered as focusable
 */
var tabbables = ['button:enabled', 'select:enabled', 'textarea:enabled', 'input:enabled',
// elements with explicit roles will also use explicit tabindex
// '[role="button"]',
'a[href]', 'area[href]', 'summary', 'iframe', 'object', 'embed', 'audio[controls]', 'video[controls]', '[tabindex]', '[contenteditable]', '[autofocus]'];
exports.tabbables = tabbables;
},{}],"TQKr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParentAutofocusables = exports.getFocusables = void 0;
var _constants = require("../constants");
var _array = require("./array");
var _tabbables = require("./tabbables");
var queryTabbables = _tabbables.tabbables.join(',');
var queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]");
var getFocusablesWithShadowDom = function getFocusablesWithShadowDom(parent, withGuards) {
  var _a;
  return (0, _array.toArray)(((_a = parent.shadowRoot) === null || _a === void 0 ? void 0 : _a.children) || parent.children).reduce(function (acc, child) {
    return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], getFocusablesWithShadowDom(child));
  }, []);
};
var getFocusables = function getFocusables(parents, withGuards) {
  return parents.reduce(function (acc, parent) {
    return acc.concat(
    // add all tabbables inside and within shadow DOMs in DOM order
    getFocusablesWithShadowDom(parent, withGuards),
    // add if node is tabbable itself
    parent.parentNode ? (0, _array.toArray)(parent.parentNode.querySelectorAll(queryTabbables)).filter(function (node) {
      return node === parent;
    }) : []);
  }, []);
};
/**
 * return a list of focusable nodes within an area marked as "auto-focusable"
 * @param parent
 */
exports.getFocusables = getFocusables;
var getParentAutofocusables = function getParentAutofocusables(parent) {
  var parentFocus = parent.querySelectorAll("[".concat(_constants.FOCUS_AUTO, "]"));
  return (0, _array.toArray)(parentFocus).map(function (node) {
    return getFocusables([node]);
  }).reduce(function (acc, nodes) {
    return acc.concat(nodes);
  }, []);
};
exports.getParentAutofocusables = getParentAutofocusables;
},{"../constants":"MRzZ","./array":"amJv","./tabbables":"Hvmu"}],"NPgS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parentAutofocusables = exports.getTabbableNodes = exports.getAllTabbableNodes = exports.filterFocusable = exports.filterAutoFocusable = exports.contains = void 0;
var _array = require("./array");
var _is = require("./is");
var _tabOrder = require("./tabOrder");
var _tabUtils = require("./tabUtils");
/**
 * given list of focusable elements keeps the ones user can interact with
 * @param nodes
 * @param visibilityCache
 */
var filterFocusable = function filterFocusable(nodes, visibilityCache) {
  return (0, _array.toArray)(nodes).filter(function (node) {
    return (0, _is.isVisibleCached)(visibilityCache, node);
  }).filter(function (node) {
    return (0, _is.notHiddenInput)(node);
  });
};
exports.filterFocusable = filterFocusable;
var filterAutoFocusable = function filterAutoFocusable(nodes, cache) {
  if (cache === void 0) {
    cache = new Map();
  }
  return (0, _array.toArray)(nodes).filter(function (node) {
    return (0, _is.isAutoFocusAllowedCached)(cache, node);
  });
};
/**
 * only tabbable ones
 * (but with guards which would be ignored)
 */
exports.filterAutoFocusable = filterAutoFocusable;
var getTabbableNodes = function getTabbableNodes(topNodes, visibilityCache, withGuards) {
  return (0, _tabOrder.orderByTabIndex)(filterFocusable((0, _tabUtils.getFocusables)(topNodes, withGuards), visibilityCache), true, withGuards);
};
/**
 * actually anything "focusable", not only tabbable
 * (without guards, as long as they are not expected to be focused)
 */
exports.getTabbableNodes = getTabbableNodes;
var getAllTabbableNodes = function getAllTabbableNodes(topNodes, visibilityCache) {
  return (0, _tabOrder.orderByTabIndex)(filterFocusable((0, _tabUtils.getFocusables)(topNodes), visibilityCache), false);
};
/**
 * return list of nodes which are expected to be auto-focused
 * @param topNode
 * @param visibilityCache
 */
exports.getAllTabbableNodes = getAllTabbableNodes;
var parentAutofocusables = function parentAutofocusables(topNode, visibilityCache) {
  return filterFocusable((0, _tabUtils.getParentAutofocusables)(topNode), visibilityCache);
};
/*
 * Determines if element is contained in scope, including nested shadow DOMs
 */
exports.parentAutofocusables = parentAutofocusables;
var contains = function contains(scope, element) {
  if (scope.shadowRoot) {
    return contains(scope.shadowRoot, element);
  } else {
    if (Object.getPrototypeOf(scope).contains !== undefined && Object.getPrototypeOf(scope).contains.call(scope, element)) {
      return true;
    }
    return (0, _array.toArray)(scope.children).some(function (child) {
      return contains(child, element);
    });
  }
};
exports.contains = contains;
},{"./array":"amJv","./is":"TrUa","./tabOrder":"uKAn","./tabUtils":"TQKr"}],"S0G2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllAffectedNodes = void 0;
var _constants = require("../constants");
var _array = require("./array");
/**
 * in case of multiple nodes nested inside each other
 * keeps only top ones
 * this is O(nlogn)
 * @param nodes
 * @returns {*}
 */
var filterNested = function filterNested(nodes) {
  var contained = new Set();
  var l = nodes.length;
  for (var i = 0; i < l; i += 1) {
    for (var j = i + 1; j < l; j += 1) {
      var position = nodes[i].compareDocumentPosition(nodes[j]);
      /* eslint-disable no-bitwise */
      if ((position & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
        contained.add(j);
      }
      if ((position & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
        contained.add(i);
      }
      /* eslint-enable */
    }
  }

  return nodes.filter(function (_, index) {
    return !contained.has(index);
  });
};
/**
 * finds top most parent for a node
 * @param node
 * @returns {*}
 */
var getTopParent = function getTopParent(node) {
  return node.parentNode ? getTopParent(node.parentNode) : node;
};
/**
 * returns all "focus containers" inside a given node
 * @param node
 * @returns {T}
 */
var getAllAffectedNodes = function getAllAffectedNodes(node) {
  var nodes = (0, _array.asArray)(node);
  return nodes.filter(Boolean).reduce(function (acc, currentNode) {
    var group = currentNode.getAttribute(_constants.FOCUS_GROUP);
    acc.push.apply(acc, group ? filterNested((0, _array.toArray)(getTopParent(currentNode).querySelectorAll("[".concat(_constants.FOCUS_GROUP, "=\"").concat(group, "\"]:not([").concat(_constants.FOCUS_DISABLED, "=\"disabled\"])")))) : [currentNode]);
    return acc;
  }, []);
};
exports.getAllAffectedNodes = getAllAffectedNodes;
},{"../constants":"MRzZ","./array":"amJv"}],"YUWN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getActiveElement = void 0;
var getNestedShadowActiveElement = function getNestedShadowActiveElement(shadowRoot) {
  return shadowRoot.activeElement ? shadowRoot.activeElement.shadowRoot ? getNestedShadowActiveElement(shadowRoot.activeElement.shadowRoot) : shadowRoot.activeElement : undefined;
};
/**
 * returns active element from document or from nested shadowdoms
 */
var getActiveElement = function getActiveElement() {
  return document.activeElement ? document.activeElement.shadowRoot ? getNestedShadowActiveElement(document.activeElement.shadowRoot) : document.activeElement : undefined; // eslint-disable-next-line @typescript-eslint/no-explicit-any
};
exports.getActiveElement = getActiveElement;
},{}],"TTal":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.focusInside = void 0;
var _DOMutils = require("./utils/DOMutils");
var _allAffected = require("./utils/all-affected");
var _array = require("./utils/array");
var _getActiveElement = require("./utils/getActiveElement");
var focusInFrame = function focusInFrame(frame) {
  return frame === document.activeElement;
};
var focusInsideIframe = function focusInsideIframe(topNode) {
  return Boolean((0, _array.toArray)(topNode.querySelectorAll('iframe')).some(function (node) {
    return focusInFrame(node);
  }));
};
/**
 * @returns {Boolean} true, if the current focus is inside given node or nodes
 */
var focusInside = function focusInside(topNode) {
  var activeElement = document && (0, _getActiveElement.getActiveElement)();
  if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
    return false;
  }
  return (0, _allAffected.getAllAffectedNodes)(topNode).some(function (node) {
    return (0, _DOMutils.contains)(node, activeElement) || focusInsideIframe(node);
  });
};
exports.focusInside = focusInside;
},{"./utils/DOMutils":"NPgS","./utils/all-affected":"S0G2","./utils/array":"amJv","./utils/getActiveElement":"YUWN"}],"GNty":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.focusIsHidden = void 0;
var _constants = require("./constants");
var _DOMutils = require("./utils/DOMutils");
var _array = require("./utils/array");
var _getActiveElement = require("./utils/getActiveElement");
/**
 * focus is hidden FROM the focus-lock
 * ie contained inside a node focus-lock shall ignore
 * @returns {boolean} focus is currently is in "allow" area
 */
var focusIsHidden = function focusIsHidden() {
  var activeElement = document && (0, _getActiveElement.getActiveElement)();
  if (!activeElement) {
    return false;
  }
  // this does not support setting FOCUS_ALLOW within shadow dom
  return (0, _array.toArray)(document.querySelectorAll("[".concat(_constants.FOCUS_ALLOW, "]"))).some(function (node) {
    return (0, _DOMutils.contains)(node, activeElement);
  });
};
exports.focusIsHidden = focusIsHidden;
},{"./constants":"MRzZ","./utils/DOMutils":"NPgS","./utils/array":"amJv","./utils/getActiveElement":"YUWN"}],"A4ix":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.correctNodes = exports.correctNode = void 0;
var _is = require("./is");
var findSelectedRadio = function findSelectedRadio(node, nodes) {
  return nodes.filter(_is.isRadioElement).filter(function (el) {
    return el.name === node.name;
  }).filter(function (el) {
    return el.checked;
  })[0] || node;
};
var correctNode = function correctNode(node, nodes) {
  if ((0, _is.isRadioElement)(node) && node.name) {
    return findSelectedRadio(node, nodes);
  }
  return node;
};
/**
 * giving a set of radio inputs keeps only selected (tabbable) ones
 * @param nodes
 */
exports.correctNode = correctNode;
var correctNodes = function correctNodes(nodes) {
  // IE11 has no Set(array) constructor
  var resultSet = new Set();
  nodes.forEach(function (node) {
    return resultSet.add(correctNode(node, nodes));
  });
  // using filter to support IE11
  return nodes.filter(function (node) {
    return resultSet.has(node);
  });
};
exports.correctNodes = correctNodes;
},{"./is":"TrUa"}],"vMDv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pickFocusable = exports.pickFirstFocus = void 0;
var _correctFocus = require("./correctFocus");
var pickFirstFocus = function pickFirstFocus(nodes) {
  if (nodes[0] && nodes.length > 1) {
    return (0, _correctFocus.correctNode)(nodes[0], nodes);
  }
  return nodes[0];
};
exports.pickFirstFocus = pickFirstFocus;
var pickFocusable = function pickFocusable(nodes, index) {
  if (nodes.length > 1) {
    return nodes.indexOf((0, _correctFocus.correctNode)(nodes[index], nodes));
  }
  return index;
};
exports.pickFocusable = pickFocusable;
},{"./correctFocus":"A4ix"}],"yS1K":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newFocus = exports.NEW_FOCUS = void 0;
var _correctFocus = require("./utils/correctFocus");
var _firstFocus = require("./utils/firstFocus");
var _is = require("./utils/is");
var NEW_FOCUS = 'NEW_FOCUS';
/**
 * Main solver for the "find next focus" question
 * @param innerNodes
 * @param outerNodes
 * @param activeElement
 * @param lastNode
 * @returns {number|string|undefined|*}
 */
exports.NEW_FOCUS = NEW_FOCUS;
var newFocus = function newFocus(innerNodes, outerNodes, activeElement, lastNode) {
  var cnt = innerNodes.length;
  var firstFocus = innerNodes[0];
  var lastFocus = innerNodes[cnt - 1];
  var isOnGuard = (0, _is.isGuard)(activeElement);
  // focus is inside
  if (activeElement && innerNodes.indexOf(activeElement) >= 0) {
    return undefined;
  }
  var activeIndex = activeElement !== undefined ? outerNodes.indexOf(activeElement) : -1;
  var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
  var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
  var indexDiff = activeIndex - lastIndex;
  var firstNodeIndex = outerNodes.indexOf(firstFocus);
  var lastNodeIndex = outerNodes.indexOf(lastFocus);
  var correctedNodes = (0, _correctFocus.correctNodes)(outerNodes);
  var correctedIndex = activeElement !== undefined ? correctedNodes.indexOf(activeElement) : -1;
  var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);
  var returnFirstNode = (0, _firstFocus.pickFocusable)(innerNodes, 0);
  var returnLastNode = (0, _firstFocus.pickFocusable)(innerNodes, cnt - 1);
  // new focus
  if (activeIndex === -1 || lastNodeInside === -1) {
    return NEW_FOCUS;
  }
  // old focus
  if (!indexDiff && lastNodeInside >= 0) {
    return lastNodeInside;
  }
  // first element
  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnLastNode;
  }
  // last element
  if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnFirstNode;
  }
  // jump out, but not on the guard
  if (indexDiff && Math.abs(correctedIndexDiff) > 1) {
    return lastNodeInside;
  }
  // focus above lock
  if (activeIndex <= firstNodeIndex) {
    return returnLastNode;
  }
  // focus below lock
  if (activeIndex > lastNodeIndex) {
    return returnFirstNode;
  }
  // index is inside tab order, but outside Lock
  if (indexDiff) {
    if (Math.abs(indexDiff) > 1) {
      return lastNodeInside;
    }
    return (cnt + lastNodeInside + indexDiff) % cnt;
  }
  // do nothing
  return undefined;
};
exports.newFocus = newFocus;
},{"./utils/correctFocus":"A4ix","./utils/firstFocus":"vMDv","./utils/is":"TrUa"}],"Yf6F":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pickAutofocus = void 0;
var _DOMutils = require("./DOMutils");
var _firstFocus = require("./firstFocus");
var _is = require("./is");
var findAutoFocused = function findAutoFocused(autoFocusables) {
  return function (node) {
    var _a;
    var autofocus = (_a = (0, _is.getDataset)(node)) === null || _a === void 0 ? void 0 : _a.autofocus;
    return (
      // @ts-expect-error
      node.autofocus ||
      //
      autofocus !== undefined && autofocus !== 'false' ||
      //
      autoFocusables.indexOf(node) >= 0
    );
  };
};
var pickAutofocus = function pickAutofocus(nodesIndexes, orderedNodes, groups) {
  var nodes = nodesIndexes.map(function (_a) {
    var node = _a.node;
    return node;
  });
  var autoFocusable = (0, _DOMutils.filterAutoFocusable)(nodes.filter(findAutoFocused(groups)));
  if (autoFocusable && autoFocusable.length) {
    return (0, _firstFocus.pickFirstFocus)(autoFocusable);
  }
  return (0, _firstFocus.pickFirstFocus)((0, _DOMutils.filterAutoFocusable)(orderedNodes));
};
exports.pickAutofocus = pickAutofocus;
},{"./DOMutils":"NPgS","./firstFocus":"vMDv","./is":"TrUa"}],"xURm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTopCommonParent = exports.getCommonParent = exports.allParentAutofocusables = void 0;
var _DOMutils = require("./DOMutils");
var _array = require("./array");
var getParents = function getParents(node, parents) {
  if (parents === void 0) {
    parents = [];
  }
  parents.push(node);
  if (node.parentNode) {
    getParents(node.parentNode.host || node.parentNode, parents);
  }
  return parents;
};
/**
 * finds a parent for both nodeA and nodeB
 * @param nodeA
 * @param nodeB
 * @returns {boolean|*}
 */
var getCommonParent = function getCommonParent(nodeA, nodeB) {
  var parentsA = getParents(nodeA);
  var parentsB = getParents(nodeB);
  // tslint:disable-next-line:prefer-for-of
  for (var i = 0; i < parentsA.length; i += 1) {
    var currentParent = parentsA[i];
    if (parentsB.indexOf(currentParent) >= 0) {
      return currentParent;
    }
  }
  return false;
};
exports.getCommonParent = getCommonParent;
var getTopCommonParent = function getTopCommonParent(baseActiveElement, leftEntry, rightEntries) {
  var activeElements = (0, _array.asArray)(baseActiveElement);
  var leftEntries = (0, _array.asArray)(leftEntry);
  var activeElement = activeElements[0];
  var topCommon = false;
  leftEntries.filter(Boolean).forEach(function (entry) {
    topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
    rightEntries.filter(Boolean).forEach(function (subEntry) {
      var common = getCommonParent(activeElement, subEntry);
      if (common) {
        if (!topCommon || (0, _DOMutils.contains)(common, topCommon)) {
          topCommon = common;
        } else {
          topCommon = getCommonParent(common, topCommon);
        }
      }
    });
  });
  // TODO: add assert here?
  return topCommon;
};
/**
 * return list of nodes which are expected to be autofocused inside a given top nodes
 * @param entries
 * @param visibilityCache
 */
exports.getTopCommonParent = getTopCommonParent;
var allParentAutofocusables = function allParentAutofocusables(entries, visibilityCache) {
  return entries.reduce(function (acc, node) {
    return acc.concat((0, _DOMutils.parentAutofocusables)(node, visibilityCache));
  }, []);
};
exports.allParentAutofocusables = allParentAutofocusables;
},{"./DOMutils":"NPgS","./array":"amJv"}],"rkN0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFocusMerge = void 0;
var _solver = require("./solver");
var _DOMutils = require("./utils/DOMutils");
var _allAffected = require("./utils/all-affected");
var _autoFocus = require("./utils/auto-focus");
var _getActiveElement = require("./utils/getActiveElement");
var _is = require("./utils/is");
var _parenting = require("./utils/parenting");
var reorderNodes = function reorderNodes(srcNodes, dstNodes) {
  var remap = new Map();
  // no Set(dstNodes) for IE11 :(
  dstNodes.forEach(function (entity) {
    return remap.set(entity.node, entity);
  });
  // remap to dstNodes
  return srcNodes.map(function (node) {
    return remap.get(node);
  }).filter(_is.isDefined);
};
/**
 * given top node(s) and the last active element return the element to be focused next
 * @param topNode
 * @param lastNode
 */
var getFocusMerge = function getFocusMerge(topNode, lastNode) {
  var activeElement = document && (0, _getActiveElement.getActiveElement)();
  var entries = (0, _allAffected.getAllAffectedNodes)(topNode).filter(_is.isNotAGuard);
  var commonParent = (0, _parenting.getTopCommonParent)(activeElement || topNode, topNode, entries);
  var visibilityCache = new Map();
  var anyFocusable = (0, _DOMutils.getAllTabbableNodes)(entries, visibilityCache);
  var innerElements = (0, _DOMutils.getTabbableNodes)(entries, visibilityCache).filter(function (_a) {
    var node = _a.node;
    return (0, _is.isNotAGuard)(node);
  });
  if (!innerElements[0]) {
    innerElements = anyFocusable;
    if (!innerElements[0]) {
      return undefined;
    }
  }
  var outerNodes = (0, _DOMutils.getAllTabbableNodes)([commonParent], visibilityCache).map(function (_a) {
    var node = _a.node;
    return node;
  });
  var orderedInnerElements = reorderNodes(outerNodes, innerElements);
  var innerNodes = orderedInnerElements.map(function (_a) {
    var node = _a.node;
    return node;
  });
  var newId = (0, _solver.newFocus)(innerNodes, outerNodes, activeElement, lastNode);
  if (newId === _solver.NEW_FOCUS) {
    var focusNode = (0, _autoFocus.pickAutofocus)(anyFocusable, innerNodes, (0, _parenting.allParentAutofocusables)(entries, visibilityCache));
    if (focusNode) {
      return {
        node: focusNode
      };
    } else {
      console.warn('focus-lock: cannot find any node to move focus into');
      return undefined;
    }
  }
  if (newId === undefined) {
    return newId;
  }
  return orderedInnerElements[newId];
};
exports.getFocusMerge = getFocusMerge;
},{"./solver":"yS1K","./utils/DOMutils":"NPgS","./utils/all-affected":"S0G2","./utils/auto-focus":"Yf6F","./utils/getActiveElement":"YUWN","./utils/is":"TrUa","./utils/parenting":"xURm"}],"oK5K":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFocusabledIn = exports.getFocusableIn = void 0;
var _DOMutils = require("./utils/DOMutils");
var _allAffected = require("./utils/all-affected");
var _is = require("./utils/is");
var _parenting = require("./utils/parenting");
/**
 * return list of focusable elements inside a given top node
 * @deprecated use {@link getFocusableIn}. Yep, there is typo in the function name
 */
var getFocusabledIn = function getFocusabledIn(topNode) {
  var entries = (0, _allAffected.getAllAffectedNodes)(topNode).filter(_is.isNotAGuard);
  var commonParent = (0, _parenting.getTopCommonParent)(topNode, topNode, entries);
  var visibilityCache = new Map();
  var outerNodes = (0, _DOMutils.getTabbableNodes)([commonParent], visibilityCache, true);
  var innerElements = (0, _DOMutils.getTabbableNodes)(entries, visibilityCache).filter(function (_a) {
    var node = _a.node;
    return (0, _is.isNotAGuard)(node);
  }).map(function (_a) {
    var node = _a.node;
    return node;
  });
  return outerNodes.map(function (_a) {
    var node = _a.node,
      index = _a.index;
    return {
      node: node,
      index: index,
      lockItem: innerElements.indexOf(node) >= 0,
      guard: (0, _is.isGuard)(node)
    };
  });
};
/**
 * return list of focusable elements inside a given top node
 */
exports.getFocusabledIn = getFocusabledIn;
var getFocusableIn = getFocusabledIn;
exports.getFocusableIn = getFocusableIn;
},{"./utils/DOMutils":"NPgS","./utils/all-affected":"S0G2","./utils/is":"TrUa","./utils/parenting":"xURm"}],"wPxL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setFocus = exports.focusOn = void 0;
var _focusMerge = require("./focusMerge");
var focusOn = function focusOn(target, focusOptions) {
  if ('focus' in target) {
    target.focus(focusOptions);
  }
  if ('contentWindow' in target && target.contentWindow) {
    target.contentWindow.focus();
  }
};
exports.focusOn = focusOn;
var guardCount = 0;
var lockDisabled = false;
/**
 * Sets focus at a given node. The last focused element will help to determine which element(first or last) should be focused.
 * HTML markers (see {@link import('./constants').FOCUS_AUTO} constants) can control autofocus
 * @param topNode
 * @param lastNode
 * @param options
 */
var setFocus = function setFocus(topNode, lastNode, options) {
  if (options === void 0) {
    options = {};
  }
  var focusable = (0, _focusMerge.getFocusMerge)(topNode, lastNode);
  if (lockDisabled) {
    return;
  }
  if (focusable) {
    if (guardCount > 2) {
      // tslint:disable-next-line:no-console
      console.error('FocusLock: focus-fighting detected. Only one focus management system could be active. ' + 'See https://github.com/theKashey/focus-lock/#focus-fighting');
      lockDisabled = true;
      setTimeout(function () {
        lockDisabled = false;
      }, 1);
      return;
    }
    guardCount++;
    focusOn(focusable.node, options.focusOptions);
    guardCount--;
  }
};
exports.setFocus = setFocus;
},{"./focusMerge":"rkN0"}],"zYhe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.focusPrevElement = exports.focusNextElement = void 0;
var _setFocus = require("./setFocus");
var _DOMutils = require("./utils/DOMutils");
var getRelativeFocusable = function getRelativeFocusable(element, scope) {
  if (!element || !scope || !(0, _DOMutils.contains)(scope, element)) {
    return {};
  }
  var focusables = (0, _DOMutils.getTabbableNodes)([scope], new Map());
  var current = focusables.findIndex(function (_a) {
    var node = _a.node;
    return node === element;
  });
  if (current === -1) {
    return {};
  }
  return {
    prev: focusables[current - 1],
    next: focusables[current + 1],
    first: focusables[0],
    last: focusables[focusables.length - 1]
  };
};
var defaultOptions = function defaultOptions(options) {
  return Object.assign({
    scope: document.body,
    cycle: true
  }, options);
};
/**
 * focuses next element in the tab-order
 * @param baseElement - common parent to scope active element search or tab cycle order
 * @param {FocusNextOptions} [options] - focus options
 */
var focusNextElement = function focusNextElement(baseElement, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = defaultOptions(options),
    scope = _a.scope,
    cycle = _a.cycle;
  var _b = getRelativeFocusable(baseElement, scope),
    next = _b.next,
    first = _b.first;
  var newTarget = next || cycle && first;
  if (newTarget) {
    (0, _setFocus.focusOn)(newTarget.node, options.focusOptions);
  }
};
/**
 * focuses prev element in the tab order
 * @param baseElement - common parent to scope active element search or tab cycle order
 * @param {FocusNextOptions} [options] - focus options
 */
exports.focusNextElement = focusNextElement;
var focusPrevElement = function focusPrevElement(baseElement, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = defaultOptions(options),
    scope = _a.scope,
    cycle = _a.cycle;
  var _b = getRelativeFocusable(baseElement, scope),
    prev = _b.prev,
    last = _b.last;
  var newTarget = prev || cycle && last;
  if (newTarget) {
    (0, _setFocus.focusOn)(newTarget.node, options.focusOptions);
  }
};
exports.focusPrevElement = focusPrevElement;
},{"./setFocus":"wPxL","./utils/DOMutils":"NPgS"}],"YmHU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/* eslint-disable */
/**
 * @deprecated does nothing
 */
var _default = {
  attach: function attach() {},
  detach: function detach() {}
};
exports.default = _default;
},{}],"vNWG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.constants = void 0;
Object.defineProperty(exports, "focusInside", {
  enumerable: true,
  get: function () {
    return _focusInside.focusInside;
  }
});
Object.defineProperty(exports, "focusIsHidden", {
  enumerable: true,
  get: function () {
    return _focusIsHidden.focusIsHidden;
  }
});
Object.defineProperty(exports, "focusMerge", {
  enumerable: true,
  get: function () {
    return _focusMerge.getFocusMerge;
  }
});
Object.defineProperty(exports, "focusNextElement", {
  enumerable: true,
  get: function () {
    return _sibling.focusNextElement;
  }
});
Object.defineProperty(exports, "focusPrevElement", {
  enumerable: true,
  get: function () {
    return _sibling.focusPrevElement;
  }
});
Object.defineProperty(exports, "getActiveElement", {
  enumerable: true,
  get: function () {
    return _getActiveElement.getActiveElement;
  }
});
Object.defineProperty(exports, "getAllAffectedNodes", {
  enumerable: true,
  get: function () {
    return _allAffected.getAllAffectedNodes;
  }
});
Object.defineProperty(exports, "getFocusableIn", {
  enumerable: true,
  get: function () {
    return _focusables.getFocusableIn;
  }
});
Object.defineProperty(exports, "getFocusabledIn", {
  enumerable: true,
  get: function () {
    return _focusables.getFocusabledIn;
  }
});
Object.defineProperty(exports, "tabHook", {
  enumerable: true,
  get: function () {
    return _tabHook.default;
  }
});
var constants = _interopRequireWildcard(require("./constants"));
exports.constants = constants;
var _focusInside = require("./focusInside");
var _focusIsHidden = require("./focusIsHidden");
var _focusMerge = require("./focusMerge");
var _focusables = require("./focusables");
var _setFocus = require("./setFocus");
var _sibling = require("./sibling");
var _tabHook = _interopRequireDefault(require("./tabHook"));
var _allAffected = require("./utils/all-affected");
var _getActiveElement = require("./utils/getActiveElement");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _default = _setFocus.setFocus; //
exports.default = _default;
},{"./constants":"MRzZ","./focusInside":"TTal","./focusIsHidden":"GNty","./focusMerge":"rkN0","./focusables":"oK5K","./setFocus":"wPxL","./sibling":"zYhe","./tabHook":"YmHU","./utils/all-affected":"S0G2","./utils/getActiveElement":"YUWN"}],"V6mn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deferAction = deferAction;
exports.inlineProp = void 0;
function deferAction(action) {
  // Hidding setImmediate from Webpack to avoid inserting polyfill
  var _window = window,
    setImmediate = _window.setImmediate;
  if (typeof setImmediate !== 'undefined') {
    setImmediate(action);
  } else {
    setTimeout(action, 1);
  }
}
var inlineProp = function inlineProp(name, value) {
  var obj = {};
  obj[name] = value;
  return obj;
};
exports.inlineProp = inlineProp;
},{}],"Uzjl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _reactClientsideEffect = _interopRequireDefault(require("react-clientside-effect"));
var _focusLock = _interopRequireWildcard(require("focus-lock"));
var _util = require("./util");
var _medium = require("./medium");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/* eslint-disable no-mixed-operators */

var focusOnBody = function focusOnBody() {
  return document && document.activeElement === document.body;
};
var isFreeFocus = function isFreeFocus() {
  return focusOnBody() || (0, _focusLock.focusIsHidden)();
};
var lastActiveTrap = null;
var lastActiveFocus = null;
var lastPortaledElement = null;
var focusWasOutsideWindow = false;
var defaultWhitelist = function defaultWhitelist() {
  return true;
};
var focusWhitelisted = function focusWhitelisted(activeElement) {
  return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
};
var recordPortal = function recordPortal(observerNode, portaledElement) {
  lastPortaledElement = {
    observerNode: observerNode,
    portaledElement: portaledElement
  };
};
var focusIsPortaledPair = function focusIsPortaledPair(element) {
  return lastPortaledElement && lastPortaledElement.portaledElement === element;
};
function autoGuard(startIndex, end, step, allNodes) {
  var lastGuard = null;
  var i = startIndex;
  do {
    var item = allNodes[i];
    if (item.guard) {
      if (item.node.dataset.focusAutoGuard) {
        lastGuard = item;
      }
    } else if (item.lockItem) {
      if (i !== startIndex) {
        // we will tab to the next element
        return;
      }
      lastGuard = null;
    } else {
      break;
    }
  } while ((i += step) !== end);
  if (lastGuard) {
    lastGuard.node.tabIndex = 0;
  }
}
var extractRef = function extractRef(ref) {
  return ref && 'current' in ref ? ref.current : ref;
};
var focusWasOutside = function focusWasOutside(crossFrameOption) {
  if (crossFrameOption) {
    // with cross frame return true for any value
    return Boolean(focusWasOutsideWindow);
  } // in other case return only of focus went a while aho

  return focusWasOutsideWindow === 'meanwhile';
};
var checkInHost = function checkInHost(check, el, boundary) {
  return el && (
  // find host equal to active element and check nested active element
  el.host === check && (!el.activeElement || boundary.contains(el.activeElement)) // dive up
  || el.parentNode && checkInHost(check, el.parentNode, boundary));
};
var withinHost = function withinHost(activeElement, workingArea) {
  return workingArea.some(function (area) {
    return checkInHost(activeElement, area, area);
  });
};
var activateTrap = function activateTrap() {
  var result = false;
  if (lastActiveTrap) {
    var _lastActiveTrap = lastActiveTrap,
      observed = _lastActiveTrap.observed,
      persistentFocus = _lastActiveTrap.persistentFocus,
      autoFocus = _lastActiveTrap.autoFocus,
      shards = _lastActiveTrap.shards,
      crossFrame = _lastActiveTrap.crossFrame,
      focusOptions = _lastActiveTrap.focusOptions;
    var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
    var activeElement = document && document.activeElement;
    if (workingNode) {
      var workingArea = [workingNode].concat(shards.map(extractRef).filter(Boolean));
      if (!activeElement || focusWhitelisted(activeElement)) {
        if (persistentFocus || focusWasOutside(crossFrame) || !isFreeFocus() || !lastActiveFocus && autoFocus) {
          if (workingNode && !(
          // active element is "inside" working area
          (0, _focusLock.focusInside)(workingArea) ||
          // check for shadow-dom contained elements
          activeElement && withinHost(activeElement, workingArea) || focusIsPortaledPair(activeElement, workingNode))) {
            if (document && !lastActiveFocus && activeElement && !autoFocus) {
              // Check if blur() exists, which is missing on certain elements on IE
              if (activeElement.blur) {
                activeElement.blur();
              }
              document.body.focus();
            } else {
              result = (0, _focusLock.default)(workingArea, lastActiveFocus, {
                focusOptions: focusOptions
              });
              lastPortaledElement = {};
            }
          }
          focusWasOutsideWindow = false;
          lastActiveFocus = document && document.activeElement;
        }
      }
      if (document) {
        var newActiveElement = document && document.activeElement;
        var allNodes = (0, _focusLock.getFocusabledIn)(workingArea);
        var focusedIndex = allNodes.map(function (_ref) {
          var node = _ref.node;
          return node;
        }).indexOf(newActiveElement);
        if (focusedIndex > -1) {
          // remove old focus
          allNodes.filter(function (_ref2) {
            var guard = _ref2.guard,
              node = _ref2.node;
            return guard && node.dataset.focusAutoGuard;
          }).forEach(function (_ref3) {
            var node = _ref3.node;
            return node.removeAttribute('tabIndex');
          });
          autoGuard(focusedIndex, allNodes.length, +1, allNodes);
          autoGuard(focusedIndex, -1, -1, allNodes);
        }
      }
    }
  }
  return result;
};
var onTrap = function onTrap(event) {
  if (activateTrap() && event) {
    // prevent scroll jump
    event.stopPropagation();
    event.preventDefault();
  }
};
var onBlur = function onBlur() {
  return (0, _util.deferAction)(activateTrap);
};
var onFocus = function onFocus(event) {
  // detect portal
  var source = event.target;
  var currentNode = event.currentTarget;
  if (!currentNode.contains(source)) {
    recordPortal(currentNode, source);
  }
};
var FocusWatcher = function FocusWatcher() {
  return null;
};
var FocusTrap = function FocusTrap(_ref4) {
  var children = _ref4.children;
  return /*#__PURE__*/React.createElement("div", {
    onBlur: onBlur,
    onFocus: onFocus
  }, children);
};
FocusTrap.propTypes = "production" !== "production" ? {
  children: _propTypes.default.node.isRequired
} : {};
var onWindowBlur = function onWindowBlur() {
  focusWasOutsideWindow = 'just'; // using setTimeout to set  this variable after React/sidecar reaction

  setTimeout(function () {
    focusWasOutsideWindow = 'meanwhile';
  }, 0);
};
var attachHandler = function attachHandler() {
  document.addEventListener('focusin', onTrap);
  document.addEventListener('focusout', onBlur);
  window.addEventListener('blur', onWindowBlur);
};
var detachHandler = function detachHandler() {
  document.removeEventListener('focusin', onTrap);
  document.removeEventListener('focusout', onBlur);
  window.removeEventListener('blur', onWindowBlur);
};
function reducePropsToState(propsList) {
  return propsList.filter(function (_ref5) {
    var disabled = _ref5.disabled;
    return !disabled;
  });
}
function handleStateChangeOnClient(traps) {
  var trap = traps.slice(-1)[0];
  if (trap && !lastActiveTrap) {
    attachHandler();
  }
  var lastTrap = lastActiveTrap;
  var sameTrap = lastTrap && trap && trap.id === lastTrap.id;
  lastActiveTrap = trap;
  if (lastTrap && !sameTrap) {
    lastTrap.onDeactivation(); // return focus only of last trap was removed

    if (!traps.filter(function (_ref6) {
      var id = _ref6.id;
      return id === lastTrap.id;
    }).length) {
      // allow defer is no other trap is awaiting restore
      lastTrap.returnFocus(!trap);
    }
  }
  if (trap) {
    lastActiveFocus = null;
    if (!sameTrap || lastTrap.observed !== trap.observed) {
      trap.onActivation();
    }
    activateTrap(true);
    (0, _util.deferAction)(activateTrap);
  } else {
    detachHandler();
    lastActiveFocus = null;
  }
} // bind medium

_medium.mediumFocus.assignSyncMedium(onFocus);
_medium.mediumBlur.assignMedium(onBlur);
_medium.mediumEffect.assignMedium(function (cb) {
  return cb({
    moveFocusInside: _focusLock.default,
    focusInside: _focusLock.focusInside
  });
});
var _default = (0, _reactClientsideEffect.default)(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);
exports.default = _default;
},{"react":"n8MK","prop-types":"D9Od","react-clientside-effect":"x8bj","focus-lock":"vNWG","./util":"V6mn","./medium":"bmnZ"}],"hFFf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectWithoutPropertiesLoose"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/extends"));
var React = _interopRequireWildcard(require("react"));
var _Lock = _interopRequireDefault(require("./Lock"));
var _Trap = _interopRequireDefault(require("./Trap"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* that would be a BREAKING CHANGE!
// delaying sidecar execution till the first usage
const RequireSideCar = (props) => {
  // eslint-disable-next-line global-require
  const SideCar = require('./Trap').default;
  return <SideCar {...props} />;
};
*/

var FocusLockCombination = /*#__PURE__*/React.forwardRef(function FocusLockUICombination(props, ref) {
  return /*#__PURE__*/React.createElement(_Lock.default, (0, _extends2.default)({
    sideCar: _Trap.default,
    ref: ref
  }, props));
});
var _ref = _Lock.default.propTypes || {},
  sideCar = _ref.sideCar,
  propTypes = (0, _objectWithoutPropertiesLoose2.default)(_ref, ["sideCar"]);
FocusLockCombination.propTypes = "production" !== "production" ? propTypes : {};
var _default = FocusLockCombination;
exports.default = _default;
},{"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose":"Vabl","@babel/runtime/helpers/esm/extends":"SpjQ","react":"n8MK","./Lock":"KGNx","./Trap":"Uzjl"}],"bj07":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/extends"));
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var constants = _interopRequireWildcard(require("focus-lock/constants"));
var _util = require("./util");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var AutoFocusInside = function AutoFocusInside(_ref) {
  var disabled = _ref.disabled,
    children = _ref.children,
    className = _ref.className;
  return /*#__PURE__*/React.createElement("div", (0, _extends2.default)({}, (0, _util.inlineProp)(constants.FOCUS_AUTO, !disabled), {
    className: className
  }), children);
};
AutoFocusInside.propTypes = "production" !== "production" ? {
  children: _propTypes.default.node.isRequired,
  disabled: _propTypes.default.bool,
  className: _propTypes.default.string
} : {};
AutoFocusInside.defaultProps = {
  disabled: false,
  className: undefined
};
var _default = AutoFocusInside;
exports.default = _default;
},{"@babel/runtime/helpers/esm/extends":"SpjQ","react":"n8MK","prop-types":"D9Od","focus-lock/constants":"MRzZ","./util":"V6mn"}],"DWaG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFocusInside = exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/extends"));
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var constants = _interopRequireWildcard(require("focus-lock/constants"));
var _util = require("./util");
var _medium = require("./medium");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var useFocusInside = function useFocusInside(observedRef) {
  React.useEffect(function () {
    var enabled = true;
    _medium.mediumEffect.useMedium(function (car) {
      var observed = observedRef && observedRef.current;
      if (enabled && observed) {
        if (!car.focusInside(observed)) {
          car.moveFocusInside(observed, null);
        }
      }
    });
    return function () {
      enabled = false;
    };
  }, [observedRef]);
};
exports.useFocusInside = useFocusInside;
function MoveFocusInside(_ref) {
  var isDisabled = _ref.disabled,
    className = _ref.className,
    children = _ref.children;
  var ref = React.useRef(null);
  useFocusInside(isDisabled ? undefined : ref);
  return /*#__PURE__*/React.createElement("div", (0, _extends2.default)({}, (0, _util.inlineProp)(constants.FOCUS_AUTO, !isDisabled), {
    ref: ref,
    className: className
  }), children);
}
MoveFocusInside.propTypes = "production" !== "production" ? {
  children: _propTypes.default.node.isRequired,
  disabled: _propTypes.default.bool,
  className: _propTypes.default.string
} : {};
MoveFocusInside.defaultProps = {
  disabled: false,
  className: undefined
};
var _default = MoveFocusInside;
exports.default = _default;
},{"@babel/runtime/helpers/esm/extends":"SpjQ","react":"n8MK","prop-types":"D9Od","focus-lock/constants":"MRzZ","./util":"V6mn","./medium":"bmnZ"}],"GgOx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/extends"));
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var constants = _interopRequireWildcard(require("focus-lock/constants"));
var _util = require("./util");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var FreeFocusInside = function FreeFocusInside(_ref) {
  var children = _ref.children,
    className = _ref.className;
  return /*#__PURE__*/React.createElement("div", (0, _extends2.default)({}, (0, _util.inlineProp)(constants.FOCUS_ALLOW, true), {
    className: className
  }), children);
};
FreeFocusInside.propTypes = "production" !== "production" ? {
  children: _propTypes.default.node.isRequired,
  className: _propTypes.default.string
} : {};
FreeFocusInside.defaultProps = {
  className: undefined
};
var _default = FreeFocusInside;
exports.default = _default;
},{"@babel/runtime/helpers/esm/extends":"SpjQ","react":"n8MK","prop-types":"D9Od","focus-lock/constants":"MRzZ","./util":"V6mn"}],"aqC0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AutoFocusInside", {
  enumerable: true,
  get: function () {
    return _AutoFocusInside.default;
  }
});
Object.defineProperty(exports, "FocusLockUI", {
  enumerable: true,
  get: function () {
    return _Lock.default;
  }
});
Object.defineProperty(exports, "FreeFocusInside", {
  enumerable: true,
  get: function () {
    return _FreeFocusInside.default;
  }
});
Object.defineProperty(exports, "InFocusGuard", {
  enumerable: true,
  get: function () {
    return _FocusGuard.default;
  }
});
Object.defineProperty(exports, "MoveFocusInside", {
  enumerable: true,
  get: function () {
    return _MoveFocusInside.default;
  }
});
exports.default = void 0;
Object.defineProperty(exports, "useFocusInside", {
  enumerable: true,
  get: function () {
    return _MoveFocusInside.useFocusInside;
  }
});
var _Lock = _interopRequireDefault(require("./Lock"));
var _AutoFocusInside = _interopRequireDefault(require("./AutoFocusInside"));
var _MoveFocusInside = _interopRequireWildcard(require("./MoveFocusInside"));
var _FreeFocusInside = _interopRequireDefault(require("./FreeFocusInside"));
var _FocusGuard = _interopRequireDefault(require("./FocusGuard"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _Lock.default;
exports.default = _default;
},{"./Lock":"KGNx","./AutoFocusInside":"bj07","./MoveFocusInside":"DWaG","./FreeFocusInside":"GgOx","./FocusGuard":"dzMM"}],"N75C":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {};
exports.default = void 0;
var _Combination = _interopRequireDefault(require("./Combination"));
var _UI = require("./UI");
Object.keys(_UI).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _UI[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _UI[key];
    }
  });
});
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _Combination.default;
exports.default = _default;
},{"./Combination":"hFFf","./UI":"aqC0"}],"ZXLg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.focus_lock_default = exports.FocusLock = void 0;
var _reactFocusLock = _interopRequireDefault(require("react-focus-lock"));
var _domUtils = require("@chakra-ui/dom-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// src/focus-lock.tsx

var FocusLock = props => {
  const {
    initialFocusRef,
    finalFocusRef,
    contentRef,
    restoreFocus,
    children,
    isDisabled,
    autoFocus,
    persistentFocus,
    lockFocusAcrossFrames
  } = props;
  const onActivation = (0, _react.useCallback)(() => {
    if (initialFocusRef == null ? void 0 : initialFocusRef.current) {
      initialFocusRef.current.focus();
    } else if (contentRef == null ? void 0 : contentRef.current) {
      const focusables = (0, _domUtils.getAllFocusable)(contentRef.current);
      if (focusables.length === 0) {
        requestAnimationFrame(() => {
          var _a;
          (_a = contentRef.current) == null ? void 0 : _a.focus();
        });
      }
    }
  }, [initialFocusRef, contentRef]);
  const onDeactivation = (0, _react.useCallback)(() => {
    var _a;
    (_a = finalFocusRef == null ? void 0 : finalFocusRef.current) == null ? void 0 : _a.focus();
  }, [finalFocusRef]);
  const returnFocus = restoreFocus && !finalFocusRef;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_reactFocusLock.default, {
    crossFrame: lockFocusAcrossFrames,
    persistentFocus,
    autoFocus,
    disabled: isDisabled,
    onActivation,
    onDeactivation,
    returnFocus,
    children
  });
};
exports.FocusLock = FocusLock;
FocusLock.displayName = "FocusLock";
var focus_lock_default = FocusLock;
exports.focus_lock_default = focus_lock_default;
},{"react-focus-lock":"N75C","@chakra-ui/dom-utils":"p6n0","react":"n8MK","react/jsx-runtime":"plwR"}],"zukx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FocusLock", {
  enumerable: true,
  get: function () {
    return _chunk7RZHVGW.FocusLock;
  }
});
var _chunk7RZHVGW = require("./chunk-7RZHVGW6.mjs");
},{"./chunk-7RZHVGW6.mjs":"ZXLg"}],"SgLN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zeroRightClassName = exports.removedBarSizeVariable = exports.noScrollbarsClassName = exports.fullWidthClassName = void 0;
var zeroRightClassName = 'right-scroll-bar-position';
exports.zeroRightClassName = zeroRightClassName;
var fullWidthClassName = 'width-before-scroll-bar';
exports.fullWidthClassName = fullWidthClassName;
var noScrollbarsClassName = 'with-scroll-bars-hidden';
/**
 * Name of a CSS variable containing the amount of "hidden" scrollbar
 * ! might be undefined ! use will fallback!
 */
exports.noScrollbarsClassName = noScrollbarsClassName;
var removedBarSizeVariable = '--removed-body-scroll-bar-size';
exports.removedBarSizeVariable = removedBarSizeVariable;
},{}],"Fbhq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.effectCar = void 0;
var _useSidecar = require("use-sidecar");
var effectCar = (0, _useSidecar.createSidecarMedium)();
exports.effectCar = effectCar;
},{"use-sidecar":"eYAk"}],"Ltj8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemoveScroll = void 0;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
var _constants = require("react-remove-scroll-bar/constants");
var _useCallbackRef = require("use-callback-ref");
var _medium = require("./medium");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var nothing = function nothing() {
  return;
};
/**
 * Removes scrollbar from the page and contain the scroll within the Lock
 */
var RemoveScroll = React.forwardRef(function (props, parentRef) {
  var ref = React.useRef(null);
  var _a = React.useState({
      onScrollCapture: nothing,
      onWheelCapture: nothing,
      onTouchMoveCapture: nothing
    }),
    callbacks = _a[0],
    setCallbacks = _a[1];
  var forwardProps = props.forwardProps,
    children = props.children,
    className = props.className,
    removeScrollBar = props.removeScrollBar,
    enabled = props.enabled,
    shards = props.shards,
    sideCar = props.sideCar,
    noIsolation = props.noIsolation,
    inert = props.inert,
    allowPinchZoom = props.allowPinchZoom,
    _b = props.as,
    Container = _b === void 0 ? 'div' : _b,
    rest = (0, _tslib.__rest)(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar = sideCar;
  var containerRef = (0, _useCallbackRef.useMergeRefs)([ref, parentRef]);
  var containerProps = (0, _tslib.__assign)((0, _tslib.__assign)({}, rest), callbacks);
  return React.createElement(React.Fragment, null, enabled && React.createElement(SideCar, {
    sideCar: _medium.effectCar,
    removeScrollBar: removeScrollBar,
    shards: shards,
    noIsolation: noIsolation,
    inert: inert,
    setCallbacks: setCallbacks,
    allowPinchZoom: !!allowPinchZoom,
    lockRef: ref
  }), forwardProps ? React.cloneElement(React.Children.only(children), (0, _tslib.__assign)((0, _tslib.__assign)({}, containerProps), {
    ref: containerRef
  })) : React.createElement(Container, (0, _tslib.__assign)({}, containerProps, {
    className: className,
    ref: containerRef
  }), children));
});
exports.RemoveScroll = RemoveScroll;
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: _constants.fullWidthClassName,
  zeroRight: _constants.zeroRightClassName
};
},{"tslib":"vCxL","react":"n8MK","react-remove-scroll-bar/constants":"SgLN","use-callback-ref":"QPxv","./medium":"Fbhq"}],"DGNN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setNonce = exports.getNonce = void 0;
var currentNonce;
var setNonce = function (nonce) {
  currentNonce = nonce;
};
exports.setNonce = setNonce;
var getNonce = function () {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== 'undefined') {
    return __webpack_nonce__;
  }
  return undefined;
};
exports.getNonce = getNonce;
},{}],"DxEz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stylesheetSingleton = void 0;
var _getNonce = require("get-nonce");
function makeStyleTag() {
  if (!document) return null;
  var tag = document.createElement('style');
  tag.type = 'text/css';
  var nonce = (0, _getNonce.getNonce)();
  if (nonce) {
    tag.setAttribute('nonce', nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  // @ts-ignore
  if (tag.styleSheet) {
    // @ts-ignore
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName('head')[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function stylesheetSingleton() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function add(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function remove() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
exports.stylesheetSingleton = stylesheetSingleton;
},{"get-nonce":"DGNN"}],"HwUT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.styleHookSingleton = void 0;
var React = _interopRequireWildcard(require("react"));
var _singleton = require("./singleton");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * creates a hook to control style singleton
 * @see {@link styleSingleton} for a safer component version
 * @example
 * ```tsx
 * const useStyle = styleHookSingleton();
 * ///
 * useStyle('body { overflow: hidden}');
 */
var styleHookSingleton = function styleHookSingleton() {
  var sheet = (0, _singleton.stylesheetSingleton)();
  return function (styles, isDynamic) {
    React.useEffect(function () {
      sheet.add(styles);
      return function () {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
exports.styleHookSingleton = styleHookSingleton;
},{"react":"n8MK","./singleton":"DxEz"}],"O08L":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.styleSingleton = void 0;
var _hook = require("./hook");
/**
 * create a Component to add styles on demand
 * - styles are added when first instance is mounted
 * - styles are removed when the last instance is unmounted
 * - changing styles in runtime does nothing unless dynamic is set. But with multiple components that can lead to the undefined behavior
 */
var styleSingleton = function styleSingleton() {
  var useStyle = (0, _hook.styleHookSingleton)();
  var Sheet = function Sheet(_a) {
    var styles = _a.styles,
      dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
exports.styleSingleton = styleSingleton;
},{"./hook":"HwUT"}],"F1au":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "styleHookSingleton", {
  enumerable: true,
  get: function () {
    return _hook.styleHookSingleton;
  }
});
Object.defineProperty(exports, "styleSingleton", {
  enumerable: true,
  get: function () {
    return _component.styleSingleton;
  }
});
Object.defineProperty(exports, "stylesheetSingleton", {
  enumerable: true,
  get: function () {
    return _singleton.stylesheetSingleton;
  }
});
var _component = require("./component");
var _singleton = require("./singleton");
var _hook = require("./hook");
},{"./component":"O08L","./singleton":"DxEz","./hook":"HwUT"}],"z5zd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zeroGap = exports.getGapWidth = void 0;
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
exports.zeroGap = zeroGap;
var parse = function parse(x) {
  return parseInt(x || '', 10) || 0;
};
var getOffset = function getOffset(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === 'padding' ? 'paddingLeft' : 'marginLeft'];
  var top = cs[gapMode === 'padding' ? 'paddingTop' : 'marginTop'];
  var right = cs[gapMode === 'padding' ? 'paddingRight' : 'marginRight'];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function getGapWidth(gapMode) {
  if (gapMode === void 0) {
    gapMode = 'margin';
  }
  if (typeof window === 'undefined') {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
exports.getGapWidth = getGapWidth;
},{}],"TW1D":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemoveScrollBar = void 0;
var React = _interopRequireWildcard(require("react"));
var _reactStyleSingleton = require("react-style-singleton");
var _constants = require("./constants");
var _utils = require("./utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var Style = (0, _reactStyleSingleton.styleSingleton)();
// important tip - once we measure scrollBar width and remove them
// we could not repeat this operation
// thus we are using style-singleton - only the first "yet correct" style will be applied.
var getStyles = function getStyles(_a, allowRelative, gapMode, important) {
  var left = _a.left,
    top = _a.top,
    right = _a.right,
    gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = 'margin';
  }
  return "\n  .".concat(_constants.noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([allowRelative && "position: relative ".concat(important, ";"), gapMode === 'margin' && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "), gapMode === 'padding' && "padding-right: ".concat(gap, "px ").concat(important, ";")].filter(Boolean).join(''), "\n  }\n  \n  .").concat(_constants.zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(_constants.fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(_constants.zeroRightClassName, " .").concat(_constants.zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(_constants.fullWidthClassName, " .").concat(_constants.fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(_constants.removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
/**
 * Removes page scrollbar and blocks page scroll when mounted
 */
var RemoveScrollBar = function RemoveScrollBar(props) {
  var noRelative = props.noRelative,
    noImportant = props.noImportant,
    _a = props.gapMode,
    gapMode = _a === void 0 ? 'margin' : _a;
  /*
   gap will be measured on every component mount
   however it will be used only by the "first" invocation
   due to singleton nature of <Style
   */
  var gap = React.useMemo(function () {
    return (0, _utils.getGapWidth)(gapMode);
  }, [gapMode]);
  return React.createElement(Style, {
    styles: getStyles(gap, !noRelative, gapMode, !noImportant ? '!important' : '')
  });
};
exports.RemoveScrollBar = RemoveScrollBar;
},{"react":"n8MK","react-style-singleton":"F1au","./constants":"SgLN","./utils":"z5zd"}],"pzIg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "RemoveScrollBar", {
  enumerable: true,
  get: function () {
    return _component.RemoveScrollBar;
  }
});
Object.defineProperty(exports, "fullWidthClassName", {
  enumerable: true,
  get: function () {
    return _constants.fullWidthClassName;
  }
});
Object.defineProperty(exports, "getGapWidth", {
  enumerable: true,
  get: function () {
    return _utils.getGapWidth;
  }
});
Object.defineProperty(exports, "noScrollbarsClassName", {
  enumerable: true,
  get: function () {
    return _constants.noScrollbarsClassName;
  }
});
Object.defineProperty(exports, "removedBarSizeVariable", {
  enumerable: true,
  get: function () {
    return _constants.removedBarSizeVariable;
  }
});
Object.defineProperty(exports, "zeroRightClassName", {
  enumerable: true,
  get: function () {
    return _constants.zeroRightClassName;
  }
});
var _component = require("./component");
var _constants = require("./constants");
var _utils = require("./utils");
},{"./component":"TW1D","./constants":"SgLN","./utils":"z5zd"}],"oa5i":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nonPassive = void 0;
var passiveSupported = false;
if (typeof window !== 'undefined') {
  try {
    var options = Object.defineProperty({}, 'passive', {
      get: function get() {
        passiveSupported = true;
        return true;
      }
    });
    // @ts-ignore
    window.addEventListener('test', options, options);
    // @ts-ignore
    window.removeEventListener('test', options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? {
  passive: false
} : false;
exports.nonPassive = nonPassive;
},{}],"igH5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locationCouldBeScrolled = exports.handleScroll = void 0;
var alwaysContainsScroll = function alwaysContainsScroll(node) {
  // textarea will always _contain_ scroll inside self. It only can be hidden
  return node.tagName === 'TEXTAREA';
};
var elementCanBeScrolled = function elementCanBeScrolled(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== 'hidden' &&
    // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible')
  );
};
var elementCouldBeVScrolled = function elementCouldBeVScrolled(node) {
  return elementCanBeScrolled(node, 'overflowY');
};
var elementCouldBeHScrolled = function elementCouldBeHScrolled(node) {
  return elementCanBeScrolled(node, 'overflowX');
};
var locationCouldBeScrolled = function locationCouldBeScrolled(axis, node) {
  var current = node;
  do {
    // Skip over shadow root
    if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current),
        s = _a[1],
        d = _a[2];
      if (s > d) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
exports.locationCouldBeScrolled = locationCouldBeScrolled;
var getVScrollVariables = function getVScrollVariables(_a) {
  var scrollTop = _a.scrollTop,
    scrollHeight = _a.scrollHeight,
    clientHeight = _a.clientHeight;
  return [scrollTop, scrollHeight, clientHeight];
};
var getHScrollVariables = function getHScrollVariables(_a) {
  var scrollLeft = _a.scrollLeft,
    scrollWidth = _a.scrollWidth,
    clientWidth = _a.clientWidth;
  return [scrollLeft, scrollWidth, clientWidth];
};
var elementCouldBeScrolled = function elementCouldBeScrolled(axis, node) {
  return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function getScrollVariables(axis, node) {
  return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function getDirectionFactor(axis, direction) {
  /**
   * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,
   * and then increasingly negative as you scroll towards the end of the content.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft
   */
  return axis === 'h' && direction === 'rtl' ? -1 : 1;
};
var handleScroll = function handleScroll(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  // find scrollable target
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target),
      position = _a[0],
      scroll_1 = _a[1],
      capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (
  // portaled content
  !targetInLock && target !== document.body ||
  // self content
  targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
exports.handleScroll = handleScroll;
},{}],"gQ5z":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemoveScrollSideCar = RemoveScrollSideCar;
exports.getTouchXY = exports.getDeltaXY = void 0;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
var _reactRemoveScrollBar = require("react-remove-scroll-bar");
var _reactStyleSingleton = require("react-style-singleton");
var _aggresiveCapture = require("./aggresiveCapture");
var _handleScroll = require("./handleScroll");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var getTouchXY = function getTouchXY(event) {
  return 'changedTouches' in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
exports.getTouchXY = getTouchXY;
var getDeltaXY = function getDeltaXY(event) {
  return [event.deltaX, event.deltaY];
};
exports.getDeltaXY = getDeltaXY;
var extractRef = function extractRef(ref) {
  return ref && 'current' in ref ? ref.current : ref;
};
var deltaCompare = function deltaCompare(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function generateStyle(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]);
  var touchStartRef = React.useRef([0, 0]);
  var activeAxis = React.useRef();
  var id = React.useState(idCounter++)[0];
  var Style = React.useState(function () {
    return (0, _reactStyleSingleton.styleSingleton)();
  })[0];
  var lastProps = React.useRef(props);
  React.useEffect(function () {
    lastProps.current = props;
  }, [props]);
  React.useEffect(function () {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = (0, _tslib.__spreadArray)([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function (el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function () {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function (el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function (event, parent) {
    if ('touches' in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = 'deltaX' in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = 'deltaY' in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'h' : 'v';
    // allow horizontal touch move on Range inputs. They will not cause any scroll
    if ('touches' in event && moveDirection === 'h' && target.type === 'range') {
      return false;
    }
    var canBeScrolledInMainDirection = (0, _handleScroll.locationCouldBeScrolled)(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === 'v' ? 'h' : 'v';
      canBeScrolledInMainDirection = (0, _handleScroll.locationCouldBeScrolled)(moveDirection, target);
      // other axis might be not scrollable
    }

    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && 'changedTouches' in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return (0, _handleScroll.handleScroll)(cancelingAxis, parent, event, cancelingAxis === 'h' ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React.useCallback(function (_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style) {
      // not the last active
      return;
    }
    var delta = 'deltaY' in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function (e) {
      return e.name === event.type && e.target === event.target && deltaCompare(e.delta, delta);
    })[0];
    // self event, and should be canceled
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    // outside or shard event
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function (node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React.useCallback(function (name, delta, target, should) {
    var event = {
      name: name,
      delta: delta,
      target: target,
      should: should
    };
    shouldPreventQueue.current.push(event);
    setTimeout(function () {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function (e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React.useCallback(function (event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = undefined;
  }, []);
  var scrollWheel = React.useCallback(function (event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React.useCallback(function (event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function () {
    lockStack.push(Style);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener('wheel', shouldPrevent, _aggresiveCapture.nonPassive);
    document.addEventListener('touchmove', shouldPrevent, _aggresiveCapture.nonPassive);
    document.addEventListener('touchstart', scrollTouchStart, _aggresiveCapture.nonPassive);
    return function () {
      lockStack = lockStack.filter(function (inst) {
        return inst !== Style;
      });
      document.removeEventListener('wheel', shouldPrevent, _aggresiveCapture.nonPassive);
      document.removeEventListener('touchmove', shouldPrevent, _aggresiveCapture.nonPassive);
      document.removeEventListener('touchstart', scrollTouchStart, _aggresiveCapture.nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar,
    inert = props.inert;
  return React.createElement(React.Fragment, null, inert ? React.createElement(Style, {
    styles: generateStyle(id)
  }) : null, removeScrollBar ? React.createElement(_reactRemoveScrollBar.RemoveScrollBar, {
    gapMode: "margin"
  }) : null);
}
},{"tslib":"vCxL","react":"n8MK","react-remove-scroll-bar":"pzIg","react-style-singleton":"F1au","./aggresiveCapture":"oa5i","./handleScroll":"igH5"}],"KvEZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _useSidecar = require("use-sidecar");
var _SideEffect = require("./SideEffect");
var _medium = require("./medium");
var _default = (0, _useSidecar.exportSidecar)(_medium.effectCar, _SideEffect.RemoveScrollSideCar);
exports.default = _default;
},{"use-sidecar":"eYAk","./SideEffect":"gQ5z","./medium":"Fbhq"}],"keVS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = require("tslib");
var React = _interopRequireWildcard(require("react"));
var _UI = require("./UI");
var _sidecar = _interopRequireDefault(require("./sidecar"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var ReactRemoveScroll = React.forwardRef(function (props, ref) {
  return React.createElement(_UI.RemoveScroll, (0, _tslib.__assign)({}, props, {
    ref: ref,
    sideCar: _sidecar.default
  }));
});
ReactRemoveScroll.classNames = _UI.RemoveScroll.classNames;
var _default = ReactRemoveScroll;
exports.default = _default;
},{"tslib":"vCxL","react":"n8MK","./UI":"Ltj8","./sidecar":"KvEZ"}],"nI5P":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "RemoveScroll", {
  enumerable: true,
  get: function () {
    return _Combination.default;
  }
});
var _Combination = _interopRequireDefault(require("./Combination"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./Combination":"keVS"}],"ocvS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModalFocusScope = ModalFocusScope;
var _chunkQDOQR5LQ = require("./chunk-QDOQR5LQ.mjs");
var _focusLock = require("@chakra-ui/focus-lock");
var _framerMotion = require("framer-motion");
var _react = require("react");
var _reactRemoveScroll = require("react-remove-scroll");
var _jsxRuntime = require("react/jsx-runtime");
// src/modal-focus.tsx

function ModalFocusScope(props) {
  const {
    autoFocus,
    trapFocus,
    dialogRef,
    initialFocusRef,
    blockScrollOnMount,
    allowPinchZoom,
    finalFocusRef,
    returnFocusOnClose,
    preserveScrollBarGap,
    lockFocusAcrossFrames
  } = (0, _chunkQDOQR5LQ.useModalContext)();
  const [isPresent, safeToRemove] = (0, _framerMotion.usePresence)();
  (0, _react.useEffect)(() => {
    if (!isPresent && safeToRemove) {
      setTimeout(safeToRemove);
    }
  }, [isPresent, safeToRemove]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_focusLock.FocusLock, {
    autoFocus,
    isDisabled: !trapFocus,
    initialFocusRef,
    finalFocusRef,
    restoreFocus: returnFocusOnClose,
    contentRef: dialogRef,
    lockFocusAcrossFrames,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_reactRemoveScroll.RemoveScroll, {
      removeScrollBar: !preserveScrollBarGap,
      allowPinchZoom,
      enabled: blockScrollOnMount,
      forwardProps: true,
      children: props.children
    })
  });
}
},{"./chunk-QDOQR5LQ.mjs":"PTTK","@chakra-ui/focus-lock":"zukx","framer-motion":"gNpu","react":"n8MK","react-remove-scroll":"nI5P","react/jsx-runtime":"plwR"}],"pgUE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModalContent = void 0;
var _chunkXV7ZWFID = require("./chunk-XV7ZWFID.mjs");
var _chunkZ22N3J7E = require("./chunk-Z22N3J7E.mjs");
var _chunkQDOQR5LQ = require("./chunk-QDOQR5LQ.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/modal-content.tsx

var ModalContent = (0, _system.forwardRef)((props, ref) => {
  const {
    className,
    children,
    containerProps: rootProps,
    motionProps,
    ...rest
  } = props;
  const {
    getDialogProps,
    getDialogContainerProps
  } = (0, _chunkQDOQR5LQ.useModalContext)();
  const dialogProps = getDialogProps(rest, ref);
  const containerProps = getDialogContainerProps(rootProps);
  const _className = (0, _sharedUtils.cx)("chakra-modal__content", className);
  const styles = (0, _chunkQDOQR5LQ.useModalStyles)();
  const dialogStyles = {
    display: "flex",
    flexDirection: "column",
    position: "relative",
    width: "100%",
    outline: 0,
    ...styles.dialog
  };
  const dialogContainerStyles = {
    display: "flex",
    width: "100vw",
    height: "$100vh",
    position: "fixed",
    left: 0,
    top: 0,
    ...styles.dialogContainer
  };
  const {
    motionPreset
  } = (0, _chunkQDOQR5LQ.useModalContext)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkZ22N3J7E.ModalFocusScope, {
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
      ...containerProps,
      className: "chakra-modal__content-container",
      tabIndex: -1,
      __css: dialogContainerStyles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkXV7ZWFID.ModalTransition, {
        preset: motionPreset,
        motionProps,
        className: _className,
        ...dialogProps,
        __css: dialogStyles,
        children
      })
    })
  });
});
exports.ModalContent = ModalContent;
ModalContent.displayName = "ModalContent";
},{"./chunk-XV7ZWFID.mjs":"aPMz","./chunk-Z22N3J7E.mjs":"ocvS","./chunk-QDOQR5LQ.mjs":"PTTK","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"bh07":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlertDialog = AlertDialog;
exports.AlertDialogContent = void 0;
var _chunkARV3YJLM = require("./chunk-ARV3YJLM.mjs");
var _chunkQDOQR5LQ = require("./chunk-QDOQR5LQ.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/alert-dialog.tsx

function AlertDialog(props) {
  const {
    leastDestructiveRef,
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkQDOQR5LQ.Modal, {
    ...rest,
    initialFocusRef: leastDestructiveRef
  });
}
var AlertDialogContent = (0, _system.forwardRef)((props, ref) => /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkARV3YJLM.ModalContent, {
  ref,
  role: "alertdialog",
  ...props
}));
exports.AlertDialogContent = AlertDialogContent;
},{"./chunk-ARV3YJLM.mjs":"pgUE","./chunk-QDOQR5LQ.mjs":"PTTK","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"SgT4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Drawer = Drawer;
exports.useDrawerContext = void 0;
var _chunkQDOQR5LQ = require("./chunk-QDOQR5LQ.mjs");
var _reactContext = require("@chakra-ui/react-context");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/drawer.tsx

var [DrawerContextProvider, useDrawerContext] = (0, _reactContext.createContext)();
exports.useDrawerContext = useDrawerContext;
var placementMap = {
  start: {
    ltr: "left",
    rtl: "right"
  },
  end: {
    ltr: "right",
    rtl: "left"
  }
};
function getDrawerPlacement(placement, dir) {
  var _a, _b;
  if (!placement) return;
  return (_b = (_a = placementMap[placement]) == null ? void 0 : _a[dir]) != null ? _b : placement;
}
function Drawer(props) {
  var _a;
  const {
    isOpen,
    onClose,
    placement: placementProp = "right",
    children,
    ...rest
  } = props;
  const theme = (0, _system.useTheme)();
  const drawerStyleConfig = (_a = theme.components) == null ? void 0 : _a.Drawer;
  const placement = getDrawerPlacement(placementProp, theme.direction);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(DrawerContextProvider, {
    value: {
      placement
    },
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkQDOQR5LQ.Modal, {
      isOpen,
      onClose,
      styleConfig: drawerStyleConfig,
      ...rest,
      children
    })
  });
}
},{"./chunk-QDOQR5LQ.mjs":"PTTK","@chakra-ui/react-context":"lT23","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"wcZ1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawerContent = void 0;
var _chunkDYEWBK6J = require("./chunk-DYEWBK6J.mjs");
var _chunkZ22N3J7E = require("./chunk-Z22N3J7E.mjs");
var _chunkQDOQR5LQ = require("./chunk-QDOQR5LQ.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _transition = require("@chakra-ui/transition");
var _jsxRuntime = require("react/jsx-runtime");
// src/drawer-content.tsx

var MotionDiv = (0, _system.chakra)(_transition.Slide);
var DrawerContent = (0, _system.forwardRef)((props, ref) => {
  const {
    className,
    children,
    motionProps,
    containerProps: rootProps,
    ...rest
  } = props;
  const {
    getDialogProps,
    getDialogContainerProps,
    isOpen
  } = (0, _chunkQDOQR5LQ.useModalContext)();
  const dialogProps = getDialogProps(rest, ref);
  const containerProps = getDialogContainerProps(rootProps);
  const _className = (0, _sharedUtils.cx)("chakra-modal__content", className);
  const styles = (0, _chunkQDOQR5LQ.useModalStyles)();
  const dialogStyles = {
    display: "flex",
    flexDirection: "column",
    position: "relative",
    width: "100%",
    outline: 0,
    ...styles.dialog
  };
  const dialogContainerStyles = {
    display: "flex",
    width: "100vw",
    height: "$100vh",
    position: "fixed",
    left: 0,
    top: 0,
    ...styles.dialogContainer
  };
  const {
    placement
  } = (0, _chunkDYEWBK6J.useDrawerContext)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkZ22N3J7E.ModalFocusScope, {
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
      ...containerProps,
      className: "chakra-modal__content-container",
      __css: dialogContainerStyles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(MotionDiv, {
        motionProps,
        direction: placement,
        in: isOpen,
        className: _className,
        ...dialogProps,
        __css: dialogStyles,
        children
      })
    })
  });
});
exports.DrawerContent = DrawerContent;
DrawerContent.displayName = "DrawerContent";
},{"./chunk-DYEWBK6J.mjs":"SgT4","./chunk-Z22N3J7E.mjs":"ocvS","./chunk-QDOQR5LQ.mjs":"PTTK","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","@chakra-ui/transition":"H7Ru","react/jsx-runtime":"plwR"}],"MdMz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModalFooter = void 0;
var _chunkQDOQR5LQ = require("./chunk-QDOQR5LQ.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/modal-footer.tsx

var ModalFooter = (0, _system.forwardRef)((props, ref) => {
  const {
    className,
    ...rest
  } = props;
  const _className = (0, _sharedUtils.cx)("chakra-modal__footer", className);
  const styles = (0, _chunkQDOQR5LQ.useModalStyles)();
  const footerStyles = {
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-end",
    ...styles.footer
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.footer, {
    ref,
    ...rest,
    __css: footerStyles,
    className: _className
  });
});
exports.ModalFooter = ModalFooter;
ModalFooter.displayName = "ModalFooter";
},{"./chunk-QDOQR5LQ.mjs":"PTTK","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"mhtY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModalHeader = void 0;
var _chunkQDOQR5LQ = require("./chunk-QDOQR5LQ.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/modal-header.tsx

var ModalHeader = (0, _system.forwardRef)((props, ref) => {
  const {
    className,
    ...rest
  } = props;
  const {
    headerId,
    setHeaderMounted
  } = (0, _chunkQDOQR5LQ.useModalContext)();
  (0, _react.useEffect)(() => {
    setHeaderMounted(true);
    return () => setHeaderMounted(false);
  }, [setHeaderMounted]);
  const _className = (0, _sharedUtils.cx)("chakra-modal__header", className);
  const styles = (0, _chunkQDOQR5LQ.useModalStyles)();
  const headerStyles = {
    flex: 0,
    ...styles.header
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.header, {
    ref,
    className: _className,
    id: headerId,
    ...rest,
    __css: headerStyles
  });
});
exports.ModalHeader = ModalHeader;
ModalHeader.displayName = "ModalHeader";
},{"./chunk-QDOQR5LQ.mjs":"PTTK","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react":"n8MK","react/jsx-runtime":"plwR"}],"cb4M":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModalOverlay = void 0;
var _chunkQDOQR5LQ = require("./chunk-QDOQR5LQ.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _transition = require("@chakra-ui/transition");
var _framerMotion = require("framer-motion");
var _jsxRuntime = require("react/jsx-runtime");
// src/modal-overlay.tsx

var MotionDiv = (0, _system.chakra)(_framerMotion.motion.div);
var ModalOverlay = (0, _system.forwardRef)((props, ref) => {
  const {
    className,
    transition,
    motionProps: _motionProps,
    ...rest
  } = props;
  const _className = (0, _sharedUtils.cx)("chakra-modal__overlay", className);
  const styles = (0, _chunkQDOQR5LQ.useModalStyles)();
  const overlayStyle = {
    pos: "fixed",
    left: "0",
    top: "0",
    w: "100vw",
    h: "100vh",
    ...styles.overlay
  };
  const {
    motionPreset
  } = (0, _chunkQDOQR5LQ.useModalContext)();
  const defaultMotionProps = motionPreset === "none" ? {} : _transition.fadeConfig;
  const motionProps = _motionProps || defaultMotionProps;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(MotionDiv, {
    ...motionProps,
    __css: overlayStyle,
    ref,
    className: _className,
    ...rest
  });
});
exports.ModalOverlay = ModalOverlay;
ModalOverlay.displayName = "ModalOverlay";
},{"./chunk-QDOQR5LQ.mjs":"PTTK","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","@chakra-ui/transition":"H7Ru","framer-motion":"gNpu","react/jsx-runtime":"plwR"}],"PhXV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModalBody = void 0;
var _chunkQDOQR5LQ = require("./chunk-QDOQR5LQ.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/modal-body.tsx

var ModalBody = (0, _system.forwardRef)((props, ref) => {
  const {
    className,
    ...rest
  } = props;
  const {
    bodyId,
    setBodyMounted
  } = (0, _chunkQDOQR5LQ.useModalContext)();
  (0, _react.useEffect)(() => {
    setBodyMounted(true);
    return () => setBodyMounted(false);
  }, [setBodyMounted]);
  const _className = (0, _sharedUtils.cx)("chakra-modal__body", className);
  const styles = (0, _chunkQDOQR5LQ.useModalStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    className: _className,
    id: bodyId,
    ...rest,
    __css: styles.body
  });
});
exports.ModalBody = ModalBody;
ModalBody.displayName = "ModalBody";
},{"./chunk-QDOQR5LQ.mjs":"PTTK","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react":"n8MK","react/jsx-runtime":"plwR"}],"sA7a":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModalCloseButton = void 0;
var _chunkQDOQR5LQ = require("./chunk-QDOQR5LQ.mjs");
var _closeButton = require("@chakra-ui/close-button");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/modal-close-button.tsx

var ModalCloseButton = (0, _system.forwardRef)((props, ref) => {
  const {
    onClick,
    className,
    ...rest
  } = props;
  const {
    onClose
  } = (0, _chunkQDOQR5LQ.useModalContext)();
  const _className = (0, _sharedUtils.cx)("chakra-modal__close-btn", className);
  const styles = (0, _chunkQDOQR5LQ.useModalStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_closeButton.CloseButton, {
    ref,
    __css: styles.closeButton,
    className: _className,
    onClick: (0, _sharedUtils.callAllHandlers)(onClick, event => {
      event.stopPropagation();
      onClose();
    }),
    ...rest
  });
});
exports.ModalCloseButton = ModalCloseButton;
ModalCloseButton.displayName = "ModalCloseButton";
},{"./chunk-QDOQR5LQ.mjs":"PTTK","@chakra-ui/close-button":"pReG","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"HZsu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AlertDialog", {
  enumerable: true,
  get: function () {
    return _chunkB4R3XVXG.AlertDialog;
  }
});
Object.defineProperty(exports, "AlertDialogBody", {
  enumerable: true,
  get: function () {
    return _chunkHM4YFVU.ModalBody;
  }
});
Object.defineProperty(exports, "AlertDialogCloseButton", {
  enumerable: true,
  get: function () {
    return _chunkUH5GSJBK.ModalCloseButton;
  }
});
Object.defineProperty(exports, "AlertDialogContent", {
  enumerable: true,
  get: function () {
    return _chunkB4R3XVXG.AlertDialogContent;
  }
});
Object.defineProperty(exports, "AlertDialogFooter", {
  enumerable: true,
  get: function () {
    return _chunkLOE35NO.ModalFooter;
  }
});
Object.defineProperty(exports, "AlertDialogHeader", {
  enumerable: true,
  get: function () {
    return _chunk33WRONZ.ModalHeader;
  }
});
Object.defineProperty(exports, "AlertDialogOverlay", {
  enumerable: true,
  get: function () {
    return _chunkZEHAHQ4Q.ModalOverlay;
  }
});
Object.defineProperty(exports, "Drawer", {
  enumerable: true,
  get: function () {
    return _chunkDYEWBK6J.Drawer;
  }
});
Object.defineProperty(exports, "DrawerBody", {
  enumerable: true,
  get: function () {
    return _chunkHM4YFVU.ModalBody;
  }
});
Object.defineProperty(exports, "DrawerCloseButton", {
  enumerable: true,
  get: function () {
    return _chunkUH5GSJBK.ModalCloseButton;
  }
});
Object.defineProperty(exports, "DrawerContent", {
  enumerable: true,
  get: function () {
    return _chunk5VICFQ.DrawerContent;
  }
});
Object.defineProperty(exports, "DrawerFooter", {
  enumerable: true,
  get: function () {
    return _chunkLOE35NO.ModalFooter;
  }
});
Object.defineProperty(exports, "DrawerHeader", {
  enumerable: true,
  get: function () {
    return _chunk33WRONZ.ModalHeader;
  }
});
Object.defineProperty(exports, "DrawerOverlay", {
  enumerable: true,
  get: function () {
    return _chunkZEHAHQ4Q.ModalOverlay;
  }
});
Object.defineProperty(exports, "Modal", {
  enumerable: true,
  get: function () {
    return _chunkQDOQR5LQ.Modal;
  }
});
Object.defineProperty(exports, "ModalBody", {
  enumerable: true,
  get: function () {
    return _chunkHM4YFVU.ModalBody;
  }
});
Object.defineProperty(exports, "ModalCloseButton", {
  enumerable: true,
  get: function () {
    return _chunkUH5GSJBK.ModalCloseButton;
  }
});
Object.defineProperty(exports, "ModalContent", {
  enumerable: true,
  get: function () {
    return _chunkARV3YJLM.ModalContent;
  }
});
Object.defineProperty(exports, "ModalContextProvider", {
  enumerable: true,
  get: function () {
    return _chunkQDOQR5LQ.ModalContextProvider;
  }
});
Object.defineProperty(exports, "ModalFocusScope", {
  enumerable: true,
  get: function () {
    return _chunkZ22N3J7E.ModalFocusScope;
  }
});
Object.defineProperty(exports, "ModalFooter", {
  enumerable: true,
  get: function () {
    return _chunkLOE35NO.ModalFooter;
  }
});
Object.defineProperty(exports, "ModalHeader", {
  enumerable: true,
  get: function () {
    return _chunk33WRONZ.ModalHeader;
  }
});
Object.defineProperty(exports, "ModalOverlay", {
  enumerable: true,
  get: function () {
    return _chunkZEHAHQ4Q.ModalOverlay;
  }
});
Object.defineProperty(exports, "useAriaHidden", {
  enumerable: true,
  get: function () {
    return _chunk3JMIHPMG.useAriaHidden;
  }
});
Object.defineProperty(exports, "useDrawerContext", {
  enumerable: true,
  get: function () {
    return _chunkDYEWBK6J.useDrawerContext;
  }
});
Object.defineProperty(exports, "useModal", {
  enumerable: true,
  get: function () {
    return _chunk3JMIHPMG.useModal;
  }
});
Object.defineProperty(exports, "useModalContext", {
  enumerable: true,
  get: function () {
    return _chunkQDOQR5LQ.useModalContext;
  }
});
Object.defineProperty(exports, "useModalStyles", {
  enumerable: true,
  get: function () {
    return _chunkQDOQR5LQ.useModalStyles;
  }
});
var _chunkB4R3XVXG = require("./chunk-B4R3XVXG.mjs");
var _chunk5VICFQ = require("./chunk-5VICFQ65.mjs");
var _chunkDYEWBK6J = require("./chunk-DYEWBK6J.mjs");
var _chunkLOE35NO = require("./chunk-LOE35NO6.mjs");
var _chunk33WRONZ = require("./chunk-33WRONZ2.mjs");
var _chunkZEHAHQ4Q = require("./chunk-ZEHAHQ4Q.mjs");
var _chunkHM4YFVU = require("./chunk-HM4YFVU6.mjs");
var _chunkUH5GSJBK = require("./chunk-UH5GSJBK.mjs");
var _chunkARV3YJLM = require("./chunk-ARV3YJLM.mjs");
require("./chunk-XV7ZWFID.mjs");
var _chunkZ22N3J7E = require("./chunk-Z22N3J7E.mjs");
var _chunkQDOQR5LQ = require("./chunk-QDOQR5LQ.mjs");
var _chunk3JMIHPMG = require("./chunk-3JMIHPMG.mjs");
require("./chunk-BR5VXYQ3.mjs");
require("./chunk-NHABU752.mjs");
},{"./chunk-B4R3XVXG.mjs":"bh07","./chunk-5VICFQ65.mjs":"wcZ1","./chunk-DYEWBK6J.mjs":"SgT4","./chunk-LOE35NO6.mjs":"MdMz","./chunk-33WRONZ2.mjs":"mhtY","./chunk-ZEHAHQ4Q.mjs":"cb4M","./chunk-HM4YFVU6.mjs":"PhXV","./chunk-UH5GSJBK.mjs":"sA7a","./chunk-ARV3YJLM.mjs":"pgUE","./chunk-XV7ZWFID.mjs":"aPMz","./chunk-Z22N3J7E.mjs":"ocvS","./chunk-QDOQR5LQ.mjs":"PTTK","./chunk-3JMIHPMG.mjs":"V7IG","./chunk-BR5VXYQ3.mjs":"B0SQ","./chunk-NHABU752.mjs":"e2uv"}],"ca5E":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TriangleUpIcon = exports.TriangleDownIcon = void 0;
var _icon = require("@chakra-ui/icon");
var _jsxRuntime = require("react/jsx-runtime");
// src/icons.tsx

var TriangleDownIcon = props => /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
  viewBox: "0 0 24 24",
  ...props,
  children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
    fill: "currentColor",
    d: "M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z"
  })
});
exports.TriangleDownIcon = TriangleDownIcon;
var TriangleUpIcon = props => /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
  viewBox: "0 0 24 24",
  ...props,
  children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
    fill: "currentColor",
    d: "M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z"
  })
});
exports.TriangleUpIcon = TriangleUpIcon;
},{"@chakra-ui/icon":"aPuf","react/jsx-runtime":"plwR"}],"jdyo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAttributeObserver = useAttributeObserver;
var _react = require("react");
// src/use-attr-observer.ts

function useAttributeObserver(ref, attributes, fn, enabled) {
  (0, _react.useEffect)(() => {
    var _a;
    if (!ref.current || !enabled) return;
    const win = (_a = ref.current.ownerDocument.defaultView) != null ? _a : window;
    const attrs = Array.isArray(attributes) ? attributes : [attributes];
    const obs = new win.MutationObserver(changes => {
      for (const change of changes) {
        if (change.type === "attributes" && change.attributeName && attrs.includes(change.attributeName)) {
          fn(change);
        }
      }
    });
    obs.observe(ref.current, {
      attributes: true,
      attributeFilter: attrs
    });
    return () => obs.disconnect();
  });
}
},{"react":"n8MK"}],"nLDP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInterval = useInterval;
var _react = require("react");
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
// src/index.ts

function useInterval(callback, delay) {
  const fn = (0, _reactUseCallbackRef.useCallbackRef)(callback);
  (0, _react.useEffect)(() => {
    let intervalId = null;
    const tick = () => fn();
    if (delay !== null) {
      intervalId = window.setInterval(tick, delay);
    }
    return () => {
      if (intervalId) {
        window.clearInterval(intervalId);
      }
    };
  }, [delay, fn]);
}
},{"react":"n8MK","@chakra-ui/react-use-callback-ref":"PPhG"}],"QVWj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSpinner = useSpinner;
var _reactUseInterval = require("@chakra-ui/react-use-interval");
var _react = require("react");
// src/use-spinner.ts

var CONTINUOUS_CHANGE_INTERVAL = 50;
var CONTINUOUS_CHANGE_DELAY = 300;
function useSpinner(increment, decrement) {
  const [isSpinning, setIsSpinning] = (0, _react.useState)(false);
  const [action, setAction] = (0, _react.useState)(null);
  const [runOnce, setRunOnce] = (0, _react.useState)(true);
  const timeoutRef = (0, _react.useRef)(null);
  const removeTimeout = () => clearTimeout(timeoutRef.current);
  (0, _reactUseInterval.useInterval)(() => {
    if (action === "increment") {
      increment();
    }
    if (action === "decrement") {
      decrement();
    }
  }, isSpinning ? CONTINUOUS_CHANGE_INTERVAL : null);
  const up = (0, _react.useCallback)(() => {
    if (runOnce) {
      increment();
    }
    timeoutRef.current = setTimeout(() => {
      setRunOnce(false);
      setIsSpinning(true);
      setAction("increment");
    }, CONTINUOUS_CHANGE_DELAY);
  }, [increment, runOnce]);
  const down = (0, _react.useCallback)(() => {
    if (runOnce) {
      decrement();
    }
    timeoutRef.current = setTimeout(() => {
      setRunOnce(false);
      setIsSpinning(true);
      setAction("decrement");
    }, CONTINUOUS_CHANGE_DELAY);
  }, [decrement, runOnce]);
  const stop = (0, _react.useCallback)(() => {
    setRunOnce(true);
    setIsSpinning(false);
    removeTimeout();
  }, []);
  (0, _react.useEffect)(() => {
    return () => removeTimeout();
  }, []);
  return {
    up,
    down,
    stop,
    isSpinning
  };
}
},{"@chakra-ui/react-use-interval":"nLDP","react":"n8MK"}],"kOPV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useNumberInput = useNumberInput;
var _chunkXRH675A = require("./chunk-XRH675A5.mjs");
var _chunkJCNYS6PS = require("./chunk-JCNYS6PS.mjs");
var _counter = require("@chakra-ui/counter");
var _reactUseEventListener = require("@chakra-ui/react-use-event-listener");
var _reactUseUpdateEffect = require("@chakra-ui/react-use-update-effect");
var _reactUseSafeLayoutEffect = require("@chakra-ui/react-use-safe-layout-effect");
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
// src/use-number-input.ts

var FLOATING_POINT_REGEX = /^[Ee0-9+\-.]$/;
function isFloatingPointNumericCharacter(character) {
  return FLOATING_POINT_REGEX.test(character);
}
function isValidNumericKeyboardEvent(event, isValid) {
  if (event.key == null) return true;
  const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
  const isSingleCharacterKey = event.key.length === 1;
  if (!isSingleCharacterKey || isModifierKey) return true;
  return isValid(event.key);
}
function useNumberInput(props = {}) {
  const {
    focusInputOnChange = true,
    clampValueOnBlur = true,
    keepWithinRange = true,
    min = Number.MIN_SAFE_INTEGER,
    max = Number.MAX_SAFE_INTEGER,
    step: stepProp = 1,
    isReadOnly,
    isDisabled,
    isRequired,
    isInvalid,
    pattern = "[0-9]*(.[0-9]+)?",
    inputMode = "decimal",
    allowMouseWheel,
    id,
    onChange: _,
    precision,
    name,
    "aria-describedby": ariaDescBy,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    onFocus: onFocusProp,
    onBlur: onBlurProp,
    onInvalid: onInvalidProp,
    getAriaValueText: getAriaValueTextProp,
    isValidCharacter: isValidCharacterProp,
    format: formatValue,
    parse: parseValue,
    ...htmlProps
  } = props;
  const onFocus = (0, _reactUseCallbackRef.useCallbackRef)(onFocusProp);
  const onBlur = (0, _reactUseCallbackRef.useCallbackRef)(onBlurProp);
  const onInvalid = (0, _reactUseCallbackRef.useCallbackRef)(onInvalidProp);
  const isValidCharacter = (0, _reactUseCallbackRef.useCallbackRef)(isValidCharacterProp != null ? isValidCharacterProp : isFloatingPointNumericCharacter);
  const getAriaValueText = (0, _reactUseCallbackRef.useCallbackRef)(getAriaValueTextProp);
  const counter = (0, _counter.useCounter)(props);
  const {
    update: updateFn,
    increment: incrementFn,
    decrement: decrementFn
  } = counter;
  const [isFocused, setFocused] = (0, _react.useState)(false);
  const isInteractive = !(isReadOnly || isDisabled);
  const inputRef = (0, _react.useRef)(null);
  const inputSelectionRef = (0, _react.useRef)(null);
  const incrementButtonRef = (0, _react.useRef)(null);
  const decrementButtonRef = (0, _react.useRef)(null);
  const sanitize = (0, _react.useCallback)(value => value.split("").filter(isValidCharacter).join(""), [isValidCharacter]);
  const parse = (0, _react.useCallback)(value => {
    var _a;
    return (_a = parseValue == null ? void 0 : parseValue(value)) != null ? _a : value;
  }, [parseValue]);
  const format = (0, _react.useCallback)(value => {
    var _a;
    return ((_a = formatValue == null ? void 0 : formatValue(value)) != null ? _a : value).toString();
  }, [formatValue]);
  (0, _reactUseUpdateEffect.useUpdateEffect)(() => {
    if (counter.valueAsNumber > max) {
      onInvalid == null ? void 0 : onInvalid("rangeOverflow", format(counter.value), counter.valueAsNumber);
    } else if (counter.valueAsNumber < min) {
      onInvalid == null ? void 0 : onInvalid("rangeOverflow", format(counter.value), counter.valueAsNumber);
    }
  }, [counter.valueAsNumber, counter.value, format, onInvalid]);
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => {
    if (!inputRef.current) return;
    const notInSync = inputRef.current.value != counter.value;
    if (notInSync) {
      const parsedInput = parse(inputRef.current.value);
      counter.setValue(sanitize(parsedInput));
    }
  }, [parse, sanitize]);
  const increment = (0, _react.useCallback)((step = stepProp) => {
    if (isInteractive) {
      incrementFn(step);
    }
  }, [incrementFn, isInteractive, stepProp]);
  const decrement = (0, _react.useCallback)((step = stepProp) => {
    if (isInteractive) {
      decrementFn(step);
    }
  }, [decrementFn, isInteractive, stepProp]);
  const spinner = (0, _chunkJCNYS6PS.useSpinner)(increment, decrement);
  (0, _chunkXRH675A.useAttributeObserver)(incrementButtonRef, "disabled", spinner.stop, spinner.isSpinning);
  (0, _chunkXRH675A.useAttributeObserver)(decrementButtonRef, "disabled", spinner.stop, spinner.isSpinning);
  const onChange = (0, _react.useCallback)(event => {
    const evt = event.nativeEvent;
    if (evt.isComposing) return;
    const parsedInput = parse(event.currentTarget.value);
    updateFn(sanitize(parsedInput));
    inputSelectionRef.current = {
      start: event.currentTarget.selectionStart,
      end: event.currentTarget.selectionEnd
    };
  }, [updateFn, sanitize, parse]);
  const _onFocus = (0, _react.useCallback)(event => {
    var _a, _b, _c;
    onFocus == null ? void 0 : onFocus(event);
    if (!inputSelectionRef.current) return;
    event.target.selectionStart = (_b = inputSelectionRef.current.start) != null ? _b : (_a = event.currentTarget.value) == null ? void 0 : _a.length;
    event.currentTarget.selectionEnd = (_c = inputSelectionRef.current.end) != null ? _c : event.currentTarget.selectionStart;
  }, [onFocus]);
  const onKeyDown = (0, _react.useCallback)(event => {
    if (event.nativeEvent.isComposing) return;
    if (!isValidNumericKeyboardEvent(event, isValidCharacter)) {
      event.preventDefault();
    }
    const stepFactor = getStepFactor(event) * stepProp;
    const eventKey = event.key;
    const keyMap = {
      ArrowUp: () => increment(stepFactor),
      ArrowDown: () => decrement(stepFactor),
      Home: () => updateFn(min),
      End: () => updateFn(max)
    };
    const action = keyMap[eventKey];
    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [isValidCharacter, stepProp, increment, decrement, updateFn, min, max]);
  const getStepFactor = event => {
    let ratio = 1;
    if (event.metaKey || event.ctrlKey) {
      ratio = 0.1;
    }
    if (event.shiftKey) {
      ratio = 10;
    }
    return ratio;
  };
  const ariaValueText = (0, _react.useMemo)(() => {
    const text = getAriaValueText == null ? void 0 : getAriaValueText(counter.value);
    if (text != null) return text;
    const defaultText = counter.value.toString();
    return !defaultText ? void 0 : defaultText;
  }, [counter.value, getAriaValueText]);
  const validateAndClamp = (0, _react.useCallback)(() => {
    let next = counter.value;
    if (counter.value === "") return;
    const valueStartsWithE = /^[eE]/.test(counter.value.toString());
    if (valueStartsWithE) {
      counter.setValue("");
    } else {
      if (counter.valueAsNumber < min) {
        next = min;
      }
      if (counter.valueAsNumber > max) {
        next = max;
      }
      counter.cast(next);
    }
  }, [counter, max, min]);
  const onInputBlur = (0, _react.useCallback)(() => {
    setFocused(false);
    if (clampValueOnBlur) {
      validateAndClamp();
    }
  }, [clampValueOnBlur, setFocused, validateAndClamp]);
  const focusInput = (0, _react.useCallback)(() => {
    if (focusInputOnChange) {
      requestAnimationFrame(() => {
        var _a;
        (_a = inputRef.current) == null ? void 0 : _a.focus();
      });
    }
  }, [focusInputOnChange]);
  const spinUp = (0, _react.useCallback)(event => {
    event.preventDefault();
    spinner.up();
    focusInput();
  }, [focusInput, spinner]);
  const spinDown = (0, _react.useCallback)(event => {
    event.preventDefault();
    spinner.down();
    focusInput();
  }, [focusInput, spinner]);
  (0, _reactUseEventListener.useEventListener)(() => inputRef.current, "wheel", event => {
    var _a, _b;
    const doc = (_b = (_a = inputRef.current) == null ? void 0 : _a.ownerDocument) != null ? _b : document;
    const isInputFocused = doc.activeElement === inputRef.current;
    if (!allowMouseWheel || !isInputFocused) return;
    event.preventDefault();
    const stepFactor = getStepFactor(event) * stepProp;
    const direction = Math.sign(event.deltaY);
    if (direction === -1) {
      increment(stepFactor);
    } else if (direction === 1) {
      decrement(stepFactor);
    }
  }, {
    passive: false
  });
  const getIncrementButtonProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    const disabled = isDisabled || keepWithinRange && counter.isAtMax;
    return {
      ...props2,
      ref: (0, _reactUseMergeRefs.mergeRefs)(ref, incrementButtonRef),
      role: "button",
      tabIndex: -1,
      onPointerDown: (0, _sharedUtils.callAllHandlers)(props2.onPointerDown, event => {
        if (event.button !== 0 || disabled) return;
        spinUp(event);
      }),
      onPointerLeave: (0, _sharedUtils.callAllHandlers)(props2.onPointerLeave, spinner.stop),
      onPointerUp: (0, _sharedUtils.callAllHandlers)(props2.onPointerUp, spinner.stop),
      disabled,
      "aria-disabled": (0, _sharedUtils.ariaAttr)(disabled)
    };
  }, [counter.isAtMax, keepWithinRange, spinUp, spinner.stop, isDisabled]);
  const getDecrementButtonProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    const disabled = isDisabled || keepWithinRange && counter.isAtMin;
    return {
      ...props2,
      ref: (0, _reactUseMergeRefs.mergeRefs)(ref, decrementButtonRef),
      role: "button",
      tabIndex: -1,
      onPointerDown: (0, _sharedUtils.callAllHandlers)(props2.onPointerDown, event => {
        if (event.button !== 0 || disabled) return;
        spinDown(event);
      }),
      onPointerLeave: (0, _sharedUtils.callAllHandlers)(props2.onPointerLeave, spinner.stop),
      onPointerUp: (0, _sharedUtils.callAllHandlers)(props2.onPointerUp, spinner.stop),
      disabled,
      "aria-disabled": (0, _sharedUtils.ariaAttr)(disabled)
    };
  }, [counter.isAtMin, keepWithinRange, spinDown, spinner.stop, isDisabled]);
  const getInputProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    var _a, _b, _c, _d;
    return {
      name,
      inputMode,
      type: "text",
      pattern,
      "aria-labelledby": ariaLabelledBy,
      "aria-label": ariaLabel,
      "aria-describedby": ariaDescBy,
      id,
      disabled: isDisabled,
      ...props2,
      readOnly: (_a = props2.readOnly) != null ? _a : isReadOnly,
      "aria-readonly": (_b = props2.readOnly) != null ? _b : isReadOnly,
      "aria-required": (_c = props2.required) != null ? _c : isRequired,
      required: (_d = props2.required) != null ? _d : isRequired,
      ref: (0, _reactUseMergeRefs.mergeRefs)(inputRef, ref),
      value: format(counter.value),
      role: "spinbutton",
      "aria-valuemin": min,
      "aria-valuemax": max,
      "aria-valuenow": Number.isNaN(counter.valueAsNumber) ? void 0 : counter.valueAsNumber,
      "aria-invalid": (0, _sharedUtils.ariaAttr)(isInvalid != null ? isInvalid : counter.isOutOfRange),
      "aria-valuetext": ariaValueText,
      autoComplete: "off",
      autoCorrect: "off",
      onChange: (0, _sharedUtils.callAllHandlers)(props2.onChange, onChange),
      onKeyDown: (0, _sharedUtils.callAllHandlers)(props2.onKeyDown, onKeyDown),
      onFocus: (0, _sharedUtils.callAllHandlers)(props2.onFocus, _onFocus, () => setFocused(true)),
      onBlur: (0, _sharedUtils.callAllHandlers)(props2.onBlur, onBlur, onInputBlur)
    };
  }, [name, inputMode, pattern, ariaLabelledBy, ariaLabel, format, ariaDescBy, id, isDisabled, isRequired, isReadOnly, isInvalid, counter.value, counter.valueAsNumber, counter.isOutOfRange, min, max, ariaValueText, onChange, onKeyDown, _onFocus, onBlur, onInputBlur]);
  return {
    value: format(counter.value),
    valueAsNumber: counter.valueAsNumber,
    isFocused,
    isDisabled,
    isReadOnly,
    getIncrementButtonProps,
    getDecrementButtonProps,
    getInputProps,
    htmlProps
  };
}
},{"./chunk-XRH675A5.mjs":"jdyo","./chunk-JCNYS6PS.mjs":"QVWj","@chakra-ui/counter":"yOVB","@chakra-ui/react-use-event-listener":"Lu7g","@chakra-ui/react-use-update-effect":"GqG2","@chakra-ui/react-use-safe-layout-effect":"cYtR","@chakra-ui/react-use-callback-ref":"PPhG","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/shared-utils":"gghr","react":"n8MK"}],"Ggea":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useNumberInputStyles = exports.StyledStepper = exports.NumberInputStepper = exports.NumberInputField = exports.NumberInput = exports.NumberIncrementStepper = exports.NumberDecrementStepper = void 0;
var _chunkATDT5RFJ = require("./chunk-ATDT5RFJ.mjs");
var _chunkRBDW77H = require("./chunk-RBDW77H4.mjs");
var _formControl = require("@chakra-ui/form-control");
var _reactContext = require("@chakra-ui/react-context");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/number-input.tsx

var [NumberInputStylesProvider, useNumberInputStyles] = (0, _reactContext.createContext)({
  name: `NumberInputStylesContext`,
  errorMessage: `useNumberInputStyles returned is 'undefined'. Seems you forgot to wrap the components in "<NumberInput />" `
});
exports.useNumberInputStyles = useNumberInputStyles;
var [NumberInputProvider, useNumberInputContext] = (0, _reactContext.createContext)({
  name: "NumberInputContext",
  errorMessage: "useNumberInputContext: `context` is undefined. Seems you forgot to wrap number-input's components within <NumberInput />"
});
var NumberInput = (0, _system.forwardRef)(function NumberInput2(props, ref) {
  const styles = (0, _system.useMultiStyleConfig)("NumberInput", props);
  const ownProps = (0, _system.omitThemingProps)(props);
  const controlProps = (0, _formControl.useFormControlProps)(ownProps);
  const {
    htmlProps,
    ...context
  } = (0, _chunkRBDW77H.useNumberInput)(controlProps);
  const ctx = (0, _react.useMemo)(() => context, [context]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(NumberInputProvider, {
    value: ctx,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(NumberInputStylesProvider, {
      value: styles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
        ...htmlProps,
        ref,
        className: (0, _sharedUtils.cx)("chakra-numberinput", props.className),
        __css: {
          position: "relative",
          zIndex: 0,
          ...styles.root
        }
      })
    })
  });
});
exports.NumberInput = NumberInput;
NumberInput.displayName = "NumberInput";
var NumberInputStepper = (0, _system.forwardRef)(function NumberInputStepper2(props, ref) {
  const styles = useNumberInputStyles();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    "aria-hidden": true,
    ref,
    ...props,
    __css: {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      height: "calc(100% - 2px)",
      zIndex: 1,
      ...styles.stepperGroup
    }
  });
});
exports.NumberInputStepper = NumberInputStepper;
NumberInputStepper.displayName = "NumberInputStepper";
var NumberInputField = (0, _system.forwardRef)(function NumberInputField2(props, ref) {
  const {
    getInputProps
  } = useNumberInputContext();
  const input = getInputProps(props, ref);
  const styles = useNumberInputStyles();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.input, {
    ...input,
    className: (0, _sharedUtils.cx)("chakra-numberinput__field", props.className),
    __css: {
      width: "100%",
      ...styles.field
    }
  });
});
exports.NumberInputField = NumberInputField;
NumberInputField.displayName = "NumberInputField";
var StyledStepper = (0, _system.chakra)("div", {
  baseStyle: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flex: 1,
    transitionProperty: "common",
    transitionDuration: "normal",
    userSelect: "none",
    cursor: "pointer",
    lineHeight: "normal"
  }
});
exports.StyledStepper = StyledStepper;
var NumberDecrementStepper = (0, _system.forwardRef)(function NumberDecrementStepper2(props, ref) {
  var _a;
  const styles = useNumberInputStyles();
  const {
    getDecrementButtonProps
  } = useNumberInputContext();
  const decrement = getDecrementButtonProps(props, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(StyledStepper, {
    ...decrement,
    __css: styles.stepper,
    children: (_a = props.children) != null ? _a : /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkATDT5RFJ.TriangleDownIcon, {})
  });
});
exports.NumberDecrementStepper = NumberDecrementStepper;
NumberDecrementStepper.displayName = "NumberDecrementStepper";
var NumberIncrementStepper = (0, _system.forwardRef)(function NumberIncrementStepper2(props, ref) {
  var _a;
  const {
    getIncrementButtonProps
  } = useNumberInputContext();
  const increment = getIncrementButtonProps(props, ref);
  const styles = useNumberInputStyles();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(StyledStepper, {
    ...increment,
    __css: styles.stepper,
    children: (_a = props.children) != null ? _a : /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkATDT5RFJ.TriangleUpIcon, {})
  });
});
exports.NumberIncrementStepper = NumberIncrementStepper;
NumberIncrementStepper.displayName = "NumberIncrementStepper";
},{"./chunk-ATDT5RFJ.mjs":"ca5E","./chunk-RBDW77H4.mjs":"kOPV","@chakra-ui/form-control":"fjMD","@chakra-ui/react-context":"lT23","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"l28Y":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "NumberDecrementStepper", {
  enumerable: true,
  get: function () {
    return _chunkGIDWA67N.NumberDecrementStepper;
  }
});
Object.defineProperty(exports, "NumberIncrementStepper", {
  enumerable: true,
  get: function () {
    return _chunkGIDWA67N.NumberIncrementStepper;
  }
});
Object.defineProperty(exports, "NumberInput", {
  enumerable: true,
  get: function () {
    return _chunkGIDWA67N.NumberInput;
  }
});
Object.defineProperty(exports, "NumberInputField", {
  enumerable: true,
  get: function () {
    return _chunkGIDWA67N.NumberInputField;
  }
});
Object.defineProperty(exports, "NumberInputStepper", {
  enumerable: true,
  get: function () {
    return _chunkGIDWA67N.NumberInputStepper;
  }
});
Object.defineProperty(exports, "StyledStepper", {
  enumerable: true,
  get: function () {
    return _chunkGIDWA67N.StyledStepper;
  }
});
Object.defineProperty(exports, "useNumberInput", {
  enumerable: true,
  get: function () {
    return _chunkRBDW77H.useNumberInput;
  }
});
Object.defineProperty(exports, "useNumberInputStyles", {
  enumerable: true,
  get: function () {
    return _chunkGIDWA67N.useNumberInputStyles;
  }
});
var _chunkGIDWA67N = require("./chunk-GIDWA67N.mjs");
require("./chunk-ATDT5RFJ.mjs");
var _chunkRBDW77H = require("./chunk-RBDW77H4.mjs");
require("./chunk-XRH675A5.mjs");
require("./chunk-JCNYS6PS.mjs");
},{"./chunk-GIDWA67N.mjs":"Ggea","./chunk-ATDT5RFJ.mjs":"ca5E","./chunk-RBDW77H4.mjs":"kOPV","./chunk-XRH675A5.mjs":"jdyo","./chunk-JCNYS6PS.mjs":"QVWj"}],"y8hB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PinInputProvider = exports.PinInputDescendantsProvider = void 0;
exports.usePinInput = usePinInput;
exports.usePinInputDescendantsContext = exports.usePinInputDescendants = exports.usePinInputDescendant = exports.usePinInputContext = void 0;
exports.usePinInputField = usePinInputField;
var _descendant = require("@chakra-ui/descendant");
var _reactUseControllableState = require("@chakra-ui/react-use-controllable-state");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _reactContext = require("@chakra-ui/react-context");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _react = require("react");
// src/use-pin-input.ts

var [PinInputDescendantsProvider, usePinInputDescendantsContext, usePinInputDescendants, usePinInputDescendant] = (0, _descendant.createDescendantContext)();
exports.usePinInputDescendant = usePinInputDescendant;
exports.usePinInputDescendants = usePinInputDescendants;
exports.usePinInputDescendantsContext = usePinInputDescendantsContext;
exports.PinInputDescendantsProvider = PinInputDescendantsProvider;
var [PinInputProvider, usePinInputContext] = (0, _reactContext.createContext)({
  name: "PinInputContext",
  errorMessage: "usePinInputContext: `context` is undefined. Seems you forgot to all pin input fields within `<PinInput />`"
});
exports.usePinInputContext = usePinInputContext;
exports.PinInputProvider = PinInputProvider;
var toArray = value => value == null ? void 0 : value.split("");
function validate(value, type) {
  const NUMERIC_REGEX = /^[0-9]+$/;
  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i;
  const regex = type === "alphanumeric" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX;
  return regex.test(value);
}
function usePinInput(props = {}) {
  const {
    autoFocus,
    value,
    defaultValue,
    onChange,
    onComplete,
    placeholder = "\u25CB",
    manageFocus = true,
    otp = false,
    id: idProp,
    isDisabled,
    isInvalid,
    type = "number",
    mask
  } = props;
  const uuid = (0, _react.useId)();
  const id = idProp != null ? idProp : `pin-input-${uuid}`;
  const descendants = usePinInputDescendants();
  const [moveFocus, setMoveFocus] = (0, _react.useState)(true);
  const [focusedIndex, setFocusedIndex] = (0, _react.useState)(-1);
  const [values, setValues] = (0, _reactUseControllableState.useControllableState)({
    defaultValue: toArray(defaultValue) || [],
    value: toArray(value),
    onChange: values2 => onChange == null ? void 0 : onChange(values2.join(""))
  });
  (0, _react.useEffect)(() => {
    if (autoFocus) {
      const first = descendants.first();
      if (first) {
        requestAnimationFrame(() => {
          first.node.focus();
        });
      }
    }
  }, [descendants]);
  const focusNext = (0, _react.useCallback)(index => {
    if (!moveFocus || !manageFocus) return;
    const next = descendants.next(index, false);
    if (next) {
      requestAnimationFrame(() => {
        next.node.focus();
      });
    }
  }, [descendants, moveFocus, manageFocus]);
  const setValue = (0, _react.useCallback)((value2, index, handleFocus = true) => {
    const nextValues = [...values];
    nextValues[index] = value2;
    setValues(nextValues);
    const isComplete = value2 !== "" && nextValues.length === descendants.count() && nextValues.every(inputValue => inputValue != null && inputValue !== "");
    if (isComplete) {
      onComplete == null ? void 0 : onComplete(nextValues.join(""));
    } else {
      if (handleFocus) focusNext(index);
    }
  }, [values, setValues, focusNext, onComplete, descendants]);
  const clear = (0, _react.useCallback)(() => {
    var _a;
    const values2 = Array(descendants.count()).fill("");
    setValues(values2);
    const first = descendants.first();
    (_a = first == null ? void 0 : first.node) == null ? void 0 : _a.focus();
  }, [descendants, setValues]);
  const getNextValue = (0, _react.useCallback)((value2, eventValue) => {
    let nextValue = eventValue;
    if ((value2 == null ? void 0 : value2.length) > 0) {
      if (value2[0] === eventValue.charAt(0)) {
        nextValue = eventValue.charAt(1);
      } else if (value2[0] === eventValue.charAt(1)) {
        nextValue = eventValue.charAt(0);
      }
    }
    return nextValue;
  }, []);
  const getInputProps = (0, _react.useCallback)(props2 => {
    const {
      index,
      ...rest
    } = props2;
    const onChange2 = event => {
      const eventValue = event.target.value;
      const currentValue = values[index];
      const nextValue = getNextValue(currentValue, eventValue);
      if (nextValue === "") {
        setValue("", index);
        return;
      }
      if (eventValue.length > 2) {
        if (validate(eventValue, type)) {
          const nextValue2 = eventValue.split("").filter((_, index2) => index2 < descendants.count());
          setValues(nextValue2);
          if (nextValue2.length === descendants.count()) {
            onComplete == null ? void 0 : onComplete(nextValue2.join(""));
          }
        }
      } else {
        if (validate(nextValue, type)) {
          setValue(nextValue, index);
        }
        setMoveFocus(true);
      }
    };
    const onKeyDown = event => {
      var _a;
      if (event.key === "Backspace" && manageFocus) {
        if (event.target.value === "") {
          const prevInput = descendants.prev(index, false);
          if (prevInput) {
            setValue("", index - 1, false);
            (_a = prevInput.node) == null ? void 0 : _a.focus();
            setMoveFocus(true);
          }
        } else {
          setMoveFocus(false);
        }
      }
    };
    const onFocus = () => {
      setFocusedIndex(index);
    };
    const onBlur = () => {
      setFocusedIndex(-1);
    };
    const hasFocus = focusedIndex === index;
    const inputType = type === "number" ? "tel" : "text";
    return {
      "aria-label": "Please enter your pin code",
      inputMode: type === "number" ? "numeric" : "text",
      type: mask ? "password" : inputType,
      ...rest,
      id: `${id}-${index}`,
      disabled: isDisabled,
      "aria-invalid": (0, _sharedUtils.ariaAttr)(isInvalid),
      onChange: (0, _sharedUtils.callAllHandlers)(rest.onChange, onChange2),
      onKeyDown: (0, _sharedUtils.callAllHandlers)(rest.onKeyDown, onKeyDown),
      onFocus: (0, _sharedUtils.callAllHandlers)(rest.onFocus, onFocus),
      onBlur: (0, _sharedUtils.callAllHandlers)(rest.onBlur, onBlur),
      value: values[index] || "",
      autoComplete: otp ? "one-time-code" : "off",
      placeholder: hasFocus ? "" : placeholder
    };
  }, [descendants, focusedIndex, getNextValue, id, isDisabled, mask, isInvalid, manageFocus, onComplete, otp, placeholder, setValue, setValues, type, values]);
  return {
    getInputProps,
    id,
    descendants,
    values,
    setValue,
    setValues,
    clear
  };
}
function usePinInputField(props = {}, ref = null) {
  const {
    getInputProps
  } = usePinInputContext();
  const {
    index,
    register
  } = usePinInputDescendant();
  return getInputProps({
    ...props,
    ref: (0, _reactUseMergeRefs.mergeRefs)(register, ref),
    index
  });
}
},{"@chakra-ui/descendant":"HJpF","@chakra-ui/react-use-controllable-state":"DWQz","@chakra-ui/shared-utils":"gghr","@chakra-ui/react-context":"lT23","@chakra-ui/react-use-merge-refs":"EUzL","react":"n8MK"}],"hjP0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PinInput = PinInput;
exports.PinInputField = void 0;
var _chunkE34PQC4X = require("./chunk-E34PQC4X.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _reactChildrenUtils = require("@chakra-ui/react-children-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/pin-input.tsx

function PinInput(props) {
  const styles = (0, _system.useStyleConfig)("PinInput", props);
  const {
    children,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const {
    descendants,
    ...context
  } = (0, _chunkE34PQC4X.usePinInput)(rest);
  const clones = (0, _reactChildrenUtils.getValidChildren)(children).map(child => (0, _react.cloneElement)(child, {
    __css: styles
  }));
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkE34PQC4X.PinInputDescendantsProvider, {
    value: descendants,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkE34PQC4X.PinInputProvider, {
      value: context,
      children: clones
    })
  });
}
PinInput.displayName = "PinInput";
var PinInputField = (0, _system.forwardRef)(function PinInputField2(props, ref) {
  const inputProps = (0, _chunkE34PQC4X.usePinInputField)(props, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.input, {
    ...inputProps,
    className: (0, _sharedUtils.cx)("chakra-pin-input", props.className)
  });
});
exports.PinInputField = PinInputField;
PinInputField.displayName = "PinInputField";
},{"./chunk-E34PQC4X.mjs":"y8hB","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","@chakra-ui/react-children-utils":"PLf5","react":"n8MK","react/jsx-runtime":"plwR"}],"HXQv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "PinInput", {
  enumerable: true,
  get: function () {
    return _chunkUS44V7OZ.PinInput;
  }
});
Object.defineProperty(exports, "PinInputDescendantsProvider", {
  enumerable: true,
  get: function () {
    return _chunkE34PQC4X.PinInputDescendantsProvider;
  }
});
Object.defineProperty(exports, "PinInputField", {
  enumerable: true,
  get: function () {
    return _chunkUS44V7OZ.PinInputField;
  }
});
Object.defineProperty(exports, "PinInputProvider", {
  enumerable: true,
  get: function () {
    return _chunkE34PQC4X.PinInputProvider;
  }
});
Object.defineProperty(exports, "usePinInput", {
  enumerable: true,
  get: function () {
    return _chunkE34PQC4X.usePinInput;
  }
});
Object.defineProperty(exports, "usePinInputContext", {
  enumerable: true,
  get: function () {
    return _chunkE34PQC4X.usePinInputContext;
  }
});
Object.defineProperty(exports, "usePinInputDescendant", {
  enumerable: true,
  get: function () {
    return _chunkE34PQC4X.usePinInputDescendant;
  }
});
Object.defineProperty(exports, "usePinInputDescendants", {
  enumerable: true,
  get: function () {
    return _chunkE34PQC4X.usePinInputDescendants;
  }
});
Object.defineProperty(exports, "usePinInputDescendantsContext", {
  enumerable: true,
  get: function () {
    return _chunkE34PQC4X.usePinInputDescendantsContext;
  }
});
Object.defineProperty(exports, "usePinInputField", {
  enumerable: true,
  get: function () {
    return _chunkE34PQC4X.usePinInputField;
  }
});
var _chunkUS44V7OZ = require("./chunk-US44V7OZ.mjs");
var _chunkE34PQC4X = require("./chunk-E34PQC4X.mjs");
},{"./chunk-US44V7OZ.mjs":"hjP0","./chunk-E34PQC4X.mjs":"y8hB"}],"kTQL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePopoverStyles = exports.usePopoverContext = exports.PopoverStylesProvider = exports.PopoverProvider = void 0;
var _reactContext = require("@chakra-ui/react-context");
// src/popover-context.ts

var [PopoverProvider, usePopoverContext] = (0, _reactContext.createContext)({
  name: "PopoverContext",
  errorMessage: "usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"
});
exports.usePopoverContext = usePopoverContext;
exports.PopoverProvider = PopoverProvider;
var [PopoverStylesProvider, usePopoverStyles] = (0, _reactContext.createContext)({
  name: `PopoverStylesContext`,
  errorMessage: `usePopoverStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Popover />" `
});
exports.usePopoverStyles = usePopoverStyles;
exports.PopoverStylesProvider = PopoverStylesProvider;
},{"@chakra-ui/react-context":"lT23"}],"NIga":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopoverHeader = void 0;
var _chunkFOAN3JQV = require("./chunk-FOAN3JQV.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/popover-header.tsx

var PopoverHeader = (0, _system.forwardRef)(function PopoverHeader2(props, ref) {
  const {
    getHeaderProps
  } = (0, _chunkFOAN3JQV.usePopoverContext)();
  const styles = (0, _chunkFOAN3JQV.usePopoverStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.header, {
    ...getHeaderProps(props, ref),
    className: (0, _sharedUtils.cx)("chakra-popover__header", props.className),
    __css: styles.header
  });
});
exports.PopoverHeader = PopoverHeader;
PopoverHeader.displayName = "PopoverHeader";
},{"./chunk-FOAN3JQV.mjs":"kTQL","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"YM0s":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopoverTrigger = PopoverTrigger;
var _chunkFOAN3JQV = require("./chunk-FOAN3JQV.mjs");
var _react = require("react");
// src/popover-trigger.tsx

function PopoverTrigger(props) {
  const child = _react.Children.only(props.children);
  const {
    getTriggerProps
  } = (0, _chunkFOAN3JQV.usePopoverContext)();
  return (0, _react.cloneElement)(child, getTriggerProps(child.props, child.ref));
}
PopoverTrigger.displayName = "PopoverTrigger";
},{"./chunk-FOAN3JQV.mjs":"kTQL","react":"n8MK"}],"jv9z":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePopover = usePopover;
var _reactUseAnimationState = require("@chakra-ui/react-use-animation-state");
var _reactUseFocusOnPointerDown = require("@chakra-ui/react-use-focus-on-pointer-down");
var _reactUseFocusEffect = require("@chakra-ui/react-use-focus-effect");
var _reactUseDisclosure = require("@chakra-ui/react-use-disclosure");
var _popper = require("@chakra-ui/popper");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _lazyUtils = require("@chakra-ui/lazy-utils");
var _react = require("react");
// src/use-popover.ts

var TRIGGER = {
  click: "click",
  hover: "hover"
};
function usePopover(props = {}) {
  const {
    closeOnBlur = true,
    closeOnEsc = true,
    initialFocusRef,
    id,
    returnFocusOnClose = true,
    autoFocus = true,
    arrowSize,
    arrowShadowColor,
    trigger = TRIGGER.click,
    openDelay = 200,
    closeDelay = 200,
    isLazy,
    lazyBehavior = "unmount",
    computePositionOnMount,
    ...popperProps
  } = props;
  const {
    isOpen,
    onClose,
    onOpen,
    onToggle
  } = (0, _reactUseDisclosure.useDisclosure)(props);
  const anchorRef = (0, _react.useRef)(null);
  const triggerRef = (0, _react.useRef)(null);
  const popoverRef = (0, _react.useRef)(null);
  const isHoveringRef = (0, _react.useRef)(false);
  const hasBeenOpened = (0, _react.useRef)(false);
  if (isOpen) {
    hasBeenOpened.current = true;
  }
  const [hasHeader, setHasHeader] = (0, _react.useState)(false);
  const [hasBody, setHasBody] = (0, _react.useState)(false);
  const uuid = (0, _react.useId)();
  const uid = id != null ? id : uuid;
  const [triggerId, popoverId, headerId, bodyId] = ["popover-trigger", "popover-content", "popover-header", "popover-body"].map(id2 => `${id2}-${uid}`);
  const {
    referenceRef,
    getArrowProps,
    getPopperProps,
    getArrowInnerProps,
    forceUpdate
  } = (0, _popper.usePopper)({
    ...popperProps,
    enabled: isOpen || !!computePositionOnMount
  });
  const animated = (0, _reactUseAnimationState.useAnimationState)({
    isOpen,
    ref: popoverRef
  });
  (0, _reactUseFocusOnPointerDown.useFocusOnPointerDown)({
    enabled: isOpen,
    ref: triggerRef
  });
  (0, _reactUseFocusEffect.useFocusOnHide)(popoverRef, {
    focusRef: triggerRef,
    visible: isOpen,
    shouldFocus: returnFocusOnClose && trigger === TRIGGER.click
  });
  (0, _reactUseFocusEffect.useFocusOnShow)(popoverRef, {
    focusRef: initialFocusRef,
    visible: isOpen,
    shouldFocus: autoFocus && trigger === TRIGGER.click
  });
  const shouldRenderChildren = (0, _lazyUtils.lazyDisclosure)({
    wasSelected: hasBeenOpened.current,
    enabled: isLazy,
    mode: lazyBehavior,
    isSelected: animated.present
  });
  const getPopoverProps = (0, _react.useCallback)((props2 = {}, _ref = null) => {
    const popoverProps = {
      ...props2,
      style: {
        ...props2.style,
        transformOrigin: _popper.popperCSSVars.transformOrigin.varRef,
        [_popper.popperCSSVars.arrowSize.var]: arrowSize ? `${arrowSize}px` : void 0,
        [_popper.popperCSSVars.arrowShadowColor.var]: arrowShadowColor
      },
      ref: (0, _reactUseMergeRefs.mergeRefs)(popoverRef, _ref),
      children: shouldRenderChildren ? props2.children : null,
      id: popoverId,
      tabIndex: -1,
      role: "dialog",
      onKeyDown: (0, _sharedUtils.callAllHandlers)(props2.onKeyDown, event => {
        if (closeOnEsc && event.key === "Escape") {
          onClose();
        }
      }),
      onBlur: (0, _sharedUtils.callAllHandlers)(props2.onBlur, event => {
        const relatedTarget = getRelatedTarget(event);
        const targetIsPopover = contains(popoverRef.current, relatedTarget);
        const targetIsTrigger = contains(triggerRef.current, relatedTarget);
        const isValidBlur = !targetIsPopover && !targetIsTrigger;
        if (isOpen && closeOnBlur && isValidBlur) {
          onClose();
        }
      }),
      "aria-labelledby": hasHeader ? headerId : void 0,
      "aria-describedby": hasBody ? bodyId : void 0
    };
    if (trigger === TRIGGER.hover) {
      popoverProps.role = "tooltip";
      popoverProps.onMouseEnter = (0, _sharedUtils.callAllHandlers)(props2.onMouseEnter, () => {
        isHoveringRef.current = true;
      });
      popoverProps.onMouseLeave = (0, _sharedUtils.callAllHandlers)(props2.onMouseLeave, event => {
        if (event.nativeEvent.relatedTarget === null) {
          return;
        }
        isHoveringRef.current = false;
        setTimeout(() => onClose(), closeDelay);
      });
    }
    return popoverProps;
  }, [shouldRenderChildren, popoverId, hasHeader, headerId, hasBody, bodyId, trigger, closeOnEsc, onClose, isOpen, closeOnBlur, closeDelay, arrowShadowColor, arrowSize]);
  const getPopoverPositionerProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => getPopperProps({
    ...props2,
    style: {
      visibility: isOpen ? "visible" : "hidden",
      ...props2.style
    }
  }, forwardedRef), [isOpen, getPopperProps]);
  const getAnchorProps = (0, _react.useCallback)((props2, _ref = null) => {
    return {
      ...props2,
      ref: (0, _reactUseMergeRefs.mergeRefs)(_ref, anchorRef, referenceRef)
    };
  }, [anchorRef, referenceRef]);
  const openTimeout = (0, _react.useRef)();
  const closeTimeout = (0, _react.useRef)();
  const maybeReferenceRef = (0, _react.useCallback)(node => {
    if (anchorRef.current == null) {
      referenceRef(node);
    }
  }, [referenceRef]);
  const getTriggerProps = (0, _react.useCallback)((props2 = {}, _ref = null) => {
    const triggerProps = {
      ...props2,
      ref: (0, _reactUseMergeRefs.mergeRefs)(triggerRef, _ref, maybeReferenceRef),
      id: triggerId,
      "aria-haspopup": "dialog",
      "aria-expanded": isOpen,
      "aria-controls": popoverId
    };
    if (trigger === TRIGGER.click) {
      triggerProps.onClick = (0, _sharedUtils.callAllHandlers)(props2.onClick, onToggle);
    }
    if (trigger === TRIGGER.hover) {
      triggerProps.onFocus = (0, _sharedUtils.callAllHandlers)(props2.onFocus, () => {
        if (openTimeout.current === void 0) {
          onOpen();
        }
      });
      triggerProps.onBlur = (0, _sharedUtils.callAllHandlers)(props2.onBlur, event => {
        const relatedTarget = getRelatedTarget(event);
        const isValidBlur = !contains(popoverRef.current, relatedTarget);
        if (isOpen && closeOnBlur && isValidBlur) {
          onClose();
        }
      });
      triggerProps.onKeyDown = (0, _sharedUtils.callAllHandlers)(props2.onKeyDown, event => {
        if (event.key === "Escape") {
          onClose();
        }
      });
      triggerProps.onMouseEnter = (0, _sharedUtils.callAllHandlers)(props2.onMouseEnter, () => {
        isHoveringRef.current = true;
        openTimeout.current = window.setTimeout(() => onOpen(), openDelay);
      });
      triggerProps.onMouseLeave = (0, _sharedUtils.callAllHandlers)(props2.onMouseLeave, () => {
        isHoveringRef.current = false;
        if (openTimeout.current) {
          clearTimeout(openTimeout.current);
          openTimeout.current = void 0;
        }
        closeTimeout.current = window.setTimeout(() => {
          if (isHoveringRef.current === false) {
            onClose();
          }
        }, closeDelay);
      });
    }
    return triggerProps;
  }, [triggerId, isOpen, popoverId, trigger, maybeReferenceRef, onToggle, onOpen, closeOnBlur, onClose, openDelay, closeDelay]);
  (0, _react.useEffect)(() => {
    return () => {
      if (openTimeout.current) {
        clearTimeout(openTimeout.current);
      }
      if (closeTimeout.current) {
        clearTimeout(closeTimeout.current);
      }
    };
  }, []);
  const getHeaderProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    id: headerId,
    ref: (0, _reactUseMergeRefs.mergeRefs)(ref, node => {
      setHasHeader(!!node);
    })
  }), [headerId]);
  const getBodyProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    id: bodyId,
    ref: (0, _reactUseMergeRefs.mergeRefs)(ref, node => {
      setHasBody(!!node);
    })
  }), [bodyId]);
  return {
    forceUpdate,
    isOpen,
    onAnimationComplete: animated.onComplete,
    onClose,
    getAnchorProps,
    getArrowProps,
    getArrowInnerProps,
    getPopoverPositionerProps,
    getPopoverProps,
    getTriggerProps,
    getHeaderProps,
    getBodyProps
  };
}
function contains(parent, child) {
  return parent === child || (parent == null ? void 0 : parent.contains(child));
}
function getRelatedTarget(event) {
  var _a;
  const activeEl = event.currentTarget.ownerDocument.activeElement;
  return (_a = event.relatedTarget) != null ? _a : activeEl;
}
},{"@chakra-ui/react-use-animation-state":"Qgbt","@chakra-ui/react-use-focus-on-pointer-down":"B5wa","@chakra-ui/react-use-focus-effect":"fXis","@chakra-ui/react-use-disclosure":"xJYi","@chakra-ui/popper":"gOdA","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/shared-utils":"gghr","@chakra-ui/lazy-utils":"wsFr","react":"n8MK"}],"iJ3L":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Popover = Popover;
var _chunkBOXNG7YC = require("./chunk-BOXNG7YC.mjs");
var _chunkFOAN3JQV = require("./chunk-FOAN3JQV.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/popover.tsx

function Popover(props) {
  const styles = (0, _system.useMultiStyleConfig)("Popover", props);
  const {
    children,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const theme = (0, _system.useTheme)();
  const context = (0, _chunkBOXNG7YC.usePopover)({
    ...rest,
    direction: theme.direction
  });
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkFOAN3JQV.PopoverProvider, {
    value: context,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkFOAN3JQV.PopoverStylesProvider, {
      value: styles,
      children: (0, _sharedUtils.runIfFn)(children, {
        isOpen: context.isOpen,
        onClose: context.onClose,
        forceUpdate: context.forceUpdate
      })
    })
  });
}
Popover.displayName = "Popover";
},{"./chunk-BOXNG7YC.mjs":"jv9z","./chunk-FOAN3JQV.mjs":"kTQL","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"iNU4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopoverAnchor = PopoverAnchor;
var _chunkFOAN3JQV = require("./chunk-FOAN3JQV.mjs");
var _react = require("react");
// src/popover-anchor.tsx

function PopoverAnchor(props) {
  const child = _react.Children.only(props.children);
  const {
    getAnchorProps
  } = (0, _chunkFOAN3JQV.usePopoverContext)();
  return (0, _react.cloneElement)(child, getAnchorProps(child.props, child.ref));
}
PopoverAnchor.displayName = "PopoverAnchor";
},{"./chunk-FOAN3JQV.mjs":"kTQL","react":"n8MK"}],"aqT4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopoverArrow = PopoverArrow;
var _chunkFOAN3JQV = require("./chunk-FOAN3JQV.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/popover-arrow.tsx

function PopoverArrow(props) {
  var _a;
  const {
    bg,
    bgColor,
    backgroundColor,
    shadow,
    boxShadow
  } = props;
  const {
    getArrowProps,
    getArrowInnerProps
  } = (0, _chunkFOAN3JQV.usePopoverContext)();
  const styles = (0, _chunkFOAN3JQV.usePopoverStyles)();
  const arrowBg = (_a = bg != null ? bg : bgColor) != null ? _a : backgroundColor;
  const arrowShadow = shadow != null ? shadow : boxShadow;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...getArrowProps(),
    className: "chakra-popover__arrow-positioner",
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
      className: (0, _sharedUtils.cx)("chakra-popover__arrow", props.className),
      ...getArrowInnerProps(props),
      __css: {
        "--popper-arrow-bg": arrowBg ? `colors.${arrowBg}, ${arrowBg}` : void 0,
        "--popper-arrow-shadow": arrowShadow ? `shadows.${arrowShadow}, ${arrowShadow}` : void 0,
        ...styles.arrow
      }
    })
  });
}
PopoverArrow.displayName = "PopoverArrow";
},{"./chunk-FOAN3JQV.mjs":"kTQL","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"Yox4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopoverBody = void 0;
var _chunkFOAN3JQV = require("./chunk-FOAN3JQV.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/popover-body.tsx

var PopoverBody = (0, _system.forwardRef)(function PopoverBody2(props, ref) {
  const {
    getBodyProps
  } = (0, _chunkFOAN3JQV.usePopoverContext)();
  const styles = (0, _chunkFOAN3JQV.usePopoverStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...getBodyProps(props, ref),
    className: (0, _sharedUtils.cx)("chakra-popover__body", props.className),
    __css: styles.body
  });
});
exports.PopoverBody = PopoverBody;
PopoverBody.displayName = "PopoverBody";
},{"./chunk-FOAN3JQV.mjs":"kTQL","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"NRey":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopoverCloseButton = void 0;
var _chunkFOAN3JQV = require("./chunk-FOAN3JQV.mjs");
var _closeButton = require("@chakra-ui/close-button");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/popover-close-button.tsx

var PopoverCloseButton = (0, _system.forwardRef)(function PopoverCloseButton2(props, ref) {
  const {
    onClose
  } = (0, _chunkFOAN3JQV.usePopoverContext)();
  const styles = (0, _chunkFOAN3JQV.usePopoverStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_closeButton.CloseButton, {
    size: "sm",
    onClick: onClose,
    className: (0, _sharedUtils.cx)("chakra-popover__close-btn", props.className),
    __css: styles.closeButton,
    ref,
    ...props
  });
});
exports.PopoverCloseButton = PopoverCloseButton;
PopoverCloseButton.displayName = "PopoverCloseButton";
},{"./chunk-FOAN3JQV.mjs":"kTQL","@chakra-ui/close-button":"pReG","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"KnCm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopoverTransition = void 0;
var _chunkFOAN3JQV = require("./chunk-FOAN3JQV.mjs");
var _system = require("@chakra-ui/system");
var _framerMotion = require("framer-motion");
var _jsxRuntime = require("react/jsx-runtime");
// src/popover-transition.tsx

function mergeVariants(variants) {
  if (!variants) return;
  return {
    enter: {
      ...variants.enter,
      visibility: "visible"
    },
    exit: {
      ...variants.exit,
      transitionEnd: {
        visibility: "hidden"
      }
    }
  };
}
var scaleFade = {
  exit: {
    opacity: 0,
    scale: 0.95,
    transition: {
      duration: 0.1,
      ease: [0.4, 0, 1, 1]
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      duration: 0.15,
      ease: [0, 0, 0.2, 1]
    }
  }
};
var MotionSection = (0, _system.chakra)(_framerMotion.motion.section);
var PopoverTransition = (0, _system.forwardRef)(function PopoverTransition2(props, ref) {
  const {
    variants = scaleFade,
    ...rest
  } = props;
  const {
    isOpen
  } = (0, _chunkFOAN3JQV.usePopoverContext)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(MotionSection, {
    ref,
    variants: mergeVariants(variants),
    initial: false,
    animate: isOpen ? "enter" : "exit",
    ...rest
  });
});
exports.PopoverTransition = PopoverTransition;
PopoverTransition.displayName = "PopoverTransition";
},{"./chunk-FOAN3JQV.mjs":"kTQL","@chakra-ui/system":"ogbg","framer-motion":"gNpu","react/jsx-runtime":"plwR"}],"NwNp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopoverContent = void 0;
var _chunkLZVBC5YS = require("./chunk-LZVBC5YS.mjs");
var _chunkFOAN3JQV = require("./chunk-FOAN3JQV.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/popover-content.tsx

var PopoverContent = (0, _system.forwardRef)(function PopoverContent2(props, ref) {
  const {
    rootProps,
    motionProps,
    ...contentProps
  } = props;
  const {
    getPopoverProps,
    getPopoverPositionerProps,
    onAnimationComplete
  } = (0, _chunkFOAN3JQV.usePopoverContext)();
  const styles = (0, _chunkFOAN3JQV.usePopoverStyles)();
  const contentStyles = {
    position: "relative",
    display: "flex",
    flexDirection: "column",
    ...styles.content
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...getPopoverPositionerProps(rootProps),
    __css: styles.popper,
    className: "chakra-popover__popper",
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkLZVBC5YS.PopoverTransition, {
      ...motionProps,
      ...getPopoverProps(contentProps, ref),
      onAnimationComplete: (0, _sharedUtils.callAll)(onAnimationComplete, contentProps.onAnimationComplete),
      className: (0, _sharedUtils.cx)("chakra-popover__content", props.className),
      __css: contentStyles
    })
  });
});
exports.PopoverContent = PopoverContent;
PopoverContent.displayName = "PopoverContent";
},{"./chunk-LZVBC5YS.mjs":"KnCm","./chunk-FOAN3JQV.mjs":"kTQL","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"t1MM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopoverFooter = PopoverFooter;
var _chunkFOAN3JQV = require("./chunk-FOAN3JQV.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/popover-footer.tsx

function PopoverFooter(props) {
  const styles = (0, _chunkFOAN3JQV.usePopoverStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.footer, {
    ...props,
    className: (0, _sharedUtils.cx)("chakra-popover__footer", props.className),
    __css: styles.footer
  });
}
PopoverFooter.displayName = "PopoverFooter";
},{"./chunk-FOAN3JQV.mjs":"kTQL","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"H2Gd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Popover", {
  enumerable: true,
  get: function () {
    return _chunk4OGHDZEB.Popover;
  }
});
Object.defineProperty(exports, "PopoverAnchor", {
  enumerable: true,
  get: function () {
    return _chunk7NBWC5PS.PopoverAnchor;
  }
});
Object.defineProperty(exports, "PopoverArrow", {
  enumerable: true,
  get: function () {
    return _chunkRACJ2OQY.PopoverArrow;
  }
});
Object.defineProperty(exports, "PopoverBody", {
  enumerable: true,
  get: function () {
    return _chunk3JH7ZFSI.PopoverBody;
  }
});
Object.defineProperty(exports, "PopoverCloseButton", {
  enumerable: true,
  get: function () {
    return _chunkTHJVJMZP.PopoverCloseButton;
  }
});
Object.defineProperty(exports, "PopoverContent", {
  enumerable: true,
  get: function () {
    return _chunkKVBLLJMP.PopoverContent;
  }
});
Object.defineProperty(exports, "PopoverFooter", {
  enumerable: true,
  get: function () {
    return _chunkA3QMTCPA.PopoverFooter;
  }
});
Object.defineProperty(exports, "PopoverHeader", {
  enumerable: true,
  get: function () {
    return _chunkBYOOQOH.PopoverHeader;
  }
});
Object.defineProperty(exports, "PopoverTrigger", {
  enumerable: true,
  get: function () {
    return _chunk3O5UWOX.PopoverTrigger;
  }
});
Object.defineProperty(exports, "usePopover", {
  enumerable: true,
  get: function () {
    return _chunkBOXNG7YC.usePopover;
  }
});
Object.defineProperty(exports, "usePopoverContext", {
  enumerable: true,
  get: function () {
    return _chunkFOAN3JQV.usePopoverContext;
  }
});
Object.defineProperty(exports, "usePopoverStyles", {
  enumerable: true,
  get: function () {
    return _chunkFOAN3JQV.usePopoverStyles;
  }
});
var _chunkBYOOQOH = require("./chunk-BYOOQOH2.mjs");
var _chunk3O5UWOX = require("./chunk-3O5UWOX6.mjs");
var _chunk4OGHDZEB = require("./chunk-4OGHDZEB.mjs");
var _chunkBOXNG7YC = require("./chunk-BOXNG7YC.mjs");
var _chunk7NBWC5PS = require("./chunk-7NBWC5PS.mjs");
var _chunkRACJ2OQY = require("./chunk-RACJ2OQY.mjs");
var _chunk3JH7ZFSI = require("./chunk-3JH7ZFSI.mjs");
var _chunkTHJVJMZP = require("./chunk-THJVJMZP.mjs");
var _chunkKVBLLJMP = require("./chunk-KVBLLJMP.mjs");
require("./chunk-LZVBC5YS.mjs");
var _chunkA3QMTCPA = require("./chunk-A3QMTCPA.mjs");
var _chunkFOAN3JQV = require("./chunk-FOAN3JQV.mjs");
},{"./chunk-BYOOQOH2.mjs":"NIga","./chunk-3O5UWOX6.mjs":"YM0s","./chunk-4OGHDZEB.mjs":"iJ3L","./chunk-BOXNG7YC.mjs":"jv9z","./chunk-7NBWC5PS.mjs":"iNU4","./chunk-RACJ2OQY.mjs":"aqT4","./chunk-3JH7ZFSI.mjs":"Yox4","./chunk-THJVJMZP.mjs":"NRey","./chunk-KVBLLJMP.mjs":"NwNp","./chunk-LZVBC5YS.mjs":"KnCm","./chunk-A3QMTCPA.mjs":"t1MM","./chunk-FOAN3JQV.mjs":"kTQL"}],"i7h5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CircularProgressLabel = void 0;
var _system = require("@chakra-ui/system");
// src/circular-progress-label.tsx

var CircularProgressLabel = (0, _system.chakra)("div", {
  baseStyle: {
    fontSize: "0.24em",
    top: "50%",
    left: "50%",
    width: "100%",
    textAlign: "center",
    position: "absolute",
    transform: "translate(-50%, -50%)"
  }
});
exports.CircularProgressLabel = CircularProgressLabel;
CircularProgressLabel.displayName = "CircularProgressLabel";
},{"@chakra-ui/system":"ogbg"}],"hz9T":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Circle = void 0;
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/circle.tsx

var Circle = props => /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.circle, {
  cx: 50,
  cy: 50,
  r: 42,
  fill: "transparent",
  ...props
});
exports.Circle = Circle;
Circle.displayName = "Circle";
},{"@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"amW8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getProgressProps = getProgressProps;
exports.stripe = exports.spin = exports.rotate = exports.progress = void 0;
var _system = require("@chakra-ui/system");
// src/progress.utils.tsx

function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}
var spin = (0, _system.keyframes)({
  "0%": {
    strokeDasharray: "1, 400",
    strokeDashoffset: "0"
  },
  "50%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-100"
  },
  "100%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-260"
  }
});
exports.spin = spin;
var rotate = (0, _system.keyframes)({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
exports.rotate = rotate;
var progress = (0, _system.keyframes)({
  "0%": {
    left: "-40%"
  },
  "100%": {
    left: "100%"
  }
});
exports.progress = progress;
var stripe = (0, _system.keyframes)({
  from: {
    backgroundPosition: "1rem 0"
  },
  to: {
    backgroundPosition: "0 0"
  }
});
exports.stripe = stripe;
function getProgressProps(options) {
  const {
    value = 0,
    min,
    max,
    valueText,
    getValueText,
    isIndeterminate,
    role = "progressbar"
  } = options;
  const percent = valueToPercent(value, min, max);
  const getAriaValueText = () => {
    if (value == null) return void 0;
    return typeof getValueText === "function" ? getValueText(value, percent) : valueText;
  };
  return {
    bind: {
      "data-indeterminate": isIndeterminate ? "" : void 0,
      "aria-valuemax": max,
      "aria-valuemin": min,
      "aria-valuenow": isIndeterminate ? void 0 : value,
      "aria-valuetext": getAriaValueText(),
      role
    },
    percent,
    value
  };
}
},{"@chakra-ui/system":"ogbg"}],"hTZY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Shape = void 0;
var _chunk33PGJX5B = require("./chunk-33PGJX5B.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/shape.tsx

var Shape = props => {
  const {
    size,
    isIndeterminate,
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.svg, {
    viewBox: "0 0 100 100",
    __css: {
      width: size,
      height: size,
      animation: isIndeterminate ? `${_chunk33PGJX5B.rotate} 2s linear infinite` : void 0
    },
    ...rest
  });
};
exports.Shape = Shape;
Shape.displayName = "Shape";
},{"./chunk-33PGJX5B.mjs":"amW8","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"PHrY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CircularProgress = void 0;
var _chunk7E427UAG = require("./chunk-7E427UAG.mjs");
var _chunkTMEF3X4C = require("./chunk-TMEF3X4C.mjs");
var _chunk33PGJX5B = require("./chunk-33PGJX5B.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/circular-progress.tsx

var CircularProgress = (0, _system.forwardRef)((props, ref) => {
  var _a;
  const {
    size = "48px",
    max = 100,
    min = 0,
    valueText,
    getValueText,
    value,
    capIsRound,
    children,
    thickness = "10px",
    color = "#0078d4",
    trackColor = "#edebe9",
    isIndeterminate,
    ...rest
  } = props;
  const progress = (0, _chunk33PGJX5B.getProgressProps)({
    min,
    max,
    value,
    valueText,
    getValueText,
    isIndeterminate
  });
  const determinant = isIndeterminate ? void 0 : ((_a = progress.percent) != null ? _a : 0) * 2.64;
  const strokeDasharray = determinant == null ? void 0 : `${determinant} ${264 - determinant}`;
  const indicatorProps = isIndeterminate ? {
    css: {
      animation: `${_chunk33PGJX5B.spin} 1.5s linear infinite`
    }
  } : {
    strokeDashoffset: 66,
    strokeDasharray,
    transitionProperty: "stroke-dasharray, stroke",
    transitionDuration: "0.6s",
    transitionTimingFunction: "ease"
  };
  const rootStyles = {
    display: "inline-block",
    position: "relative",
    verticalAlign: "middle",
    fontSize: size
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.div, {
    ref,
    className: "chakra-progress",
    ...progress.bind,
    ...rest,
    __css: rootStyles,
    children: [/* @__PURE__ */(0, _jsxRuntime.jsxs)(_chunkTMEF3X4C.Shape, {
      size,
      isIndeterminate,
      children: [/* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk7E427UAG.Circle, {
        stroke: trackColor,
        strokeWidth: thickness,
        className: "chakra-progress__track"
      }), /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunk7E427UAG.Circle, {
        stroke: color,
        strokeWidth: thickness,
        className: "chakra-progress__indicator",
        strokeLinecap: capIsRound ? "round" : void 0,
        opacity: progress.value === 0 && !isIndeterminate ? 0 : void 0,
        ...indicatorProps
      })]
    }), children]
  });
});
exports.CircularProgress = CircularProgress;
CircularProgress.displayName = "CircularProgress";
},{"./chunk-7E427UAG.mjs":"hz9T","./chunk-TMEF3X4C.mjs":"hTZY","./chunk-33PGJX5B.mjs":"amW8","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"XmgU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useProgressStyles = exports.Progress = void 0;
var _chunk33PGJX5B = require("./chunk-33PGJX5B.mjs");
var _system = require("@chakra-ui/system");
var _reactContext = require("@chakra-ui/react-context");
var _jsxRuntime = require("react/jsx-runtime");
// src/progress.tsx

var [ProgressStylesProvider, useProgressStyles] = (0, _reactContext.createContext)({
  name: `ProgressStylesContext`,
  errorMessage: `useProgressStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Progress />" `
});
exports.useProgressStyles = useProgressStyles;
var ProgressFilledTrack = (0, _system.forwardRef)((props, ref) => {
  const {
    min,
    max,
    value,
    isIndeterminate,
    role,
    ...rest
  } = props;
  const progress2 = (0, _chunk33PGJX5B.getProgressProps)({
    value,
    min,
    max,
    isIndeterminate,
    role
  });
  const styles = useProgressStyles();
  const trackStyles = {
    height: "100%",
    ...styles.filledTrack
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    style: {
      width: `${progress2.percent}%`,
      ...rest.style
    },
    ...progress2.bind,
    ...rest,
    __css: trackStyles
  });
});
var Progress = (0, _system.forwardRef)((props, ref) => {
  var _a;
  const {
    value,
    min = 0,
    max = 100,
    hasStripe,
    isAnimated,
    children,
    borderRadius: propBorderRadius,
    isIndeterminate,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-valuetext": ariaValueText,
    title,
    role,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const styles = (0, _system.useMultiStyleConfig)("Progress", props);
  const borderRadius = propBorderRadius != null ? propBorderRadius : (_a = styles.track) == null ? void 0 : _a.borderRadius;
  const stripeAnimation = {
    animation: `${_chunk33PGJX5B.stripe} 1s linear infinite`
  };
  const shouldAddStripe = !isIndeterminate && hasStripe;
  const shouldAnimateStripe = shouldAddStripe && isAnimated;
  const css = {
    ...(shouldAnimateStripe && stripeAnimation),
    ...(isIndeterminate && {
      position: "absolute",
      willChange: "left",
      minWidth: "50%",
      animation: `${_chunk33PGJX5B.progress} 1s ease infinite normal none running`
    })
  };
  const trackStyles = {
    overflow: "hidden",
    position: "relative",
    ...styles.track
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    borderRadius,
    __css: trackStyles,
    ...rest,
    children: /* @__PURE__ */(0, _jsxRuntime.jsxs)(ProgressStylesProvider, {
      value: styles,
      children: [/* @__PURE__ */(0, _jsxRuntime.jsx)(ProgressFilledTrack, {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-valuetext": ariaValueText,
        min,
        max,
        value,
        isIndeterminate,
        css,
        borderRadius,
        title,
        role
      }), children]
    })
  });
});
exports.Progress = Progress;
Progress.displayName = "Progress";
},{"./chunk-33PGJX5B.mjs":"amW8","@chakra-ui/system":"ogbg","@chakra-ui/react-context":"lT23","react/jsx-runtime":"plwR"}],"NC01":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProgressLabel = void 0;
var _chunkW6SSP5F = require("./chunk-W6SSP5F2.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/progress-label.tsx

var ProgressLabel = props => {
  const styles = (0, _chunkW6SSP5F.useProgressStyles)();
  const labelStyles = {
    top: "50%",
    left: "50%",
    width: "100%",
    textAlign: "center",
    position: "absolute",
    transform: "translate(-50%, -50%)",
    ...styles.label
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...props,
    __css: labelStyles
  });
};
exports.ProgressLabel = ProgressLabel;
ProgressLabel.displayName = "ProgressLabel";
},{"./chunk-W6SSP5F2.mjs":"XmgU","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"Few2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CircularProgress", {
  enumerable: true,
  get: function () {
    return _chunkFQ7BGFQK.CircularProgress;
  }
});
Object.defineProperty(exports, "CircularProgressLabel", {
  enumerable: true,
  get: function () {
    return _chunkV6BT6UQX.CircularProgressLabel;
  }
});
Object.defineProperty(exports, "Progress", {
  enumerable: true,
  get: function () {
    return _chunkW6SSP5F.Progress;
  }
});
Object.defineProperty(exports, "ProgressLabel", {
  enumerable: true,
  get: function () {
    return _chunkBC4GAYVP.ProgressLabel;
  }
});
Object.defineProperty(exports, "useProgressStyles", {
  enumerable: true,
  get: function () {
    return _chunkW6SSP5F.useProgressStyles;
  }
});
var _chunkV6BT6UQX = require("./chunk-V6BT6UQX.mjs");
var _chunkFQ7BGFQK = require("./chunk-FQ7BGFQK.mjs");
require("./chunk-7E427UAG.mjs");
var _chunkBC4GAYVP = require("./chunk-BC4GAYVP.mjs");
var _chunkW6SSP5F = require("./chunk-W6SSP5F2.mjs");
require("./chunk-TMEF3X4C.mjs");
require("./chunk-33PGJX5B.mjs");
},{"./chunk-V6BT6UQX.mjs":"i7h5","./chunk-FQ7BGFQK.mjs":"PHrY","./chunk-7E427UAG.mjs":"hz9T","./chunk-BC4GAYVP.mjs":"NC01","./chunk-W6SSP5F2.mjs":"XmgU","./chunk-TMEF3X4C.mjs":"hTZY","./chunk-33PGJX5B.mjs":"amW8"}],"cP4D":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useRadioGroup = useRadioGroup;
var _sharedUtils = require("@chakra-ui/shared-utils");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _react = require("react");
// src/use-radio-group.ts

function isInputEvent(value) {
  return value && (0, _sharedUtils.isObject)(value) && (0, _sharedUtils.isObject)(value.target);
}
function useRadioGroup(props = {}) {
  const {
    onChange: onChangeProp,
    value: valueProp,
    defaultValue,
    name: nameProp,
    isDisabled,
    isFocusable,
    isNative,
    ...htmlProps
  } = props;
  const [valueState, setValue] = (0, _react.useState)(defaultValue || "");
  const isControlled = typeof valueProp !== "undefined";
  const value = isControlled ? valueProp : valueState;
  const ref = (0, _react.useRef)(null);
  const focus = (0, _react.useCallback)(() => {
    const rootNode = ref.current;
    if (!rootNode) return;
    let query = `input:not(:disabled):checked`;
    const firstEnabledAndCheckedInput = rootNode.querySelector(query);
    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }
    query = `input:not(:disabled)`;
    const firstEnabledInput = rootNode.querySelector(query);
    firstEnabledInput == null ? void 0 : firstEnabledInput.focus();
  }, []);
  const uuid = (0, _react.useId)();
  const fallbackName = `radio-${uuid}`;
  const name = nameProp || fallbackName;
  const onChange = (0, _react.useCallback)(eventOrValue => {
    const nextValue = isInputEvent(eventOrValue) ? eventOrValue.target.value : eventOrValue;
    if (!isControlled) {
      setValue(nextValue);
    }
    onChangeProp == null ? void 0 : onChangeProp(String(nextValue));
  }, [onChangeProp, isControlled]);
  const getRootProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => ({
    ...props2,
    ref: (0, _reactUseMergeRefs.mergeRefs)(forwardedRef, ref),
    role: "radiogroup"
  }), []);
  const getRadioProps = (0, _react.useCallback)((props2 = {}, ref2 = null) => {
    const checkedKey = isNative ? "checked" : "isChecked";
    return {
      ...props2,
      ref: ref2,
      name,
      [checkedKey]: value != null ? props2.value === value : void 0,
      onChange(event) {
        onChange(event);
      },
      "data-radiogroup": true
    };
  }, [isNative, name, onChange, value]);
  return {
    getRootProps,
    getRadioProps,
    name,
    ref,
    focus,
    setValue,
    value,
    onChange,
    isDisabled,
    isFocusable,
    htmlProps
  };
}
},{"@chakra-ui/shared-utils":"gghr","@chakra-ui/react-use-merge-refs":"EUzL","react":"n8MK"}],"nV2M":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useRadioGroupContext = exports.RadioGroup = void 0;
var _chunkROBJ47HJ = require("./chunk-ROBJ47HJ.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _reactContext = require("@chakra-ui/react-context");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/radio-group.tsx

var [RadioGroupProvider, useRadioGroupContext] = (0, _reactContext.createContext)({
  name: "RadioGroupContext",
  strict: false
});
exports.useRadioGroupContext = useRadioGroupContext;
var RadioGroup = (0, _system.forwardRef)((props, ref) => {
  const {
    colorScheme,
    size,
    variant,
    children,
    className,
    isDisabled,
    isFocusable,
    ...rest
  } = props;
  const {
    value,
    onChange,
    getRootProps,
    name,
    htmlProps
  } = (0, _chunkROBJ47HJ.useRadioGroup)(rest);
  const group = (0, _react.useMemo)(() => ({
    name,
    size,
    onChange,
    colorScheme,
    value,
    variant,
    isDisabled,
    isFocusable
  }), [name, size, onChange, colorScheme, value, variant, isDisabled, isFocusable]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(RadioGroupProvider, {
    value: group,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
      ...getRootProps(htmlProps, ref),
      className: (0, _sharedUtils.cx)("chakra-radio-group", className),
      children
    })
  });
});
exports.RadioGroup = RadioGroup;
RadioGroup.displayName = "RadioGroup";
},{"./chunk-ROBJ47HJ.mjs":"cP4D","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","@chakra-ui/react-context":"lT23","react":"n8MK","react/jsx-runtime":"plwR"}],"HvYf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useRadio = useRadio;
var _chunkQUJ23J4G = require("./chunk-QUJ23J4G.mjs");
var _formControl = require("@chakra-ui/form-control");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _focusVisible = require("@zag-js/focus-visible");
var _react = require("react");
// src/use-radio.ts

// ../visually-hidden/src/visually-hidden.style.ts
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0, 0, 0, 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: "0",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};

// src/use-radio.ts

function useRadio(props = {}) {
  const {
    defaultChecked,
    isChecked: isCheckedProp,
    isFocusable,
    isDisabled: isDisabledProp,
    isReadOnly: isReadOnlyProp,
    isRequired: isRequiredProp,
    onChange,
    isInvalid: isInvalidProp,
    name,
    value,
    id: idProp,
    "data-radiogroup": dataRadioGroup,
    "aria-describedby": ariaDescribedBy,
    ...htmlProps
  } = props;
  const uuid = `radio-${(0, _react.useId)()}`;
  const formControl = (0, _formControl.useFormControlContext)();
  const group = (0, _chunkQUJ23J4G.useRadioGroupContext)();
  const isWithinRadioGroup = !!group || !!dataRadioGroup;
  const isWithinFormControl = !!formControl;
  let id = isWithinFormControl && !isWithinRadioGroup ? formControl.id : uuid;
  id = idProp != null ? idProp : id;
  const isDisabled = isDisabledProp != null ? isDisabledProp : formControl == null ? void 0 : formControl.isDisabled;
  const isReadOnly = isReadOnlyProp != null ? isReadOnlyProp : formControl == null ? void 0 : formControl.isReadOnly;
  const isRequired = isRequiredProp != null ? isRequiredProp : formControl == null ? void 0 : formControl.isRequired;
  const isInvalid = isInvalidProp != null ? isInvalidProp : formControl == null ? void 0 : formControl.isInvalid;
  const [isFocusVisible, setIsFocusVisible] = (0, _react.useState)(false);
  const [isFocused, setFocused] = (0, _react.useState)(false);
  const [isHovered, setHovering] = (0, _react.useState)(false);
  const [isActive, setActive] = (0, _react.useState)(false);
  const [isCheckedState, setChecked] = (0, _react.useState)(Boolean(defaultChecked));
  const isControlled = typeof isCheckedProp !== "undefined";
  const isChecked = isControlled ? isCheckedProp : isCheckedState;
  (0, _react.useEffect)(() => {
    return (0, _focusVisible.trackFocusVisible)(setIsFocusVisible);
  }, []);
  const handleChange = (0, _react.useCallback)(event => {
    if (isReadOnly || isDisabled) {
      event.preventDefault();
      return;
    }
    if (!isControlled) {
      setChecked(event.target.checked);
    }
    onChange == null ? void 0 : onChange(event);
  }, [isControlled, isDisabled, isReadOnly, onChange]);
  const onKeyDown = (0, _react.useCallback)(event => {
    if (event.key === " ") {
      setActive(true);
    }
  }, [setActive]);
  const onKeyUp = (0, _react.useCallback)(event => {
    if (event.key === " ") {
      setActive(false);
    }
  }, [setActive]);
  const getRadioProps = (0, _react.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref,
    "data-active": (0, _sharedUtils.dataAttr)(isActive),
    "data-hover": (0, _sharedUtils.dataAttr)(isHovered),
    "data-disabled": (0, _sharedUtils.dataAttr)(isDisabled),
    "data-invalid": (0, _sharedUtils.dataAttr)(isInvalid),
    "data-checked": (0, _sharedUtils.dataAttr)(isChecked),
    "data-focus": (0, _sharedUtils.dataAttr)(isFocused),
    "data-focus-visible": (0, _sharedUtils.dataAttr)(isFocused && isFocusVisible),
    "data-readonly": (0, _sharedUtils.dataAttr)(isReadOnly),
    "aria-hidden": true,
    onMouseDown: (0, _sharedUtils.callAllHandlers)(props2.onMouseDown, () => setActive(true)),
    onMouseUp: (0, _sharedUtils.callAllHandlers)(props2.onMouseUp, () => setActive(false)),
    onMouseEnter: (0, _sharedUtils.callAllHandlers)(props2.onMouseEnter, () => setHovering(true)),
    onMouseLeave: (0, _sharedUtils.callAllHandlers)(props2.onMouseLeave, () => setHovering(false))
  }), [isActive, isHovered, isDisabled, isInvalid, isChecked, isFocused, isReadOnly, isFocusVisible]);
  const {
    onFocus,
    onBlur
  } = formControl != null ? formControl : {};
  const getInputProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    const trulyDisabled = isDisabled && !isFocusable;
    return {
      ...props2,
      id,
      ref,
      type: "radio",
      name,
      value,
      onChange: (0, _sharedUtils.callAllHandlers)(props2.onChange, handleChange),
      onBlur: (0, _sharedUtils.callAllHandlers)(onBlur, props2.onBlur, () => setFocused(false)),
      onFocus: (0, _sharedUtils.callAllHandlers)(onFocus, props2.onFocus, () => setFocused(true)),
      onKeyDown: (0, _sharedUtils.callAllHandlers)(props2.onKeyDown, onKeyDown),
      onKeyUp: (0, _sharedUtils.callAllHandlers)(props2.onKeyUp, onKeyUp),
      checked: isChecked,
      disabled: trulyDisabled,
      readOnly: isReadOnly,
      required: isRequired,
      "aria-invalid": (0, _sharedUtils.ariaAttr)(isInvalid),
      "aria-disabled": (0, _sharedUtils.ariaAttr)(trulyDisabled),
      "aria-required": (0, _sharedUtils.ariaAttr)(isRequired),
      "data-readonly": (0, _sharedUtils.dataAttr)(isReadOnly),
      "aria-describedby": ariaDescribedBy,
      style: visuallyHiddenStyle
    };
  }, [isDisabled, isFocusable, id, name, value, handleChange, onBlur, onFocus, onKeyDown, onKeyUp, isChecked, isReadOnly, isRequired, isInvalid, ariaDescribedBy]);
  const getLabelProps = (props2 = {}, ref = null) => ({
    ...props2,
    ref,
    onMouseDown: (0, _sharedUtils.callAllHandlers)(props2.onMouseDown, stop),
    onTouchStart: (0, _sharedUtils.callAllHandlers)(props2.onTouchStart, stop),
    "data-disabled": (0, _sharedUtils.dataAttr)(isDisabled),
    "data-checked": (0, _sharedUtils.dataAttr)(isChecked),
    "data-invalid": (0, _sharedUtils.dataAttr)(isInvalid)
  });
  const getRootProps = (props2, ref = null) => ({
    ...props2,
    ref,
    "data-disabled": (0, _sharedUtils.dataAttr)(isDisabled),
    "data-checked": (0, _sharedUtils.dataAttr)(isChecked),
    "data-invalid": (0, _sharedUtils.dataAttr)(isInvalid)
  });
  const state = {
    isInvalid,
    isFocused,
    isChecked,
    isActive,
    isHovered,
    isDisabled,
    isReadOnly,
    isRequired
  };
  return {
    state,
    getCheckboxProps: getRadioProps,
    getInputProps,
    getLabelProps,
    getRootProps,
    htmlProps
  };
}
function stop(event) {
  event.preventDefault();
  event.stopPropagation();
}
},{"./chunk-QUJ23J4G.mjs":"nV2M","@chakra-ui/form-control":"fjMD","@chakra-ui/shared-utils":"gghr","@zag-js/focus-visible":"yUYU","react":"n8MK"}],"XWt0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Radio = void 0;
var _chunkPAIHW5OI = require("./chunk-PAIHW5OI.mjs");
var _chunkQUJ23J4G = require("./chunk-QUJ23J4G.mjs");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/radio.tsx

// ../../utilities/object-utils/src/index.ts
function split(object, keys) {
  const picked = {};
  const omitted = {};
  for (const [key, value] of Object.entries(object)) {
    if (keys.includes(key)) picked[key] = value;else omitted[key] = value;
  }
  return [picked, omitted];
}

// src/radio.tsx

var Radio = (0, _system.forwardRef)((props, ref) => {
  var _a;
  const group = (0, _chunkQUJ23J4G.useRadioGroupContext)();
  const {
    onChange: onChangeProp,
    value: valueProp
  } = props;
  const styles = (0, _system.useMultiStyleConfig)("Radio", {
    ...group,
    ...props
  });
  const ownProps = (0, _system.omitThemingProps)(props);
  const {
    spacing = "0.5rem",
    children,
    isDisabled = group == null ? void 0 : group.isDisabled,
    isFocusable = group == null ? void 0 : group.isFocusable,
    inputProps: htmlInputProps,
    ...rest
  } = ownProps;
  let isChecked = props.isChecked;
  if ((group == null ? void 0 : group.value) != null && valueProp != null) {
    isChecked = group.value === valueProp;
  }
  let onChange = onChangeProp;
  if ((group == null ? void 0 : group.onChange) && valueProp != null) {
    onChange = (0, _sharedUtils.callAll)(group.onChange, onChangeProp);
  }
  const name = (_a = props == null ? void 0 : props.name) != null ? _a : group == null ? void 0 : group.name;
  const {
    getInputProps,
    getCheckboxProps,
    getLabelProps,
    getRootProps,
    htmlProps
  } = (0, _chunkPAIHW5OI.useRadio)({
    ...rest,
    isChecked,
    isFocusable,
    isDisabled,
    onChange,
    name
  });
  const [layoutProps, otherProps] = split(htmlProps, _system.layoutPropNames);
  const checkboxProps = getCheckboxProps(otherProps);
  const inputProps = getInputProps(htmlInputProps, ref);
  const labelProps = getLabelProps();
  const rootProps = Object.assign({}, layoutProps, getRootProps());
  const rootStyles = {
    display: "inline-flex",
    alignItems: "center",
    verticalAlign: "top",
    cursor: "pointer",
    position: "relative",
    ...styles.container
  };
  const checkboxStyles = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    ...styles.control
  };
  const labelStyles = {
    userSelect: "none",
    marginStart: spacing,
    ...styles.label
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.label, {
    className: "chakra-radio",
    ...rootProps,
    __css: rootStyles,
    children: [/* @__PURE__ */(0, _jsxRuntime.jsx)("input", {
      className: "chakra-radio__input",
      ...inputProps
    }), /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      className: "chakra-radio__control",
      ...checkboxProps,
      __css: checkboxStyles
    }), children && /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      className: "chakra-radio__label",
      ...labelProps,
      __css: labelStyles,
      children
    })]
  });
});
exports.Radio = Radio;
Radio.displayName = "Radio";
},{"./chunk-PAIHW5OI.mjs":"HvYf","./chunk-QUJ23J4G.mjs":"nV2M","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"EpKe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Radio", {
  enumerable: true,
  get: function () {
    return _chunk7UFLJ3PE.Radio;
  }
});
Object.defineProperty(exports, "RadioGroup", {
  enumerable: true,
  get: function () {
    return _chunkQUJ23J4G.RadioGroup;
  }
});
Object.defineProperty(exports, "useRadio", {
  enumerable: true,
  get: function () {
    return _chunkPAIHW5OI.useRadio;
  }
});
Object.defineProperty(exports, "useRadioGroup", {
  enumerable: true,
  get: function () {
    return _chunkROBJ47HJ.useRadioGroup;
  }
});
Object.defineProperty(exports, "useRadioGroupContext", {
  enumerable: true,
  get: function () {
    return _chunkQUJ23J4G.useRadioGroupContext;
  }
});
var _chunk7UFLJ3PE = require("./chunk-7UFLJ3PE.mjs");
var _chunkPAIHW5OI = require("./chunk-PAIHW5OI.mjs");
var _chunkQUJ23J4G = require("./chunk-QUJ23J4G.mjs");
var _chunkROBJ47HJ = require("./chunk-ROBJ47HJ.mjs");
},{"./chunk-7UFLJ3PE.mjs":"XWt0","./chunk-PAIHW5OI.mjs":"HvYf","./chunk-QUJ23J4G.mjs":"nV2M","./chunk-ROBJ47HJ.mjs":"cP4D"}],"HPZn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SelectField = void 0;
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/select-field.tsx

var SelectField = (0, _system.forwardRef)(function SelectField2(props, ref) {
  const {
    children,
    placeholder,
    className,
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.select, {
    ...rest,
    ref,
    className: (0, _sharedUtils.cx)("chakra-select", className),
    children: [placeholder && /* @__PURE__ */(0, _jsxRuntime.jsx)("option", {
      value: "",
      children: placeholder
    }), children]
  });
});
exports.SelectField = SelectField;
SelectField.displayName = "SelectField";
},{"@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"kkNd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Select = exports.DefaultIcon = void 0;
var _chunkHQIEHZYI = require("./chunk-HQIEHZYI.mjs");
var _formControl = require("@chakra-ui/form-control");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/select.tsx

// ../../utilities/object-utils/src/index.ts
function split(object, keys) {
  const picked = {};
  const omitted = {};
  for (const [key, value] of Object.entries(object)) {
    if (keys.includes(key)) picked[key] = value;else omitted[key] = value;
  }
  return [picked, omitted];
}

// src/select.tsx

var Select = (0, _system.forwardRef)((props, ref) => {
  var _a;
  const styles = (0, _system.useMultiStyleConfig)("Select", props);
  const {
    rootProps,
    placeholder,
    icon,
    color,
    height,
    h,
    minH,
    minHeight,
    iconColor,
    iconSize,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const [layoutProps, otherProps] = split(rest, _system.layoutPropNames);
  const ownProps = (0, _formControl.useFormControl)(otherProps);
  const rootStyles = {
    width: "100%",
    height: "fit-content",
    position: "relative",
    color
  };
  const fieldStyles = {
    paddingEnd: "2rem",
    ...styles.field,
    _focus: {
      zIndex: "unset",
      ...((_a = styles.field) == null ? void 0 : _a["_focus"])
    }
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.div, {
    className: "chakra-select__wrapper",
    __css: rootStyles,
    ...layoutProps,
    ...rootProps,
    children: [/* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkHQIEHZYI.SelectField, {
      ref,
      height: h != null ? h : height,
      minH: minH != null ? minH : minHeight,
      placeholder,
      ...ownProps,
      __css: fieldStyles,
      children: props.children
    }), /* @__PURE__ */(0, _jsxRuntime.jsx)(SelectIcon, {
      "data-disabled": (0, _sharedUtils.dataAttr)(ownProps.disabled),
      ...((iconColor || color) && {
        color: iconColor || color
      }),
      __css: styles.icon,
      ...(iconSize && {
        fontSize: iconSize
      }),
      children: icon
    })]
  });
});
exports.Select = Select;
Select.displayName = "Select";
var DefaultIcon = props => /* @__PURE__ */(0, _jsxRuntime.jsx)("svg", {
  viewBox: "0 0 24 24",
  ...props,
  children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
    fill: "currentColor",
    d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
  })
});
exports.DefaultIcon = DefaultIcon;
var IconWrapper = (0, _system.chakra)("div", {
  baseStyle: {
    position: "absolute",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    pointerEvents: "none",
    top: "50%",
    transform: "translateY(-50%)"
  }
});
var SelectIcon = props => {
  const {
    children = /* @__PURE__ */(0, _jsxRuntime.jsx)(DefaultIcon, {}),
    ...rest
  } = props;
  const clone = (0, _react.cloneElement)(children, {
    role: "presentation",
    className: "chakra-select__icon",
    focusable: false,
    "aria-hidden": true,
    style: {
      width: "1em",
      height: "1em",
      color: "currentColor"
    }
  });
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(IconWrapper, {
    ...rest,
    className: "chakra-select__icon-wrapper",
    children: (0, _react.isValidElement)(children) ? clone : null
  });
};
SelectIcon.displayName = "SelectIcon";
},{"./chunk-HQIEHZYI.mjs":"HPZn","@chakra-ui/form-control":"fjMD","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"nHsR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DefaultIcon", {
  enumerable: true,
  get: function () {
    return _chunkGJO77I2I.DefaultIcon;
  }
});
Object.defineProperty(exports, "Select", {
  enumerable: true,
  get: function () {
    return _chunkGJO77I2I.Select;
  }
});
Object.defineProperty(exports, "SelectField", {
  enumerable: true,
  get: function () {
    return _chunkHQIEHZYI.SelectField;
  }
});
var _chunkGJO77I2I = require("./chunk-GJO77I2I.mjs");
var _chunkHQIEHZYI = require("./chunk-HQIEHZYI.mjs");
},{"./chunk-GJO77I2I.mjs":"kkNd","./chunk-HQIEHZYI.mjs":"HPZn"}],"SA5s":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useIsFirstRender = useIsFirstRender;
var _react = require("react");
// src/use-is-first-render.ts

function useIsFirstRender() {
  const isFirstRender = (0, _react.useRef)(true);
  (0, _react.useEffect)(() => {
    isFirstRender.current = false;
  }, []);
  return isFirstRender.current;
}
},{"react":"n8MK"}],"EoHU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePrevious = usePrevious;
var _react = require("react");
// src/index.ts

function usePrevious(value) {
  const ref = (0, _react.useRef)();
  (0, _react.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
},{"react":"n8MK"}],"WDmI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Skeleton = void 0;
var _chunk5L3NXCNX = require("./chunk-5L3NXCNX.mjs");
var _reactUsePrevious = require("@chakra-ui/react-use-previous");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/skeleton.tsx

var StyledSkeleton = (0, _system.chakra)("div", {
  baseStyle: {
    boxShadow: "none",
    backgroundClip: "padding-box",
    cursor: "default",
    color: "transparent",
    pointerEvents: "none",
    userSelect: "none",
    "&::before, &::after, *": {
      visibility: "hidden"
    }
  }
});
var $startColor = (0, _system.cssVar)("skeleton-start-color");
var $endColor = (0, _system.cssVar)("skeleton-end-color");
var fade = (0, _system.keyframes)({
  from: {
    opacity: 0
  },
  to: {
    opacity: 1
  }
});
var bgFade = (0, _system.keyframes)({
  from: {
    borderColor: $startColor.reference,
    background: $startColor.reference
  },
  to: {
    borderColor: $endColor.reference,
    background: $endColor.reference
  }
});
var Skeleton = (0, _system.forwardRef)((props, ref) => {
  const skeletonProps = {
    fadeDuration: 0.4,
    speed: 0.8,
    ...props
  };
  const styles = (0, _system.useStyleConfig)("Skeleton", skeletonProps);
  const isFirstRender = (0, _chunk5L3NXCNX.useIsFirstRender)();
  const {
    startColor = "",
    endColor = "",
    isLoaded,
    fadeDuration,
    speed,
    className,
    fitContent,
    ...rest
  } = (0, _system.omitThemingProps)(skeletonProps);
  const [startColorVar, endColorVar] = (0, _system.useToken)("colors", [startColor, endColor]);
  const wasPreviouslyLoaded = (0, _reactUsePrevious.usePrevious)(isLoaded);
  const _className = (0, _sharedUtils.cx)("chakra-skeleton", className);
  const cssVarStyles = {
    ...(startColorVar && {
      [$startColor.variable]: startColorVar
    }),
    ...(endColorVar && {
      [$endColor.variable]: endColorVar
    })
  };
  if (isLoaded) {
    const animation = isFirstRender || wasPreviouslyLoaded ? "none" : `${fade} ${fadeDuration}s`;
    return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
      ref,
      className: _className,
      __css: {
        animation
      },
      ...rest
    });
  }
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(StyledSkeleton, {
    ref,
    className: _className,
    ...rest,
    __css: {
      width: fitContent ? "fit-content" : void 0,
      ...styles,
      ...cssVarStyles,
      _dark: {
        ...styles["_dark"],
        ...cssVarStyles
      },
      animation: `${speed}s linear infinite alternate ${bgFade}`
    }
  });
});
exports.Skeleton = Skeleton;
Skeleton.displayName = "Skeleton";
},{"./chunk-5L3NXCNX.mjs":"SA5s","@chakra-ui/react-use-previous":"EoHU","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"ZWIH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SkeletonCircle = void 0;
var _chunkWTFA3K5H = require("./chunk-WTFA3K5H.mjs");
var _jsxRuntime = require("react/jsx-runtime");
// src/skeleton-circle.tsx

var SkeletonCircle = ({
  size = "2rem",
  ...rest
}) => /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkWTFA3K5H.Skeleton, {
  borderRadius: "full",
  boxSize: size,
  ...rest
});
exports.SkeletonCircle = SkeletonCircle;
SkeletonCircle.displayName = "SkeletonCircle";
},{"./chunk-WTFA3K5H.mjs":"WDmI","react/jsx-runtime":"plwR"}],"qM8w":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SkeletonText = void 0;
var _chunkWTFA3K5H = require("./chunk-WTFA3K5H.mjs");
var _mediaQuery = require("@chakra-ui/media-query");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/skeleton-text.tsx

function range(count) {
  return Array(count).fill(1).map((_, index) => index + 1);
}
var defaultNoOfLines = 3;
var SkeletonText = props => {
  const {
    noOfLines = defaultNoOfLines,
    spacing = "0.5rem",
    skeletonHeight = "0.5rem",
    className,
    startColor,
    endColor,
    isLoaded,
    fadeDuration,
    speed,
    children,
    ...rest
  } = props;
  const noOfLinesValue = (0, _mediaQuery.useBreakpointValue)(typeof noOfLines === "number" ? [noOfLines] : noOfLines) || defaultNoOfLines;
  const numbers = range(noOfLinesValue);
  const getWidth = index => {
    if (noOfLinesValue > 1) {
      return index === numbers.length ? "80%" : "100%";
    }
    return "100%";
  };
  const _className = (0, _sharedUtils.cx)("chakra-skeleton__group", className);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    className: _className,
    ...rest,
    children: numbers.map((number, index) => {
      if (isLoaded && index > 0) {
        return null;
      }
      const sizeProps = isLoaded ? null : {
        mb: number === numbers.length ? "0" : spacing,
        width: getWidth(number),
        height: skeletonHeight
      };
      return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkWTFA3K5H.Skeleton, {
        startColor,
        endColor,
        isLoaded,
        fadeDuration,
        speed,
        ...sizeProps,
        children: index === 0 ? children : void 0
      }, numbers.length.toString() + number);
    })
  });
};
exports.SkeletonText = SkeletonText;
SkeletonText.displayName = "SkeletonText";
},{"./chunk-WTFA3K5H.mjs":"WDmI","@chakra-ui/media-query":"cY5H","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"giO0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Skeleton", {
  enumerable: true,
  get: function () {
    return _chunkWTFA3K5H.Skeleton;
  }
});
Object.defineProperty(exports, "SkeletonCircle", {
  enumerable: true,
  get: function () {
    return _chunkHVOE6EUN.SkeletonCircle;
  }
});
Object.defineProperty(exports, "SkeletonText", {
  enumerable: true,
  get: function () {
    return _chunkHSMM5BK.SkeletonText;
  }
});
var _chunkHVOE6EUN = require("./chunk-HVOE6EUN.mjs");
var _chunkHSMM5BK = require("./chunk-HSMM5BK4.mjs");
var _chunkWTFA3K5H = require("./chunk-WTFA3K5H.mjs");
require("./chunk-5L3NXCNX.mjs");
},{"./chunk-HVOE6EUN.mjs":"ZWIH","./chunk-HSMM5BK4.mjs":"qM8w","./chunk-WTFA3K5H.mjs":"WDmI","./chunk-5L3NXCNX.mjs":"SA5s"}],"xVQi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ariaAttr = void 0;
exports.callAllHandlers = callAllHandlers;
exports.dataAttr = exports.cx = void 0;
// ../../legacy/utils/src/dom.ts
var dataAttr = condition => condition ? "" : void 0;
exports.dataAttr = dataAttr;
var ariaAttr = condition => condition ? true : void 0;
exports.ariaAttr = ariaAttr;
var cx = (...classNames) => classNames.filter(Boolean).join(" ");

// ../../legacy/utils/src/function.ts
exports.cx = cx;
function callAllHandlers(...fns) {
  return function func(event) {
    fns.some(fn => {
      fn == null ? void 0 : fn(event);
      return event == null ? void 0 : event.defaultPrevented;
    });
  };
}
},{}],"M4Ne":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getIds = getIds;
exports.getIsReversed = getIsReversed;
exports.getStyles = getStyles;
exports.orient = orient;
// src/slider-utils.ts
function getIds(id) {
  return {
    root: `slider-root-${id}`,
    getThumb: i => `slider-thumb-${id}-${i}`,
    getInput: i => `slider-input-${id}-${i}`,
    track: `slider-track-${id}`,
    innerTrack: `slider-filled-track-${id}`,
    getMarker: i => `slider-marker-${id}-${i}`,
    output: `slider-output-${id}`
  };
}
function orient(options) {
  const {
    orientation,
    vertical,
    horizontal
  } = options;
  return orientation === "vertical" ? vertical : horizontal;
}
var zeroSize = {
  width: 0,
  height: 0
};
var normalize = a => a || zeroSize;
function getStyles(options) {
  const {
    orientation,
    thumbPercents,
    thumbRects,
    isReversed
  } = options;
  const getThumbStyle = i => {
    var _a;
    const rect = (_a = thumbRects[i]) != null ? _a : zeroSize;
    return {
      position: "absolute",
      userSelect: "none",
      WebkitUserSelect: "none",
      MozUserSelect: "none",
      msUserSelect: "none",
      touchAction: "none",
      ...orient({
        orientation,
        vertical: {
          bottom: `calc(${thumbPercents[i]}% - ${rect.height / 2}px)`
        },
        horizontal: {
          left: `calc(${thumbPercents[i]}% - ${rect.width / 2}px)`
        }
      })
    };
  };
  const size = orientation === "vertical" ? thumbRects.reduce((a, b) => normalize(a).height > normalize(b).height ? a : b, zeroSize) : thumbRects.reduce((a, b) => normalize(a).width > normalize(b).width ? a : b, zeroSize);
  const rootStyle = {
    position: "relative",
    touchAction: "none",
    WebkitTapHighlightColor: "rgba(0,0,0,0)",
    userSelect: "none",
    outline: 0,
    ...orient({
      orientation,
      vertical: size ? {
        paddingLeft: size.width / 2,
        paddingRight: size.width / 2
      } : {},
      horizontal: size ? {
        paddingTop: size.height / 2,
        paddingBottom: size.height / 2
      } : {}
    })
  };
  const trackStyle = {
    position: "absolute",
    ...orient({
      orientation,
      vertical: {
        left: "50%",
        transform: "translateX(-50%)",
        height: "100%"
      },
      horizontal: {
        top: "50%",
        transform: "translateY(-50%)",
        width: "100%"
      }
    })
  };
  const isSingleThumb = thumbPercents.length === 1;
  const fallback = [0, isReversed ? 100 - thumbPercents[0] : thumbPercents[0]];
  const range = isSingleThumb ? fallback : thumbPercents;
  let start = range[0];
  if (!isSingleThumb && isReversed) {
    start = 100 - start;
  }
  const percent = Math.abs(range[range.length - 1] - range[0]);
  const innerTrackStyle = {
    ...trackStyle,
    ...orient({
      orientation,
      vertical: isReversed ? {
        height: `${percent}%`,
        top: `${start}%`
      } : {
        height: `${percent}%`,
        bottom: `${start}%`
      },
      horizontal: isReversed ? {
        width: `${percent}%`,
        right: `${start}%`
      } : {
        width: `${percent}%`,
        left: `${start}%`
      }
    })
  };
  return {
    trackStyle,
    innerTrackStyle,
    rootStyle,
    getThumbStyle
  };
}
function getIsReversed(options) {
  const {
    isReversed,
    direction,
    orientation
  } = options;
  if (direction === "ltr" || orientation === "vertical") {
    return isReversed;
  }
  return !isReversed;
}
},{}],"Rn2R":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDomEvent = addDomEvent;
// src/add-dom-event.ts
function addDomEvent(target, eventName, handler, options) {
  target.addEventListener(eventName, handler, options);
  return () => {
    target.removeEventListener(eventName, handler, options);
  };
}
},{}],"Fwg0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEventWindow = getEventWindow;
exports.isMouseEvent = isMouseEvent;
exports.isMultiTouchEvent = isMultiTouchEvent;
exports.isTouchEvent = isTouchEvent;
// src/assertion.ts
function isMouseEvent(event) {
  const win = getEventWindow(event);
  if (typeof win.PointerEvent !== "undefined" && event instanceof win.PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof win.MouseEvent;
}
function isTouchEvent(event) {
  const hasTouches = !!event.touches;
  return hasTouches;
}
function isMultiTouchEvent(event) {
  return isTouchEvent(event) && event.touches.length > 1;
}
function getEventWindow(event) {
  var _a;
  return (_a = event.view) != null ? _a : window;
}
},{}],"bZr1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEventPoint = getEventPoint;
var _chunkB7KYFEHM = require("./chunk-B7KYFEHM.mjs");
// src/get-event-point.ts
function pointFromTouch(e, type = "page") {
  const point = e.touches[0] || e.changedTouches[0];
  return {
    x: point[`${type}X`],
    y: point[`${type}Y`]
  };
}
function pointFromMouse(point, type = "page") {
  return {
    x: point[`${type}X`],
    y: point[`${type}Y`]
  };
}
function getEventPoint(event, type = "page") {
  return (0, _chunkB7KYFEHM.isTouchEvent)(event) ? pointFromTouch(event, type) : pointFromMouse(event, type);
}
},{"./chunk-B7KYFEHM.mjs":"Fwg0"}],"JOPx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addPointerEvent = addPointerEvent;
var _chunk6K7SS4J = require("./chunk-6K7SS4J6.mjs");
var _chunk6FBKF3LK = require("./chunk-6FBKF3LK.mjs");
var _chunkB7KYFEHM = require("./chunk-B7KYFEHM.mjs");
// src/add-pointer-event.ts
function filter(cb) {
  return event => {
    const isMouse = (0, _chunkB7KYFEHM.isMouseEvent)(event);
    if (!isMouse || isMouse && event.button === 0) {
      cb(event);
    }
  };
}
function wrap(cb, filterPrimary = false) {
  function listener(event) {
    cb(event, {
      point: (0, _chunk6FBKF3LK.getEventPoint)(event)
    });
  }
  const fn = filterPrimary ? filter(listener) : listener;
  return fn;
}
function addPointerEvent(target, type, cb, options) {
  return (0, _chunk6K7SS4J.addDomEvent)(target, type, wrap(cb, type === "pointerdown"), options);
}
},{"./chunk-6K7SS4J6.mjs":"Rn2R","./chunk-6FBKF3LK.mjs":"bZr1","./chunk-B7KYFEHM.mjs":"Fwg0"}],"xbgg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "addDomEvent", {
  enumerable: true,
  get: function () {
    return _chunk6K7SS4J.addDomEvent;
  }
});
Object.defineProperty(exports, "addPointerEvent", {
  enumerable: true,
  get: function () {
    return _chunkKDLSVIYE.addPointerEvent;
  }
});
Object.defineProperty(exports, "getEventPoint", {
  enumerable: true,
  get: function () {
    return _chunk6FBKF3LK.getEventPoint;
  }
});
Object.defineProperty(exports, "isMouseEvent", {
  enumerable: true,
  get: function () {
    return _chunkB7KYFEHM.isMouseEvent;
  }
});
Object.defineProperty(exports, "isMultiTouchEvent", {
  enumerable: true,
  get: function () {
    return _chunkB7KYFEHM.isMultiTouchEvent;
  }
});
Object.defineProperty(exports, "isTouchEvent", {
  enumerable: true,
  get: function () {
    return _chunkB7KYFEHM.isTouchEvent;
  }
});
var _chunkKDLSVIYE = require("./chunk-KDLSVIYE.mjs");
var _chunk6K7SS4J = require("./chunk-6K7SS4J6.mjs");
var _chunk6FBKF3LK = require("./chunk-6FBKF3LK.mjs");
var _chunkB7KYFEHM = require("./chunk-B7KYFEHM.mjs");
},{"./chunk-KDLSVIYE.mjs":"JOPx","./chunk-6K7SS4J6.mjs":"Rn2R","./chunk-6FBKF3LK.mjs":"bZr1","./chunk-B7KYFEHM.mjs":"Fwg0"}],"ay4H":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PanEvent = void 0;
exports.distance = distance;
var _eventUtils = require("@chakra-ui/event-utils");
var _framesync = _interopRequireWildcard(require("framesync"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/pan-event.ts

var PanEvent = class {
  constructor(event, handlers, threshold) {
    __publicField(this, "history", []);
    __publicField(this, "startEvent", null);
    __publicField(this, "lastEvent", null);
    __publicField(this, "lastEventInfo", null);
    __publicField(this, "handlers", {});
    __publicField(this, "removeListeners", () => {});
    __publicField(this, "threshold", 3);
    __publicField(this, "win");
    __publicField(this, "updatePoint", () => {
      if (!(this.lastEvent && this.lastEventInfo)) return;
      const info = getPanInfo(this.lastEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance(info.offset, {
        x: 0,
        y: 0
      }) >= this.threshold;
      if (!isPanStarted && !isDistancePastThreshold) return;
      const {
        timestamp
      } = (0, _framesync.getFrameData)();
      this.history.push({
        ...info.point,
        timestamp
      });
      const {
        onStart,
        onMove
      } = this.handlers;
      if (!isPanStarted) {
        onStart == null ? void 0 : onStart(this.lastEvent, info);
        this.startEvent = this.lastEvent;
      }
      onMove == null ? void 0 : onMove(this.lastEvent, info);
    });
    __publicField(this, "onPointerMove", (event, info) => {
      this.lastEvent = event;
      this.lastEventInfo = info;
      _framesync.default.update(this.updatePoint, true);
    });
    __publicField(this, "onPointerUp", (event, info) => {
      const panInfo = getPanInfo(info, this.history);
      const {
        onEnd,
        onSessionEnd
      } = this.handlers;
      onSessionEnd == null ? void 0 : onSessionEnd(event, panInfo);
      this.end();
      if (!onEnd || !this.startEvent) return;
      onEnd == null ? void 0 : onEnd(event, panInfo);
    });
    var _a;
    this.win = (_a = event.view) != null ? _a : window;
    if ((0, _eventUtils.isMultiTouchEvent)(event)) return;
    this.handlers = handlers;
    if (threshold) {
      this.threshold = threshold;
    }
    event.stopPropagation();
    event.preventDefault();
    const info = {
      point: (0, _eventUtils.getEventPoint)(event)
    };
    const {
      timestamp
    } = (0, _framesync.getFrameData)();
    this.history = [{
      ...info.point,
      timestamp
    }];
    const {
      onSessionStart
    } = handlers;
    onSessionStart == null ? void 0 : onSessionStart(event, getPanInfo(info, this.history));
    this.removeListeners = pipe((0, _eventUtils.addPointerEvent)(this.win, "pointermove", this.onPointerMove), (0, _eventUtils.addPointerEvent)(this.win, "pointerup", this.onPointerUp), (0, _eventUtils.addPointerEvent)(this.win, "pointercancel", this.onPointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    var _a;
    (_a = this.removeListeners) == null ? void 0 : _a.call(this);
    _framesync.cancelSync.update(this.updatePoint);
  }
};
exports.PanEvent = PanEvent;
function subtract(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}
function getPanInfo(info, history) {
  return {
    point: info.point,
    delta: subtract(info.point, history[history.length - 1]),
    offset: subtract(info.point, history[0]),
    velocity: getVelocity(history, 0.1)
  };
}
var toMilliseconds = v => v * 1e3;
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return {
      x: 0,
      y: 0
    };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = history[history.length - 1];
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return {
      x: 0,
      y: 0
    };
  }
  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time === 0) {
    return {
      x: 0,
      y: 0
    };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function pipe(...fns) {
  return v => fns.reduce((a, b) => b(a), v);
}
function distance1D(a, b) {
  return Math.abs(a - b);
}
function isPoint(point) {
  return "x" in point && "y" in point;
}
function distance(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return distance1D(a, b);
  }
  if (isPoint(a) && isPoint(b)) {
    const xDelta = distance1D(a.x, b.x);
    const yDelta = distance1D(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }
  return 0;
}
},{"@chakra-ui/event-utils":"xbgg","framesync":"V2xU"}],"iUkH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useLatestRef = useLatestRef;
var _react = require("react");
// src/index.ts

function useLatestRef(value) {
  const ref = (0, _react.useRef)(null);
  ref.current = value;
  return ref;
}
},{"react":"n8MK"}],"iEO7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePanEvent = usePanEvent;
var _chunkOT5ZKXS = require("./chunk-OT5ZKXS2.mjs");
var _eventUtils = require("@chakra-ui/event-utils");
var _reactUseLatestRef = require("@chakra-ui/react-use-latest-ref");
var _react = require("react");
// src/use-pan-event.ts

function usePanEvent(ref, options) {
  const {
    onPan,
    onPanStart,
    onPanEnd,
    onPanSessionStart,
    onPanSessionEnd,
    threshold
  } = options;
  const hasPanEvents = Boolean(onPan || onPanStart || onPanEnd || onPanSessionStart || onPanSessionEnd);
  const panSession = (0, _react.useRef)(null);
  const handlersRef = (0, _reactUseLatestRef.useLatestRef)({
    onSessionStart: onPanSessionStart,
    onSessionEnd: onPanSessionEnd,
    onStart: onPanStart,
    onMove: onPan,
    onEnd(event, info) {
      panSession.current = null;
      onPanEnd == null ? void 0 : onPanEnd(event, info);
    }
  });
  (0, _react.useEffect)(() => {
    var _a;
    (_a = panSession.current) == null ? void 0 : _a.updateHandlers(handlersRef.current);
  });
  (0, _react.useEffect)(() => {
    const node = ref.current;
    if (!node || !hasPanEvents) return;
    function onPointerDown(event) {
      panSession.current = new _chunkOT5ZKXS.PanEvent(event, handlersRef.current, threshold);
    }
    return (0, _eventUtils.addPointerEvent)(node, "pointerdown", onPointerDown);
  }, [ref, hasPanEvents, handlersRef, threshold]);
  (0, _react.useEffect)(() => {
    return () => {
      var _a;
      (_a = panSession.current) == null ? void 0 : _a.end();
      panSession.current = null;
    };
  }, []);
}
},{"./chunk-OT5ZKXS2.mjs":"ay4H","@chakra-ui/event-utils":"xbgg","@chakra-ui/react-use-latest-ref":"iUkH","react":"n8MK"}],"YbLn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "usePanEvent", {
  enumerable: true,
  get: function () {
    return _chunkVOTNCFOA.usePanEvent;
  }
});
var _chunkVOTNCFOA = require("./chunk-VOTNCFOA.mjs");
require("./chunk-OT5ZKXS2.mjs");
},{"./chunk-VOTNCFOA.mjs":"iEO7","./chunk-OT5ZKXS2.mjs":"ay4H"}],"dDc2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trackElementSize = trackElementSize;
// src/index.ts
function trackElementSize(element, callback) {
  if (!element) {
    callback(void 0);
    return;
  }
  callback({
    width: element.offsetWidth,
    height: element.offsetHeight
  });
  const win = element.ownerDocument.defaultView ?? window;
  const observer = new win.ResizeObserver(entries => {
    if (!Array.isArray(entries) || !entries.length) return;
    const [entry] = entries;
    let width;
    let height;
    if ("borderBoxSize" in entry) {
      const borderSizeEntry = entry["borderBoxSize"];
      const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
      width = borderSize["inlineSize"];
      height = borderSize["blockSize"];
    } else {
      width = element.offsetWidth;
      height = element.offsetHeight;
    }
    callback({
      width,
      height
    });
  });
  observer.observe(element, {
    box: "border-box"
  });
  return () => observer.unobserve(element);
}
},{}],"HPbm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSize = useSize;
exports.useSizes = useSizes;
var _elementSize = require("@zag-js/element-size");
var _react = require("react");
// src/index.ts

var useSafeLayoutEffect = Boolean(globalThis == null ? void 0 : globalThis.document) ? _react.useLayoutEffect : _react.useEffect;
function trackMutation(el, cb) {
  var _a, _b;
  if (!el || !el.parentElement) return;
  const win = (_b = (_a = el.ownerDocument) == null ? void 0 : _a.defaultView) != null ? _b : window;
  const observer = new win.MutationObserver(() => {
    cb();
  });
  observer.observe(el.parentElement, {
    childList: true
  });
  return () => {
    observer.disconnect();
  };
}
function useSizes({
  getNodes,
  observeMutation = true
}) {
  const [sizes, setSizes] = (0, _react.useState)([]);
  const [count, setCount] = (0, _react.useState)(0);
  useSafeLayoutEffect(() => {
    const elements = getNodes();
    const cleanups = elements.map((element, index) => (0, _elementSize.trackElementSize)(element, size => {
      setSizes(sizes2 => {
        return [...sizes2.slice(0, index), size, ...sizes2.slice(index + 1)];
      });
    }));
    if (observeMutation) {
      const firstNode = elements[0];
      cleanups.push(trackMutation(firstNode, () => {
        setCount(count2 => count2 + 1);
      }));
    }
    return () => {
      cleanups.forEach(cleanup => {
        cleanup == null ? void 0 : cleanup();
      });
    };
  }, [count]);
  return sizes;
}
function isRef(ref) {
  return typeof ref === "object" && ref !== null && "current" in ref;
}
function useSize(subject) {
  const [size] = useSizes({
    observeMutation: false,
    getNodes() {
      const node = isRef(subject) ? subject.current : subject;
      return [node];
    }
  });
  return size;
}
},{"@zag-js/element-size":"dDc2","react":"n8MK"}],"m2xh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useRangeSlider = useRangeSlider;
var _chunkXYDKRZ3V = require("./chunk-XYDKRZ3V.mjs");
var _chunkVWAPXGBD = require("./chunk-VWAPXGBD.mjs");
var _reactUsePanEvent = require("@chakra-ui/react-use-pan-event");
var _reactUseControllableState = require("@chakra-ui/react-use-controllable-state");
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
var _reactUseUpdateEffect = require("@chakra-ui/react-use-update-effect");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _numberUtils = require("@chakra-ui/number-utils");
var _react = require("react");
var _reactUseSize = require("@chakra-ui/react-use-size");
// src/use-range-slider.ts

function useRangeSlider(props) {
  const {
    min = 0,
    max = 100,
    onChange,
    value: valueProp,
    defaultValue,
    isReversed: isReversedProp,
    direction = "ltr",
    orientation = "horizontal",
    id: idProp,
    isDisabled,
    isReadOnly,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    step = 1,
    getAriaValueText: getAriaValueTextProp,
    "aria-valuetext": ariaValueText,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    name,
    focusThumbOnChange = true,
    minStepsBetweenThumbs = 0,
    ...htmlProps
  } = props;
  const onChangeStart = (0, _reactUseCallbackRef.useCallbackRef)(onChangeStartProp);
  const onChangeEnd = (0, _reactUseCallbackRef.useCallbackRef)(onChangeEndProp);
  const getAriaValueText = (0, _reactUseCallbackRef.useCallbackRef)(getAriaValueTextProp);
  const isReversed = (0, _chunkVWAPXGBD.getIsReversed)({
    isReversed: isReversedProp,
    direction,
    orientation
  });
  const [valueState, setValue] = (0, _reactUseControllableState.useControllableState)({
    value: valueProp,
    defaultValue: defaultValue != null ? defaultValue : [25, 75],
    onChange
  });
  if (!Array.isArray(valueState)) {
    throw new TypeError(`[range-slider] You passed an invalid value for \`value\` or \`defaultValue\`, expected \`Array\` but got \`${typeof valueState}\``);
  }
  const [isDragging, setDragging] = (0, _react.useState)(false);
  const [isFocused, setFocused] = (0, _react.useState)(false);
  const [activeIndex, setActiveIndex] = (0, _react.useState)(-1);
  const isInteractive = !(isDisabled || isReadOnly);
  const initialValue = (0, _react.useRef)(valueState);
  const value = valueState.map(val => (0, _numberUtils.clampValue)(val, min, max));
  const spacing = minStepsBetweenThumbs * step;
  const valueBounds = getValueBounds(value, min, max, spacing);
  const stateRef = (0, _react.useRef)({
    eventSource: null,
    value: [],
    valueBounds: []
  });
  stateRef.current.value = value;
  stateRef.current.valueBounds = valueBounds;
  const reversedValue = value.map(val => max - val + min);
  const thumbValues = isReversed ? reversedValue : value;
  const thumbPercents = thumbValues.map(val => (0, _numberUtils.valueToPercent)(val, min, max));
  const isVertical = orientation === "vertical";
  const trackRef = (0, _react.useRef)(null);
  const rootRef = (0, _react.useRef)(null);
  const thumbRects = (0, _reactUseSize.useSizes)({
    getNodes() {
      const rootNode = rootRef.current;
      const thumbNodes = rootNode == null ? void 0 : rootNode.querySelectorAll("[role=slider]");
      return thumbNodes ? Array.from(thumbNodes) : [];
    }
  });
  const reactId = (0, _react.useId)();
  const uuid = idProp != null ? idProp : reactId;
  const ids = (0, _chunkVWAPXGBD.getIds)(uuid);
  const getValueFromPointer = (0, _react.useCallback)(event => {
    var _a, _b;
    if (!trackRef.current) return;
    stateRef.current.eventSource = "pointer";
    const rect = trackRef.current.getBoundingClientRect();
    const {
      clientX,
      clientY
    } = (_b = (_a = event.touches) == null ? void 0 : _a[0]) != null ? _b : event;
    const diff = isVertical ? rect.bottom - clientY : clientX - rect.left;
    const length = isVertical ? rect.height : rect.width;
    let percent = diff / length;
    if (isReversed) percent = 1 - percent;
    return (0, _numberUtils.percentToValue)(percent, min, max);
  }, [isVertical, isReversed, max, min]);
  const tenSteps = (max - min) / 10;
  const oneStep = step || (max - min) / 100;
  const actions = (0, _react.useMemo)(() => ({
    setValueAtIndex(index, val) {
      if (!isInteractive) return;
      const bounds = stateRef.current.valueBounds[index];
      val = parseFloat((0, _numberUtils.roundValueToStep)(val, bounds.min, oneStep));
      val = (0, _numberUtils.clampValue)(val, bounds.min, bounds.max);
      const next = [...stateRef.current.value];
      next[index] = val;
      setValue(next);
    },
    setActiveIndex,
    stepUp(index, step2 = oneStep) {
      const valueAtIndex = stateRef.current.value[index];
      const next = isReversed ? valueAtIndex - step2 : valueAtIndex + step2;
      actions.setValueAtIndex(index, next);
    },
    stepDown(index, step2 = oneStep) {
      const valueAtIndex = stateRef.current.value[index];
      const next = isReversed ? valueAtIndex + step2 : valueAtIndex - step2;
      actions.setValueAtIndex(index, next);
    },
    reset() {
      setValue(initialValue.current);
    }
  }), [oneStep, isReversed, setValue, isInteractive]);
  const onKeyDown = (0, _react.useCallback)(event => {
    const eventKey = event.key;
    const keyMap = {
      ArrowRight: () => actions.stepUp(activeIndex),
      ArrowUp: () => actions.stepUp(activeIndex),
      ArrowLeft: () => actions.stepDown(activeIndex),
      ArrowDown: () => actions.stepDown(activeIndex),
      PageUp: () => actions.stepUp(activeIndex, tenSteps),
      PageDown: () => actions.stepDown(activeIndex, tenSteps),
      Home: () => {
        const {
          min: value2
        } = valueBounds[activeIndex];
        actions.setValueAtIndex(activeIndex, value2);
      },
      End: () => {
        const {
          max: value2
        } = valueBounds[activeIndex];
        actions.setValueAtIndex(activeIndex, value2);
      }
    };
    const action = keyMap[eventKey];
    if (action) {
      event.preventDefault();
      event.stopPropagation();
      action(event);
      stateRef.current.eventSource = "keyboard";
    }
  }, [actions, activeIndex, tenSteps, valueBounds]);
  const {
    getThumbStyle,
    rootStyle,
    trackStyle,
    innerTrackStyle
  } = (0, _react.useMemo)(() => (0, _chunkVWAPXGBD.getStyles)({
    isReversed,
    orientation,
    thumbRects,
    thumbPercents
  }), [isReversed, orientation, thumbPercents, thumbRects]);
  const focusThumb = (0, _react.useCallback)(index => {
    var _a;
    const idx = index != null ? index : activeIndex;
    if (idx !== -1 && focusThumbOnChange) {
      const id = ids.getThumb(idx);
      const thumb = (_a = rootRef.current) == null ? void 0 : _a.ownerDocument.getElementById(id);
      if (thumb) {
        setTimeout(() => thumb.focus());
      }
    }
  }, [focusThumbOnChange, activeIndex, ids]);
  (0, _reactUseUpdateEffect.useUpdateEffect)(() => {
    if (stateRef.current.eventSource === "keyboard") {
      onChangeEnd == null ? void 0 : onChangeEnd(stateRef.current.value);
    }
  }, [value, onChangeEnd]);
  const onPanSessionStart = event => {
    const pointValue = getValueFromPointer(event) || 0;
    const distances = stateRef.current.value.map(val => Math.abs(val - pointValue));
    const closest = Math.min(...distances);
    let index = distances.indexOf(closest);
    const thumbsAtPosition = distances.filter(distance => distance === closest);
    const isThumbStacked = thumbsAtPosition.length > 1;
    if (isThumbStacked && pointValue > stateRef.current.value[index]) {
      index = index + thumbsAtPosition.length - 1;
    }
    setActiveIndex(index);
    actions.setValueAtIndex(index, pointValue);
    focusThumb(index);
  };
  const onPan = event => {
    if (activeIndex == -1) return;
    const pointValue = getValueFromPointer(event) || 0;
    setActiveIndex(activeIndex);
    actions.setValueAtIndex(activeIndex, pointValue);
    focusThumb(activeIndex);
  };
  (0, _reactUsePanEvent.usePanEvent)(rootRef, {
    onPanSessionStart(event) {
      if (!isInteractive) return;
      setDragging(true);
      onPanSessionStart(event);
      onChangeStart == null ? void 0 : onChangeStart(stateRef.current.value);
    },
    onPanSessionEnd() {
      if (!isInteractive) return;
      setDragging(false);
      onChangeEnd == null ? void 0 : onChangeEnd(stateRef.current.value);
    },
    onPan(event) {
      if (!isInteractive) return;
      onPan(event);
    }
  });
  const getRootProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    return {
      ...props2,
      ...htmlProps,
      id: ids.root,
      ref: (0, _reactUseMergeRefs.mergeRefs)(ref, rootRef),
      tabIndex: -1,
      "aria-disabled": (0, _chunkXYDKRZ3V.ariaAttr)(isDisabled),
      "data-focused": (0, _chunkXYDKRZ3V.dataAttr)(isFocused),
      style: {
        ...props2.style,
        ...rootStyle
      }
    };
  }, [htmlProps, isDisabled, isFocused, rootStyle, ids]);
  const getTrackProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    return {
      ...props2,
      ref: (0, _reactUseMergeRefs.mergeRefs)(ref, trackRef),
      id: ids.track,
      "data-disabled": (0, _chunkXYDKRZ3V.dataAttr)(isDisabled),
      style: {
        ...props2.style,
        ...trackStyle
      }
    };
  }, [isDisabled, trackStyle, ids]);
  const getInnerTrackProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    return {
      ...props2,
      ref,
      id: ids.innerTrack,
      style: {
        ...props2.style,
        ...innerTrackStyle
      }
    };
  }, [innerTrackStyle, ids]);
  const getThumbProps = (0, _react.useCallback)((props2, ref = null) => {
    var _a;
    const {
      index,
      ...rest
    } = props2;
    const valueAtIndex = value[index];
    if (valueAtIndex == null) {
      throw new TypeError(`[range-slider > thumb] Cannot find value at index \`${index}\`. The \`value\` or \`defaultValue\` length is : ${value.length}`);
    }
    const bounds = valueBounds[index];
    return {
      ...rest,
      ref,
      role: "slider",
      tabIndex: isInteractive ? 0 : void 0,
      id: ids.getThumb(index),
      "data-active": (0, _chunkXYDKRZ3V.dataAttr)(isDragging && activeIndex === index),
      "aria-valuetext": (_a = getAriaValueText == null ? void 0 : getAriaValueText(valueAtIndex)) != null ? _a : ariaValueText == null ? void 0 : ariaValueText[index],
      "aria-valuemin": bounds.min,
      "aria-valuemax": bounds.max,
      "aria-valuenow": valueAtIndex,
      "aria-orientation": orientation,
      "aria-disabled": (0, _chunkXYDKRZ3V.ariaAttr)(isDisabled),
      "aria-readonly": (0, _chunkXYDKRZ3V.ariaAttr)(isReadOnly),
      "aria-label": ariaLabel == null ? void 0 : ariaLabel[index],
      "aria-labelledby": (ariaLabel == null ? void 0 : ariaLabel[index]) ? void 0 : ariaLabelledBy == null ? void 0 : ariaLabelledBy[index],
      style: {
        ...props2.style,
        ...getThumbStyle(index)
      },
      onKeyDown: (0, _chunkXYDKRZ3V.callAllHandlers)(props2.onKeyDown, onKeyDown),
      onFocus: (0, _chunkXYDKRZ3V.callAllHandlers)(props2.onFocus, () => {
        setFocused(true);
        setActiveIndex(index);
      }),
      onBlur: (0, _chunkXYDKRZ3V.callAllHandlers)(props2.onBlur, () => {
        setFocused(false);
        setActiveIndex(-1);
      })
    };
  }, [ids, value, valueBounds, isInteractive, isDragging, activeIndex, getAriaValueText, ariaValueText, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown, setFocused]);
  const getOutputProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    return {
      ...props2,
      ref,
      id: ids.output,
      htmlFor: value.map((v, i) => ids.getThumb(i)).join(" "),
      "aria-live": "off"
    };
  }, [ids, value]);
  const getMarkerProps = (0, _react.useCallback)((props2, ref = null) => {
    const {
      value: v,
      ...rest
    } = props2;
    const isInRange = !(v < min || v > max);
    const isHighlighted = v >= value[0] && v <= value[value.length - 1];
    let percent = (0, _numberUtils.valueToPercent)(v, min, max);
    percent = isReversed ? 100 - percent : percent;
    const markerStyle = {
      position: "absolute",
      pointerEvents: "none",
      ...(0, _chunkVWAPXGBD.orient)({
        orientation,
        vertical: {
          bottom: `${percent}%`
        },
        horizontal: {
          left: `${percent}%`
        }
      })
    };
    return {
      ...rest,
      ref,
      id: ids.getMarker(props2.value),
      role: "presentation",
      "aria-hidden": true,
      "data-disabled": (0, _chunkXYDKRZ3V.dataAttr)(isDisabled),
      "data-invalid": (0, _chunkXYDKRZ3V.dataAttr)(!isInRange),
      "data-highlighted": (0, _chunkXYDKRZ3V.dataAttr)(isHighlighted),
      style: {
        ...props2.style,
        ...markerStyle
      }
    };
  }, [isDisabled, isReversed, max, min, orientation, value, ids]);
  const getInputProps = (0, _react.useCallback)((props2, ref = null) => {
    const {
      index,
      ...rest
    } = props2;
    return {
      ...rest,
      ref,
      id: ids.getInput(index),
      type: "hidden",
      value: value[index],
      name: Array.isArray(name) ? name[index] : `${name}-${index}`
    };
  }, [name, value, ids]);
  const state = {
    value,
    isFocused,
    isDragging,
    getThumbPercent: index => thumbPercents[index],
    getThumbMinValue: index => valueBounds[index].min,
    getThumbMaxValue: index => valueBounds[index].max
  };
  return {
    state,
    actions,
    getRootProps,
    getTrackProps,
    getInnerTrackProps,
    getThumbProps,
    getMarkerProps,
    getInputProps,
    getOutputProps
  };
}
function getValueBounds(arr, min, max, spacing) {
  return arr.map((v, i) => {
    const _min = i === 0 ? min : arr[i - 1] + spacing;
    const _max = i === arr.length - 1 ? max : arr[i + 1] - spacing;
    return {
      min: _min,
      max: _max
    };
  });
}
},{"./chunk-XYDKRZ3V.mjs":"xVQi","./chunk-VWAPXGBD.mjs":"M4Ne","@chakra-ui/react-use-pan-event":"YbLn","@chakra-ui/react-use-controllable-state":"DWQz","@chakra-ui/react-use-callback-ref":"PPhG","@chakra-ui/react-use-update-effect":"GqG2","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/number-utils":"n1rw","react":"n8MK","@chakra-ui/react-use-size":"HPbm"}],"QXgi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useRangeSliderStyles = exports.useRangeSliderContext = exports.RangeSliderTrack = exports.RangeSliderThumb = exports.RangeSliderProvider = exports.RangeSliderMark = exports.RangeSliderFilledTrack = exports.RangeSlider = void 0;
var _chunkURECC76Z = require("./chunk-URECC76Z.mjs");
var _chunkXYDKRZ3V = require("./chunk-XYDKRZ3V.mjs");
var _reactContext = require("@chakra-ui/react-context");
var _system = require("@chakra-ui/system");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/range-slider.tsx

var [RangeSliderProvider, useRangeSliderContext] = (0, _reactContext.createContext)({
  name: "SliderContext",
  errorMessage: "useSliderContext: `context` is undefined. Seems you forgot to wrap all slider components within <RangeSlider />"
});
exports.useRangeSliderContext = useRangeSliderContext;
exports.RangeSliderProvider = RangeSliderProvider;
var [RangeSliderStylesProvider, useRangeSliderStyles] = (0, _reactContext.createContext)({
  name: `RangeSliderStylesContext`,
  errorMessage: `useRangeSliderStyles returned is 'undefined'. Seems you forgot to wrap the components in "<RangeSlider />" `
});
exports.useRangeSliderStyles = useRangeSliderStyles;
var RangeSlider = (0, _system.forwardRef)(function RangeSlider2(props, ref) {
  const sliderProps = {
    orientation: "horizontal",
    ...props
  };
  const styles = (0, _system.useMultiStyleConfig)("Slider", sliderProps);
  const ownProps = (0, _system.omitThemingProps)(sliderProps);
  const {
    direction
  } = (0, _system.useTheme)();
  ownProps.direction = direction;
  const {
    getRootProps,
    ...context
  } = (0, _chunkURECC76Z.useRangeSlider)(ownProps);
  const ctx = (0, _react.useMemo)(() => ({
    ...context,
    name: sliderProps.name
  }), [context, sliderProps.name]);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(RangeSliderProvider, {
    value: ctx,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(RangeSliderStylesProvider, {
      value: styles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
        ...getRootProps({}, ref),
        className: "chakra-slider",
        __css: styles.container,
        children: sliderProps.children
      })
    })
  });
});
exports.RangeSlider = RangeSlider;
RangeSlider.displayName = "RangeSlider";
var RangeSliderThumb = (0, _system.forwardRef)(function RangeSliderThumb2(props, ref) {
  const {
    getThumbProps,
    getInputProps,
    name
  } = useRangeSliderContext();
  const styles = useRangeSliderStyles();
  const thumbProps = getThumbProps(props, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.div, {
    ...thumbProps,
    className: (0, _chunkXYDKRZ3V.cx)("chakra-slider__thumb", props.className),
    __css: styles.thumb,
    children: [thumbProps.children, name && /* @__PURE__ */(0, _jsxRuntime.jsx)("input", {
      ...getInputProps({
        index: props.index
      })
    })]
  });
});
exports.RangeSliderThumb = RangeSliderThumb;
RangeSliderThumb.displayName = "RangeSliderThumb";
var RangeSliderTrack = (0, _system.forwardRef)(function RangeSliderTrack2(props, ref) {
  const {
    getTrackProps
  } = useRangeSliderContext();
  const styles = useRangeSliderStyles();
  const trackProps = getTrackProps(props, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...trackProps,
    className: (0, _chunkXYDKRZ3V.cx)("chakra-slider__track", props.className),
    __css: styles.track,
    "data-testid": "chakra-range-slider-track"
  });
});
exports.RangeSliderTrack = RangeSliderTrack;
RangeSliderTrack.displayName = "RangeSliderTrack";
var RangeSliderFilledTrack = (0, _system.forwardRef)(function RangeSliderFilledTrack2(props, ref) {
  const {
    getInnerTrackProps
  } = useRangeSliderContext();
  const styles = useRangeSliderStyles();
  const trackProps = getInnerTrackProps(props, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...trackProps,
    className: "chakra-slider__filled-track",
    __css: styles.filledTrack
  });
});
exports.RangeSliderFilledTrack = RangeSliderFilledTrack;
RangeSliderFilledTrack.displayName = "RangeSliderFilledTrack";
var RangeSliderMark = (0, _system.forwardRef)(function RangeSliderMark2(props, ref) {
  const {
    getMarkerProps
  } = useRangeSliderContext();
  const markProps = getMarkerProps(props, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...markProps,
    className: (0, _chunkXYDKRZ3V.cx)("chakra-slider__marker", props.className)
  });
});
exports.RangeSliderMark = RangeSliderMark;
RangeSliderMark.displayName = "RangeSliderMark";
},{"./chunk-URECC76Z.mjs":"m2xh","./chunk-XYDKRZ3V.mjs":"xVQi","@chakra-ui/react-context":"lT23","@chakra-ui/system":"ogbg","react":"n8MK","react/jsx-runtime":"plwR"}],"F2xu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSlider = useSlider;
var _chunkXYDKRZ3V = require("./chunk-XYDKRZ3V.mjs");
var _chunkVWAPXGBD = require("./chunk-VWAPXGBD.mjs");
var _reactUsePanEvent = require("@chakra-ui/react-use-pan-event");
var _reactUseCallbackRef = require("@chakra-ui/react-use-callback-ref");
var _reactUseUpdateEffect = require("@chakra-ui/react-use-update-effect");
var _reactUseControllableState = require("@chakra-ui/react-use-controllable-state");
var _reactUseSize = require("@chakra-ui/react-use-size");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _reactUseLatestRef = require("@chakra-ui/react-use-latest-ref");
var _numberUtils = require("@chakra-ui/number-utils");
var _react = require("react");
// src/use-slider.ts

function useSlider(props) {
  var _a;
  const {
    min = 0,
    max = 100,
    onChange,
    value: valueProp,
    defaultValue,
    isReversed: isReversedProp,
    direction = "ltr",
    orientation = "horizontal",
    id: idProp,
    isDisabled,
    isReadOnly,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    step = 1,
    getAriaValueText: getAriaValueTextProp,
    "aria-valuetext": ariaValueText,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    name,
    focusThumbOnChange = true,
    ...htmlProps
  } = props;
  const onChangeStart = (0, _reactUseCallbackRef.useCallbackRef)(onChangeStartProp);
  const onChangeEnd = (0, _reactUseCallbackRef.useCallbackRef)(onChangeEndProp);
  const getAriaValueText = (0, _reactUseCallbackRef.useCallbackRef)(getAriaValueTextProp);
  const isReversed = (0, _chunkVWAPXGBD.getIsReversed)({
    isReversed: isReversedProp,
    direction,
    orientation
  });
  const [computedValue, setValue] = (0, _reactUseControllableState.useControllableState)({
    value: valueProp,
    defaultValue: defaultValue != null ? defaultValue : getDefaultValue(min, max),
    onChange
  });
  const [isDragging, setDragging] = (0, _react.useState)(false);
  const [isFocused, setFocused] = (0, _react.useState)(false);
  const isInteractive = !(isDisabled || isReadOnly);
  const tenSteps = (max - min) / 10;
  const oneStep = step || (max - min) / 100;
  const value = (0, _numberUtils.clampValue)(computedValue, min, max);
  const reversedValue = max - value + min;
  const trackValue = isReversed ? reversedValue : value;
  const thumbPercent = (0, _numberUtils.valueToPercent)(trackValue, min, max);
  const isVertical = orientation === "vertical";
  const stateRef = (0, _reactUseLatestRef.useLatestRef)({
    min,
    max,
    step,
    isDisabled,
    value,
    isInteractive,
    isReversed,
    isVertical,
    eventSource: null,
    focusThumbOnChange,
    orientation
  });
  const trackRef = (0, _react.useRef)(null);
  const thumbRef = (0, _react.useRef)(null);
  const rootRef = (0, _react.useRef)(null);
  const reactId = (0, _react.useId)();
  const uuid = idProp != null ? idProp : reactId;
  const [thumbId, trackId] = [`slider-thumb-${uuid}`, `slider-track-${uuid}`];
  const getValueFromPointer = (0, _react.useCallback)(event => {
    var _a2, _b;
    if (!trackRef.current) return;
    const state2 = stateRef.current;
    state2.eventSource = "pointer";
    const trackRect = trackRef.current.getBoundingClientRect();
    const {
      clientX,
      clientY
    } = (_b = (_a2 = event.touches) == null ? void 0 : _a2[0]) != null ? _b : event;
    const diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;
    const length = isVertical ? trackRect.height : trackRect.width;
    let percent = diff / length;
    if (isReversed) {
      percent = 1 - percent;
    }
    let nextValue = (0, _numberUtils.percentToValue)(percent, state2.min, state2.max);
    if (state2.step) {
      nextValue = parseFloat((0, _numberUtils.roundValueToStep)(nextValue, state2.min, state2.step));
    }
    nextValue = (0, _numberUtils.clampValue)(nextValue, state2.min, state2.max);
    return nextValue;
  }, [isVertical, isReversed, stateRef]);
  const constrain = (0, _react.useCallback)(value2 => {
    const state2 = stateRef.current;
    if (!state2.isInteractive) return;
    value2 = parseFloat((0, _numberUtils.roundValueToStep)(value2, state2.min, oneStep));
    value2 = (0, _numberUtils.clampValue)(value2, state2.min, state2.max);
    setValue(value2);
  }, [oneStep, setValue, stateRef]);
  const actions = (0, _react.useMemo)(() => ({
    stepUp(step2 = oneStep) {
      const next = isReversed ? value - step2 : value + step2;
      constrain(next);
    },
    stepDown(step2 = oneStep) {
      const next = isReversed ? value + step2 : value - step2;
      constrain(next);
    },
    reset() {
      constrain(defaultValue || 0);
    },
    stepTo(value2) {
      constrain(value2);
    }
  }), [constrain, isReversed, value, oneStep, defaultValue]);
  const onKeyDown = (0, _react.useCallback)(event => {
    const state2 = stateRef.current;
    const keyMap = {
      ArrowRight: () => actions.stepUp(),
      ArrowUp: () => actions.stepUp(),
      ArrowLeft: () => actions.stepDown(),
      ArrowDown: () => actions.stepDown(),
      PageUp: () => actions.stepUp(tenSteps),
      PageDown: () => actions.stepDown(tenSteps),
      Home: () => constrain(state2.min),
      End: () => constrain(state2.max)
    };
    const action = keyMap[event.key];
    if (action) {
      event.preventDefault();
      event.stopPropagation();
      action(event);
      state2.eventSource = "keyboard";
    }
  }, [actions, constrain, tenSteps, stateRef]);
  const valueText = (_a = getAriaValueText == null ? void 0 : getAriaValueText(value)) != null ? _a : ariaValueText;
  const thumbSize = (0, _reactUseSize.useSize)(thumbRef);
  const {
    getThumbStyle,
    rootStyle,
    trackStyle,
    innerTrackStyle
  } = (0, _react.useMemo)(() => {
    const state2 = stateRef.current;
    const thumbRect = thumbSize != null ? thumbSize : {
      width: 0,
      height: 0
    };
    return (0, _chunkVWAPXGBD.getStyles)({
      isReversed,
      orientation: state2.orientation,
      thumbRects: [thumbRect],
      thumbPercents: [thumbPercent]
    });
  }, [isReversed, thumbSize, thumbPercent, stateRef]);
  const focusThumb = (0, _react.useCallback)(() => {
    const state2 = stateRef.current;
    if (state2.focusThumbOnChange) {
      setTimeout(() => {
        var _a2;
        return (_a2 = thumbRef.current) == null ? void 0 : _a2.focus();
      });
    }
  }, [stateRef]);
  (0, _reactUseUpdateEffect.useUpdateEffect)(() => {
    const state2 = stateRef.current;
    focusThumb();
    if (state2.eventSource === "keyboard") {
      onChangeEnd == null ? void 0 : onChangeEnd(state2.value);
    }
  }, [value, onChangeEnd]);
  function setValueFromPointer(event) {
    const nextValue = getValueFromPointer(event);
    if (nextValue != null && nextValue !== stateRef.current.value) {
      setValue(nextValue);
    }
  }
  (0, _reactUsePanEvent.usePanEvent)(rootRef, {
    onPanSessionStart(event) {
      const state2 = stateRef.current;
      if (!state2.isInteractive) return;
      setDragging(true);
      focusThumb();
      setValueFromPointer(event);
      onChangeStart == null ? void 0 : onChangeStart(state2.value);
    },
    onPanSessionEnd() {
      const state2 = stateRef.current;
      if (!state2.isInteractive) return;
      setDragging(false);
      onChangeEnd == null ? void 0 : onChangeEnd(state2.value);
    },
    onPan(event) {
      const state2 = stateRef.current;
      if (!state2.isInteractive) return;
      setValueFromPointer(event);
    }
  });
  const getRootProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    return {
      ...props2,
      ...htmlProps,
      ref: (0, _reactUseMergeRefs.mergeRefs)(ref, rootRef),
      tabIndex: -1,
      "aria-disabled": (0, _chunkXYDKRZ3V.ariaAttr)(isDisabled),
      "data-focused": (0, _chunkXYDKRZ3V.dataAttr)(isFocused),
      style: {
        ...props2.style,
        ...rootStyle
      }
    };
  }, [htmlProps, isDisabled, isFocused, rootStyle]);
  const getTrackProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    return {
      ...props2,
      ref: (0, _reactUseMergeRefs.mergeRefs)(ref, trackRef),
      id: trackId,
      "data-disabled": (0, _chunkXYDKRZ3V.dataAttr)(isDisabled),
      style: {
        ...props2.style,
        ...trackStyle
      }
    };
  }, [isDisabled, trackId, trackStyle]);
  const getInnerTrackProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    return {
      ...props2,
      ref,
      style: {
        ...props2.style,
        ...innerTrackStyle
      }
    };
  }, [innerTrackStyle]);
  const getThumbProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    return {
      ...props2,
      ref: (0, _reactUseMergeRefs.mergeRefs)(ref, thumbRef),
      role: "slider",
      tabIndex: isInteractive ? 0 : void 0,
      id: thumbId,
      "data-active": (0, _chunkXYDKRZ3V.dataAttr)(isDragging),
      "aria-valuetext": valueText,
      "aria-valuemin": min,
      "aria-valuemax": max,
      "aria-valuenow": value,
      "aria-orientation": orientation,
      "aria-disabled": (0, _chunkXYDKRZ3V.ariaAttr)(isDisabled),
      "aria-readonly": (0, _chunkXYDKRZ3V.ariaAttr)(isReadOnly),
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabel ? void 0 : ariaLabelledBy,
      style: {
        ...props2.style,
        ...getThumbStyle(0)
      },
      onKeyDown: (0, _chunkXYDKRZ3V.callAllHandlers)(props2.onKeyDown, onKeyDown),
      onFocus: (0, _chunkXYDKRZ3V.callAllHandlers)(props2.onFocus, () => setFocused(true)),
      onBlur: (0, _chunkXYDKRZ3V.callAllHandlers)(props2.onBlur, () => setFocused(false))
    };
  }, [isInteractive, thumbId, isDragging, valueText, min, max, value, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown]);
  const getMarkerProps = (0, _react.useCallback)((props2, ref = null) => {
    const isInRange = !(props2.value < min || props2.value > max);
    const isHighlighted = value >= props2.value;
    const markerPercent = (0, _numberUtils.valueToPercent)(props2.value, min, max);
    const markerStyle = {
      position: "absolute",
      pointerEvents: "none",
      ...orient({
        orientation,
        vertical: {
          bottom: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`
        },
        horizontal: {
          left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`
        }
      })
    };
    return {
      ...props2,
      ref,
      role: "presentation",
      "aria-hidden": true,
      "data-disabled": (0, _chunkXYDKRZ3V.dataAttr)(isDisabled),
      "data-invalid": (0, _chunkXYDKRZ3V.dataAttr)(!isInRange),
      "data-highlighted": (0, _chunkXYDKRZ3V.dataAttr)(isHighlighted),
      style: {
        ...props2.style,
        ...markerStyle
      }
    };
  }, [isDisabled, isReversed, max, min, orientation, value]);
  const getInputProps = (0, _react.useCallback)((props2 = {}, ref = null) => {
    return {
      ...props2,
      ref,
      type: "hidden",
      value,
      name
    };
  }, [name, value]);
  const state = {
    value,
    isFocused,
    isDragging
  };
  return {
    state,
    actions,
    getRootProps,
    getTrackProps,
    getInnerTrackProps,
    getThumbProps,
    getMarkerProps,
    getInputProps
  };
}
function orient(options) {
  const {
    orientation,
    vertical,
    horizontal
  } = options;
  return orientation === "vertical" ? vertical : horizontal;
}
function getDefaultValue(min, max) {
  return max < min ? min : min + (max - min) / 2;
}
},{"./chunk-XYDKRZ3V.mjs":"xVQi","./chunk-VWAPXGBD.mjs":"M4Ne","@chakra-ui/react-use-pan-event":"YbLn","@chakra-ui/react-use-callback-ref":"PPhG","@chakra-ui/react-use-update-effect":"GqG2","@chakra-ui/react-use-controllable-state":"DWQz","@chakra-ui/react-use-size":"HPbm","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/react-use-latest-ref":"iUkH","@chakra-ui/number-utils":"n1rw","react":"n8MK"}],"ADo6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSliderStyles = exports.useSliderContext = exports.SliderTrack = exports.SliderThumb = exports.SliderProvider = exports.SliderMark = exports.SliderFilledTrack = exports.Slider = void 0;
var _chunkRO527DKG = require("./chunk-RO527DKG.mjs");
var _chunkXYDKRZ3V = require("./chunk-XYDKRZ3V.mjs");
var _reactContext = require("@chakra-ui/react-context");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/slider.tsx

var [SliderProvider, useSliderContext] = (0, _reactContext.createContext)({
  name: "SliderContext",
  hookName: "useSliderContext",
  providerName: "<Slider />"
});
exports.useSliderContext = useSliderContext;
exports.SliderProvider = SliderProvider;
var [SliderStylesProvider, useSliderStyles] = (0, _reactContext.createContext)({
  name: `SliderStylesContext`,
  hookName: `useSliderStyles`,
  providerName: "<Slider />"
});
exports.useSliderStyles = useSliderStyles;
var Slider = (0, _system.forwardRef)((props, ref) => {
  const sliderProps = {
    orientation: "horizontal",
    ...props
  };
  const styles = (0, _system.useMultiStyleConfig)("Slider", sliderProps);
  const ownProps = (0, _system.omitThemingProps)(sliderProps);
  const {
    direction
  } = (0, _system.useTheme)();
  ownProps.direction = direction;
  const {
    getInputProps,
    getRootProps,
    ...context
  } = (0, _chunkRO527DKG.useSlider)(ownProps);
  const rootProps = getRootProps();
  const inputProps = getInputProps({}, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(SliderProvider, {
    value: context,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(SliderStylesProvider, {
      value: styles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.div, {
        ...rootProps,
        className: (0, _chunkXYDKRZ3V.cx)("chakra-slider", sliderProps.className),
        __css: styles.container,
        children: [sliderProps.children, /* @__PURE__ */(0, _jsxRuntime.jsx)("input", {
          ...inputProps
        })]
      })
    })
  });
});
exports.Slider = Slider;
Slider.displayName = "Slider";
var SliderThumb = (0, _system.forwardRef)((props, ref) => {
  const {
    getThumbProps
  } = useSliderContext();
  const styles = useSliderStyles();
  const thumbProps = getThumbProps(props, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...thumbProps,
    className: (0, _chunkXYDKRZ3V.cx)("chakra-slider__thumb", props.className),
    __css: styles.thumb
  });
});
exports.SliderThumb = SliderThumb;
SliderThumb.displayName = "SliderThumb";
var SliderTrack = (0, _system.forwardRef)((props, ref) => {
  const {
    getTrackProps
  } = useSliderContext();
  const styles = useSliderStyles();
  const trackProps = getTrackProps(props, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...trackProps,
    className: (0, _chunkXYDKRZ3V.cx)("chakra-slider__track", props.className),
    __css: styles.track
  });
});
exports.SliderTrack = SliderTrack;
SliderTrack.displayName = "SliderTrack";
var SliderFilledTrack = (0, _system.forwardRef)((props, ref) => {
  const {
    getInnerTrackProps
  } = useSliderContext();
  const styles = useSliderStyles();
  const trackProps = getInnerTrackProps(props, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...trackProps,
    className: (0, _chunkXYDKRZ3V.cx)("chakra-slider__filled-track", props.className),
    __css: styles.filledTrack
  });
});
exports.SliderFilledTrack = SliderFilledTrack;
SliderFilledTrack.displayName = "SliderFilledTrack";
var SliderMark = (0, _system.forwardRef)((props, ref) => {
  const {
    getMarkerProps
  } = useSliderContext();
  const styles = useSliderStyles();
  const markProps = getMarkerProps(props, ref);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...markProps,
    className: (0, _chunkXYDKRZ3V.cx)("chakra-slider__marker", props.className),
    __css: styles.mark
  });
});
exports.SliderMark = SliderMark;
SliderMark.displayName = "SliderMark";
},{"./chunk-RO527DKG.mjs":"F2xu","./chunk-XYDKRZ3V.mjs":"xVQi","@chakra-ui/react-context":"lT23","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"kM9G":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "RangeSlider", {
  enumerable: true,
  get: function () {
    return _chunkMGDSBG3R.RangeSlider;
  }
});
Object.defineProperty(exports, "RangeSliderFilledTrack", {
  enumerable: true,
  get: function () {
    return _chunkMGDSBG3R.RangeSliderFilledTrack;
  }
});
Object.defineProperty(exports, "RangeSliderMark", {
  enumerable: true,
  get: function () {
    return _chunkMGDSBG3R.RangeSliderMark;
  }
});
Object.defineProperty(exports, "RangeSliderProvider", {
  enumerable: true,
  get: function () {
    return _chunkMGDSBG3R.RangeSliderProvider;
  }
});
Object.defineProperty(exports, "RangeSliderThumb", {
  enumerable: true,
  get: function () {
    return _chunkMGDSBG3R.RangeSliderThumb;
  }
});
Object.defineProperty(exports, "RangeSliderTrack", {
  enumerable: true,
  get: function () {
    return _chunkMGDSBG3R.RangeSliderTrack;
  }
});
Object.defineProperty(exports, "Slider", {
  enumerable: true,
  get: function () {
    return _chunkN22PRFAW.Slider;
  }
});
Object.defineProperty(exports, "SliderFilledTrack", {
  enumerable: true,
  get: function () {
    return _chunkN22PRFAW.SliderFilledTrack;
  }
});
Object.defineProperty(exports, "SliderMark", {
  enumerable: true,
  get: function () {
    return _chunkN22PRFAW.SliderMark;
  }
});
Object.defineProperty(exports, "SliderProvider", {
  enumerable: true,
  get: function () {
    return _chunkN22PRFAW.SliderProvider;
  }
});
Object.defineProperty(exports, "SliderThumb", {
  enumerable: true,
  get: function () {
    return _chunkN22PRFAW.SliderThumb;
  }
});
Object.defineProperty(exports, "SliderTrack", {
  enumerable: true,
  get: function () {
    return _chunkN22PRFAW.SliderTrack;
  }
});
Object.defineProperty(exports, "useRangeSlider", {
  enumerable: true,
  get: function () {
    return _chunkURECC76Z.useRangeSlider;
  }
});
Object.defineProperty(exports, "useRangeSliderContext", {
  enumerable: true,
  get: function () {
    return _chunkMGDSBG3R.useRangeSliderContext;
  }
});
Object.defineProperty(exports, "useRangeSliderStyles", {
  enumerable: true,
  get: function () {
    return _chunkMGDSBG3R.useRangeSliderStyles;
  }
});
Object.defineProperty(exports, "useSlider", {
  enumerable: true,
  get: function () {
    return _chunkRO527DKG.useSlider;
  }
});
Object.defineProperty(exports, "useSliderContext", {
  enumerable: true,
  get: function () {
    return _chunkN22PRFAW.useSliderContext;
  }
});
Object.defineProperty(exports, "useSliderStyles", {
  enumerable: true,
  get: function () {
    return _chunkN22PRFAW.useSliderStyles;
  }
});
var _chunkMGDSBG3R = require("./chunk-MGDSBG3R.mjs");
var _chunkN22PRFAW = require("./chunk-N22PRFAW.mjs");
var _chunkURECC76Z = require("./chunk-URECC76Z.mjs");
var _chunkRO527DKG = require("./chunk-RO527DKG.mjs");
require("./chunk-XYDKRZ3V.mjs");
require("./chunk-VWAPXGBD.mjs");
},{"./chunk-MGDSBG3R.mjs":"QXgi","./chunk-N22PRFAW.mjs":"ADo6","./chunk-URECC76Z.mjs":"m2xh","./chunk-RO527DKG.mjs":"F2xu","./chunk-XYDKRZ3V.mjs":"xVQi","./chunk-VWAPXGBD.mjs":"M4Ne"}],"RPwk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useStatStyles = exports.Stat = void 0;
var _reactContext = require("@chakra-ui/react-context");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/stat.tsx

var [StatStylesProvider, useStatStyles] = (0, _reactContext.createContext)({
  name: `StatStylesContext`,
  errorMessage: `useStatStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Stat />" `
});
exports.useStatStyles = useStatStyles;
var Stat = (0, _system.forwardRef)(function Stat2(props, ref) {
  const styles = (0, _system.useMultiStyleConfig)("Stat", props);
  const statStyles = {
    position: "relative",
    flex: "1 1 0%",
    ...styles.container
  };
  const {
    className,
    children,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(StatStylesProvider, {
    value: styles,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
      ref,
      ...rest,
      className: (0, _sharedUtils.cx)("chakra-stat", className),
      __css: statStyles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)("dl", {
        children
      })
    })
  });
});
exports.Stat = Stat;
Stat.displayName = "Stat";
},{"@chakra-ui/react-context":"lT23","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"WPLK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatArrow = StatArrow;
exports.StatDownArrow = void 0;
exports.StatUpArrow = StatUpArrow;
var _chunkRQ72AXHY = require("./chunk-RQ72AXHY.mjs");
var _icon = require("@chakra-ui/icon");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/stat-arrow.tsx

var StatDownArrow = props => /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
  color: "red.400",
  ...props,
  children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
    fill: "currentColor",
    d: "M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z"
  })
});
exports.StatDownArrow = StatDownArrow;
StatDownArrow.displayName = "StatDownArrow";
function StatUpArrow(props) {
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
    color: "green.400",
    ...props,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
      fill: "currentColor",
      d: "M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z"
    })
  });
}
StatUpArrow.displayName = "StatUpArrow";
function StatArrow(props) {
  const {
    type,
    "aria-label": ariaLabel,
    ...rest
  } = props;
  const styles = (0, _chunkRQ72AXHY.useStatStyles)();
  const BaseIcon = type === "increase" ? StatUpArrow : StatDownArrow;
  const defaultAriaLabel = type === "increase" ? "increased by" : "decreased by";
  const label = ariaLabel || defaultAriaLabel;
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [/* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      srOnly: true,
      children: label
    }), /* @__PURE__ */(0, _jsxRuntime.jsx)(BaseIcon, {
      "aria-hidden": true,
      ...rest,
      __css: styles.icon
    })]
  });
}
StatArrow.displayName = "StatArrow";
},{"./chunk-RQ72AXHY.mjs":"RPwk","@chakra-ui/icon":"aPuf","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"qEH3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatGroup = void 0;
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/stat-group.tsx

var StatGroup = (0, _system.forwardRef)(function StatGroup2(props, ref) {
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...props,
    ref,
    role: "group",
    className: (0, _sharedUtils.cx)("chakra-stat__group", props.className),
    __css: {
      display: "flex",
      flexWrap: "wrap",
      justifyContent: "space-around",
      alignItems: "flex-start"
    }
  });
});
exports.StatGroup = StatGroup;
StatGroup.displayName = "StatGroup";
},{"@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"jEOZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatHelpText = void 0;
var _chunkRQ72AXHY = require("./chunk-RQ72AXHY.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/stat-help-text.tsx

var StatHelpText = (0, _system.forwardRef)(function StatHelpText2(props, ref) {
  const styles = (0, _chunkRQ72AXHY.useStatStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.dd, {
    ref,
    ...props,
    className: (0, _sharedUtils.cx)("chakra-stat__help-text", props.className),
    __css: styles.helpText
  });
});
exports.StatHelpText = StatHelpText;
StatHelpText.displayName = "StatHelpText";
},{"./chunk-RQ72AXHY.mjs":"RPwk","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"vYB8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatLabel = void 0;
var _chunkRQ72AXHY = require("./chunk-RQ72AXHY.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/stat-label.tsx

var StatLabel = (0, _system.forwardRef)(function StatLabel2(props, ref) {
  const styles = (0, _chunkRQ72AXHY.useStatStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.dt, {
    ref,
    ...props,
    className: (0, _sharedUtils.cx)("chakra-stat__label", props.className),
    __css: styles.label
  });
});
exports.StatLabel = StatLabel;
StatLabel.displayName = "StatLabel";
},{"./chunk-RQ72AXHY.mjs":"RPwk","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"azo3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatNumber = void 0;
var _chunkRQ72AXHY = require("./chunk-RQ72AXHY.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/stat-number.tsx

var StatNumber = (0, _system.forwardRef)(function StatNumber2(props, ref) {
  const styles = (0, _chunkRQ72AXHY.useStatStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.dd, {
    ref,
    ...props,
    className: (0, _sharedUtils.cx)("chakra-stat__number", props.className),
    __css: {
      ...styles.number,
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums"
    }
  });
});
exports.StatNumber = StatNumber;
StatNumber.displayName = "StatNumber";
},{"./chunk-RQ72AXHY.mjs":"RPwk","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"upbh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function () {
    return _chunkRQ72AXHY.Stat;
  }
});
Object.defineProperty(exports, "StatArrow", {
  enumerable: true,
  get: function () {
    return _chunkP7HN4X7G.StatArrow;
  }
});
Object.defineProperty(exports, "StatDownArrow", {
  enumerable: true,
  get: function () {
    return _chunkP7HN4X7G.StatDownArrow;
  }
});
Object.defineProperty(exports, "StatGroup", {
  enumerable: true,
  get: function () {
    return _chunkCU33DNCY.StatGroup;
  }
});
Object.defineProperty(exports, "StatHelpText", {
  enumerable: true,
  get: function () {
    return _chunk2THWWZP.StatHelpText;
  }
});
Object.defineProperty(exports, "StatLabel", {
  enumerable: true,
  get: function () {
    return _chunkS22BHKCQ.StatLabel;
  }
});
Object.defineProperty(exports, "StatNumber", {
  enumerable: true,
  get: function () {
    return _chunk7LNWOFRF.StatNumber;
  }
});
Object.defineProperty(exports, "StatUpArrow", {
  enumerable: true,
  get: function () {
    return _chunkP7HN4X7G.StatUpArrow;
  }
});
Object.defineProperty(exports, "useStatStyles", {
  enumerable: true,
  get: function () {
    return _chunkRQ72AXHY.useStatStyles;
  }
});
var _chunkP7HN4X7G = require("./chunk-P7HN4X7G.mjs");
var _chunkCU33DNCY = require("./chunk-CU33DNCY.mjs");
var _chunk2THWWZP = require("./chunk-2THWWZP3.mjs");
var _chunkS22BHKCQ = require("./chunk-S22BHKCQ.mjs");
var _chunk7LNWOFRF = require("./chunk-7LNWOFRF.mjs");
var _chunkRQ72AXHY = require("./chunk-RQ72AXHY.mjs");
},{"./chunk-P7HN4X7G.mjs":"WPLK","./chunk-CU33DNCY.mjs":"qEH3","./chunk-2THWWZP3.mjs":"jEOZ","./chunk-S22BHKCQ.mjs":"vYB8","./chunk-7LNWOFRF.mjs":"azo3","./chunk-RQ72AXHY.mjs":"RPwk"}],"xXFU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Switch = void 0;
var _checkbox = require("@chakra-ui/checkbox");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/switch.tsx

var Switch = (0, _system.forwardRef)(function Switch2(props, ref) {
  const styles = (0, _system.useMultiStyleConfig)("Switch", props);
  const {
    spacing = "0.5rem",
    children,
    ...ownProps
  } = (0, _system.omitThemingProps)(props);
  const {
    state,
    getInputProps,
    getCheckboxProps,
    getRootProps,
    getLabelProps
  } = (0, _checkbox.useCheckbox)(ownProps);
  const containerStyles = (0, _react.useMemo)(() => ({
    display: "inline-block",
    position: "relative",
    verticalAlign: "middle",
    lineHeight: 0,
    ...styles.container
  }), [styles.container]);
  const trackStyles = (0, _react.useMemo)(() => ({
    display: "inline-flex",
    flexShrink: 0,
    justifyContent: "flex-start",
    boxSizing: "content-box",
    cursor: "pointer",
    ...styles.track
  }), [styles.track]);
  const labelStyles = (0, _react.useMemo)(() => ({
    userSelect: "none",
    marginStart: spacing,
    ...styles.label
  }), [spacing, styles.label]);
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_system.chakra.label, {
    ...getRootProps(),
    className: (0, _sharedUtils.cx)("chakra-switch", props.className),
    __css: containerStyles,
    children: [/* @__PURE__ */(0, _jsxRuntime.jsx)("input", {
      className: "chakra-switch__input",
      ...getInputProps({}, ref)
    }), /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      ...getCheckboxProps(),
      className: "chakra-switch__track",
      __css: trackStyles,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
        __css: styles.thumb,
        className: "chakra-switch__thumb",
        "data-checked": (0, _sharedUtils.dataAttr)(state.isChecked),
        "data-hover": (0, _sharedUtils.dataAttr)(state.isHovered)
      })
    }), children && /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      className: "chakra-switch__label",
      ...getLabelProps(),
      __css: labelStyles,
      children
    })]
  });
});
exports.Switch = Switch;
Switch.displayName = "Switch";
},{"@chakra-ui/checkbox":"QvbT","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"IYpb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Switch", {
  enumerable: true,
  get: function () {
    return _chunkB22GDMVL.Switch;
  }
});
var _chunkB22GDMVL = require("./chunk-B22GDMVL.mjs");
},{"./chunk-B22GDMVL.mjs":"xXFU"}],"Lq29":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTableStyles = exports.Table = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _reactContext = require("@chakra-ui/react-context");
var _jsxRuntime = require("react/jsx-runtime");
// src/table.tsx

var [TableStylesProvider, useTableStyles] = (0, _reactContext.createContext)({
  name: `TableStylesContext`,
  errorMessage: `useTableStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Table />" `
});
exports.useTableStyles = useTableStyles;
var Table = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _system.useMultiStyleConfig)("Table", props);
  const {
    className,
    layout,
    ...tableProps
  } = (0, _system.omitThemingProps)(props);
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(TableStylesProvider, {
    value: styles,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.table, {
      ref,
      __css: {
        tableLayout: layout,
        ...styles.table
      },
      className: (0, _sharedUtils.cx)("chakra-table", className),
      ...tableProps
    })
  });
});
exports.Table = Table;
Table.displayName = "Table";
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","@chakra-ui/react-context":"lT23","react/jsx-runtime":"plwR"}],"D7c0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Thead = void 0;
var _chunkB3MS3L3D = require("./chunk-B3MS3L3D.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/thead.tsx

var Thead = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _chunkB3MS3L3D.useTableStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.thead, {
    ...props,
    ref,
    __css: styles.thead
  });
});
exports.Thead = Thead;
},{"./chunk-B3MS3L3D.mjs":"Lq29","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"HfiE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tr = void 0;
var _chunkB3MS3L3D = require("./chunk-B3MS3L3D.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/tr.tsx

var Tr = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _chunkB3MS3L3D.useTableStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.tr, {
    ...props,
    ref,
    __css: styles.tr
  });
});
exports.Tr = Tr;
},{"./chunk-B3MS3L3D.mjs":"Lq29","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"FE7P":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TableCaption = void 0;
var _chunkB3MS3L3D = require("./chunk-B3MS3L3D.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/table-caption.tsx

var TableCaption = (0, _system.forwardRef)((props, ref) => {
  const {
    placement = "bottom",
    ...rest
  } = props;
  const styles = (0, _chunkB3MS3L3D.useTableStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.caption, {
    ...rest,
    ref,
    __css: {
      ...styles.caption,
      captionSide: placement
    }
  });
});
exports.TableCaption = TableCaption;
TableCaption.displayName = "TableCaption";
},{"./chunk-B3MS3L3D.mjs":"Lq29","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"e4Zx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TableContainer = void 0;
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/table-container.tsx

var TableContainer = (0, _system.forwardRef)((props, ref) => {
  var _a;
  const {
    overflow,
    overflowX,
    className,
    ...rest
  } = props;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    className: (0, _sharedUtils.cx)("chakra-table__container", className),
    ...rest,
    __css: {
      display: "block",
      whiteSpace: "nowrap",
      WebkitOverflowScrolling: "touch",
      overflowX: (_a = overflow != null ? overflow : overflowX) != null ? _a : "auto",
      overflowY: "hidden",
      maxWidth: "100%"
    }
  });
});
exports.TableContainer = TableContainer;
},{"@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"qB41":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tbody = void 0;
var _chunkB3MS3L3D = require("./chunk-B3MS3L3D.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/tbody.tsx

var Tbody = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _chunkB3MS3L3D.useTableStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.tbody, {
    ...props,
    ref,
    __css: styles.tbody
  });
});
exports.Tbody = Tbody;
},{"./chunk-B3MS3L3D.mjs":"Lq29","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"aXg3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Td = void 0;
var _chunkB3MS3L3D = require("./chunk-B3MS3L3D.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/td.tsx

var Td = (0, _system.forwardRef)(({
  isNumeric,
  ...rest
}, ref) => {
  const styles = (0, _chunkB3MS3L3D.useTableStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.td, {
    ...rest,
    ref,
    __css: styles.td,
    "data-is-numeric": isNumeric
  });
});
exports.Td = Td;
},{"./chunk-B3MS3L3D.mjs":"Lq29","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"OHs1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tfoot = void 0;
var _chunkB3MS3L3D = require("./chunk-B3MS3L3D.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/tfooter.tsx

var Tfoot = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _chunkB3MS3L3D.useTableStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.tfoot, {
    ...props,
    ref,
    __css: styles.tfoot
  });
});
exports.Tfoot = Tfoot;
},{"./chunk-B3MS3L3D.mjs":"Lq29","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"ZXJp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Th = void 0;
var _chunkB3MS3L3D = require("./chunk-B3MS3L3D.mjs");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/th.tsx

var Th = (0, _system.forwardRef)(({
  isNumeric,
  ...rest
}, ref) => {
  const styles = (0, _chunkB3MS3L3D.useTableStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.th, {
    ...rest,
    ref,
    __css: styles.th,
    "data-is-numeric": isNumeric
  });
});
exports.Th = Th;
},{"./chunk-B3MS3L3D.mjs":"Lq29","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"FQF7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Table", {
  enumerable: true,
  get: function () {
    return _chunkB3MS3L3D.Table;
  }
});
Object.defineProperty(exports, "TableCaption", {
  enumerable: true,
  get: function () {
    return _chunkV3BNVYZO.TableCaption;
  }
});
Object.defineProperty(exports, "TableContainer", {
  enumerable: true,
  get: function () {
    return _chunk7FCBKWFD.TableContainer;
  }
});
Object.defineProperty(exports, "Tbody", {
  enumerable: true,
  get: function () {
    return _chunkD3HTYHQX.Tbody;
  }
});
Object.defineProperty(exports, "Td", {
  enumerable: true,
  get: function () {
    return _chunkBLRPLYZO.Td;
  }
});
Object.defineProperty(exports, "Tfoot", {
  enumerable: true,
  get: function () {
    return _chunkPEV6T2J.Tfoot;
  }
});
Object.defineProperty(exports, "Th", {
  enumerable: true,
  get: function () {
    return _chunkZ3IFIKNA.Th;
  }
});
Object.defineProperty(exports, "Thead", {
  enumerable: true,
  get: function () {
    return _chunkDJP6PLAX.Thead;
  }
});
Object.defineProperty(exports, "Tr", {
  enumerable: true,
  get: function () {
    return _chunkL7UVV2ML.Tr;
  }
});
Object.defineProperty(exports, "useTableStyles", {
  enumerable: true,
  get: function () {
    return _chunkB3MS3L3D.useTableStyles;
  }
});
var _chunkDJP6PLAX = require("./chunk-DJP6PLAX.mjs");
var _chunkL7UVV2ML = require("./chunk-L7UVV2ML.mjs");
var _chunkV3BNVYZO = require("./chunk-V3BNVYZO.mjs");
var _chunk7FCBKWFD = require("./chunk-7FCBKWFD.mjs");
var _chunkD3HTYHQX = require("./chunk-D3HTYHQX.mjs");
var _chunkBLRPLYZO = require("./chunk-BLRPLYZO.mjs");
var _chunkPEV6T2J = require("./chunk-PEV6T2J3.mjs");
var _chunkZ3IFIKNA = require("./chunk-Z3IFIKNA.mjs");
var _chunkB3MS3L3D = require("./chunk-B3MS3L3D.mjs");
},{"./chunk-DJP6PLAX.mjs":"D7c0","./chunk-L7UVV2ML.mjs":"HfiE","./chunk-V3BNVYZO.mjs":"FE7P","./chunk-7FCBKWFD.mjs":"e4Zx","./chunk-D3HTYHQX.mjs":"qB41","./chunk-BLRPLYZO.mjs":"aXg3","./chunk-PEV6T2J3.mjs":"OHs1","./chunk-Z3IFIKNA.mjs":"ZXJp","./chunk-B3MS3L3D.mjs":"Lq29"}],"C5yS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TabsProvider = exports.TabsDescendantsProvider = void 0;
exports.useTab = useTab;
exports.useTabIndicator = useTabIndicator;
exports.useTabList = useTabList;
exports.useTabPanel = useTabPanel;
exports.useTabPanels = useTabPanels;
exports.useTabs = useTabs;
exports.useTabsDescendantsContext = exports.useTabsDescendants = exports.useTabsDescendant = exports.useTabsContext = void 0;
var _clickable = require("@chakra-ui/clickable");
var _descendant = require("@chakra-ui/descendant");
var _reactContext = require("@chakra-ui/react-context");
var _reactUseSafeLayoutEffect = require("@chakra-ui/react-use-safe-layout-effect");
var _reactUseControllableState = require("@chakra-ui/react-use-controllable-state");
var _reactChildrenUtils = require("@chakra-ui/react-children-utils");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _lazyUtils = require("@chakra-ui/lazy-utils");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
// src/use-tabs.ts

var [TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant] = (0, _descendant.createDescendantContext)();
exports.useTabsDescendant = useTabsDescendant;
exports.useTabsDescendants = useTabsDescendants;
exports.useTabsDescendantsContext = useTabsDescendantsContext;
exports.TabsDescendantsProvider = TabsDescendantsProvider;
function useTabs(props) {
  var _a;
  const {
    defaultIndex,
    onChange,
    index,
    isManual,
    isLazy,
    lazyBehavior = "unmount",
    orientation = "horizontal",
    direction = "ltr",
    ...htmlProps
  } = props;
  const [focusedIndex, setFocusedIndex] = (0, _react.useState)(defaultIndex != null ? defaultIndex : 0);
  const [selectedIndex, setSelectedIndex] = (0, _reactUseControllableState.useControllableState)({
    defaultValue: defaultIndex != null ? defaultIndex : 0,
    value: index,
    onChange
  });
  (0, _react.useEffect)(() => {
    if (index != null) {
      setFocusedIndex(index);
    }
  }, [index]);
  const descendants = useTabsDescendants();
  const uuid = (0, _react.useId)();
  const uid = (_a = props.id) != null ? _a : uuid;
  const id = `tabs-${uid}`;
  return {
    id,
    selectedIndex,
    focusedIndex,
    setSelectedIndex,
    setFocusedIndex,
    isManual,
    isLazy,
    lazyBehavior,
    orientation,
    descendants,
    direction,
    htmlProps
  };
}
var [TabsProvider, useTabsContext] = (0, _reactContext.createContext)({
  name: "TabsContext",
  errorMessage: "useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />"
});
exports.useTabsContext = useTabsContext;
exports.TabsProvider = TabsProvider;
function useTabList(props) {
  const {
    focusedIndex,
    orientation,
    direction
  } = useTabsContext();
  const descendants = useTabsDescendantsContext();
  const onKeyDown = (0, _react.useCallback)(event => {
    const nextTab = () => {
      var _a;
      const next = descendants.nextEnabled(focusedIndex);
      if (next) (_a = next.node) == null ? void 0 : _a.focus();
    };
    const prevTab = () => {
      var _a;
      const prev = descendants.prevEnabled(focusedIndex);
      if (prev) (_a = prev.node) == null ? void 0 : _a.focus();
    };
    const firstTab = () => {
      var _a;
      const first = descendants.firstEnabled();
      if (first) (_a = first.node) == null ? void 0 : _a.focus();
    };
    const lastTab = () => {
      var _a;
      const last = descendants.lastEnabled();
      if (last) (_a = last.node) == null ? void 0 : _a.focus();
    };
    const isHorizontal = orientation === "horizontal";
    const isVertical = orientation === "vertical";
    const eventKey = event.key;
    const ArrowStart = direction === "ltr" ? "ArrowLeft" : "ArrowRight";
    const ArrowEnd = direction === "ltr" ? "ArrowRight" : "ArrowLeft";
    const keyMap = {
      [ArrowStart]: () => isHorizontal && prevTab(),
      [ArrowEnd]: () => isHorizontal && nextTab(),
      ArrowDown: () => isVertical && nextTab(),
      ArrowUp: () => isVertical && prevTab(),
      Home: firstTab,
      End: lastTab
    };
    const action = keyMap[eventKey];
    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [descendants, focusedIndex, orientation, direction]);
  return {
    ...props,
    role: "tablist",
    "aria-orientation": orientation,
    onKeyDown: (0, _sharedUtils.callAllHandlers)(props.onKeyDown, onKeyDown)
  };
}
function useTab(props) {
  const {
    isDisabled,
    isFocusable,
    ...htmlProps
  } = props;
  const {
    setSelectedIndex,
    isManual,
    id,
    setFocusedIndex,
    selectedIndex
  } = useTabsContext();
  const {
    index,
    register
  } = useTabsDescendant({
    disabled: isDisabled && !isFocusable
  });
  const isSelected = index === selectedIndex;
  const onClick = () => {
    setSelectedIndex(index);
  };
  const onFocus = () => {
    setFocusedIndex(index);
    const isDisabledButFocusable = isDisabled && isFocusable;
    const shouldSelect = !isManual && !isDisabledButFocusable;
    if (shouldSelect) {
      setSelectedIndex(index);
    }
  };
  const clickableProps = (0, _clickable.useClickable)({
    ...htmlProps,
    ref: (0, _reactUseMergeRefs.mergeRefs)(register, props.ref),
    isDisabled,
    isFocusable,
    onClick: (0, _sharedUtils.callAllHandlers)(props.onClick, onClick)
  });
  const type = "button";
  return {
    ...clickableProps,
    id: makeTabId(id, index),
    role: "tab",
    tabIndex: isSelected ? 0 : -1,
    type,
    "aria-selected": isSelected,
    "aria-controls": makeTabPanelId(id, index),
    onFocus: isDisabled ? void 0 : (0, _sharedUtils.callAllHandlers)(props.onFocus, onFocus)
  };
}
var [TabPanelProvider, useTabPanelContext] = (0, _reactContext.createContext)({});
function useTabPanels(props) {
  const context = useTabsContext();
  const {
    id,
    selectedIndex
  } = context;
  const validChildren = (0, _reactChildrenUtils.getValidChildren)(props.children);
  const children = validChildren.map((child, index) => (0, _react.createElement)(TabPanelProvider, {
    key: index,
    value: {
      isSelected: index === selectedIndex,
      id: makeTabPanelId(id, index),
      tabId: makeTabId(id, index),
      selectedIndex
    }
  }, child));
  return {
    ...props,
    children
  };
}
function useTabPanel(props) {
  const {
    children,
    ...htmlProps
  } = props;
  const {
    isLazy,
    lazyBehavior
  } = useTabsContext();
  const {
    isSelected,
    id,
    tabId
  } = useTabPanelContext();
  const hasBeenSelected = (0, _react.useRef)(false);
  if (isSelected) {
    hasBeenSelected.current = true;
  }
  const shouldRenderChildren = (0, _lazyUtils.lazyDisclosure)({
    wasSelected: hasBeenSelected.current,
    isSelected,
    enabled: isLazy,
    mode: lazyBehavior
  });
  return {
    tabIndex: 0,
    ...htmlProps,
    children: shouldRenderChildren ? children : null,
    role: "tabpanel",
    "aria-labelledby": tabId,
    hidden: !isSelected,
    id
  };
}
function useTabIndicator() {
  const context = useTabsContext();
  const descendants = useTabsDescendantsContext();
  const {
    selectedIndex,
    orientation
  } = context;
  const isHorizontal = orientation === "horizontal";
  const isVertical = orientation === "vertical";
  const [rect, setRect] = (0, _react.useState)(() => {
    if (isHorizontal) return {
      left: 0,
      width: 0
    };
    if (isVertical) return {
      top: 0,
      height: 0
    };
    return void 0;
  });
  const [hasMeasured, setHasMeasured] = (0, _react.useState)(false);
  (0, _reactUseSafeLayoutEffect.useSafeLayoutEffect)(() => {
    if (selectedIndex == null) return;
    const tab = descendants.item(selectedIndex);
    if (tab == null) return;
    if (isHorizontal) {
      setRect({
        left: tab.node.offsetLeft,
        width: tab.node.offsetWidth
      });
    }
    if (isVertical) {
      setRect({
        top: tab.node.offsetTop,
        height: tab.node.offsetHeight
      });
    }
    const id = requestAnimationFrame(() => {
      setHasMeasured(true);
    });
    return () => {
      if (id) {
        cancelAnimationFrame(id);
      }
    };
  }, [selectedIndex, isHorizontal, isVertical, descendants]);
  return {
    position: "absolute",
    transitionProperty: "left, right, top, bottom, height, width",
    transitionDuration: hasMeasured ? "200ms" : "0ms",
    transitionTimingFunction: "cubic-bezier(0, 0, 0.2, 1)",
    ...rect
  };
}
function makeTabId(id, index) {
  return `${id}--tab-${index}`;
}
function makeTabPanelId(id, index) {
  return `${id}--tabpanel-${index}`;
}
},{"@chakra-ui/clickable":"T7OC","@chakra-ui/descendant":"HJpF","@chakra-ui/react-context":"lT23","@chakra-ui/react-use-safe-layout-effect":"cYtR","@chakra-ui/react-use-controllable-state":"DWQz","@chakra-ui/react-children-utils":"PLf5","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/lazy-utils":"wsFr","@chakra-ui/shared-utils":"gghr","react":"n8MK"}],"CuEo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTabsStyles = exports.Tabs = void 0;
var _chunkROBISDLO = require("./chunk-ROBISDLO.mjs");
var _reactContext = require("@chakra-ui/react-context");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/tabs.tsx

var [TabsStylesProvider, useTabsStyles] = (0, _reactContext.createContext)({
  name: `TabsStylesContext`,
  errorMessage: `useTabsStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Tabs />" `
});
exports.useTabsStyles = useTabsStyles;
var Tabs = (0, _system.forwardRef)(function Tabs2(props, ref) {
  const styles = (0, _system.useMultiStyleConfig)("Tabs", props);
  const {
    children,
    className,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const {
    htmlProps,
    descendants,
    ...ctx
  } = (0, _chunkROBISDLO.useTabs)(rest);
  const context = (0, _react.useMemo)(() => ctx, [ctx]);
  const {
    isFitted: _,
    ...rootProps
  } = htmlProps;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkROBISDLO.TabsDescendantsProvider, {
    value: descendants,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_chunkROBISDLO.TabsProvider, {
      value: context,
      children: /* @__PURE__ */(0, _jsxRuntime.jsx)(TabsStylesProvider, {
        value: styles,
        children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
          className: (0, _sharedUtils.cx)("chakra-tabs", className),
          ref,
          ...rootProps,
          __css: styles.root,
          children
        })
      })
    })
  });
});
exports.Tabs = Tabs;
Tabs.displayName = "Tabs";
},{"./chunk-ROBISDLO.mjs":"C5yS","@chakra-ui/react-context":"lT23","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react":"n8MK","react/jsx-runtime":"plwR"}],"MoiS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TabIndicator = void 0;
var _chunkZWUY3VWT = require("./chunk-ZWUY3VWT.mjs");
var _chunkROBISDLO = require("./chunk-ROBISDLO.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/tab-indicator.tsx

var TabIndicator = (0, _system.forwardRef)(function TabIndicator2(props, ref) {
  const indicatorStyle = (0, _chunkROBISDLO.useTabIndicator)();
  const style = {
    ...props.style,
    ...indicatorStyle
  };
  const styles = (0, _chunkZWUY3VWT.useTabsStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ref,
    ...props,
    className: (0, _sharedUtils.cx)("chakra-tabs__tab-indicator", props.className),
    style,
    __css: styles.indicator
  });
});
exports.TabIndicator = TabIndicator;
TabIndicator.displayName = "TabIndicator";
},{"./chunk-ZWUY3VWT.mjs":"CuEo","./chunk-ROBISDLO.mjs":"C5yS","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"r2OL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TabList = void 0;
var _chunkZWUY3VWT = require("./chunk-ZWUY3VWT.mjs");
var _chunkROBISDLO = require("./chunk-ROBISDLO.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/tab-list.tsx

var TabList = (0, _system.forwardRef)(function TabList2(props, ref) {
  const tablistProps = (0, _chunkROBISDLO.useTabList)({
    ...props,
    ref
  });
  const styles = (0, _chunkZWUY3VWT.useTabsStyles)();
  const tablistStyles = {
    display: "flex",
    ...styles.tablist
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...tablistProps,
    className: (0, _sharedUtils.cx)("chakra-tabs__tablist", props.className),
    __css: tablistStyles
  });
});
exports.TabList = TabList;
TabList.displayName = "TabList";
},{"./chunk-ZWUY3VWT.mjs":"CuEo","./chunk-ROBISDLO.mjs":"C5yS","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"fhCR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TabPanel = void 0;
var _chunkZWUY3VWT = require("./chunk-ZWUY3VWT.mjs");
var _chunkROBISDLO = require("./chunk-ROBISDLO.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/tab-panel.tsx

var TabPanel = (0, _system.forwardRef)(function TabPanel2(props, ref) {
  const panelProps = (0, _chunkROBISDLO.useTabPanel)({
    ...props,
    ref
  });
  const styles = (0, _chunkZWUY3VWT.useTabsStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    outline: "0",
    ...panelProps,
    className: (0, _sharedUtils.cx)("chakra-tabs__tab-panel", props.className),
    __css: styles.tabpanel
  });
});
exports.TabPanel = TabPanel;
TabPanel.displayName = "TabPanel";
},{"./chunk-ZWUY3VWT.mjs":"CuEo","./chunk-ROBISDLO.mjs":"C5yS","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"E4TS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TabPanels = void 0;
var _chunkZWUY3VWT = require("./chunk-ZWUY3VWT.mjs");
var _chunkROBISDLO = require("./chunk-ROBISDLO.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/tab-panels.tsx

var TabPanels = (0, _system.forwardRef)(function TabPanels2(props, ref) {
  const panelsProps = (0, _chunkROBISDLO.useTabPanels)(props);
  const styles = (0, _chunkZWUY3VWT.useTabsStyles)();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
    ...panelsProps,
    width: "100%",
    ref,
    className: (0, _sharedUtils.cx)("chakra-tabs__tab-panels", props.className),
    __css: styles.tabpanels
  });
});
exports.TabPanels = TabPanels;
TabPanels.displayName = "TabPanels";
},{"./chunk-ZWUY3VWT.mjs":"CuEo","./chunk-ROBISDLO.mjs":"C5yS","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"HkN1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tab = void 0;
var _chunkZWUY3VWT = require("./chunk-ZWUY3VWT.mjs");
var _chunkROBISDLO = require("./chunk-ROBISDLO.mjs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/tab.tsx

var Tab = (0, _system.forwardRef)(function Tab2(props, ref) {
  const styles = (0, _chunkZWUY3VWT.useTabsStyles)();
  const tabProps = (0, _chunkROBISDLO.useTab)({
    ...props,
    ref
  });
  const tabStyles = {
    outline: "0",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    ...styles.tab
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.button, {
    ...tabProps,
    className: (0, _sharedUtils.cx)("chakra-tabs__tab", props.className),
    __css: tabStyles
  });
});
exports.Tab = Tab;
Tab.displayName = "Tab";
},{"./chunk-ZWUY3VWT.mjs":"CuEo","./chunk-ROBISDLO.mjs":"C5yS","@chakra-ui/shared-utils":"gghr","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"dskc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Tab", {
  enumerable: true,
  get: function () {
    return _chunkTPBRUKW.Tab;
  }
});
Object.defineProperty(exports, "TabIndicator", {
  enumerable: true,
  get: function () {
    return _chunkUCTXUILV.TabIndicator;
  }
});
Object.defineProperty(exports, "TabList", {
  enumerable: true,
  get: function () {
    return _chunkZWLVZLKQ.TabList;
  }
});
Object.defineProperty(exports, "TabPanel", {
  enumerable: true,
  get: function () {
    return _chunk7W5ZCZ.TabPanel;
  }
});
Object.defineProperty(exports, "TabPanels", {
  enumerable: true,
  get: function () {
    return _chunk45U2LZ4E.TabPanels;
  }
});
Object.defineProperty(exports, "Tabs", {
  enumerable: true,
  get: function () {
    return _chunkZWUY3VWT.Tabs;
  }
});
Object.defineProperty(exports, "TabsDescendantsProvider", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.TabsDescendantsProvider;
  }
});
Object.defineProperty(exports, "TabsProvider", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.TabsProvider;
  }
});
Object.defineProperty(exports, "useTab", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.useTab;
  }
});
Object.defineProperty(exports, "useTabIndicator", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.useTabIndicator;
  }
});
Object.defineProperty(exports, "useTabList", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.useTabList;
  }
});
Object.defineProperty(exports, "useTabPanel", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.useTabPanel;
  }
});
Object.defineProperty(exports, "useTabPanels", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.useTabPanels;
  }
});
Object.defineProperty(exports, "useTabs", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.useTabs;
  }
});
Object.defineProperty(exports, "useTabsContext", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.useTabsContext;
  }
});
Object.defineProperty(exports, "useTabsDescendant", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.useTabsDescendant;
  }
});
Object.defineProperty(exports, "useTabsDescendants", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.useTabsDescendants;
  }
});
Object.defineProperty(exports, "useTabsDescendantsContext", {
  enumerable: true,
  get: function () {
    return _chunkROBISDLO.useTabsDescendantsContext;
  }
});
Object.defineProperty(exports, "useTabsStyles", {
  enumerable: true,
  get: function () {
    return _chunkZWUY3VWT.useTabsStyles;
  }
});
var _chunkUCTXUILV = require("./chunk-UCTXUILV.mjs");
var _chunkZWLVZLKQ = require("./chunk-ZWLVZLKQ.mjs");
var _chunk7W5ZCZ = require("./chunk-7W5ZCZ76.mjs");
var _chunk45U2LZ4E = require("./chunk-45U2LZ4E.mjs");
var _chunkTPBRUKW = require("./chunk-TPBRUKW6.mjs");
var _chunkZWUY3VWT = require("./chunk-ZWUY3VWT.mjs");
var _chunkROBISDLO = require("./chunk-ROBISDLO.mjs");
},{"./chunk-UCTXUILV.mjs":"MoiS","./chunk-ZWLVZLKQ.mjs":"r2OL","./chunk-7W5ZCZ76.mjs":"fhCR","./chunk-45U2LZ4E.mjs":"E4TS","./chunk-TPBRUKW6.mjs":"HkN1","./chunk-ZWUY3VWT.mjs":"CuEo","./chunk-ROBISDLO.mjs":"C5yS"}],"tKbj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTagStyles = exports.TagRightIcon = exports.TagLeftIcon = exports.TagLabel = exports.TagCloseButton = exports.Tag = void 0;
var _icon = require("@chakra-ui/icon");
var _reactContext = require("@chakra-ui/react-context");
var _system = require("@chakra-ui/system");
var _jsxRuntime = require("react/jsx-runtime");
// src/tag.tsx

var [TagStylesProvider, useTagStyles] = (0, _reactContext.createContext)({
  name: `TagStylesContext`,
  errorMessage: `useTagStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Tag />" `
});
exports.useTagStyles = useTagStyles;
var Tag = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _system.useMultiStyleConfig)("Tag", props);
  const ownProps = (0, _system.omitThemingProps)(props);
  const containerStyles = {
    display: "inline-flex",
    verticalAlign: "top",
    alignItems: "center",
    maxWidth: "100%",
    ...styles.container
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(TagStylesProvider, {
    value: styles,
    children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      ref,
      ...ownProps,
      __css: containerStyles
    })
  });
});
exports.Tag = Tag;
Tag.displayName = "Tag";
var TagLabel = (0, _system.forwardRef)((props, ref) => {
  const styles = useTagStyles();
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
    ref,
    noOfLines: 1,
    ...props,
    __css: styles.label
  });
});
exports.TagLabel = TagLabel;
TagLabel.displayName = "TagLabel";
var TagLeftIcon = (0, _system.forwardRef)((props, ref) => /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
  ref,
  verticalAlign: "top",
  marginEnd: "0.5rem",
  ...props
}));
exports.TagLeftIcon = TagLeftIcon;
TagLeftIcon.displayName = "TagLeftIcon";
var TagRightIcon = (0, _system.forwardRef)((props, ref) => /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
  ref,
  verticalAlign: "top",
  marginStart: "0.5rem",
  ...props
}));
exports.TagRightIcon = TagRightIcon;
TagRightIcon.displayName = "TagRightIcon";
var TagCloseIcon = props => /* @__PURE__ */(0, _jsxRuntime.jsx)(_icon.Icon, {
  verticalAlign: "inherit",
  viewBox: "0 0 512 512",
  ...props,
  children: /* @__PURE__ */(0, _jsxRuntime.jsx)("path", {
    fill: "currentColor",
    d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z"
  })
});
TagCloseIcon.displayName = "TagCloseIcon";
var TagCloseButton = (0, _system.forwardRef)((props, ref) => {
  const {
    isDisabled,
    children,
    ...rest
  } = props;
  const styles = useTagStyles();
  const btnStyles = {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    outline: "0",
    ...styles.closeButton
  };
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.button, {
    ref,
    "aria-label": "close",
    ...rest,
    type: "button",
    disabled: isDisabled,
    __css: btnStyles,
    children: children || /* @__PURE__ */(0, _jsxRuntime.jsx)(TagCloseIcon, {})
  });
});
exports.TagCloseButton = TagCloseButton;
TagCloseButton.displayName = "TagCloseButton";
},{"@chakra-ui/icon":"aPuf","@chakra-ui/react-context":"lT23","@chakra-ui/system":"ogbg","react/jsx-runtime":"plwR"}],"HxLd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Tag", {
  enumerable: true,
  get: function () {
    return _chunkIXKZFKRY.Tag;
  }
});
Object.defineProperty(exports, "TagCloseButton", {
  enumerable: true,
  get: function () {
    return _chunkIXKZFKRY.TagCloseButton;
  }
});
Object.defineProperty(exports, "TagLabel", {
  enumerable: true,
  get: function () {
    return _chunkIXKZFKRY.TagLabel;
  }
});
Object.defineProperty(exports, "TagLeftIcon", {
  enumerable: true,
  get: function () {
    return _chunkIXKZFKRY.TagLeftIcon;
  }
});
Object.defineProperty(exports, "TagRightIcon", {
  enumerable: true,
  get: function () {
    return _chunkIXKZFKRY.TagRightIcon;
  }
});
Object.defineProperty(exports, "useTagStyles", {
  enumerable: true,
  get: function () {
    return _chunkIXKZFKRY.useTagStyles;
  }
});
var _chunkIXKZFKRY = require("./chunk-IXKZFKRY.mjs");
},{"./chunk-IXKZFKRY.mjs":"tKbj"}],"kbR7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Textarea = void 0;
var _formControl = require("@chakra-ui/form-control");
var _system = require("@chakra-ui/system");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _jsxRuntime = require("react/jsx-runtime");
// src/textarea.tsx

// ../../utilities/object-utils/src/index.ts
function omit(object, keysToOmit = []) {
  const clone = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone) delete clone[key];
  }
  return clone;
}

// src/textarea.tsx

var omitted = ["h", "minH", "height", "minHeight"];
var Textarea = (0, _system.forwardRef)((props, ref) => {
  const styles = (0, _system.useStyleConfig)("Textarea", props);
  const {
    className,
    rows,
    ...rest
  } = (0, _system.omitThemingProps)(props);
  const textareaProps = (0, _formControl.useFormControl)(rest);
  const textareaStyles = rows ? omit(styles, omitted) : styles;
  return /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.textarea, {
    ref,
    rows,
    ...textareaProps,
    className: (0, _sharedUtils.cx)("chakra-textarea", className),
    __css: textareaStyles
  });
});
exports.Textarea = Textarea;
Textarea.displayName = "Textarea";
},{"@chakra-ui/form-control":"fjMD","@chakra-ui/system":"ogbg","@chakra-ui/shared-utils":"gghr","react/jsx-runtime":"plwR"}],"uJAZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Textarea", {
  enumerable: true,
  get: function () {
    return _chunkQ5L4T23M.Textarea;
  }
});
var _chunkQ5L4T23M = require("./chunk-Q5L4T23M.mjs");
},{"./chunk-Q5L4T23M.mjs":"kbR7"}],"NCC9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scale = void 0;
// src/tooltip.transition.tsx
var scale = {
  exit: {
    scale: 0.85,
    opacity: 0,
    transition: {
      opacity: {
        duration: 0.15,
        easings: "easeInOut"
      },
      scale: {
        duration: 0.2,
        easings: "easeInOut"
      }
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      opacity: {
        easings: "easeOut",
        duration: 0.2
      },
      scale: {
        duration: 0.2,
        ease: [0.175, 0.885, 0.4, 1.1]
      }
    }
  }
};
exports.scale = scale;
},{}],"InJa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTooltip = useTooltip;
var _reactUseEventListener = require("@chakra-ui/react-use-event-listener");
var _reactUseDisclosure = require("@chakra-ui/react-use-disclosure");
var _popper = require("@chakra-ui/popper");
var _reactUseMergeRefs = require("@chakra-ui/react-use-merge-refs");
var _sharedUtils = require("@chakra-ui/shared-utils");
var _react = require("react");
// src/use-tooltip.ts

var getDoc = ref => {
  var _a;
  return ((_a = ref.current) == null ? void 0 : _a.ownerDocument) || document;
};
var getWin = ref => {
  var _a, _b;
  return ((_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument) == null ? void 0 : _b.defaultView) || window;
};
function useTooltip(props = {}) {
  const {
    openDelay = 0,
    closeDelay = 0,
    closeOnClick = true,
    closeOnMouseDown,
    closeOnScroll,
    closeOnPointerDown = closeOnMouseDown,
    closeOnEsc = true,
    onOpen: onOpenProp,
    onClose: onCloseProp,
    placement,
    id,
    isOpen: isOpenProp,
    defaultIsOpen,
    arrowSize = 10,
    arrowShadowColor,
    arrowPadding,
    modifiers,
    isDisabled,
    gutter,
    offset,
    direction,
    ...htmlProps
  } = props;
  const {
    isOpen,
    onOpen,
    onClose
  } = (0, _reactUseDisclosure.useDisclosure)({
    isOpen: isOpenProp,
    defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  });
  const {
    referenceRef,
    getPopperProps,
    getArrowInnerProps,
    getArrowProps
  } = (0, _popper.usePopper)({
    enabled: isOpen,
    placement,
    arrowPadding,
    modifiers,
    gutter,
    offset,
    direction
  });
  const uuid = (0, _react.useId)();
  const uid = id != null ? id : uuid;
  const tooltipId = `tooltip-${uid}`;
  const ref = (0, _react.useRef)(null);
  const enterTimeout = (0, _react.useRef)();
  const clearEnterTimeout = (0, _react.useCallback)(() => {
    if (enterTimeout.current) {
      clearTimeout(enterTimeout.current);
      enterTimeout.current = void 0;
    }
  }, []);
  const exitTimeout = (0, _react.useRef)();
  const clearExitTimeout = (0, _react.useCallback)(() => {
    if (exitTimeout.current) {
      clearTimeout(exitTimeout.current);
      exitTimeout.current = void 0;
    }
  }, []);
  const closeNow = (0, _react.useCallback)(() => {
    clearExitTimeout();
    onClose();
  }, [onClose, clearExitTimeout]);
  const dispatchCloseEvent = useCloseEvent(ref, closeNow);
  const openWithDelay = (0, _react.useCallback)(() => {
    if (!isDisabled && !enterTimeout.current) {
      dispatchCloseEvent();
      const win = getWin(ref);
      enterTimeout.current = win.setTimeout(onOpen, openDelay);
    }
  }, [dispatchCloseEvent, isDisabled, onOpen, openDelay]);
  const closeWithDelay = (0, _react.useCallback)(() => {
    clearEnterTimeout();
    const win = getWin(ref);
    exitTimeout.current = win.setTimeout(closeNow, closeDelay);
  }, [closeDelay, closeNow, clearEnterTimeout]);
  const onClick = (0, _react.useCallback)(() => {
    if (isOpen && closeOnClick) {
      closeWithDelay();
    }
  }, [closeOnClick, closeWithDelay, isOpen]);
  const onPointerDown = (0, _react.useCallback)(() => {
    if (isOpen && closeOnPointerDown) {
      closeWithDelay();
    }
  }, [closeOnPointerDown, closeWithDelay, isOpen]);
  const onKeyDown = (0, _react.useCallback)(event => {
    if (isOpen && event.key === "Escape") {
      closeWithDelay();
    }
  }, [isOpen, closeWithDelay]);
  (0, _reactUseEventListener.useEventListener)(() => getDoc(ref), "keydown", closeOnEsc ? onKeyDown : void 0);
  (0, _reactUseEventListener.useEventListener)(() => getDoc(ref), "scroll", () => {
    if (isOpen && closeOnScroll) {
      closeNow();
    }
  });
  (0, _react.useEffect)(() => {
    if (!isDisabled) return;
    clearEnterTimeout();
    if (isOpen) onClose();
  }, [isDisabled, isOpen, onClose, clearEnterTimeout]);
  (0, _react.useEffect)(() => () => {
    clearEnterTimeout();
    clearExitTimeout();
  }, [clearEnterTimeout, clearExitTimeout]);
  (0, _reactUseEventListener.useEventListener)(() => ref.current, "pointerleave", closeWithDelay);
  const getTriggerProps = (0, _react.useCallback)((props2 = {}, _ref = null) => {
    const triggerProps = {
      ...props2,
      ref: (0, _reactUseMergeRefs.mergeRefs)(ref, _ref, referenceRef),
      onPointerEnter: (0, _sharedUtils.callAllHandlers)(props2.onPointerEnter, e => {
        if (e.pointerType === "touch") return;
        openWithDelay();
      }),
      onClick: (0, _sharedUtils.callAllHandlers)(props2.onClick, onClick),
      onPointerDown: (0, _sharedUtils.callAllHandlers)(props2.onPointerDown, onPointerDown),
      onFocus: (0, _sharedUtils.callAllHandlers)(props2.onFocus, openWithDelay),
      onBlur: (0, _sharedUtils.callAllHandlers)(props2.onBlur, closeWithDelay),
      "aria-describedby": isOpen ? tooltipId : void 0
    };
    return triggerProps;
  }, [openWithDelay, closeWithDelay, onPointerDown, isOpen, tooltipId, onClick, referenceRef]);
  const getTooltipPositionerProps = (0, _react.useCallback)((props2 = {}, forwardedRef = null) => getPopperProps({
    ...props2,
    style: {
      ...props2.style,
      [_popper.popperCSSVars.arrowSize.var]: arrowSize ? `${arrowSize}px` : void 0,
      [_popper.popperCSSVars.arrowShadowColor.var]: arrowShadowColor
    }
  }, forwardedRef), [getPopperProps, arrowSize, arrowShadowColor]);
  const getTooltipProps = (0, _react.useCallback)((props2 = {}, ref2 = null) => {
    const styles = {
      ...props2.style,
      position: "relative",
      transformOrigin: _popper.popperCSSVars.transformOrigin.varRef
    };
    return {
      ref: ref2,
      ...htmlProps,
      ...props2,
      id: tooltipId,
      role: "tooltip",
      style: styles
    };
  }, [htmlProps, tooltipId]);
  return {
    isOpen,
    show: openWithDelay,
    hide: closeWithDelay,
    getTriggerProps,
    getTooltipProps,
    getTooltipPositionerProps,
    getArrowProps,
    getArrowInnerProps
  };
}
var closeEventName = "chakra-ui:close-tooltip";
function useCloseEvent(ref, close) {
  (0, _react.useEffect)(() => {
    const doc = getDoc(ref);
    doc.addEventListener(closeEventName, close);
    return () => doc.removeEventListener(closeEventName, close);
  }, [close, ref]);
  return () => {
    const doc = getDoc(ref);
    const win = getWin(ref);
    doc.dispatchEvent(new win.CustomEvent(closeEventName));
  };
}
},{"@chakra-ui/react-use-event-listener":"Lu7g","@chakra-ui/react-use-disclosure":"xJYi","@chakra-ui/popper":"gOdA","@chakra-ui/react-use-merge-refs":"EUzL","@chakra-ui/shared-utils":"gghr","react":"n8MK"}],"KuGL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tooltip = void 0;
var _chunkUNJFLZPD = require("./chunk-UNJFLZPD.mjs");
var _chunkGOQMVUD = require("./chunk-GOQMVUD7.mjs");
var _popper = require("@chakra-ui/popper");
var _portal = require("@chakra-ui/portal");
var _system = require("@chakra-ui/system");
var _framerMotion = require("framer-motion");
var _react = require("react");
var _jsxRuntime = require("react/jsx-runtime");
// src/tooltip.tsx

// ../../utilities/object-utils/src/index.ts
function omit(object, keysToOmit = []) {
  const clone = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone) delete clone[key];
  }
  return clone;
}
function pick(object, keysToPick) {
  const result = {};
  for (const key of keysToPick) {
    if (key in object) {
      result[key] = object[key];
    }
  }
  return result;
}

// src/tooltip.tsx

var MotionDiv = (0, _system.chakra)(_framerMotion.motion.div);
var Tooltip = (0, _system.forwardRef)((props, ref) => {
  var _a, _b;
  const styles = (0, _system.useStyleConfig)("Tooltip", props);
  const ownProps = (0, _system.omitThemingProps)(props);
  const theme = (0, _system.useTheme)();
  const {
    children,
    label,
    shouldWrapChildren,
    "aria-label": ariaLabel,
    hasArrow,
    bg,
    portalProps,
    background,
    backgroundColor,
    bgColor,
    motionProps,
    ...rest
  } = ownProps;
  const userDefinedBg = (_b = (_a = background != null ? background : backgroundColor) != null ? _a : bg) != null ? _b : bgColor;
  if (userDefinedBg) {
    styles.bg = userDefinedBg;
    const bgVar = (0, _system.getCSSVar)(theme, "colors", userDefinedBg);
    styles[_popper.popperCSSVars.arrowBg.var] = bgVar;
  }
  const tooltip = (0, _chunkGOQMVUD.useTooltip)({
    ...rest,
    direction: theme.direction
  });
  const shouldWrap = typeof children === "string" || shouldWrapChildren;
  let trigger;
  if (shouldWrap) {
    trigger = /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
      display: "inline-block",
      tabIndex: 0,
      ...tooltip.getTriggerProps(),
      children
    });
  } else {
    const child = _react.Children.only(children);
    trigger = (0, _react.cloneElement)(child, tooltip.getTriggerProps(child.props, child.ref));
  }
  const hasAriaLabel = !!ariaLabel;
  const _tooltipProps = tooltip.getTooltipProps({}, ref);
  const tooltipProps = hasAriaLabel ? omit(_tooltipProps, ["role", "id"]) : _tooltipProps;
  const srOnlyProps = pick(_tooltipProps, ["role", "id"]);
  if (!label) {
    return /* @__PURE__ */(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
      children
    });
  }
  return /* @__PURE__ */(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [trigger, /* @__PURE__ */(0, _jsxRuntime.jsx)(_framerMotion.AnimatePresence, {
      children: tooltip.isOpen && /* @__PURE__ */(0, _jsxRuntime.jsx)(_portal.Portal, {
        ...portalProps,
        children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
          ...tooltip.getTooltipPositionerProps(),
          __css: {
            zIndex: styles.zIndex,
            pointerEvents: "none"
          },
          children: /* @__PURE__ */(0, _jsxRuntime.jsxs)(MotionDiv, {
            variants: _chunkUNJFLZPD.scale,
            initial: "exit",
            animate: "enter",
            exit: "exit",
            ...motionProps,
            ...tooltipProps,
            __css: styles,
            children: [label, hasAriaLabel && /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.span, {
              srOnly: true,
              ...srOnlyProps,
              children: ariaLabel
            }), hasArrow && /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
              "data-popper-arrow": true,
              className: "chakra-tooltip__arrow-wrapper",
              children: /* @__PURE__ */(0, _jsxRuntime.jsx)(_system.chakra.div, {
                "data-popper-arrow-inner": true,
                className: "chakra-tooltip__arrow",
                __css: {
                  bg: styles.bg
                }
              })
            })]
          })
        })
      })
    })]
  });
});
exports.Tooltip = Tooltip;
Tooltip.displayName = "Tooltip";
},{"./chunk-UNJFLZPD.mjs":"NCC9","./chunk-GOQMVUD7.mjs":"InJa","@chakra-ui/popper":"gOdA","@chakra-ui/portal":"HPzc","@chakra-ui/system":"ogbg","framer-motion":"gNpu","react":"n8MK","react/jsx-runtime":"plwR"}],"d8qk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Tooltip", {
  enumerable: true,
  get: function () {
    return _chunkBYB6QSEH.Tooltip;
  }
});
Object.defineProperty(exports, "useTooltip", {
  enumerable: true,
  get: function () {
    return _chunkGOQMVUD.useTooltip;
  }
});
var _chunkBYB6QSEH = require("./chunk-BYB6QSEH.mjs");
require("./chunk-UNJFLZPD.mjs");
var _chunkGOQMVUD = require("./chunk-GOQMVUD7.mjs");
},{"./chunk-BYB6QSEH.mjs":"KuGL","./chunk-UNJFLZPD.mjs":"NCC9","./chunk-GOQMVUD7.mjs":"InJa"}],"ALOZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  ChakraBaseProvider: true,
  ChakraProvider: true
};
Object.defineProperty(exports, "ChakraBaseProvider", {
  enumerable: true,
  get: function () {
    return _chunkBOJQWC4N.ChakraBaseProvider;
  }
});
Object.defineProperty(exports, "ChakraProvider", {
  enumerable: true,
  get: function () {
    return _chunkBOJQWC4N.ChakraProvider;
  }
});
var _chunkBOJQWC4N = require("./chunk-BOJQWC4N.mjs");
var _accordion = require("@chakra-ui/accordion");
Object.keys(_accordion).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _accordion[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _accordion[key];
    }
  });
});
var _alert = require("@chakra-ui/alert");
Object.keys(_alert).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _alert[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _alert[key];
    }
  });
});
var _avatar = require("@chakra-ui/avatar");
Object.keys(_avatar).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _avatar[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _avatar[key];
    }
  });
});
var _breadcrumb = require("@chakra-ui/breadcrumb");
Object.keys(_breadcrumb).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _breadcrumb[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _breadcrumb[key];
    }
  });
});
var _button = require("@chakra-ui/button");
Object.keys(_button).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _button[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _button[key];
    }
  });
});
var _card = require("@chakra-ui/card");
Object.keys(_card).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _card[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _card[key];
    }
  });
});
var _checkbox = require("@chakra-ui/checkbox");
Object.keys(_checkbox).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _checkbox[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _checkbox[key];
    }
  });
});
var _closeButton = require("@chakra-ui/close-button");
Object.keys(_closeButton).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _closeButton[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _closeButton[key];
    }
  });
});
var _controlBox = require("@chakra-ui/control-box");
Object.keys(_controlBox).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _controlBox[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _controlBox[key];
    }
  });
});
var _counter = require("@chakra-ui/counter");
Object.keys(_counter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _counter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _counter[key];
    }
  });
});
var _cssReset = require("@chakra-ui/css-reset");
Object.keys(_cssReset).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _cssReset[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cssReset[key];
    }
  });
});
var _editable = require("@chakra-ui/editable");
Object.keys(_editable).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _editable[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _editable[key];
    }
  });
});
var _formControl = require("@chakra-ui/form-control");
Object.keys(_formControl).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _formControl[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _formControl[key];
    }
  });
});
var _hooks = require("@chakra-ui/hooks");
Object.keys(_hooks).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _hooks[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _hooks[key];
    }
  });
});
var _icon = require("@chakra-ui/icon");
Object.keys(_icon).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _icon[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _icon[key];
    }
  });
});
var _image = require("@chakra-ui/image");
Object.keys(_image).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _image[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _image[key];
    }
  });
});
var _input = require("@chakra-ui/input");
Object.keys(_input).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _input[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _input[key];
    }
  });
});
var _layout = require("@chakra-ui/layout");
Object.keys(_layout).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _layout[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _layout[key];
    }
  });
});
var _mediaQuery = require("@chakra-ui/media-query");
Object.keys(_mediaQuery).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _mediaQuery[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaQuery[key];
    }
  });
});
var _menu = require("@chakra-ui/menu");
Object.keys(_menu).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _menu[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _menu[key];
    }
  });
});
var _modal = require("@chakra-ui/modal");
Object.keys(_modal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _modal[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _modal[key];
    }
  });
});
var _numberInput = require("@chakra-ui/number-input");
Object.keys(_numberInput).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _numberInput[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _numberInput[key];
    }
  });
});
var _pinInput = require("@chakra-ui/pin-input");
Object.keys(_pinInput).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _pinInput[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pinInput[key];
    }
  });
});
var _popover = require("@chakra-ui/popover");
Object.keys(_popover).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _popover[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _popover[key];
    }
  });
});
var _popper = require("@chakra-ui/popper");
Object.keys(_popper).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _popper[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _popper[key];
    }
  });
});
var _portal = require("@chakra-ui/portal");
Object.keys(_portal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _portal[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _portal[key];
    }
  });
});
var _progress = require("@chakra-ui/progress");
Object.keys(_progress).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _progress[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _progress[key];
    }
  });
});
var _radio = require("@chakra-ui/radio");
Object.keys(_radio).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _radio[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _radio[key];
    }
  });
});
var _reactEnv = require("@chakra-ui/react-env");
Object.keys(_reactEnv).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _reactEnv[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _reactEnv[key];
    }
  });
});
var _select = require("@chakra-ui/select");
Object.keys(_select).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _select[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _select[key];
    }
  });
});
var _skeleton = require("@chakra-ui/skeleton");
Object.keys(_skeleton).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _skeleton[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _skeleton[key];
    }
  });
});
var _slider = require("@chakra-ui/slider");
Object.keys(_slider).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _slider[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _slider[key];
    }
  });
});
var _spinner = require("@chakra-ui/spinner");
Object.keys(_spinner).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _spinner[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _spinner[key];
    }
  });
});
var _stat = require("@chakra-ui/stat");
Object.keys(_stat).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _stat[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stat[key];
    }
  });
});
var _switch = require("@chakra-ui/switch");
Object.keys(_switch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _switch[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _switch[key];
    }
  });
});
var _system = require("@chakra-ui/system");
Object.keys(_system).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _system[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _system[key];
    }
  });
});
var _table = require("@chakra-ui/table");
Object.keys(_table).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _table[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _table[key];
    }
  });
});
var _tabs = require("@chakra-ui/tabs");
Object.keys(_tabs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _tabs[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tabs[key];
    }
  });
});
var _tag = require("@chakra-ui/tag");
Object.keys(_tag).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _tag[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tag[key];
    }
  });
});
var _textarea = require("@chakra-ui/textarea");
Object.keys(_textarea).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _textarea[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _textarea[key];
    }
  });
});
var _theme = require("@chakra-ui/theme");
Object.keys(_theme).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _theme[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _theme[key];
    }
  });
});
var _toast = require("@chakra-ui/toast");
Object.keys(_toast).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _toast[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _toast[key];
    }
  });
});
var _tooltip = require("@chakra-ui/tooltip");
Object.keys(_tooltip).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _tooltip[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tooltip[key];
    }
  });
});
var _transition = require("@chakra-ui/transition");
Object.keys(_transition).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _transition[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transition[key];
    }
  });
});
var _visuallyHidden = require("@chakra-ui/visually-hidden");
Object.keys(_visuallyHidden).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _visuallyHidden[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _visuallyHidden[key];
    }
  });
});
var _themeUtils = require("@chakra-ui/theme-utils");
Object.keys(_themeUtils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _themeUtils[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _themeUtils[key];
    }
  });
});
},{"./chunk-BOJQWC4N.mjs":"MnNk","@chakra-ui/accordion":"R6Ey","@chakra-ui/alert":"aC9K","@chakra-ui/avatar":"CMp1","@chakra-ui/breadcrumb":"tp1v","@chakra-ui/button":"dyFD","@chakra-ui/card":"Tlh4","@chakra-ui/checkbox":"QvbT","@chakra-ui/close-button":"pReG","@chakra-ui/control-box":"WYnY","@chakra-ui/counter":"yOVB","@chakra-ui/css-reset":"oD4r","@chakra-ui/editable":"BjNi","@chakra-ui/form-control":"fjMD","@chakra-ui/hooks":"UytI","@chakra-ui/icon":"aPuf","@chakra-ui/image":"m2EG","@chakra-ui/input":"K9fq","@chakra-ui/layout":"VBd8","@chakra-ui/media-query":"cY5H","@chakra-ui/menu":"q1K0","@chakra-ui/modal":"HZsu","@chakra-ui/number-input":"l28Y","@chakra-ui/pin-input":"HXQv","@chakra-ui/popover":"H2Gd","@chakra-ui/popper":"gOdA","@chakra-ui/portal":"HPzc","@chakra-ui/progress":"Few2","@chakra-ui/radio":"EpKe","@chakra-ui/react-env":"v0AH","@chakra-ui/select":"nHsR","@chakra-ui/skeleton":"giO0","@chakra-ui/slider":"kM9G","@chakra-ui/spinner":"tJmI","@chakra-ui/stat":"upbh","@chakra-ui/switch":"IYpb","@chakra-ui/system":"ogbg","@chakra-ui/table":"FQF7","@chakra-ui/tabs":"dskc","@chakra-ui/tag":"HxLd","@chakra-ui/textarea":"uJAZ","@chakra-ui/theme":"MnNi","@chakra-ui/toast":"GTFK","@chakra-ui/tooltip":"d8qk","@chakra-ui/transition":"H7Ru","@chakra-ui/visually-hidden":"CBEJ","@chakra-ui/theme-utils":"KCKL"}],"mSrg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireDefault(require("react"));
var _useFormData2 = _interopRequireDefault(require("../hooks/useFormData"));
var _react2 = require("@chakra-ui/react");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var Field = function Field(props) {
  console.log(props);
  var name = props.name,
    label = props.label;
  return /*#__PURE__*/_react.default.createElement(_react2.Box, {
    className: "field"
  }, /*#__PURE__*/_react.default.createElement(_react2.Text, null, label));
};
var FieldGroup = function FieldGroup(props) {
  console.log('Number of fields', props.fields.length);
  return /*#__PURE__*/_react.default.createElement(_react2.Stack, {
    direction: {
      base: 'column',
      md: 'row'
    }
  }, props.fields.map(function (fieldData, index) {
    return /*#__PURE__*/_react.default.createElement(Field, _extends({
      key: index
    }, fieldData));
  }));
};
var Form = function Form(_ref) {
  var formId = _ref.formId,
    portalId = _ref.portalId;
  var _useFormData = (0, _useFormData2.default)({
      formId: formId,
      portalId: portalId
    }),
    formData = _useFormData.formData,
    isLoading = _useFormData.isLoading;
  return /*#__PURE__*/_react.default.createElement(_react2.Box, null, /*#__PURE__*/_react.default.createElement(_react2.Stack, {
    className: "container"
  }, !isLoading ? formData.form.formFieldGroups.map(function (itemData, index) {
    return /*#__PURE__*/_react.default.createElement(FieldGroup, _extends({
      key: index
    }, itemData));
  }) : /*#__PURE__*/_react.default.createElement("p", {
    className: "loading-text"
  }, "Loading Data...")));
};
var _default = Form;
exports.default = _default;
},{"react":"n8MK","../hooks/useFormData":"SVCm","@chakra-ui/react":"ALOZ"}],"lY9v":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = App;
var React = _interopRequireWildcard(require("react"));
var _Form = _interopRequireDefault(require("./components/Form"));
require("./styles.css");
var _react2 = require("@chakra-ui/react");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function App(_ref) {
  var divElement = _ref.divElement;
  var _divElement$dataset = divElement.dataset,
    formId = _divElement$dataset.formId,
    portalId = _divElement$dataset.portalId;
  return /*#__PURE__*/React.createElement(_react2.ChakraProvider, null, /*#__PURE__*/React.createElement(_Form.default, {
    formId: formId,
    portalId: portalId
  }));
}
},{"react":"n8MK","./components/Form":"mSrg","./styles.css":"Tnu0","@chakra-ui/react":"ALOZ"}],"Focm":[function(require,module,exports) {
"use strict";

var _react = _interopRequireDefault(require("react"));
var _client = require("react-dom/client");
require("./styles.css");
var _App = _interopRequireDefault(require("./App"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var WidgetDivs = document.querySelectorAll('.hubspot-form');
console.log(WidgetDivs);
if (WidgetDivs.length === 0) {
  console.log('No Widget Divs found, create demo div');
  var demoDiv = document.createElement('div');
  demoDiv.setAttribute('data-form-id', '4cfc5151-36dc-4f43-be48-75425a6da2aa');
  demoDiv.setAttribute('data-portal-id', '25321820');
  var container = document.getElementById('root');
  var root = (0, _client.createRoot)(container);
  root.render( /*#__PURE__*/_react.default.createElement(_react.default.StrictMode, null, /*#__PURE__*/_react.default.createElement(_App.default, {
    divElement: demoDiv
  })));
} else {
  WidgetDivs.forEach(function (divElement) {
    console.log(divElement);
    var root = (0, _client.createRoot)(divElement);
    root.render( /*#__PURE__*/_react.default.createElement(_react.default.StrictMode, null, /*#__PURE__*/_react.default.createElement(_App.default, {
      divElement: divElement
    })));
  });
}

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
},{"react":"n8MK","react-dom/client":"NdAl","./styles.css":"Tnu0","./App":"lY9v"}]},{},["Focm"], null)